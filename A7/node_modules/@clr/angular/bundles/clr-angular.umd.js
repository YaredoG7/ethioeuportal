(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('@angular/animations'), require('@angular/forms'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@clr/angular', ['exports', '@angular/core', '@angular/common', 'rxjs', '@angular/animations', '@angular/forms', 'rxjs/operators'], factory) :
    (factory((global.clr = global.clr || {}, global.clr.angular = {}),global.ng.core,global.ng.common,global.rxjs,global.ng.animations,global.ng.forms,global.rxjs.operators));
}(this, (function (exports,i0,common,rxjs,animations,forms,operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIconCustomTag = /** @class */ (function () {
        function ClrIconCustomTag() {
        }
        ClrIconCustomTag.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-icon' },] }
        ];
        return ClrIconCustomTag;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_ICON_DIRECTIVES = [ClrIconCustomTag];
    var ClrIconModule = /** @class */ (function () {
        function ClrIconModule() {
        }
        ClrIconModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CLR_ICON_DIRECTIVES], exports: [CLR_ICON_DIRECTIVES] },] }
        ];
        return ClrIconModule;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var Point = {
        RIGHT_CENTER: 0,
        RIGHT_TOP: 1,
        RIGHT_BOTTOM: 2,
        TOP_CENTER: 3,
        TOP_RIGHT: 4,
        TOP_LEFT: 5,
        BOTTOM_CENTER: 6,
        BOTTOM_RIGHT: 7,
        BOTTOM_LEFT: 8,
        LEFT_CENTER: 9,
        LEFT_TOP: 10,
        LEFT_BOTTOM: 11,
    };
    Point[Point.RIGHT_CENTER] = 'RIGHT_CENTER';
    Point[Point.RIGHT_TOP] = 'RIGHT_TOP';
    Point[Point.RIGHT_BOTTOM] = 'RIGHT_BOTTOM';
    Point[Point.TOP_CENTER] = 'TOP_CENTER';
    Point[Point.TOP_RIGHT] = 'TOP_RIGHT';
    Point[Point.TOP_LEFT] = 'TOP_LEFT';
    Point[Point.BOTTOM_CENTER] = 'BOTTOM_CENTER';
    Point[Point.BOTTOM_RIGHT] = 'BOTTOM_RIGHT';
    Point[Point.BOTTOM_LEFT] = 'BOTTOM_LEFT';
    Point[Point.LEFT_CENTER] = 'LEFT_CENTER';
    Point[Point.LEFT_TOP] = 'LEFT_TOP';
    Point[Point.LEFT_BOTTOM] = 'LEFT_BOTTOM';
    /** @type {?} */
    var POSITION_RELATIVE = 'relative';
    /** @type {?} */
    var POSITION_ABSOLUTE = 'absolute';
    /** @type {?} */
    var POSITION_FIXED = 'fixed';
    /** @type {?} */
    var OVERFLOW_SCROLL = 'scroll';
    /** @type {?} */
    var OVERFLOW_AUTO = 'auto';
    var Popover = /** @class */ (function () {
        function Popover(element) {
            this.element = element;
            /*
                 * Containers up to the first positioned one will have an event on scroll
                 */
            this.scrollableElements = [];
            this.boundOnScrollListener = this.emitScrollEvent.bind(this);
            // Browsers don't agree with what to do if some of these are not specified, so we set them all to be safe.
            element.style.position = POSITION_ABSOLUTE;
            element.style.top = 0;
            element.style.bottom = 'auto';
            element.style.left = 0;
            element.style.right = 'auto';
        }
        // TODO: need a way to account for parameters that change dynamically (positioning).
        // TODO: need a way to account for parameters that change dynamically (positioning).
        /**
         * @param {?} anchor
         * @param {?} anchorAlign
         * @param {?} popoverAlign
         * @param {?=} __3
         * @return {?}
         */
        Popover.prototype.anchor =
            // TODO: need a way to account for parameters that change dynamically (positioning).
            /**
             * @param {?} anchor
             * @param {?} anchorAlign
             * @param {?} popoverAlign
             * @param {?=} __3
             * @return {?}
             */
            function (anchor, anchorAlign, popoverAlign, _a) {
                // TODO: we are assuming here that the popover is inside or next to the anchor.
                // We'd need to go up the popover tree too otherwise
                var _b = _a === void 0 ? {} : _a, _c = _b.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _b.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _b.useAnchorParent, useAnchorParent = _e === void 0 ? false : _e;
                this.addScrollEventListeners(anchor);
                if (useAnchorParent) {
                    anchor = anchor.parentNode;
                }
                // explicitly override anchor's style to static
                anchor.style.position = 'static';
                /** @type {?} */
                var anchorRect = anchor.getBoundingClientRect();
                /** @type {?} */
                var popoverRect = this.element.getBoundingClientRect();
                // position of left top corner of anchor + the offset
                /** @type {?} */
                var leftDiff = anchorRect.left - popoverRect.left + offsetX;
                /** @type {?} */
                var topDiff = anchorRect.top - popoverRect.top + offsetY;
                // first, adjust positioning based on anchor's align point
                switch (anchorAlign) {
                    case Point.LEFT_TOP:
                    case Point.TOP_LEFT:
                        break;
                    case Point.TOP_CENTER:
                        leftDiff += anchorRect.width / 2;
                        break;
                    case Point.TOP_RIGHT:
                        leftDiff += anchorRect.width;
                        break;
                    case Point.RIGHT_TOP:
                        leftDiff += anchorRect.width;
                        break;
                    case Point.LEFT_BOTTOM:
                        topDiff += anchorRect.height;
                        break;
                    case Point.BOTTOM_LEFT:
                        topDiff += anchorRect.height;
                        break;
                    case Point.BOTTOM_CENTER:
                        topDiff += anchorRect.height;
                        leftDiff += anchorRect.width / 2;
                        break;
                    case Point.BOTTOM_RIGHT:
                        topDiff += anchorRect.height;
                        leftDiff += anchorRect.width;
                        break;
                    case Point.RIGHT_BOTTOM:
                        topDiff += anchorRect.height;
                        leftDiff += anchorRect.width;
                        break;
                    case Point.LEFT_CENTER:
                        topDiff += anchorRect.height / 2;
                        break;
                    case Point.RIGHT_CENTER:
                        topDiff += anchorRect.height / 2;
                        leftDiff += anchorRect.width;
                        break;
                    default:
                }
                // second, adjust positioning based on popover's align point
                switch (popoverAlign) {
                    case Point.LEFT_TOP:
                    case Point.TOP_LEFT:
                        break;
                    case Point.TOP_CENTER:
                        leftDiff -= popoverRect.width / 2;
                        break;
                    case Point.TOP_RIGHT:
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.RIGHT_TOP:
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.LEFT_BOTTOM:
                        topDiff -= popoverRect.height;
                        break;
                    case Point.BOTTOM_LEFT:
                        topDiff -= popoverRect.height;
                        break;
                    case Point.BOTTOM_CENTER:
                        topDiff -= popoverRect.height;
                        leftDiff -= popoverRect.width / 2;
                        break;
                    case Point.BOTTOM_RIGHT:
                        topDiff -= popoverRect.height;
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.RIGHT_BOTTOM:
                        topDiff -= popoverRect.height;
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.LEFT_CENTER:
                        topDiff -= popoverRect.height / 2;
                        break;
                    case Point.RIGHT_CENTER:
                        topDiff -= popoverRect.height / 2;
                        leftDiff -= popoverRect.width;
                        break;
                    default:
                }
                // Third, adjust with popover's margins based on the two align points.
                // Here, we make an assumption that popover is primarily positioned outside the
                // anchor with minor offset. Without this assumption, it's impossible to apply
                // the popover's margins in a predictable way. For example, assume that a popover
                // and its anchor are exactly the same size. if a popover is positioned inside the
                // anchor (which is technically possible), then it becomes impossible to know what to do
                // if the popover has a non-zero margin value all around (because applying the margin in
                // all four directions will result in no margin visually, which isn't what we want).
                // Therefore, our logic makes assumptions about margins of interest given the points,
                // and only covers the cases where popover is outside the anchor.
                /** @type {?} */
                var popoverComputedStyle = getComputedStyle(this.element);
                /** @type {?} */
                var marginLeft = parseInt(popoverComputedStyle.marginLeft, 10);
                /** @type {?} */
                var marginRight = parseInt(popoverComputedStyle.marginRight, 10);
                /** @type {?} */
                var marginTop = parseInt(popoverComputedStyle.marginTop, 10);
                /** @type {?} */
                var marginBottom = parseInt(popoverComputedStyle.marginBottom, 10);
                switch (anchorAlign) {
                    case Point.LEFT_TOP:
                    case Point.TOP_LEFT:
                    case Point.TOP_RIGHT:
                    case Point.RIGHT_TOP:
                        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                            topDiff -= marginBottom;
                            leftDiff -= marginRight;
                        }
                        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                            topDiff -= marginTop;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                            topDiff += marginTop;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                            topDiff += marginTop;
                            leftDiff -= marginRight;
                        }
                        break;
                    case Point.LEFT_BOTTOM:
                    case Point.BOTTOM_LEFT:
                    case Point.BOTTOM_RIGHT:
                    case Point.RIGHT_BOTTOM:
                        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                            topDiff -= marginBottom;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                            topDiff -= marginBottom;
                            leftDiff -= marginRight;
                        }
                        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                            topDiff += marginTop;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                            topDiff += marginTop;
                            leftDiff -= marginRight;
                        }
                        break;
                    case Point.TOP_CENTER:
                        topDiff -= marginBottom;
                        leftDiff += marginLeft;
                        leftDiff -= marginRight;
                        break;
                    case Point.BOTTOM_CENTER:
                        topDiff += marginTop;
                        leftDiff += marginLeft;
                        leftDiff -= marginRight;
                        break;
                    case Point.LEFT_CENTER:
                        topDiff += marginTop;
                        topDiff -= marginBottom;
                        leftDiff -= marginRight;
                        break;
                    case Point.RIGHT_CENTER:
                        topDiff += marginTop;
                        topDiff -= marginBottom;
                        leftDiff += marginLeft;
                        break;
                    default:
                }
                this.element.style.transform = "translateX(" + Math.round(leftDiff) + "px) translateY(" + Math.round(topDiff) + "px)";
                return this._scroll.asObservable();
            };
        /**
         * @return {?}
         */
        Popover.prototype.release = /**
         * @return {?}
         */
            function () {
                this.element.style.transform = '';
                this.removeScrollEventListeners();
            };
        /**
         * @param {?} container
         * @return {?}
         */
        Popover.prototype.isPositioned = /**
         * @param {?} container
         * @return {?}
         */
            function (container) {
                /** @type {?} */
                var position = getComputedStyle(container).position;
                return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
            };
        /**
         * @return {?}
         */
        Popover.prototype.emitScrollEvent = /**
         * @return {?}
         */
            function () {
                this._scroll.next();
            };
        /**
         * @param {?} e
         * @return {?}
         */
        Popover.prototype.addScrollEventListeners = /**
         * @param {?} e
         * @return {?}
         */
            function (e) {
                this._scroll = new rxjs.Subject();
                /** @type {?} */
                var anchor = e;
                /** @type {?} */
                var current = e;
                while (current && current !== document) {
                    if (this.scrolls(current)) {
                        current.addEventListener('scroll', this.boundOnScrollListener);
                        this.scrollableElements.push(current);
                    }
                    if (current !== anchor && this.isPositioned(current)) {
                        break;
                    }
                    current = current.parentNode;
                }
            };
        /**
         * @return {?}
         */
        Popover.prototype.removeScrollEventListeners = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                try {
                    for (var _b = __values(this.scrollableElements), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var elem = _c.value;
                        elem.removeEventListener('scroll', this.boundOnScrollListener);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                this.scrollableElements.length = 0;
                if (this._scroll) {
                    this._scroll.complete();
                    delete this._scroll;
                }
            };
        /**
         * @param {?} container
         * @return {?}
         */
        Popover.prototype.scrolls = /**
         * @param {?} container
         * @return {?}
         */
            function (container) {
                /** @type {?} */
                var computedStyles = getComputedStyle(container);
                return (computedStyles.overflowX === OVERFLOW_SCROLL ||
                    computedStyles.overflowX === OVERFLOW_AUTO ||
                    computedStyles.overflowY === OVERFLOW_SCROLL ||
                    computedStyles.overflowY === OVERFLOW_AUTO);
            };
        return Popover;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var openCount = 0;
    /** @type {?} */
    var waiting = [];
    // pending create functions
    var PopoverDirectiveOld = /** @class */ (function () {
        function PopoverDirectiveOld(templateRef, viewContainer) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.popoverOptions = {};
            this.clrPopoverOldChange = new i0.EventEmitter(false);
        }
        Object.defineProperty(PopoverDirectiveOld.prototype, "clrPopoverOld", {
            set: /**
             * @param {?} open
             * @return {?}
             */ function (open) {
                var _this = this;
                if (open) {
                    if (this.popoverOptions.allowMultipleOpen) {
                        this.createPopover();
                    }
                    else {
                        if (openCount === 0) {
                            this.createPopover();
                        }
                        else {
                            waiting.push(function () {
                                _this.createPopover();
                            });
                        }
                    }
                }
                else {
                    this.viewContainer.clear();
                    this.destroyPopover();
                    if (!this.popoverOptions.allowMultipleOpen) {
                        if (waiting.length > 0) {
                            /** @type {?} */
                            var createPopoverFn = waiting.shift();
                            createPopoverFn();
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PopoverDirectiveOld.prototype.createPopover = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var embeddedViewRef = ( /** @type {?} */(this.viewContainer.createEmbeddedView(this.templateRef)));
                // TODO: Not sure of the risks associated with using this. Find an alternative.
                // Needed for find the correct height and width of dynamically created views
                // inside of the popover. For Eg: Button Groups
                embeddedViewRef.detectChanges();
                // filter out other nodes in the view ref so we are only left with element nodes
                /** @type {?} */
                var elementNodes = embeddedViewRef.rootNodes.filter(function (node) {
                    return node.nodeType === 1;
                });
                // we take the first element node in the embedded view; usually there should only be one anyways
                this._popoverInstance = new Popover(elementNodes[0]);
                this._subscription = this._popoverInstance
                    .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                    .subscribe(function () {
                    _this.clrPopoverOldChange.emit(false);
                });
                openCount++;
            };
        /**
         * @return {?}
         */
        PopoverDirectiveOld.prototype.destroyPopover = /**
         * @return {?}
         */
            function () {
                if (this._popoverInstance) {
                    this._subscription.unsubscribe();
                    this._popoverInstance.release();
                    delete this._popoverInstance;
                    openCount--;
                }
            };
        /**
         * @return {?}
         */
        PopoverDirectiveOld.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.destroyPopover();
            };
        PopoverDirectiveOld.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPopoverOld]' },] }
        ];
        /** @nocollapse */
        PopoverDirectiveOld.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        PopoverDirectiveOld.propDecorators = {
            anchorElem: [{ type: i0.Input, args: ['clrPopoverOldAnchor',] }],
            anchorPoint: [{ type: i0.Input, args: ['clrPopoverOldAnchorPoint',] }],
            popoverPoint: [{ type: i0.Input, args: ['clrPopoverOldPopoverPoint',] }],
            popoverOptions: [{ type: i0.Input, args: ['clrPopoverOldOptions',] }],
            clrPopoverOldChange: [{ type: i0.Output, args: ['clrPopoverOldChange',] }],
            clrPopoverOld: [{ type: i0.Input }]
        };
        return PopoverDirectiveOld;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var POPOVER_DIRECTIVES = [PopoverDirectiveOld];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCommonPopoverModule = /** @class */ (function () {
        function ClrCommonPopoverModule() {
        }
        ClrCommonPopoverModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [POPOVER_DIRECTIVES], exports: [POPOVER_DIRECTIVES] },] }
        ];
        return ClrCommonPopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
     * This does not mean you should extend it, simply implementing it is fine.
     * @abstract
     */
    var /**
     * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
     * This does not mean you should extend it, simply implementing it is fine.
     * @abstract
     */ LoadingListener = /** @class */ (function () {
        function LoadingListener() {
        }
        return LoadingListener;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var ClrLoadingState = {
        DEFAULT: 0,
        LOADING: 1,
        SUCCESS: 2,
        ERROR: 3,
    };
    ClrLoadingState[ClrLoadingState.DEFAULT] = 'DEFAULT';
    ClrLoadingState[ClrLoadingState.LOADING] = 'LOADING';
    ClrLoadingState[ClrLoadingState.SUCCESS] = 'SUCCESS';
    ClrLoadingState[ClrLoadingState.ERROR] = 'ERROR';
    var ClrLoading = /** @class */ (function () {
        // We find the first parent that handles something loading
        function ClrLoading(listener) {
            this.listener = listener;
            this._loadingState = ClrLoadingState.DEFAULT;
        }
        Object.defineProperty(ClrLoading.prototype, "loadingState", {
            get: /**
             * @return {?}
             */ function () {
                return this._loadingState;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === true) {
                    value = ClrLoadingState.LOADING;
                }
                else if (!value) {
                    value = ClrLoadingState.DEFAULT;
                }
                if (value === this._loadingState) {
                    return;
                }
                this._loadingState = value;
                if (this.listener) {
                    this.listener.loadingStateChange(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrLoading.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.loadingState = ClrLoadingState.DEFAULT;
            };
        ClrLoading.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrLoading]' },] }
        ];
        /** @nocollapse */
        ClrLoading.ctorParameters = function () {
            return [
                { type: LoadingListener, decorators: [{ type: i0.Optional }] }
            ];
        };
        ClrLoading.propDecorators = {
            loadingState: [{ type: i0.Input, args: ['clrLoading',] }]
        };
        return ClrLoading;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ButtonInGroupService = /** @class */ (function () {
        function ButtonInGroupService() {
            this._changes = new rxjs.Subject();
        }
        Object.defineProperty(ButtonInGroupService.prototype, "changes", {
            get: /**
             * @return {?}
             */ function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} button
         * @return {?}
         */
        ButtonInGroupService.prototype.updateButtonGroup = /**
         * @param {?} button
         * @return {?}
         */
            function (button) {
                this._changes.next(button);
            };
        ButtonInGroupService.decorators = [
            { type: i0.Injectable }
        ];
        return ButtonInGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrButton = /** @class */ (function () {
        function ClrButton(buttonInGroupService) {
            this.buttonInGroupService = buttonInGroupService;
            this._enableService = false;
            this._inMenu = false;
            this._classNames = 'btn';
            this._name = null;
            this._type = null;
            this._id = null;
            this._disabled = null;
            this._click = new i0.EventEmitter(false);
        }
        Object.defineProperty(ClrButton.prototype, "inMenu", {
            get: /**
             * @return {?}
             */ function () {
                return this._inMenu;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this._inMenu !== value) {
                    this._inMenu = value;
                    // We check if the service flag is enabled
                    // and if the service exists because the service is optional
                    if (this._enableService && this.buttonInGroupService) {
                        this.buttonInGroupService.updateButtonGroup(this);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    /** @type {?} */
                    var classNames = value.split(' ');
                    if (classNames.indexOf('btn') === -1) {
                        classNames.push('btn');
                    }
                    this._classNames = classNames.join(' ');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    this._name = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this._type;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    this._type = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    this._id = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== null && value !== false) {
                    this._disabled = '';
                }
                else {
                    this._disabled = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} state
         * @return {?}
         */
        ClrButton.prototype.loadingStateChange = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                this.loading = state === ClrLoadingState.LOADING;
            };
        /**
         * @return {?}
         */
        ClrButton.prototype.emitClick = /**
         * @return {?}
         */
            function () {
                this._click.emit(true);
            };
        /**
         * @return {?}
         */
        ClrButton.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._enableService = true;
            };
        ClrButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-button',
                        template: "\n        <ng-template #buttonProjectedRef>\n            <button \n                [class]=\"classNames\" \n                (click)=\"emitClick()\"\n                [attr.type]=\"type\"\n                [attr.name]=\"name\"\n                [attr.disabled]=\"disabled\"\n                [id]=\"id\">\n                <span class=\"spinner spinner-inline\" *ngIf=\"loading\"></span>\n                <ng-content></ng-content>\n            </button>\n        </ng-template>\n    ",
                        providers: [{ provide: LoadingListener, useExisting: ClrButton }]
                    }] }
        ];
        /** @nocollapse */
        ClrButton.ctorParameters = function () {
            return [
                { type: ButtonInGroupService, decorators: [{ type: i0.SkipSelf }, { type: i0.Optional }] }
            ];
        };
        ClrButton.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['buttonProjectedRef',] }],
            inMenu: [{ type: i0.Input, args: ['clrInMenu',] }],
            classNames: [{ type: i0.Input, args: ['class',] }],
            name: [{ type: i0.Input, args: ['name',] }],
            type: [{ type: i0.Input, args: ['type',] }],
            id: [{ type: i0.Input, args: ['id',] }],
            disabled: [{ type: i0.Input, args: ['disabled',] }],
            _click: [{ type: i0.Output, args: ['click',] }]
        };
        return ClrButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @type {?} */
    var CLR_MENU_POSITIONS = [
        'bottom-left',
        'bottom-right',
        'top-left',
        'top-right',
        'left-bottom',
        'left-top',
        'right-bottom',
        'right-top',
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @type {?} */
    var commonStringsDefault = {
        open: 'Open',
        close: 'Close',
        show: 'Show',
        hide: 'Hide',
        expand: 'Expand',
        collapse: 'Collapse',
        more: 'More',
        select: 'Select',
        selectAll: 'Select All',
        previous: 'Previous',
        next: 'Next',
        current: 'Jump to current',
        info: 'Info',
        success: 'Success',
        warning: 'Warning',
        danger: 'Error',
        rowActions: 'Available actions',
        pickColumns: 'Show or hide columns',
        showColumns: 'Show Columns',
        sortColumn: 'Sort Column',
        firstPage: 'First Page',
        lastPage: 'Last Page',
        nextPage: 'Next Page',
        previousPage: 'Previous Page',
        currentPage: 'Current Page',
        totalPages: 'Total Pages',
        minValue: 'Min value',
        maxValue: 'Max value',
        modalContentStart: 'Beginning of Modal Content',
        modalContentEnd: 'End of Modal Content',
        showColumnsMenuDescription: 'Show or hide columns menu',
        allColumnsSelected: 'All columns selected',
        signpostToggle: 'Signpost Toggle',
        signpostClose: 'Signpost Close',
        loading: 'Loading',
        singleSelectionAriaLabel: 'Single selection header',
        singleActionableAriaLabel: 'Single actionable header',
        detailExpandableAriaLabel: 'Toggle more row content',
        // Alert
        alertCloseButtonAriaLabel: 'Close alert',
        // Date Picker
        datepickerToggle: 'Toggle datepicker',
        datepickerPreviousMonth: 'Previous month',
        datepickerCurrentMonth: 'Current month',
        datepickerNextMonth: 'Next month',
        datepickerPreviousDecade: 'Previous decade',
        datepickerNextDecade: 'Next decade',
        datepickerCurrentDecade: 'Current decade',
        datepickerSelectMonthText: 'Select month, the current month is {CALENDAR_MONTH}',
        datepickerSelectYearText: 'Select year, the current year is {CALENDAR_YEAR}',
        daypickerSRCurrentMonthPhrase: 'The current month is {CURRENT_MONTH}',
        daypickerSRCurrentYearPhrase: 'The current year is {CURRENT_YEAR}',
        daypickerSRCurrentDecadePhrase: 'The current decade is {DECADE_RANGE}',
        // Stack View
        stackViewChanged: 'Value changed.',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCommonStringsService = /** @class */ (function () {
        function ClrCommonStringsService() {
            this._strings = commonStringsDefault;
        }
        /**
         * Allows you to pass in new overrides for localization
         */
        /**
         * Allows you to pass in new overrides for localization
         * @param {?} overrides
         * @return {?}
         */
        ClrCommonStringsService.prototype.localize = /**
         * Allows you to pass in new overrides for localization
         * @param {?} overrides
         * @return {?}
         */
            function (overrides) {
                this._strings = __assign({}, this._strings, overrides);
            };
        Object.defineProperty(ClrCommonStringsService.prototype, "keys", {
            /**
             * Access to all of the keys as strings
             */
            get: /**
             * Access to all of the keys as strings
             * @return {?}
             */ function () {
                return this._strings;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Parse a string with a set of tokens to replace
         */
        /**
         * Parse a string with a set of tokens to replace
         * @param {?} source
         * @param {?=} tokens
         * @return {?}
         */
        ClrCommonStringsService.prototype.parse = /**
         * Parse a string with a set of tokens to replace
         * @param {?} source
         * @param {?=} tokens
         * @return {?}
         */
            function (source, tokens) {
                if (tokens === void 0) {
                    tokens = {};
                }
                /** @type {?} */
                var names = Object.keys(tokens);
                /** @type {?} */
                var output = source;
                if (names.length) {
                    names.forEach(function (name) {
                        output = output.replace("{" + name + "}", tokens[name]);
                    });
                }
                return output;
            };
        ClrCommonStringsService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root',
                    },] }
        ];
        /** @nocollapse */ ClrCommonStringsService.ngInjectableDef = i0.defineInjectable({ factory: function ClrCommonStringsService_Factory() { return new ClrCommonStringsService(); }, token: ClrCommonStringsService, providedIn: "root" });
        return ClrCommonStringsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrButtonGroup = /** @class */ (function () {
        function ClrButtonGroup(buttonGroupNewService, elementRef, commonStrings) {
            this.buttonGroupNewService = buttonGroupNewService;
            this.elementRef = elementRef;
            this.commonStrings = commonStrings;
            this.inlineButtons = [];
            this.menuButtons = [];
            this._openMenu = false;
            this.anchorPoint = Point.BOTTOM_LEFT; // default if menuPosition isn't set
            // default if menuPosition isn't set
            this.popoverPoint = Point.LEFT_TOP; // default if menuPosition isn't set
            /**
             * Flag with indicates if the overflow menu toggle was clicked.
             * If true, this can save us traversing the DOM to find
             * whether the click was withing the button group toggle
             * or menu in the onMouseClick method
             */
            this._overflowMenuToggleClicked = false;
        }
        /**
         * 1. Initializes the initial Button Group View
         * 2. Subscribes to changes on the ContentChildren
         *    in case the user content projection changes
         */
        /**
         * 1. Initializes the initial Button Group View
         * 2. Subscribes to changes on the ContentChildren
         *    in case the user content projection changes
         * @return {?}
         */
        ClrButtonGroup.prototype.ngAfterContentInit = /**
         * 1. Initializes the initial Button Group View
         * 2. Subscribes to changes on the ContentChildren
         *    in case the user content projection changes
         * @return {?}
         */
            function () {
                var _this = this;
                this.initializeButtons();
                this.buttonGroupNewService.changes.subscribe(function (button) { return _this.rearrangeButton(button); });
                this.buttons.changes.subscribe(function () {
                    _this.initializeButtons();
                });
            };
        /**
         * Moves the button into the other ViewContainer
         * when an update is received.
         *
         * @param button
         */
        /**
         * Moves the button into the other ViewContainer
         * when an update is received.
         *
         * @param {?} button
         * @return {?}
         */
        ClrButtonGroup.prototype.rearrangeButton = /**
         * Moves the button into the other ViewContainer
         * when an update is received.
         *
         * @param {?} button
         * @return {?}
         */
            function (button) {
                /** @type {?} */
                var fromView;
                /** @type {?} */
                var toView;
                if (button.inMenu) {
                    fromView = this.inlineButtons;
                    toView = this.menuButtons;
                }
                else {
                    fromView = this.menuButtons;
                    toView = this.inlineButtons;
                }
                /** @type {?} */
                var index = fromView.indexOf(button);
                if (index > -1) {
                    fromView.splice(index, 1);
                    /** @type {?} */
                    var moveIndex = this.getMoveIndex(button);
                    if (moveIndex <= toView.length) {
                        toView.splice(moveIndex, 0, button);
                    }
                }
            };
        /**
         * Author: Eudes
         *
         * Finds the order of a button w.r.t other buttons
         *
         * @param buttonToMove
         * @returns
         */
        /**
         * Author: Eudes
         *
         * Finds the order of a button w.r.t other buttons
         *
         * @param {?} buttonToMove
         * @return {?}
         */
        ClrButtonGroup.prototype.getMoveIndex = /**
         * Author: Eudes
         *
         * Finds the order of a button w.r.t other buttons
         *
         * @param {?} buttonToMove
         * @return {?}
         */
            function (buttonToMove) {
                /** @type {?} */
                var tempArr = this.buttons.filter(function (button) { return button.inMenu === buttonToMove.inMenu; });
                return tempArr.indexOf(buttonToMove);
            };
        /**
         * @return {?}
         */
        ClrButtonGroup.prototype.initializeButtons = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var tempInlineButtons = [];
                /** @type {?} */
                var tempInMenuButtons = [];
                this.buttons.forEach(function (button) {
                    if (button.inMenu) {
                        tempInMenuButtons.push(button);
                    }
                    else {
                        tempInlineButtons.push(button);
                    }
                });
                this.inlineButtons = tempInlineButtons;
                this.menuButtons = tempInMenuButtons;
            };
        Object.defineProperty(ClrButtonGroup.prototype, "menuPosition", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuPosition;
            },
            set: /**
             * @param {?} pos
             * @return {?}
             */ function (pos) {
                if (pos && CLR_MENU_POSITIONS.indexOf(pos) > -1) {
                    this._menuPosition = pos;
                }
                else {
                    this._menuPosition = 'bottom-left';
                }
                // set the popover values based on menu position
                switch (this._menuPosition) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_RIGHT;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_LEFT;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_RIGHT;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-top':
                        this.anchorPoint = Point.RIGHT_TOP;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-bottom':
                        this.anchorPoint = Point.RIGHT_BOTTOM;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'left-top':
                        this.anchorPoint = Point.LEFT_TOP;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'left-bottom':
                        this.anchorPoint = Point.LEFT_BOTTOM;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    default:
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButtonGroup.prototype, "openMenu", {
            get: /**
             * @return {?}
             */ function () {
                return this._openMenu;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._openMenu = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
         * clicked. Also set a flag that indicates that the toggle
         * was clicked so that we don't traverse the DOM to find the
         * location of the click.
         */
        // default if menuPosition isn't set
        /**
         * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
         * clicked. Also set a flag that indicates that the toggle
         * was clicked so that we don't traverse the DOM to find the
         * location of the click.
         * @return {?}
         */
        ClrButtonGroup.prototype.toggleMenu =
            // default if menuPosition isn't set
            /**
             * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
             * clicked. Also set a flag that indicates that the toggle
             * was clicked so that we don't traverse the DOM to find the
             * location of the click.
             * @return {?}
             */
            function () {
                this.openMenu = !this.openMenu;
                this._overflowMenuToggleClicked = true;
            };
        // TODO: Generic Directive to handle this
        /**
         * Called on mouse clicks anywhere in the DOM.
         * Checks to see if the mouseclick happened on the host or outside
         */
        // TODO: Generic Directive to handle this
        /**
         * Called on mouse clicks anywhere in the DOM.
         * Checks to see if the mouseclick happened on the host or outside
         * @param {?} target
         * @return {?}
         */
        ClrButtonGroup.prototype.onMouseClick =
            // TODO: Generic Directive to handle this
            /**
             * Called on mouse clicks anywhere in the DOM.
             * Checks to see if the mouseclick happened on the host or outside
             * @param {?} target
             * @return {?}
             */
            function (target) {
                if (this.openMenu && !this._overflowMenuToggleClicked) {
                    // Reset the overflow menu toggle clicked flag
                    this._overflowMenuToggleClicked = false;
                    /** @type {?} */
                    var current = target;
                    // Get the element in the DOM on which the mouse was clicked
                    /** @type {?} */
                    var host = this.elementRef.nativeElement;
                    if (current.classList.contains('dropdown-menu')) {
                        current = current.parentNode;
                        while (current) {
                            if (current === document) {
                                this.openMenu = false;
                                return;
                            }
                            // If clicked on dropdown menu and menu is in host
                            // do nothing
                            if (current === host) {
                                return;
                            }
                            current = current.parentNode;
                        }
                    }
                    this.openMenu = false;
                }
                this._overflowMenuToggleClicked = false; // Reset the overflow menu toggle clicked flag
            };
        ClrButtonGroup.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-button-group',
                        template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-container *ngFor=\"let inlineButton of inlineButtons\">\n    <ng-template [ngTemplateOutlet]=\"inlineButton.templateRef\"></ng-template>\n</ng-container>\n<ng-container *ngIf=\"menuButtons.length > 0\">\n    <div\n        class=\"btn-group-overflow open\"\n        [ngClass]=\"menuPosition\"\n        #anchor>\n        <button\n            class=\"btn dropdown-toggle\"\n            (click)=\"toggleMenu()\">\n            <clr-icon shape=\"ellipsis-horizontal\" [attr.title]=\"commonStrings.keys.more\"></clr-icon>\n        </button>\n        <div\n            class=\"dropdown-menu\"\n            *clrPopoverOld=\"openMenu; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint;\">\n            <ng-template [ngTemplateOutlet]=\"ref\"></ng-template>\n        </div>\n    </div>\n</ng-container>\n<ng-template #ref>\n    <ng-container *ngFor=\"let menuButton of menuButtons\">\n        <ng-template [ngTemplateOutlet]=\"menuButton.templateRef\"></ng-template>\n    </ng-container>\n</ng-template>\n",
                        providers: [ButtonInGroupService],
                        host: { '[class.btn-group]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrButtonGroup.ctorParameters = function () {
            return [
                { type: ButtonInGroupService },
                { type: i0.ElementRef },
                { type: ClrCommonStringsService }
            ];
        };
        ClrButtonGroup.propDecorators = {
            buttons: [{ type: i0.ContentChildren, args: [ClrButton,] }],
            menuPosition: [{ type: i0.Input, args: ['clrMenuPosition',] }],
            onMouseClick: [{ type: i0.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return ClrButtonGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_BUTTON_GROUP_DIRECTIVES = [ClrButton, ClrButtonGroup];
    var ClrButtonGroupModule = /** @class */ (function () {
        function ClrButtonGroupModule() {
        }
        ClrButtonGroupModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrCommonPopoverModule],
                        declarations: [CLR_BUTTON_GROUP_DIRECTIVES],
                        exports: [CLR_BUTTON_GROUP_DIRECTIVES],
                    },] }
        ];
        return ClrButtonGroupModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLoadingButton = /** @class */ (function () {
        function ClrLoadingButton(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.buttonState = ClrLoadingState;
            this.state = ClrLoadingState.DEFAULT;
            this.clrLoadingChange = new i0.EventEmitter(false);
        }
        /**
         * @param {?} state
         * @return {?}
         */
        ClrLoadingButton.prototype.loadingStateChange = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                if (state === this.state) {
                    return;
                }
                this.state = state;
                switch (state) {
                    case ClrLoadingState.DEFAULT:
                        this.renderer.removeStyle(this.el.nativeElement, 'width');
                        this.renderer.removeStyle(this.el.nativeElement, 'transform'); // for chromium render bug see issue https://github.com/vmware/clarity/issues/2700
                        if (!this.disabled) {
                            this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                        }
                        break;
                    case ClrLoadingState.LOADING:
                        this.setExplicitButtonWidth();
                        this.renderer.setStyle(this.el.nativeElement, 'transform', 'translatez(0)'); // for chromium render bug see issue https://github.com/vmware/clarity/issues/2700
                        this.renderer.setAttribute(this.el.nativeElement, 'disabled', '');
                        break;
                    case ClrLoadingState.SUCCESS:
                        this.setExplicitButtonWidth();
                        break;
                    case ClrLoadingState.ERROR:
                        this.loadingStateChange(ClrLoadingState.DEFAULT);
                        break;
                    default:
                        break;
                }
                this.clrLoadingChange.emit(state);
            };
        /**
         * @return {?}
         */
        ClrLoadingButton.prototype.setExplicitButtonWidth = /**
         * @return {?}
         */
            function () {
                if (this.el.nativeElement && this.el.nativeElement.getBoundingClientRect) {
                    /** @type {?} */
                    var boundingClientRect = this.el.nativeElement.getBoundingClientRect();
                    this.renderer.setStyle(this.el.nativeElement, 'width', boundingClientRect.width + "px");
                }
            };
        ClrLoadingButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'button[clrLoading]',
                        template: "\n        <ng-container [ngSwitch]=\"state\">\n            <span *ngSwitchCase=\"buttonState.LOADING\">\n                <span @spinner class=\"spinner spinner-inline\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.SUCCESS\">\n                <span @validated (@validated.done)=\"this.loadingStateChange(this.buttonState.DEFAULT)\" class=\"spinner spinner-inline spinner-check\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.DEFAULT\" @defaultButton>\n                <ng-content></ng-content>\n            </span>\n        </ng-container>\n    ",
                        providers: [{ provide: LoadingListener, useExisting: ClrLoadingButton }],
                        animations: [
                            animations.trigger('defaultButton', [
                                animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                                // TODO: see if we can get leave animation to work before spinner's enter animation
                                animations.transition(':leave', [animations.style({ opacity: 0 })]),
                            ]),
                            animations.trigger('spinner', [
                                animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                                animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
                            ]),
                            animations.trigger('validated', [
                                animations.transition(':enter', [
                                    animations.animate('600ms', animations.keyframes([
                                        animations.style({ transform: 'scale(0,0)', offset: 0 }),
                                        animations.style({ opacity: 1, offset: 0.2 }),
                                        animations.style({ transform: 'scale(1.2,1.2)', offset: 0.4 }),
                                        animations.style({ transform: 'scale(.9,.9)', offset: 0.6 }),
                                        animations.style({ transform: 'scale(1,1)', offset: 1 }),
                                    ])),
                                ]),
                                animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
                            ]),
                        ],
                        host: { '[attr.disabled]': "disabled? '' : null" }
                    }] }
        ];
        /** @nocollapse */
        ClrLoadingButton.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        ClrLoadingButton.propDecorators = {
            disabled: [{ type: i0.Input, args: ['disabled',] }],
            clrLoadingChange: [{ type: i0.Output, args: ['clrLoadingChange',] }]
        };
        return ClrLoadingButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_LOADING_BUTTON_DIRECTIVES = [ClrLoadingButton];
    var ClrLoadingButtonModule = /** @class */ (function () {
        function ClrLoadingButtonModule() {
        }
        ClrLoadingButtonModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [CLR_LOADING_BUTTON_DIRECTIVES],
                        exports: [CLR_LOADING_BUTTON_DIRECTIVES],
                    },] }
        ];
        return ClrLoadingButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrButtonModule = /** @class */ (function () {
        function ClrButtonModule() {
        }
        ClrButtonModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [ClrLoadingButtonModule, ClrButtonGroupModule],
                    },] }
        ];
        return ClrButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var EmptyAnchor = /** @class */ (function () {
        function EmptyAnchor() {
        }
        EmptyAnchor.decorators = [
            { type: i0.Component, args: [{
                        template: ''
                    }] }
        ];
        return EmptyAnchor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Internal module, please do not export!
     */
    var ClrHostWrappingModule = /** @class */ (function () {
        function ClrHostWrappingModule() {
        }
        ClrHostWrappingModule.decorators = [
            { type: i0.NgModule, args: [{ declarations: [EmptyAnchor], exports: [EmptyAnchor], entryComponents: [EmptyAnchor] },] }
        ];
        return ClrHostWrappingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrControlError = /** @class */ (function () {
        function ClrControlError() {
        }
        ClrControlError.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-control-error',
                        template: "\n    <ng-content></ng-content>\n    ",
                        host: { '[class.clr-subtext]': 'true' }
                    }] }
        ];
        return ClrControlError;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var counter = 0;
    var ControlIdService = /** @class */ (function () {
        function ControlIdService() {
            this._id = 'clr-form-control-' + ++counter;
            this._idChange = new rxjs.BehaviorSubject(this._id);
        }
        Object.defineProperty(ControlIdService.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                this._idChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ControlIdService.prototype, "idChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._idChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        ControlIdService.decorators = [
            { type: i0.Injectable }
        ];
        return ControlIdService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrControlHelper = /** @class */ (function () {
        function ClrControlHelper(controlIdService) {
            this.controlIdService = controlIdService;
        }
        ClrControlHelper.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-control-helper',
                        template: "\n    <ng-content></ng-content>\n    ",
                        host: {
                            '[class.clr-subtext]': 'true',
                            '[id]': 'controlIdService?.id + "-helper"',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrControlHelper.ctorParameters = function () {
            return [
                { type: ControlIdService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return ClrControlHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NgControlService = /** @class */ (function () {
        function NgControlService() {
            // Observable to subscribe to the control, since its not available immediately for projected content
            this._controlChanges = new rxjs.Subject();
        }
        Object.defineProperty(NgControlService.prototype, "controlChanges", {
            get: /**
             * @return {?}
             */ function () {
                return this._controlChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} control
         * @return {?}
         */
        NgControlService.prototype.setControl = /**
         * @param {?} control
         * @return {?}
         */
            function (control) {
                this._controlChanges.next(control);
            };
        NgControlService.decorators = [
            { type: i0.Injectable }
        ];
        return NgControlService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var IfErrorService = /** @class */ (function () {
        function IfErrorService(ngControlService) {
            var _this = this;
            this.ngControlService = ngControlService;
            // Implement our own status changes observable, since Angular controls don't
            // fire on events like blur, and we want to return the boolean state instead of a string
            this._statusChanges = new rxjs.Subject();
            this.subscriptions = [];
            // Wait for the control to be available
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                if (control) {
                    _this.control = control;
                    _this.listenForChanges();
                }
            }));
        }
        Object.defineProperty(IfErrorService.prototype, "statusChanges", {
            get: /**
             * @return {?}
             */ function () {
                return this._statusChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        // Subscribe to the status change events, only after touched and emit the control
        // Subscribe to the status change events, only after touched and emit the control
        /**
         * @return {?}
         */
        IfErrorService.prototype.listenForChanges =
            // Subscribe to the status change events, only after touched and emit the control
            /**
             * @return {?}
             */
            function () {
                var _this = this;
                this.subscriptions.push(this.control.statusChanges.subscribe(function () {
                    _this.sendValidity();
                }));
            };
        /**
         * @return {?}
         */
        IfErrorService.prototype.sendValidity = /**
         * @return {?}
         */
            function () {
                if ((this.control.touched || this.control.dirty) && this.control.invalid) {
                    this._statusChanges.next(true);
                }
                else {
                    this._statusChanges.next(false);
                }
            };
        // Allows a control to push a status check upstream, such as on blur
        // Allows a control to push a status check upstream, such as on blur
        /**
         * @return {?}
         */
        IfErrorService.prototype.triggerStatusChange =
            // Allows a control to push a status check upstream, such as on blur
            /**
             * @return {?}
             */
            function () {
                if (this.control) {
                    this.sendValidity();
                }
            };
        // Clean up subscriptions
        // Clean up subscriptions
        /**
         * @return {?}
         */
        IfErrorService.prototype.ngOnDestroy =
            // Clean up subscriptions
            /**
             * @return {?}
             */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        IfErrorService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        IfErrorService.ctorParameters = function () {
            return [
                { type: NgControlService }
            ];
        };
        return IfErrorService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfError = /** @class */ (function () {
        function ClrIfError(ifErrorService, ngControlService, template, container) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.ngControlService = ngControlService;
            this.template = template;
            this.container = container;
            this.subscriptions = [];
            this.displayed = false;
            if (!this.ifErrorService) {
                throw new Error('clrIfError can only be used within a form control container element like clr-input-container');
            }
            else {
                this.displayError(false);
            }
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                // If there is a specific error to track, check it, otherwise check overall validity
                if (_this.error && _this.control) {
                    _this.displayError(_this.control.hasError(_this.error));
                }
                else {
                    _this.displayError(invalid);
                }
            }));
        }
        /**
         * @return {?}
         */
        ClrIfError.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @param {?} invalid
         * @return {?}
         */
        ClrIfError.prototype.displayError = /**
         * @param {?} invalid
         * @return {?}
         */
            function (invalid) {
                if (invalid && !this.displayed) {
                    this.container.createEmbeddedView(this.template);
                    this.displayed = true;
                }
                else if (!invalid) {
                    this.container.clear();
                    this.displayed = false;
                }
            };
        ClrIfError.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfError]' },] }
        ];
        /** @nocollapse */
        ClrIfError.ctorParameters = function () {
            return [
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrIfError.propDecorators = {
            error: [{ type: i0.Input, args: ['clrIfError',] }]
        };
        return ClrIfError;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var Layouts = {
        VERTICAL: 'vertical',
        HORIZONTAL: 'horizontal',
        COMPACT: 'compact',
    };
    var LayoutService = /** @class */ (function () {
        function LayoutService() {
            this.layout = Layouts.HORIZONTAL;
            // This is basically a replacement for Object.values(), which IE11 and Node <9 don't support :(
            // String enums cannot be reverse-mapped, meaning Layouts['COMPACT'] does not return 'compact' so
            // this exists to deal with this little caveat to get the list of the values as an array.
            this.layoutValues = Object.keys(Layouts).map(function (key) { return Layouts[key]; });
        }
        /**
         * @return {?}
         */
        LayoutService.prototype.isVertical = /**
         * @return {?}
         */
            function () {
                return this.layout === Layouts.VERTICAL;
            };
        /**
         * @return {?}
         */
        LayoutService.prototype.isHorizontal = /**
         * @return {?}
         */
            function () {
                return this.layout === Layouts.HORIZONTAL;
            };
        /**
         * @return {?}
         */
        LayoutService.prototype.isCompact = /**
         * @return {?}
         */
            function () {
                return this.layout === Layouts.COMPACT;
            };
        Object.defineProperty(LayoutService.prototype, "layoutClass", {
            get: /**
             * @return {?}
             */ function () {
                return "clr-form-" + this.layout;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} layout
         * @return {?}
         */
        LayoutService.prototype.isValid = /**
         * @param {?} layout
         * @return {?}
         */
            function (layout) {
                return this.layoutValues.indexOf(layout) > -1;
            };
        LayoutService.decorators = [
            { type: i0.Injectable }
        ];
        return LayoutService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLabel = /** @class */ (function () {
        function ClrLabel(controlIdService, layoutService, ngControlService, renderer, el) {
            this.controlIdService = controlIdService;
            this.layoutService = layoutService;
            this.ngControlService = ngControlService;
            this.renderer = renderer;
            this.el = el;
            this.subscriptions = [];
            this.enableGrid = true;
        }
        /**
         * @return {?}
         */
        ClrLabel.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Only add the clr-control-label if it is inside a control container
                if (this.controlIdService || this.ngControlService) {
                    this.renderer.addClass(this.el.nativeElement, 'clr-control-label');
                }
                // Only set the grid column classes if we are in the right context and if they aren't already set
                if (this.enableGrid &&
                    this.layoutService &&
                    !this.layoutService.isVertical() &&
                    this.el.nativeElement &&
                    this.el.nativeElement.className.indexOf('clr-col') < 0) {
                    this.renderer.addClass(this.el.nativeElement, 'clr-col-12');
                    this.renderer.addClass(this.el.nativeElement, 'clr-col-md-2');
                }
                if (this.controlIdService && !this.forAttr) {
                    this.subscriptions.push(this.controlIdService.idChange.subscribe(function (id) { return (_this.forAttr = id); }));
                }
            };
        /**
         * @return {?}
         */
        ClrLabel.prototype.disableGrid = /**
         * @return {?}
         */
            function () {
                this.enableGrid = false;
            };
        /**
         * @return {?}
         */
        ClrLabel.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrLabel.decorators = [
            { type: i0.Directive, args: [{ selector: 'label' },] }
        ];
        /** @nocollapse */
        ClrLabel.ctorParameters = function () {
            return [
                { type: ControlIdService, decorators: [{ type: i0.Optional }] },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        ClrLabel.propDecorators = {
            forAttr: [{ type: i0.HostBinding, args: ['attr.for',] }, { type: i0.Input, args: ['for',] }]
        };
        return ClrLabel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var IS_NEW_FORMS_LAYOUT = new i0.InjectionToken('IS_NEW_FORMS_LAYOUT');
    /** @type {?} */
    var IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER = {
        provide: IS_NEW_FORMS_LAYOUT,
        useValue: true,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var MarkControlService = /** @class */ (function () {
        function MarkControlService() {
            this._dirty = new rxjs.Subject();
        }
        Object.defineProperty(MarkControlService.prototype, "dirtyChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._dirty.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MarkControlService.prototype.markAsDirty = /**
         * @return {?}
         */
            function () {
                this._dirty.next();
            };
        MarkControlService.decorators = [
            { type: i0.Injectable }
        ];
        return MarkControlService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrForm = /** @class */ (function () {
        function ClrForm(layoutService, markControlService) {
            this.layoutService = layoutService;
            this.markControlService = markControlService;
        }
        /**
         * @return {?}
         */
        ClrForm.prototype.markAsDirty = /**
         * @return {?}
         */
            function () {
                this.markControlService.markAsDirty();
            };
        ClrForm.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrForm]',
                        providers: [LayoutService, MarkControlService, IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER],
                        host: {
                            '[class.clr-form]': 'true',
                            '[class.clr-form-horizontal]': 'layoutService.isHorizontal()',
                            '[class.clr-form-compact]': 'layoutService.isCompact()',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrForm.ctorParameters = function () {
            return [
                { type: LayoutService },
                { type: MarkControlService }
            ];
        };
        return ClrForm;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLayout = /** @class */ (function () {
        function ClrLayout(layoutService) {
            this.layoutService = layoutService;
        }
        /**
         * @return {?}
         */
        ClrLayout.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // Only set the layout if it is a valid option
                if (this.layout && this.layoutService.isValid(this.layout)) {
                    this.layoutService.layout = this.layout;
                }
            };
        ClrLayout.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrLayout]',
                    },] }
        ];
        /** @nocollapse */
        ClrLayout.ctorParameters = function () {
            return [
                { type: LayoutService }
            ];
        };
        ClrLayout.propDecorators = {
            layout: [{ type: i0.Input, args: ['clrLayout',] }]
        };
        return ClrLayout;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCommonFormsModule = /** @class */ (function () {
        function ClrCommonFormsModule() {
        }
        ClrCommonFormsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
                        exports: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
                    },] }
        ];
        return ClrCommonFormsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var IS_TOGGLE = new i0.InjectionToken('IS_TOGGLE');
    /**
     * @return {?}
     */
    function isToggleFactory() {
        return new rxjs.BehaviorSubject(false);
    }
    /** @type {?} */
    var IS_TOGGLE_PROVIDER = { provide: IS_TOGGLE, useFactory: isToggleFactory };
    var ClrCheckboxWrapper = /** @class */ (function () {
        function ClrCheckboxWrapper(toggleService) {
            var _this = this;
            // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
            // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
            // but we'd still need to insert a label
            this._dynamic = false;
            this.toggle = false;
            this.subscriptions = [];
            this.subscriptions.push(toggleService.subscribe(function (state) {
                _this.toggle = state;
            }));
        }
        /**
         * @return {?}
         */
        ClrCheckboxWrapper.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.label) {
                    this.label.disableGrid();
                }
            };
        /**
         * @return {?}
         */
        ClrCheckboxWrapper.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrCheckboxWrapper.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-checkbox-wrapper,clr-toggle-wrapper',
                        template: "\n    <ng-content select=\"[clrCheckbox],[clrToggle]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                        host: {
                            '[class.clr-checkbox-wrapper]': '!toggle',
                            '[class.clr-toggle-wrapper]': 'toggle',
                        },
                        providers: [ControlIdService, IS_TOGGLE_PROVIDER]
                    }] }
        ];
        /** @nocollapse */
        ClrCheckboxWrapper.ctorParameters = function () {
            return [
                { type: rxjs.BehaviorSubject, decorators: [{ type: i0.Inject, args: [IS_TOGGLE,] }] }
            ];
        };
        ClrCheckboxWrapper.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrCheckboxWrapper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
     * still undefined.
     * TODO - make sure these comment annotations do not break ng-packgr.
     * @template W
     */
    var /**
     * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
     * still undefined.
     * TODO - make sure these comment annotations do not break ng-packgr.
     * @template W
     */ HostWrapper = /** @class */ (function () {
        function HostWrapper(containerType, vcr, index) {
            if (index === void 0) {
                index = 0;
            }
            this.injector = vcr.injector;
            // If the host is already wrapped, we don't do anything
            if (!this.injector.get(containerType, null)) {
                /** @type {?} */
                var cfr = this.injector.get(i0.ComponentFactoryResolver);
                /** @type {?} */
                var el = this.injector.get(i0.ElementRef);
                // We need a new anchor, since we're projecting the current one.
                vcr.createComponent(cfr.resolveComponentFactory(EmptyAnchor));
                /** @type {?} */
                var factory = cfr.resolveComponentFactory(containerType);
                // Craft the element array based on what slot to use. Angular only uses the index to determine
                // which ng-content to project into, so if you have more than one ng-content you'll need to set
                // the index in the constructor appropriately
                /** @type {?} */
                var element = [];
                element[index] = [el.nativeElement];
                // We're assuming only one projection slot, but in more complex cases we might want to provide
                // a different array of projected elements.
                /** @type {?} */
                var containerRef = vcr.createComponent(factory, undefined, undefined, element);
                // We can now remove the useless anchor
                vcr.remove(0);
                // We note that the container was dynamically created
                containerRef.instance._dynamic = true;
                // We keep the wrapper's injector to access the dependencies that weren't available before.
                this.injector = containerRef.injector;
            }
        }
        /**
         * @template T
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        HostWrapper.prototype.get = /**
         * @template T
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
            function (token, notFoundValue) {
                return this.injector.get(token, notFoundValue);
            };
        return HostWrapper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ControlClassService = /** @class */ (function () {
        function ControlClassService() {
            this.className = '';
        }
        /**
         * @param {?=} invalid
         * @param {?=} grid
         * @param {?=} additional
         * @return {?}
         */
        ControlClassService.prototype.controlClass = /**
         * @param {?=} invalid
         * @param {?=} grid
         * @param {?=} additional
         * @return {?}
         */
            function (invalid, grid, additional) {
                if (invalid === void 0) {
                    invalid = false;
                }
                if (grid === void 0) {
                    grid = false;
                }
                if (additional === void 0) {
                    additional = '';
                }
                /** @type {?} */
                var controlClasses = [this.className, additional];
                if (invalid) {
                    controlClasses.push('clr-error');
                }
                if (grid && this.className.indexOf('clr-col') === -1) {
                    controlClasses.push('clr-col-md-10 clr-col-12');
                }
                return controlClasses.join(' ').trim();
            };
        // We want to remove the column classes from the input up to the container
        // We want to remove the column classes from the input up to the container
        /**
         * @param {?} renderer
         * @param {?} element
         * @return {?}
         */
        ControlClassService.prototype.initControlClass =
            // We want to remove the column classes from the input up to the container
            /**
             * @param {?} renderer
             * @param {?} element
             * @return {?}
             */
            function (renderer, element) {
                if (element && element.className) {
                    this.className = element.className;
                    /** @type {?} */
                    var klasses = element.className.split(' ');
                    klasses.forEach(function (klass) {
                        if (klass.startsWith('clr-col')) {
                            renderer.removeClass(element, klass);
                        }
                    });
                }
            };
        ControlClassService.decorators = [
            { type: i0.Injectable }
        ];
        return ControlClassService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template W
     */
    var WrappedFormControl = /** @class */ (function () {
        // I lost way too much time trying to make this work without injecting the ViewContainerRef and the Injector,
        // I'm giving up. So we have to inject these two manually for now.
        function WrappedFormControl(vcr, wrapperType, injector, ngControl, renderer, el) {
            var _this = this;
            this.vcr = vcr;
            this.wrapperType = wrapperType;
            this.ngControl = ngControl;
            this.subscriptions = [];
            this.index = 0;
            this.renderer = renderer;
            this.el = el;
            try {
                this.ngControlService = injector.get(NgControlService);
                this.ifErrorService = injector.get(IfErrorService);
                this.controlClassService = injector.get(ControlClassService);
                this.markControlService = injector.get(MarkControlService);
            }
            catch (e) { }
            if (this.controlClassService) {
                this.controlClassService.initControlClass(renderer, el.nativeElement);
            }
            if (this.markControlService) {
                this.subscriptions.push(this.markControlService.dirtyChange.subscribe(function () {
                    _this.ngControl.control.markAsDirty();
                    _this.ngControl.control.updateValueAndValidity();
                }));
            }
        }
        Object.defineProperty(WrappedFormControl.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                if (this.controlIdService) {
                    this.controlIdService.id = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WrappedFormControl.prototype.triggerValidation = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
            };
        // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
        // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
        // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
        // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
        // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
        // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
        // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
        // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
        /**
         * @template T
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        WrappedFormControl.prototype.getProviderFromContainer =
            // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
            // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
            // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
            // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
            /**
             * @template T
             * @param {?} token
             * @param {?=} notFoundValue
             * @return {?}
             */
            function (token, notFoundValue) {
                try {
                    return this._containerInjector.get(token, notFoundValue);
                }
                catch (e) {
                    return notFoundValue;
                }
            };
        /**
         * @return {?}
         */
        WrappedFormControl.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._containerInjector = new HostWrapper(this.wrapperType, this.vcr, this.index);
                this.controlIdService = this._containerInjector.get(ControlIdService);
                if (this._id) {
                    this.controlIdService.id = this._id;
                }
                else {
                    this._id = this.controlIdService.id;
                }
                if (this.renderer && this.el) {
                    this.renderer.setAttribute(this.el.nativeElement, 'aria-describedby', this.controlIdService.id + '-helper');
                }
                if (this.ngControlService) {
                    this.ngControlService.setControl(this.ngControl);
                }
            };
        /**
         * @return {?}
         */
        WrappedFormControl.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        WrappedFormControl.propDecorators = {
            id: [{ type: i0.HostBinding }, { type: i0.Input }],
            triggerValidation: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return WrappedFormControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This implements both the clrCheckbox and clrToggle functionality, since they are both just checkboxes with different
     * visual styling. The challenge is that the container needs to know which selector was used, which the \@Attribute
     * decorator gets for us to determine if the toggle is used, and emits a value to the wrapper container to tell it
     * there is a toggle switch instead.
     */
    var ClrCheckbox = /** @class */ (function (_super) {
        __extends(ClrCheckbox, _super);
        function ClrCheckbox(vcr, injector, control, renderer, el, toggle) {
            var _this = _super.call(this, vcr, ClrCheckboxWrapper, injector, control, renderer, el) || this;
            _this.toggle = toggle;
            return _this;
        }
        /**
         * @return {?}
         */
        ClrCheckbox.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                /** @type {?} */
                var toggleService = this.getProviderFromContainer(IS_TOGGLE, null);
                if (toggleService && this.toggle !== null) {
                    toggleService.next(true);
                }
            };
        ClrCheckbox.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrCheckbox],[clrToggle]' },] }
        ];
        /** @nocollapse */
        ClrCheckbox.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.Injector },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: String, decorators: [{ type: i0.Attribute, args: ['clrToggle',] }] }
            ];
        };
        return ClrCheckbox;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCheckboxContainer = /** @class */ (function () {
        // @TODO Solve for group validation, which doesn't work now with ngModelGroup
        // Blocked by https://github.com/angular/angular/issues/20268
        // @Input()
        // set clrFormGroup(value: FormGroup) {
        //   this.formGroup = value;
        // }
        // @Input()
        // set clrFormArray(value: FormArray) {
        //   this.formGroup = value;
        // }
        function ClrCheckboxContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this.inline = false;
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        Object.defineProperty(ClrCheckboxContainer.prototype, "clrInline", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline;
            },
            // private formGroup: AbstractControl;
            /*
             * Here we want to support the following cases
             * clrInline - true by presence
             * clrInline="true|false" - unless it is explicitly false, strings are considered true
             * [clrInline]="true|false" - expect a boolean
             */
            set: 
            // private formGroup: AbstractControl;
            /*
               * Here we want to support the following cases
               * clrInline - true by presence
               * clrInline="true|false" - unless it is explicitly false, strings are considered true
               * [clrInline]="true|false" - expect a boolean
               */
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === 'string') {
                    this.inline = value === 'false' ? false : true;
                }
                else {
                    this.inline = !!value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // @TODO put a solution in for form group validation
                // if (!this.formGroup) {
                this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                    _this.invalid = invalid;
                }));
                // } else {
                //   // Because ngModel does this, we have to delay a tick to get the result
                //   Promise.resolve().then(() => {
                //     this.subscriptions.push(
                //       this.formGroup.statusChanges.subscribe(() => {
                //         this.invalid = this.formGroup.invalid;
                //       })
                //     );
                //   });
                // }
            };
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
            };
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
            };
        ClrCheckboxContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-checkbox-container,clr-toggle-container',
                        template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-checkbox-wrapper,clr-toggle-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n  ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [NgControlService, ControlClassService, IfErrorService]
                    }] }
        ];
        /** @nocollapse */
        ClrCheckboxContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrCheckboxContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }],
            clrInline: [{ type: i0.Input }]
        };
        return ClrCheckboxContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCheckboxModule = /** @class */ (function () {
        function ClrCheckboxModule() {
        }
        ClrCheckboxModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
                        declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                        exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                        entryComponents: [ClrCheckboxWrapper],
                    },] }
        ];
        return ClrCheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var activeCounter = 0;
    /** @type {?} */
    var IF_ACTIVE_ID = new i0.InjectionToken('IF_ACTIVE_ID');
    /**
     * @return {?}
     */
    function tokenFactory() {
        return ++activeCounter;
    }
    /** @type {?} */
    var IF_ACTIVE_ID_PROVIDER = {
        provide: IF_ACTIVE_ID,
        useFactory: tokenFactory,
    };
    var IfActiveService = /** @class */ (function () {
        function IfActiveService() {
            /**
             * *****
             * \@property _currentChange
             *
             * \@description
             * A RXJS Subject that updates and provides subscriptions to for the current current state of a component template
             * implemting the IfActive structural directive.
             *
             */
            this._currentChange = new rxjs.Subject();
        }
        Object.defineProperty(IfActiveService.prototype, "currentChange", {
            /*********
             *
             * @description
             * A getter function that provides an observable for the _current Subject.
             *
             */
            get: /**
             * ******
             *
             * \@description
             * A getter function that provides an observable for the _current Subject.
             *
             * @return {?}
             */ function () {
                return this._currentChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IfActiveService.prototype, "current", {
            /*********
             *
             * @description
             * A getter that returns the current value of this IfActive instance.
             * @returns
             */
            get: /**
             * ******
             *
             * \@description
             * A getter that returns the current value of this IfActive instance.
             * @return {?}
             */ function () {
                return this._current;
            },
            /*********
             *
             * @description
             * A setter function that updates the current state of _current for this instance of IfActive structural directive.
             * And, broadcasts the new value to all subscribers.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter function that updates the current state of _current for this instance of IfActive structural directive.
             * And, broadcasts the new value to all subscribers.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._current !== value) {
                    this._current = value;
                    this._currentChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        IfActiveService.decorators = [
            { type: i0.Injectable }
        ];
        return IfActiveService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfActive = /** @class */ (function () {
        function ClrIfActive(ifActiveService, id, template, container) {
            var _this = this;
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.template = template;
            this.container = container;
            this.wasActive = false;
            /**
             * *******
             * \@property activeChange
             *
             * \@description
             * An event emitter that emits when the active property is set to allow for 2way binding when the directive is
             * used with de-structured / de-sugared syntax.
             *
             */
            this.activeChange = new i0.EventEmitter(false);
            this.checkAndUpdateView(ifActiveService.current);
            this.subscription = this.ifActiveService.currentChange.subscribe(function (newCurrentId) {
                _this.checkAndUpdateView(newCurrentId);
            });
        }
        /**
         * @param {?} currentId
         * @return {?}
         */
        ClrIfActive.prototype.checkAndUpdateView = /**
         * @param {?} currentId
         * @return {?}
         */
            function (currentId) {
                /** @type {?} */
                var isNowActive = currentId === this.id;
                // only emit if the new active state is changed since last time.
                if (isNowActive !== this.wasActive) {
                    this.updateView(isNowActive);
                    this.activeChange.emit(isNowActive);
                    this.wasActive = isNowActive;
                }
            };
        Object.defineProperty(ClrIfActive.prototype, "active", {
            /********
             *
             * @description
             * A getter that returns the current IfActiveService.active value.
             */
            get: /**
             * *****
             *
             * \@description
             * A getter that returns the current IfActiveService.active value.
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            /*********
             *
             * @description
             * A setter that updates IfActiveService.active with value.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter that updates IfActiveService.active with value.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this.ifActiveService.current = this.id;
                }
            },
            enumerable: true,
            configurable: true
        });
        /*********
         *
         * @description
         * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param value
         */
        /**
         * ******
         *
         * \@description
         * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
        ClrIfActive.prototype.updateView = /**
         * ******
         *
         * \@description
         * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.container.createEmbeddedView(this.template);
                }
                else {
                    this.container.clear();
                }
            };
        /**
         * @return {?}
         */
        ClrIfActive.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        ClrIfActive.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfActive]' },] }
        ];
        /** @nocollapse */
        ClrIfActive.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrIfActive.propDecorators = {
            active: [{ type: i0.Input, args: ['clrIfActive',] }],
            activeChange: [{ type: i0.Output, args: ['clrIfActiveChange',] }]
        };
        return ClrIfActive;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var IfOpenService = /** @class */ (function () {
        function IfOpenService() {
            /**
             * *****
             * \@property _openChange
             *
             * \@description
             * A RXJS Subject that updates and provides subscriptions to for the current open state of a component template
             * implemting the IfOpen structural directive.
             */
            this._openChange = new rxjs.Subject();
            /**
             *  Popovers might need to ignore click events on an element
             *  (eg: popover opens on focus on an input field. Clicks should be ignored in this case)
             */
            this._ignoredElementChange = new rxjs.Subject();
        }
        Object.defineProperty(IfOpenService.prototype, "openChange", {
            /*********
             *
             * @description
             * A getter function that provides an observable for the _opened Subject.
             *
             */
            get: /**
             * ******
             *
             * \@description
             * A getter function that provides an observable for the _opened Subject.
             *
             * @return {?}
             */ function () {
                return this._openChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IfOpenService.prototype, "open", {
            /*********
             *
             * @description
             * A getter that returns the current value of this IfOpen instance.
             *
             */
            get: /**
             * ******
             *
             * \@description
             * A getter that returns the current value of this IfOpen instance.
             *
             * @return {?}
             */ function () {
                return this._open;
            },
            /*********
             *
             * @description
             * A setter function that updates the current state of _open for this instance of IfOpen structural directive. And,
             * broadcasts the new value to all subscribers.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter function that updates the current state of _open for this instance of IfOpen structural directive. And,
             * broadcasts the new value to all subscribers.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this._open !== value) {
                    this._open = value;
                    this._openChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        IfOpenService.prototype.toggleWithEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.originalEvent = event;
                this.open = !this.open;
                delete this.originalEvent;
            };
        Object.defineProperty(IfOpenService.prototype, "ignoredElementChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._ignoredElementChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} element
         * @return {?}
         */
        IfOpenService.prototype.registerIgnoredElement = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                this._ignoredElementChange.next(element);
            };
        IfOpenService.decorators = [
            { type: i0.Injectable }
        ];
        return IfOpenService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfOpen = /** @class */ (function () {
        function ClrIfOpen(ifOpenService, template, container) {
            var _this = this;
            this.ifOpenService = ifOpenService;
            this.template = template;
            this.container = container;
            /**
             * *******
             * \@property openChange
             *
             * \@description
             * An event emitter that emits when the open property is set to allow for 2way binding when the directive is
             * used with de-structured / de-sugared syntax.
             */
            this.openChange = new i0.EventEmitter(false);
            this.subscription = this.ifOpenService.openChange.subscribe(function (change) {
                _this.updateView(change);
                _this.openChange.emit(change);
            });
        }
        Object.defineProperty(ClrIfOpen.prototype, "open", {
            /********
             *
             * @description
             * A getter that returns the current IfOpenService.open value.
             *
             */
            get: /**
             * *****
             *
             * \@description
             * A getter that returns the current IfOpenService.open value.
             *
             * @return {?}
             */ function () {
                return this.ifOpenService.open;
            },
            /*********
             *
             * @description
             * A setter that updates IfOpenService.open with value.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter that updates IfOpenService.open with value.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.ifOpenService.open = value;
            },
            enumerable: true,
            configurable: true
        });
        /*********
         *
         * @description
         * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param value
         */
        /**
         * ******
         *
         * \@description
         * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
        ClrIfOpen.prototype.updateView = /**
         * ******
         *
         * \@description
         * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.container.createEmbeddedView(this.template);
                }
                else {
                    this.container.clear();
                }
            };
        /**
         * @return {?}
         */
        ClrIfOpen.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        ClrIfOpen.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfOpen]' },] }
        ];
        /** @nocollapse */
        ClrIfOpen.ctorParameters = function () {
            return [
                { type: IfOpenService },
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrIfOpen.propDecorators = {
            open: [{ type: i0.Input, args: ['clrIfOpen',] }],
            openChange: [{ type: i0.Output, args: ['clrIfOpenChange',] }]
        };
        return ClrIfOpen;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CONDITIONAL_DIRECTIVES = [ClrIfActive, ClrIfOpen];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrConditionalModule = /** @class */ (function () {
        function ClrConditionalModule() {
        }
        ClrConditionalModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CONDITIONAL_DIRECTIVES], exports: [CONDITIONAL_DIRECTIVES] },] }
        ];
        return ClrConditionalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var FocusTrapTracker = /** @class */ (function () {
        function FocusTrapTracker() {
            this._previousFocusTraps = [];
        }
        Object.defineProperty(FocusTrapTracker.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._previousFocusTraps.push(this._current);
                this._current = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusTrapTracker.prototype, "nbFocusTrappers", {
            get: /**
             * @return {?}
             */ function () {
                return this._previousFocusTraps.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FocusTrapTracker.prototype.activatePreviousTrapper = /**
         * @return {?}
         */
            function () {
                this._current = this._previousFocusTraps.pop();
            };
        FocusTrapTracker.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ FocusTrapTracker.ngInjectableDef = i0.defineInjectable({ factory: function FocusTrapTracker_Factory() { return new FocusTrapTracker(); }, token: FocusTrapTracker, providedIn: "root" });
        return FocusTrapTracker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var FocusTrapDirective = /** @class */ (function () {
        function FocusTrapDirective(el, injector, focusTrapsTracker, renderer, platformId) {
            this.el = el;
            this.injector = injector;
            this.focusTrapsTracker = focusTrapsTracker;
            this.renderer = renderer;
            this.platformId = platformId;
            this.document = this.injector.get(common.DOCUMENT);
            this.focusTrapsTracker.current = this;
            this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
        }
        /**
         * @param {?} event
         * @return {?}
         */
        FocusTrapDirective.prototype.onFocusIn = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var nativeElement = this.el.nativeElement;
                if (this.focusTrapsTracker.current === this && event.target && !nativeElement.contains(event.target)) {
                    nativeElement.focus();
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.createFocusableOffScreenEl = /**
         * @return {?}
         */
            function () {
                // Not using Renderer2's createElement method because that leads to DOM leakage.
                // https://github.com/angular/angular/issues/26954
                /** @type {?} */
                var offScreenSpan = this.document.createElement('span');
                this.renderer.setAttribute(offScreenSpan, 'tabindex', '0');
                this.renderer.addClass(offScreenSpan, 'offscreen-focus-rebounder');
                return offScreenSpan;
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.addReboundEls = /**
         * @return {?}
         */
            function () {
                // We will add these focus rebounding elements only in the following conditions:
                // 1. It should be running inside browser platform as it accesses document.body element
                // 2. We should NOT add them more than once. Hence, we are counting a number of focus trappers
                //    and only add on the first focus trapper.
                if (common.isPlatformBrowser(this.platformId) && this.focusTrapsTracker.nbFocusTrappers === 1) {
                    this.topReboundEl = this.createFocusableOffScreenEl();
                    this.bottomReboundEl = this.createFocusableOffScreenEl();
                    // Add reboundBeforeTrapEl to the document body as the first child
                    this.renderer.insertBefore(this.document.body, this.topReboundEl, this.document.body.firstChild);
                    // Add reboundAfterTrapEl to the document body as the last child
                    this.renderer.appendChild(this.document.body, this.bottomReboundEl);
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.removeReboundEls = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId) &&
                    this.focusTrapsTracker.nbFocusTrappers === 1 &&
                    this.topReboundEl &&
                    this.bottomReboundEl) {
                    this.renderer.removeChild(this.document.body, this.topReboundEl);
                    this.renderer.removeChild(this.document.body, this.bottomReboundEl);
                    // These are here to to make sure that
                    // we completely delete all traces of the removed DOM objects.
                    delete this.topReboundEl;
                    delete this.bottomReboundEl;
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.setPreviousFocus = /**
         * @return {?}
         */
            function () {
                if (this.previousActiveElement && this.previousActiveElement.focus) {
                    this.previousActiveElement.focus();
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId)) {
                    this.previousActiveElement = ( /** @type {?} */(this.document.activeElement));
                }
                this.addReboundEls();
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.removeReboundEls();
                this.setPreviousFocus();
                this.focusTrapsTracker.activatePreviousTrapper();
            };
        FocusTrapDirective.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrFocusTrap]' },] }
        ];
        /** @nocollapse */
        FocusTrapDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Injector },
                { type: FocusTrapTracker },
                { type: i0.Renderer2 },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        FocusTrapDirective.propDecorators = {
            onFocusIn: [{ type: i0.HostListener, args: ['document:focusin', ['$event'],] }]
        };
        return FocusTrapDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FOCUS_TRAP_DIRECTIVES = [FocusTrapDirective];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrFocusTrapModule = /** @class */ (function () {
        function ClrFocusTrapModule() {
        }
        ClrFocusTrapModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [FOCUS_TRAP_DIRECTIVES],
                        exports: [FOCUS_TRAP_DIRECTIVES],
                    },] }
        ];
        return ClrFocusTrapModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2017 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @type {?} */
    var UP_ARROW = 38;
    /** @type {?} */
    var DOWN_ARROW = 40;
    /** @type {?} */
    var RIGHT_ARROW = 39;
    /** @type {?} */
    var LEFT_ARROW = 37;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This is the en-001 short locale date format. Setting as default.
     * @type {?}
     */
    var DEFAULT_LOCALE_FORMAT = 'dd/MM/y';
    // https://en.wikipedia.org/wiki/Date_format_by_country
    /** @type {?} */
    var LITTLE_ENDIAN_REGEX = /d+.+m+.+y+/i;
    /** @type {?} */
    var MIDDLE_ENDIAN_REGEX = /m+.+d+.+y+/i;
    // No need for BIG_ENDIAN_REGEX because anything that doesn't satisfy the above 2
    // is automatically BIG_ENDIAN
    /** @type {?} */
    var DELIMITER_REGEX = /d+|m+|y+/i;
    /** @type {?} */
    var USER_INPUT_REGEX = /\d+/g;
    /** @type {?} */
    var MOBILE_USERAGENT_REGEX = /Mobi/i;
    /** @type {?} */
    var RTL_REGEX = /\u200f/g;
    /** @type {?} */
    var YEAR = 'YYYY';
    /** @type {?} */
    var MONTH = 'MM';
    /** @type {?} */
    var DATE = 'DD';
    /** @type {?} */
    var LITTLE_ENDIAN = {
        name: 'LITTLE_ENDIAN',
        format: [DATE, MONTH, YEAR],
    };
    /** @type {?} */
    var MIDDLE_ENDIAN = {
        name: 'MIDDLE_ENDIAN',
        format: [MONTH, DATE, YEAR],
    };
    /** @type {?} */
    var BIG_ENDIAN = {
        name: 'BIG_ENDIAN',
        format: [YEAR, MONTH, DATE],
    };
    /** @type {?} */
    var NO_OF_DAYS_IN_A_WEEK = 7;
    /** @type {?} */
    var NO_OF_ROWS_IN_CALENDAR_VIEW = 6;
    /** @type {?} */
    var TOTAL_DAYS_IN_DAYS_VIEW = NO_OF_DAYS_IN_A_WEEK * NO_OF_ROWS_IN_CALENDAR_VIEW;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Returns the number of days in a month.
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function getNumberOfDaysInTheMonth(year, month) {
        // If we go to the next month, but use a day of 0, it returns the last day from the previous month
        return new Date(year, month + 1, 0).getDate();
    }
    /**
     * Returns the day for the corresponding date where 0 represents Sunday.
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    function getDay(year, month, date) {
        return new Date(year, month, date).getDay();
    }
    /**
     * Takes in a year and if it is a 2 digit year, returns the corresponding 4 digit year.
     * Window of 80 years before and 20 years after the present year.
     * Credit: https://github.com/globalizejs/globalize/blob/e1b31cd6a4f1cff75b185b68b7a32220aac5196f/src/date/parse.js
     * @param {?} year
     * @return {?}
     */
    function parseToFourDigitYear(year) {
        if (year > 9999 || (year > 100 && year < 999) || year < 10) {
            return -1;
        }
        if (year > 999) {
            return year;
        }
        /** @type {?} */
        var currYear = new Date().getFullYear();
        /** @type {?} */
        var century = Math.floor(currYear / 100) * 100;
        /** @type {?} */
        var result = year + century;
        if (result > currYear + 20) {
            result = result - 100;
        }
        return result;
    }
    /**
     * @param {?} date1
     * @param {?} date2
     * @return {?}
     */
    function datesAreEqual(date1, date2) {
        if (date1 instanceof Date && date2 instanceof Date) {
            return (date1.getFullYear() === date2.getFullYear() &&
                date1.getMonth() === date2.getMonth() &&
                date1.getDate() === date2.getDate());
        }
        else {
            return false;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DayViewModel = /** @class */ (function () {
        function DayViewModel(dayModel, isTodaysDate, isDisabled, isSelected, isFocusable) {
            if (isTodaysDate === void 0) {
                isTodaysDate = false;
            }
            if (isDisabled === void 0) {
                isDisabled = false;
            }
            if (isSelected === void 0) {
                isSelected = false;
            }
            if (isFocusable === void 0) {
                isFocusable = false;
            }
            this.dayModel = dayModel;
            this.isTodaysDate = isTodaysDate;
            this.isDisabled = isDisabled;
            this.isSelected = isSelected;
            this.isFocusable = isFocusable;
        }
        Object.defineProperty(DayViewModel.prototype, "tabIndex", {
            /**
             * Gets the tab index based on the isFocusable flag.
             */
            get: /**
             * Gets the tab index based on the isFocusable flag.
             * @return {?}
             */ function () {
                return this.isFocusable ? 0 : -1;
            },
            enumerable: true,
            configurable: true
        });
        return DayViewModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CalendarModel = /** @class */ (function () {
        function CalendarModel(year, month) {
            this.year = year;
            this.month = month;
            this.initializeDaysInCalendar();
        }
        /**
         * Populates the days array with the DayModels in the current Calendar.
         */
        /**
         * Populates the days array with the DayModels in the current Calendar.
         * @return {?}
         */
        CalendarModel.prototype.initializeDaysInCalendar = /**
         * Populates the days array with the DayModels in the current Calendar.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var noOfDaysInCalendar = getNumberOfDaysInTheMonth(this.year, this.month);
                this.days = Array(noOfDaysInCalendar)
                    .fill(null)
                    .map(function (date, index) {
                    return new DayModel(_this.year, _this.month, index + 1);
                });
            };
        /**
         * Checks if the calendar passed is equal to the current calendar.
         */
        /**
         * Checks if the calendar passed is equal to the current calendar.
         * @param {?} calendar
         * @return {?}
         */
        CalendarModel.prototype.isEqual = /**
         * Checks if the calendar passed is equal to the current calendar.
         * @param {?} calendar
         * @return {?}
         */
            function (calendar) {
                if (calendar) {
                    return this.year === calendar.year && this.month === calendar.month;
                }
                return false;
            };
        /**
         * Checks if a DayModel is in the Calendar
         */
        /**
         * Checks if a DayModel is in the Calendar
         * @param {?} day
         * @return {?}
         */
        CalendarModel.prototype.isDayInCalendar = /**
         * Checks if a DayModel is in the Calendar
         * @param {?} day
         * @return {?}
         */
            function (day) {
                if (day) {
                    return this.year === day.year && this.month === day.month;
                }
                return false;
            };
        /**
         * Returns CalendarModel of the previous month.
         */
        /**
         * Returns CalendarModel of the previous month.
         * @return {?}
         */
        CalendarModel.prototype.previousMonth = /**
         * Returns CalendarModel of the previous month.
         * @return {?}
         */
            function () {
                if (this.month === 0) {
                    return new CalendarModel(this.year - 1, 11);
                }
                else {
                    return new CalendarModel(this.year, this.month - 1);
                }
            };
        /**
         * Returns CalendarModel of the next month.
         */
        /**
         * Returns CalendarModel of the next month.
         * @return {?}
         */
        CalendarModel.prototype.nextMonth = /**
         * Returns CalendarModel of the next month.
         * @return {?}
         */
            function () {
                if (this.month === 11) {
                    return new CalendarModel(this.year + 1, 0);
                }
                else {
                    return new CalendarModel(this.year, this.month + 1);
                }
            };
        return CalendarModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DayModel = /** @class */ (function () {
        function DayModel(year, month, date) {
            this.year = year;
            this.month = month;
            this.date = date;
        }
        Object.defineProperty(DayModel.prototype, "calendar", {
            /**
             * Returns the Calendar for the current DayModel.
             */
            get: /**
             * Returns the Calendar for the current DayModel.
             * @return {?}
             */ function () {
                return new CalendarModel(this.year, this.month);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if the passed CalendarDate is equal to itself.
         */
        /**
         * Checks if the passed CalendarDate is equal to itself.
         * @param {?} day
         * @return {?}
         */
        DayModel.prototype.isEqual = /**
         * Checks if the passed CalendarDate is equal to itself.
         * @param {?} day
         * @return {?}
         */
            function (day) {
                if (day) {
                    return this.year === day.year && this.month === day.month && this.date === day.date;
                }
                return false;
            };
        /**
         * @return {?}
         */
        DayModel.prototype.toDate = /**
         * @return {?}
         */
            function () {
                return new Date(this.year, this.month, this.date);
            };
        /**
         * Returns a new DayModel which is incremented based on the value passed.
         */
        /**
         * Returns a new DayModel which is incremented based on the value passed.
         * @param {?} value
         * @return {?}
         */
        DayModel.prototype.incrementBy = /**
         * Returns a new DayModel which is incremented based on the value passed.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // Creating new Javascript Date object to increment because
                // it will automatically take care of switching to next or previous
                // months & years without we having to worry about it.
                /** @type {?} */
                var date = new Date(this.year, this.month, this.date + value);
                return new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
            };
        /**
         * Clones the current day model.
         */
        /**
         * Clones the current day model.
         * @return {?}
         */
        DayModel.prototype.clone = /**
         * Clones the current day model.
         * @return {?}
         */
            function () {
                return new DayModel(this.year, this.month, this.date);
            };
        /**
         * @return {?}
         */
        DayModel.prototype.toDateString = /**
         * @return {?}
         */
            function () {
                return this.toDate().toLocaleDateString();
            };
        return DayModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CalendarViewModel = /** @class */ (function () {
        function CalendarViewModel(calendar, selectedDay, focusableDay, today, firstDayOfWeek) {
            this.calendar = calendar;
            this.selectedDay = selectedDay;
            this.focusableDay = focusableDay;
            this.today = today;
            this.firstDayOfWeek = firstDayOfWeek;
            this.currMonthDayViews = [];
            this.initializeCalendarView();
        }
        Object.defineProperty(CalendarViewModel.prototype, "calendarView", {
            /**
             * DayViewModel matrix. Size 6x7
             */
            get: /**
             * DayViewModel matrix. Size 6x7
             * @return {?}
             */ function () {
                return this._calendarView;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Generates a 6x7 matrix of DayViewModel based on the Calendar.
         * The 6x7 matrix is structured according to the first day of the week.
         * 6 rows to accommodate months which might have dates spanning over 6 weeks.
         * 7 columns because there are 7 days in a week :P :D
         */
        /**
         * Generates a 6x7 matrix of DayViewModel based on the Calendar.
         * The 6x7 matrix is structured according to the first day of the week.
         * 6 rows to accommodate months which might have dates spanning over 6 weeks.
         * 7 columns because there are 7 days in a week :P :D
         * @return {?}
         */
        CalendarViewModel.prototype.initializeCalendarView = /**
         * Generates a 6x7 matrix of DayViewModel based on the Calendar.
         * The 6x7 matrix is structured according to the first day of the week.
         * 6 rows to accommodate months which might have dates spanning over 6 weeks.
         * 7 columns because there are 7 days in a week :P :D
         * @return {?}
         */
            function () {
                // Generate prev and next month calendar models.
                /** @type {?} */
                var prevMonthCalendar = this.calendar.previousMonth();
                /** @type {?} */
                var nextMonthCalendar = this.calendar.nextMonth();
                // Get no of days from prev and next months.
                /** @type {?} */
                var daysFromPrevMonthInCalView = this.numDaysFromPrevMonthInCalView(this.calendar.year, this.calendar.month);
                /** @type {?} */
                var daysFromNextMonthInCalView = TOTAL_DAYS_IN_DAYS_VIEW - (this.calendar.days.length + daysFromPrevMonthInCalView);
                // Generate prev, curr and next day view models
                /** @type {?} */
                var prevMonthDayViews = [];
                /** @type {?} */
                var nextMonthDayViews = [];
                if (daysFromPrevMonthInCalView > 0) {
                    prevMonthDayViews = this.generateDayViewModels(prevMonthCalendar.days.slice(-1 * daysFromPrevMonthInCalView), true, false);
                }
                this.currMonthDayViews = this.generateDayViewModels(this.calendar.days, false, true);
                if (daysFromNextMonthInCalView > 0) {
                    nextMonthDayViews = this.generateDayViewModels(nextMonthCalendar.days.slice(0, daysFromNextMonthInCalView), true, false);
                }
                // Generate calendar view and initialize flags
                this._calendarView = this.generateCalendarView(prevMonthDayViews, this.currMonthDayViews, nextMonthDayViews);
                this.initializeSelectedDay();
                this.initializeFocusableDay();
            };
        /**
         * Generates a DayViewModel array based on the DayModel passed
         */
        /**
         * Generates a DayViewModel array based on the DayModel passed
         * @param {?} days
         * @param {?} isDisabled
         * @param {?} isCurrentCalendar
         * @return {?}
         */
        CalendarViewModel.prototype.generateDayViewModels = /**
         * Generates a DayViewModel array based on the DayModel passed
         * @param {?} days
         * @param {?} isDisabled
         * @param {?} isCurrentCalendar
         * @return {?}
         */
            function (days, isDisabled, isCurrentCalendar) {
                /** @type {?} */
                var dayViews = days.map(function (day) {
                    return new DayViewModel(day, false, isDisabled, false, false);
                });
                if (isCurrentCalendar && this.calendar.isDayInCalendar(this.today)) {
                    dayViews[this.today.date - 1].isTodaysDate = true;
                }
                return dayViews;
            };
        /**
         * Gets the first day of the current month to figure out how many dates of previous month
         * are needed to complete the Calendar View based on the first day of the week.
         * eg: Assuming locale en-US, the first day of the week is Sunday,
         * if first day of the current month lands on Wednesday, then
         * (this.getDay function would return 3 since
         * first day of the week is 0), we need the 3 days from the previous month.
         */
        /**
         * Gets the first day of the current month to figure out how many dates of previous month
         * are needed to complete the Calendar View based on the first day of the week.
         * eg: Assuming locale en-US, the first day of the week is Sunday,
         * if first day of the current month lands on Wednesday, then
         * (this.getDay function would return 3 since
         * first day of the week is 0), we need the 3 days from the previous month.
         * @param {?} currentYear
         * @param {?} currentMonth
         * @return {?}
         */
        CalendarViewModel.prototype.numDaysFromPrevMonthInCalView = /**
         * Gets the first day of the current month to figure out how many dates of previous month
         * are needed to complete the Calendar View based on the first day of the week.
         * eg: Assuming locale en-US, the first day of the week is Sunday,
         * if first day of the current month lands on Wednesday, then
         * (this.getDay function would return 3 since
         * first day of the week is 0), we need the 3 days from the previous month.
         * @param {?} currentYear
         * @param {?} currentMonth
         * @return {?}
         */
            function (currentYear, currentMonth) {
                /** @type {?} */
                var firstDayOfCurrMonth = getDay(currentYear, currentMonth, 1);
                if (firstDayOfCurrMonth >= this.firstDayOfWeek) {
                    return firstDayOfCurrMonth - this.firstDayOfWeek;
                }
                else {
                    return NO_OF_DAYS_IN_A_WEEK + firstDayOfCurrMonth - this.firstDayOfWeek;
                }
            };
        /**
         * Checks if the Day passed is in the CalendarView.
         */
        /**
         * Checks if the Day passed is in the CalendarView.
         * @param {?} day
         * @return {?}
         */
        CalendarViewModel.prototype.isDayInCalendarView = /**
         * Checks if the Day passed is in the CalendarView.
         * @param {?} day
         * @return {?}
         */
            function (day) {
                if (!this.calendar.isDayInCalendar(day)) {
                    return false;
                }
                return true;
            };
        /**
         * Using the DayViewModels from the previous, current and next month, this function
         * generates the CalendarView.
         */
        /**
         * Using the DayViewModels from the previous, current and next month, this function
         * generates the CalendarView.
         * @param {?} prev
         * @param {?} curr
         * @param {?} next
         * @return {?}
         */
        CalendarViewModel.prototype.generateCalendarView = /**
         * Using the DayViewModels from the previous, current and next month, this function
         * generates the CalendarView.
         * @param {?} prev
         * @param {?} curr
         * @param {?} next
         * @return {?}
         */
            function (prev, curr, next) {
                /** @type {?} */
                var combinationArr = __spread(prev, curr, next);
                /** @type {?} */
                var calendarView = [];
                for (var i = 0; i < NO_OF_ROWS_IN_CALENDAR_VIEW; i++) {
                    calendarView[i] = combinationArr.slice(i * NO_OF_DAYS_IN_A_WEEK, (i + 1) * NO_OF_DAYS_IN_A_WEEK);
                }
                return calendarView;
            };
        /**
         * Initialize the selected day if the day is in the calendar.
         */
        /**
         * Initialize the selected day if the day is in the calendar.
         * @return {?}
         */
        CalendarViewModel.prototype.initializeSelectedDay = /**
         * Initialize the selected day if the day is in the calendar.
         * @return {?}
         */
            function () {
                if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
                    this.currMonthDayViews[this.selectedDay.date - 1].isSelected = true;
                }
            };
        /**
         * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
         * we check for the selected day. If selected day is not set then check if today is in the current
         * calendar. If not then just set the 15th of the current calendar month.
         */
        /**
         * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
         * we check for the selected day. If selected day is not set then check if today is in the current
         * calendar. If not then just set the 15th of the current calendar month.
         * @return {?}
         */
        CalendarViewModel.prototype.initializeFocusableDay = /**
         * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
         * we check for the selected day. If selected day is not set then check if today is in the current
         * calendar. If not then just set the 15th of the current calendar month.
         * @return {?}
         */
            function () {
                if (this.focusableDay && this.isDayInCalendarView(this.focusableDay)) {
                    this.setFocusableFlag(this.focusableDay, true);
                }
                else if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
                    this.setFocusableFlag(this.selectedDay, true);
                    this.focusableDay = this.selectedDay.clone();
                }
                else if (this.isDayInCalendarView(this.today)) {
                    this.setFocusableFlag(this.today, true);
                    this.focusableDay = this.today.clone();
                }
                else {
                    this.focusableDay = new DayModel(this.calendar.year, this.calendar.month, 15);
                    this.setFocusableFlag(this.focusableDay, true);
                }
            };
        /**
         * @param {?} day
         * @param {?} flag
         * @return {?}
         */
        CalendarViewModel.prototype.setFocusableFlag = /**
         * @param {?} day
         * @param {?} flag
         * @return {?}
         */
            function (day, flag) {
                if (day) {
                    this.currMonthDayViews[day.date - 1].isFocusable = flag;
                }
            };
        /**
         * Updates the focusable day in the calendar.
         */
        /**
         * Updates the focusable day in the calendar.
         * @param {?} day
         * @return {?}
         */
        CalendarViewModel.prototype.updateFocusableDay = /**
         * Updates the focusable day in the calendar.
         * @param {?} day
         * @return {?}
         */
            function (day) {
                this.setFocusableFlag(this.focusableDay, false);
                this.setFocusableFlag(day, true);
                this.focusableDay = day;
            };
        return CalendarViewModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service is responsible for:
     * 1. Initializing the displayed calendar.
     * 2. Moving the calendar to the next, previous or current months
     * 3. Managing the focused and selected day models.
     */
    var DateNavigationService = /** @class */ (function () {
        function DateNavigationService() {
            /**
             * Variable to store today's date.
             */
            this._todaysFullDate = new Date();
            this._selectedDayChange = new rxjs.Subject();
            this._displayedCalendarChange = new rxjs.Subject();
            this._focusOnCalendarChange = new rxjs.Subject();
            this._focusedDayChange = new rxjs.Subject();
        }
        Object.defineProperty(DateNavigationService.prototype, "displayedCalendar", {
            get: /**
             * @return {?}
             */ function () {
                return this._displayedCalendar;
            },
            enumerable: true,
            configurable: true
        });
        // not a setter because i want this to remain private
        // not a setter because i want this to remain private
        /**
         * @param {?} value
         * @return {?}
         */
        DateNavigationService.prototype.setDisplayedCalendar =
            // not a setter because i want this to remain private
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (!this._displayedCalendar.isEqual(value)) {
                    this._displayedCalendar = value;
                    this._displayedCalendarChange.next();
                }
            };
        /**
         * @return {?}
         */
        DateNavigationService.prototype.initializeTodaysDate = /**
         * @return {?}
         */
            function () {
                this._todaysFullDate = new Date();
                this._today = new DayModel(this._todaysFullDate.getFullYear(), this._todaysFullDate.getMonth(), this._todaysFullDate.getDate());
            };
        Object.defineProperty(DateNavigationService.prototype, "today", {
            get: /**
             * @return {?}
             */ function () {
                return this._today;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "selectedDayChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectedDayChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Notifies that the selected day has changed so that the date can be emitted to the user.
         * Note: Only to be called from day.ts
         */
        /**
         * Notifies that the selected day has changed so that the date can be emitted to the user.
         * Note: Only to be called from day.ts
         * @param {?} dayModel
         * @return {?}
         */
        DateNavigationService.prototype.notifySelectedDayChanged = /**
         * Notifies that the selected day has changed so that the date can be emitted to the user.
         * Note: Only to be called from day.ts
         * @param {?} dayModel
         * @return {?}
         */
            function (dayModel) {
                this.selectedDay = dayModel;
                this._selectedDayChange.next(dayModel);
            };
        /**
         * Initializes the calendar based on the selected day.
         */
        /**
         * Initializes the calendar based on the selected day.
         * @return {?}
         */
        DateNavigationService.prototype.initializeCalendar = /**
         * Initializes the calendar based on the selected day.
         * @return {?}
         */
            function () {
                this.focusedDay = null; // Can be removed later on the store focus
                this.initializeTodaysDate();
                if (this.selectedDay) {
                    this._displayedCalendar = new CalendarModel(this.selectedDay.year, this.selectedDay.month);
                }
                else {
                    this._displayedCalendar = new CalendarModel(this.today.year, this.today.month);
                }
            };
        /**
         * @param {?} month
         * @return {?}
         */
        DateNavigationService.prototype.changeMonth = /**
         * @param {?} month
         * @return {?}
         */
            function (month) {
                this.setDisplayedCalendar(new CalendarModel(this._displayedCalendar.year, month));
            };
        /**
         * @param {?} year
         * @return {?}
         */
        DateNavigationService.prototype.changeYear = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.setDisplayedCalendar(new CalendarModel(year, this._displayedCalendar.month));
            };
        /**
         * Moves the displayed calendar to the next month.
         */
        /**
         * Moves the displayed calendar to the next month.
         * @return {?}
         */
        DateNavigationService.prototype.moveToNextMonth = /**
         * Moves the displayed calendar to the next month.
         * @return {?}
         */
            function () {
                this.setDisplayedCalendar(this._displayedCalendar.nextMonth());
            };
        /**
         * Moves the displayed calendar to the previous month.
         */
        /**
         * Moves the displayed calendar to the previous month.
         * @return {?}
         */
        DateNavigationService.prototype.moveToPreviousMonth = /**
         * Moves the displayed calendar to the previous month.
         * @return {?}
         */
            function () {
                this.setDisplayedCalendar(this._displayedCalendar.previousMonth());
            };
        /**
         * Moves the displayed calendar to the current month and year.
         */
        /**
         * Moves the displayed calendar to the current month and year.
         * @return {?}
         */
        DateNavigationService.prototype.moveToCurrentMonth = /**
         * Moves the displayed calendar to the current month and year.
         * @return {?}
         */
            function () {
                if (!this.displayedCalendar.isDayInCalendar(this.today)) {
                    this.setDisplayedCalendar(new CalendarModel(this.today.year, this.today.month));
                }
                this._focusOnCalendarChange.next();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        DateNavigationService.prototype.incrementFocusDay = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.focusedDay = this.focusedDay.incrementBy(value);
                if (this._displayedCalendar.isDayInCalendar(this.focusedDay)) {
                    this._focusedDayChange.next(this.focusedDay);
                }
                else {
                    this.setDisplayedCalendar(this.focusedDay.calendar);
                }
                this._focusOnCalendarChange.next();
            };
        Object.defineProperty(DateNavigationService.prototype, "displayedCalendarChange", {
            /**
             * This observable lets the subscriber know that the displayed calendar has changed.
             */
            get: /**
             * This observable lets the subscriber know that the displayed calendar has changed.
             * @return {?}
             */ function () {
                return this._displayedCalendarChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "focusOnCalendarChange", {
            /**
             * This observable lets the subscriber know that the focus should be applied on the calendar.
             */
            get: /**
             * This observable lets the subscriber know that the focus should be applied on the calendar.
             * @return {?}
             */ function () {
                return this._focusOnCalendarChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "focusedDayChange", {
            /**
             * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
             */
            get: /**
             * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
             * @return {?}
             */ function () {
                return this._focusedDayChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DateNavigationService.decorators = [
            { type: i0.Injectable }
        ];
        return DateNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service focuses the day that is focusable in the calendar.
     */
    var DatepickerFocusService = /** @class */ (function () {
        function DatepickerFocusService(_ngZone, platformId) {
            this._ngZone = _ngZone;
            this.platformId = platformId;
        }
        /**
         * @param {?} elRef
         * @return {?}
         */
        DatepickerFocusService.prototype.focusCell = /**
         * @param {?} elRef
         * @return {?}
         */
            function (elRef) {
                var _this = this;
                this._ngZone.runOutsideAngular(function () {
                    _this.ngZoneIsStableInBrowser().subscribe(function () {
                        /** @type {?} */
                        var focusEl = elRef.nativeElement.querySelector('[tabindex="0"]');
                        if (focusEl) {
                            focusEl.focus();
                        }
                    });
                });
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DatepickerFocusService.prototype.focusInput = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                var _this = this;
                this._ngZone.runOutsideAngular(function () { return _this.ngZoneIsStableInBrowser().subscribe(function () { return element.focus(); }); });
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DatepickerFocusService.prototype.elementIsFocused = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return common.isPlatformBrowser(this.platformId) && document.activeElement === element;
            };
        /**
         * @return {?}
         */
        DatepickerFocusService.prototype.ngZoneIsStableInBrowser = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Credit: Material: https://github.com/angular/material2/blob/master/src/lib/datepicker/calendar.ts
                return this._ngZone.onStable.asObservable().pipe(operators.first(), operators.filter(function () { return common.isPlatformBrowser(_this.platformId); }));
            };
        DatepickerFocusService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DatepickerFocusService.ctorParameters = function () {
            return [
                { type: i0.NgZone },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        return DatepickerFocusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service extracts the Angular CLDR data needed by the datepicker.
     */
    var LocaleHelperService = /** @class */ (function () {
        function LocaleHelperService(locale) {
            this.locale = locale;
            this._firstDayOfWeek = 0;
            this.initializeLocaleData();
        }
        Object.defineProperty(LocaleHelperService.prototype, "firstDayOfWeek", {
            get: /**
             * @return {?}
             */ function () {
                return this._firstDayOfWeek;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeDaysNarrow", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeDaysNarrow;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeMonthsAbbreviated", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeMonthsAbbreviated;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeMonthsWide", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeMonthsWide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeDateFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeDateFormat;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the locale data.
         */
        /**
         * Initializes the locale data.
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleData = /**
         * Initializes the locale data.
         * @return {?}
         */
            function () {
                // Order in which these functions is called is very important.
                this.initializeFirstDayOfWeek();
                this.initializeLocaleDateFormat();
                this.initializeLocaleMonthsAbbreviated();
                this.initializeLocaleMonthsWide();
                this.initializeLocaleDaysNarrow();
            };
        /**
         * Initialize day names in the TranslationWidth.Narrow format based on the locale.
         * eg: [S, M, T...] for en-US.
         */
        /**
         * Initialize day names in the TranslationWidth.Narrow format based on the locale.
         * eg: [S, M, T...] for en-US.
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleDaysNarrow = /**
         * Initialize day names in the TranslationWidth.Narrow format based on the locale.
         * eg: [S, M, T...] for en-US.
         * @return {?}
         */
            function () {
                // Get locale day names starting with Sunday
                /** @type {?} */
                var tempArr = common.getLocaleDayNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Narrow).slice();
                // Get first day of the week based on the locale
                /** @type {?} */
                var firstDayOfWeek = this.firstDayOfWeek;
                // Rearrange the tempArr to start with the first day of the week based on the locale.
                if (firstDayOfWeek > 0) {
                    /** @type {?} */
                    var prevDays = tempArr.splice(0, firstDayOfWeek);
                    tempArr.push.apply(tempArr, __spread(prevDays));
                }
                this._localeDaysNarrow = tempArr;
            };
        /**
         * Initializes the array of month names in the TranslationWidth.Abbreviated format.
         * e.g. `[Jan, Feb, ...]` for en-US
         */
        /**
         * Initializes the array of month names in the TranslationWidth.Abbreviated format.
         * e.g. `[Jan, Feb, ...]` for en-US
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleMonthsAbbreviated = /**
         * Initializes the array of month names in the TranslationWidth.Abbreviated format.
         * e.g. `[Jan, Feb, ...]` for en-US
         * @return {?}
         */
            function () {
                this._localeMonthsAbbreviated = common.getLocaleMonthNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Abbreviated).slice();
            };
        /**
         * Initializes the array of month names in the TranslationWidth.Wide format.
         * e.g. `[January, February, ...]` for en-US
         */
        /**
         * Initializes the array of month names in the TranslationWidth.Wide format.
         * e.g. `[January, February, ...]` for en-US
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleMonthsWide = /**
         * Initializes the array of month names in the TranslationWidth.Wide format.
         * e.g. `[January, February, ...]` for en-US
         * @return {?}
         */
            function () {
                this._localeMonthsWide = common.getLocaleMonthNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Wide).slice();
            };
        /**
         * Initializes the first day of the week based on the locale.
         */
        /**
         * Initializes the first day of the week based on the locale.
         * @return {?}
         */
        LocaleHelperService.prototype.initializeFirstDayOfWeek = /**
         * Initializes the first day of the week based on the locale.
         * @return {?}
         */
            function () {
                this._firstDayOfWeek = common.getLocaleFirstDayOfWeek(this.locale);
            };
        /**
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleDateFormat = /**
         * @return {?}
         */
            function () {
                this._localeDateFormat = common.getLocaleDateFormat(this.locale, common.FormatWidth.Short);
            };
        LocaleHelperService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        LocaleHelperService.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
            ];
        };
        return LocaleHelperService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCalendar = /** @class */ (function () {
        function ClrCalendar(_localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
            this._localeHelperService = _localeHelperService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this._subs = [];
            this.generateCalendarView();
            this.initializeSubscriptions();
        }
        Object.defineProperty(ClrCalendar.prototype, "localeDaysNarrow", {
            /**
             * Gets the locale days according to the TranslationWidth.Narrow format.
             */
            get: /**
             * Gets the locale days according to the TranslationWidth.Narrow format.
             * @return {?}
             */ function () {
                return this._localeHelperService.localeDaysNarrow;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "calendar", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "selectedDay", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.selectedDay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "focusedDay", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.focusedDay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "today", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.today;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize subscriptions to:
         * 1. update the calendar view model.
         * 2. update the focusable day in the calendar view model.
         * 3. focus on the focusable day in the calendar.
         */
        /**
         * Initialize subscriptions to:
         * 1. update the calendar view model.
         * 2. update the focusable day in the calendar view model.
         * 3. focus on the focusable day in the calendar.
         * @return {?}
         */
        ClrCalendar.prototype.initializeSubscriptions = /**
         * Initialize subscriptions to:
         * 1. update the calendar view model.
         * 2. update the focusable day in the calendar view model.
         * 3. focus on the focusable day in the calendar.
         * @return {?}
         */
            function () {
                var _this = this;
                this._subs.push(this._dateNavigationService.displayedCalendarChange.subscribe(function () {
                    _this.generateCalendarView();
                }));
                this._subs.push(this._dateNavigationService.focusedDayChange.subscribe(function (focusedDay) {
                    _this.calendarViewModel.updateFocusableDay(focusedDay);
                }));
                this._subs.push(this._dateNavigationService.focusOnCalendarChange.subscribe(function () {
                    _this._datepickerFocusService.focusCell(_this._elRef);
                }));
            };
        /**
         * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
         */
        /**
         * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
         * @return {?}
         */
        ClrCalendar.prototype.generateCalendarView = /**
         * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
         * @return {?}
         */
            function () {
                this.calendarViewModel = new CalendarViewModel(this.calendar, this.selectedDay, this.focusedDay, this.today, this._localeHelperService.firstDayOfWeek);
            };
        /**
         * Delegates Keyboard arrow navigation to the DateNavigationService.
         */
        /**
         * Delegates Keyboard arrow navigation to the DateNavigationService.
         * @param {?} event
         * @return {?}
         */
        ClrCalendar.prototype.onKeyDown = /**
         * Delegates Keyboard arrow navigation to the DateNavigationService.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event && this.focusedDay) {
                    switch (event.keyCode) {
                        case UP_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(-1 * NO_OF_DAYS_IN_A_WEEK);
                            break;
                        case DOWN_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(NO_OF_DAYS_IN_A_WEEK);
                            break;
                        case LEFT_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(-1);
                            break;
                        case RIGHT_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(1);
                            break;
                        default:
                            break; // No default case. TSLint x-(
                    }
                }
            };
        /**
         * Focuses on the focusable day when the Calendar View is initialized.
         */
        /**
         * Focuses on the focusable day when the Calendar View is initialized.
         * @return {?}
         */
        ClrCalendar.prototype.ngAfterViewInit = /**
         * Focuses on the focusable day when the Calendar View is initialized.
         * @return {?}
         */
            function () {
                this._datepickerFocusService.focusCell(this._elRef);
            };
        /**
         * Unsubscribe from subscriptions.
         */
        /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
        ClrCalendar.prototype.ngOnDestroy = /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
            function () {
                this._subs.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrCalendar.decorators = [
            { type: i0.Component, args: [{ selector: 'clr-calendar', template: "<table class=\"calendar-table weekdays\">\n    <tr class=\"calendar-row\">\n        <td *ngFor=\"let day of localeDaysNarrow\" class=\"calendar-cell weekday\">\n            {{day}}\n        </td>\n    </tr>\n</table>\n<table\n    class=\"calendar-table calendar-dates\">\n    <tr class=\"calendar-row\" *ngFor=\"let row of calendarViewModel.calendarView\">\n        <td *ngFor=\"let dayView of row\" class=\"calendar-cell\">\n            <clr-day [clrDayView]=\"dayView\"></clr-day>\n        </td>\n    </tr>\n</table>\n" }] }
        ];
        /** @nocollapse */
        ClrCalendar.ctorParameters = function () {
            return [
                { type: LocaleHelperService },
                { type: DateNavigationService },
                { type: DatepickerFocusService },
                { type: i0.ElementRef }
            ];
        };
        ClrCalendar.propDecorators = {
            onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ClrCalendar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var FocusService = /** @class */ (function () {
        function FocusService() {
            this._focused = new rxjs.BehaviorSubject(false);
        }
        Object.defineProperty(FocusService.prototype, "focusChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._focused.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusService.prototype, "focused", {
            set: /**
             * @param {?} state
             * @return {?}
             */ function (state) {
                this._focused.next(state);
            },
            enumerable: true,
            configurable: true
        });
        FocusService.decorators = [
            { type: i0.Injectable }
        ];
        return FocusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DateFormControlService = /** @class */ (function () {
        function DateFormControlService() {
            this._touchedChange = new rxjs.Subject();
            this._dirtyChange = new rxjs.Subject();
        }
        Object.defineProperty(DateFormControlService.prototype, "touchedChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._touchedChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateFormControlService.prototype, "dirtyChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._dirtyChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateFormControlService.prototype.markAsTouched = /**
         * @return {?}
         */
            function () {
                this._touchedChange.next();
            };
        /**
         * @return {?}
         */
        DateFormControlService.prototype.markAsDirty = /**
         * @return {?}
         */
            function () {
                this._dirtyChange.next();
            };
        DateFormControlService.decorators = [
            { type: i0.Injectable }
        ];
        return DateFormControlService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DateIOService = /** @class */ (function () {
        function DateIOService(_localeHelperService) {
            this._localeHelperService = _localeHelperService;
            this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
            this.localeDisplayFormat = LITTLE_ENDIAN;
            this.delimiters = ['/', '/'];
            this.cldrLocaleDateFormat = this._localeHelperService.localeDateFormat;
            this.initializeLocaleDisplayFormat();
        }
        /**
         * @return {?}
         */
        DateIOService.prototype.initializeLocaleDisplayFormat = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var format = this.cldrLocaleDateFormat.toLocaleLowerCase();
                if (LITTLE_ENDIAN_REGEX.test(format)) {
                    this.localeDisplayFormat = LITTLE_ENDIAN;
                }
                else if (MIDDLE_ENDIAN_REGEX.test(format)) {
                    this.localeDisplayFormat = MIDDLE_ENDIAN;
                }
                else {
                    // everything else is set to BIG-ENDIAN FORMAT
                    this.localeDisplayFormat = BIG_ENDIAN;
                }
                this.extractDelimiters();
            };
        /**
         * @return {?}
         */
        DateIOService.prototype.extractDelimiters = /**
         * @return {?}
         */
            function () {
                if (this.cldrLocaleDateFormat) {
                    // Sanitize Date Format. Remove RTL characters.
                    // FIXME: When we support RTL, remove this and handle it correctly.
                    /** @type {?} */
                    var localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, '');
                    /** @type {?} */
                    var delimiters = localeFormat.split(DELIMITER_REGEX);
                    // NOTE: The split from the CLDR date format should always result
                    // in an arary with 4 elements. The 1st and the 2nd values are the delimiters
                    // we will use in order.
                    // Eg: "dd/MM/y".split(/d+|m+|y+/i) results in ["", "/", "/", ""]
                    if (delimiters && delimiters.length === 4) {
                        this.delimiters = [delimiters[1], delimiters[2]];
                    }
                    else {
                        console.error('Unexpected date format received. Delimiters extracted: ', delimiters);
                    }
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.toLocaleDisplayFormatString = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (date) {
                    if (isNaN(date.getTime())) {
                        return '';
                    }
                    /** @type {?} */
                    var dateNo = date.getDate();
                    /** @type {?} */
                    var monthNo = date.getMonth() + 1;
                    /** @type {?} */
                    var dateStr = dateNo > 9 ? dateNo.toString() : '0' + dateNo;
                    /** @type {?} */
                    var monthStr = monthNo > 9 ? monthNo.toString() : '0' + monthNo;
                    if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                        return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
                    }
                    else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                        return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
                    }
                    else {
                        return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
                    }
                }
                return '';
            };
        Object.defineProperty(DateIOService.prototype, "placeholderText", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var format = this.localeDisplayFormat.format;
                return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if the month entered by the user is valid or not.
         * Note: Month is 0 based.
         */
        /**
         * Checks if the month entered by the user is valid or not.
         * Note: Month is 0 based.
         * @param {?} month
         * @return {?}
         */
        DateIOService.prototype.isValidMonth = /**
         * Checks if the month entered by the user is valid or not.
         * Note: Month is 0 based.
         * @param {?} month
         * @return {?}
         */
            function (month) {
                return month > -1 && month < 12;
            };
        /**
         * Checks if the date is valid depending on the year and month provided.
         */
        /**
         * Checks if the date is valid depending on the year and month provided.
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.isValidDate = /**
         * Checks if the date is valid depending on the year and month provided.
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
            function (year, month, date) {
                return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
            };
        /**
         * Validates the parameters provided and returns the date.
         * If the parameters are not
         * valid then return null.
         * NOTE: (Month here is 1 based since the user has provided that as an input)
         */
        /**
         * Validates the parameters provided and returns the date.
         * If the parameters are not
         * valid then return null.
         * NOTE: (Month here is 1 based since the user has provided that as an input)
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.validateAndGetDate = /**
         * Validates the parameters provided and returns the date.
         * If the parameters are not
         * valid then return null.
         * NOTE: (Month here is 1 based since the user has provided that as an input)
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
            function (year, month, date) {
                // I don't know whats wrong with the TS compiler. It throws an error if I write
                // the below if statement. The error is:
                // Operator '!==' cannot be applied to types '2' and '4'
                // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
                /*
                    if (year.length !== 2 || year.length !== 4) {
                        return null;
                    }
                    */
                // I don't know whats wrong with the TS compiler. It throws an error if I write
                // the below if statement. The error is:
                // Operator '!==' cannot be applied to types '2' and '4'
                // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
                /*
                        if (year.length !== 2 || year.length !== 4) {
                            return null;
                        }
                        */
                // Instead I have to write the logic like this x-(
                /** @type {?} */
                var y = +year;
                /** @type {?} */
                var m = +month - 1;
                // month is 0 based
                /** @type {?} */
                var d = +date;
                if (!this.isValidMonth(m) || !this.isValidDate(y, m, d)) {
                    return null;
                }
                /** @type {?} */
                var result = parseToFourDigitYear(y);
                return result !== -1 ? new Date(result, m, d) : null;
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.getDateValueFromDateString = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (!date) {
                    return null;
                }
                /** @type {?} */
                var dateParts = date.match(USER_INPUT_REGEX);
                if (!dateParts || dateParts.length !== 3) {
                    return null;
                }
                var _a = __read(dateParts, 3), firstPart = _a[0], secondPart = _a[1], thirdPart = _a[2];
                if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                    // secondPart is month && firstPart is date
                    return this.validateAndGetDate(thirdPart, secondPart, firstPart);
                }
                else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                    // firstPart is month && secondPart is date
                    return this.validateAndGetDate(thirdPart, firstPart, secondPart);
                }
                else {
                    // secondPart is month && thirdPart is date
                    return this.validateAndGetDate(firstPart, secondPart, thirdPart);
                }
            };
        DateIOService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DateIOService.ctorParameters = function () {
            return [
                { type: LocaleHelperService }
            ];
        };
        return DateIOService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // iPad mini screen width
    // http://stephen.io/mediaqueries/#iPadMini
    /** @type {?} */
    var DATEPICKER_ENABLE_BREAKPOINT = 768;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatepickerEnabledService = /** @class */ (function () {
        function DatepickerEnabledService(_document) {
            this._document = _document;
            this._isUserAgentMobile = false;
            if (this._document) {
                this._isUserAgentMobile = MOBILE_USERAGENT_REGEX.test(_document.defaultView.navigator.userAgent);
                this._innerWidth = _document.defaultView.innerWidth;
            }
        }
        Object.defineProperty(DatepickerEnabledService.prototype, "isEnabled", {
            /**
             * Returns if the calendar should be active or not.
             * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
             * then the calendar is inactive.
             */
            get: /**
             * Returns if the calendar should be active or not.
             * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
             * then the calendar is inactive.
             * @return {?}
             */ function () {
                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
                // What they recommend is:
                //"In summary, we recommend looking for the string 'Mobi'
                // anywhere in the User Agent to detect a mobile device."
                if (this._document) {
                    if (this._innerWidth < DATEPICKER_ENABLE_BREAKPOINT && this._isUserAgentMobile) {
                        return false;
                    }
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        DatepickerEnabledService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DatepickerEnabledService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        return DatepickerEnabledService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This component contains two template for the old and new forms layouts.
     * When it is time to remove the old forms layouts support, remove the ng-templates
     * and ng-container, and just keep the inner content of the #newLayout as the template
     * and move the ng-content for clrDate.
     */
    var ClrDateContainer = /** @class */ (function () {
        function ClrDateContainer(_ifOpenService, _dateNavigationService, _datepickerEnabledService, dateFormControlService, commonStrings, ifErrorService, focusService, controlClassService, layoutService, newFormsLayout, ngControlService, elementRef) {
            var _this = this;
            this._ifOpenService = _ifOpenService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerEnabledService = _datepickerEnabledService;
            this.dateFormControlService = dateFormControlService;
            this.commonStrings = commonStrings;
            this.ifErrorService = ifErrorService;
            this.focusService = focusService;
            this.controlClassService = controlClassService;
            this.layoutService = layoutService;
            this.newFormsLayout = newFormsLayout;
            this.ngControlService = ngControlService;
            this.elementRef = elementRef;
            this._dynamic = false;
            this.invalid = false;
            this.focus = false;
            this.subscriptions = [];
            this.subscriptions.push(this._ifOpenService.openChange.subscribe(function (open) {
                if (open) {
                    _this.initializeCalendar();
                    _this.escapeReady = true;
                }
            }));
            this.subscriptions.push(this.focusService.focusChange.subscribe(function (state) {
                _this.focus = state;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        // Gate to be used by this escape listener and the subscription change event from ifOpenSvc
        /**
         * @param {?} event
         * @return {?}
         */
        ClrDateContainer.prototype.close =
            // Gate to be used by this escape listener and the subscription change event from ifOpenSvc
            /**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                if (this.newFormsLayout && this.escapeReady) {
                    this.elementRef.nativeElement.querySelector('.clr-input-group-icon-action').focus();
                }
                else if (!this.newFormsLayout && this.escapeReady) {
                    this.elementRef.nativeElement.querySelector('.datepicker-trigger').focus();
                }
                this.escapeReady = false;
            };
        /**
         * @return {?}
         */
        ClrDateContainer.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                    _this.invalid = invalid;
                }));
            };
        /**
         * Returns the classes to apply to the control
         */
        /**
         * Returns the classes to apply to the control
         * @return {?}
         */
        ClrDateContainer.prototype.controlClass = /**
         * Returns the classes to apply to the control
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * Determines if the control needs to add grid classes
         */
        /**
         * Determines if the control needs to add grid classes
         * @return {?}
         */
        ClrDateContainer.prototype.addGrid = /**
         * Determines if the control needs to add grid classes
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        Object.defineProperty(ClrDateContainer.prototype, "isEnabled", {
            /**
             * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
             */
            get: /**
             * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
             * @return {?}
             */ function () {
                return this._datepickerEnabledService.isEnabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
         */
        /**
         * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
         * @return {?}
         */
        ClrDateContainer.prototype.initializeCalendar = /**
         * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
         * @return {?}
         */
            function () {
                this._dateNavigationService.initializeCalendar();
            };
        /**
         * Toggles the Datepicker Popover.
         */
        /**
         * Toggles the Datepicker Popover.
         * @param {?} event
         * @return {?}
         */
        ClrDateContainer.prototype.toggleDatepicker = /**
         * Toggles the Datepicker Popover.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._ifOpenService.toggleWithEvent(event);
                this.dateFormControlService.markAsTouched();
            };
        /**
         * Unsubscribe from subscriptions.
         */
        /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
        ClrDateContainer.prototype.ngOnDestroy = /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
            function () {
                this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
            };
        ClrDateContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-date-container',
                        template: "\n    <ng-template #oldLayout>\n        <ng-content></ng-content>\n        <ng-container *ngTemplateOutlet=\"clrDate\"></ng-container>\n        <button\n            type=\"button\"\n            class=\"datepicker-trigger\"\n            (click)=\"toggleDatepicker($event)\"\n            *ngIf=\"isEnabled\">\n            <clr-icon shape=\"calendar\" class=\"datepicker-trigger-icon\" [attr.title]=\"commonStrings.keys.open\"></clr-icon>\n        </button>\n        <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>\n    </ng-template>\n    \n    <ng-template #newLayout>\n      <ng-content select=\"label\"></ng-content>\n      <label *ngIf=\"!label && addGrid()\"></label>\n      <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n        <div class=\"clr-input-wrapper\">\n          <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n            <ng-container *ngTemplateOutlet=\"clrDate\"></ng-container>\n            <button #actionButton \n                    type=\"button\" \n                    class=\"clr-input-group-icon-action\"\n                    [attr.title]=\"commonStrings.keys.datepickerToggle\"\n                    [attr.aria-label]=\"commonStrings.keys.datepickerToggle\"\n                    [disabled]=\"control?.disabled\"\n                    (click)=\"toggleDatepicker($event)\"\n                    *ngIf=\"isEnabled\">\n              <clr-icon shape=\"calendar\"></clr-icon>\n            </button>\n            <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>\n          </div>\n          <clr-icon class=\"clr-validate-icon\" shape=\"exclamation-circle\"></clr-icon>\n        </div>\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </ng-template>\n    \n    <ng-template #clrDate>\n      <ng-content select=\"[clrDate]\"></ng-content>\n    </ng-template>\n    \n    <ng-template #btnTemplate>\n        <ng-content select=\"button\"></ng-content>\n    </ng-template>\n    \n    <ng-container *ngIf=\"newFormsLayout; then newLayout else oldLayout\"></ng-container>\n    ",
                        providers: [
                            ControlIdService,
                            IfOpenService,
                            LocaleHelperService,
                            IfErrorService,
                            ControlClassService,
                            FocusService,
                            NgControlService,
                            DateIOService,
                            DateNavigationService,
                            DatepickerEnabledService,
                            DateFormControlService,
                            ClrCommonStringsService,
                        ],
                        host: {
                            '[class.date-container]': '!newFormsLayout',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-form-control]': 'newFormsLayout',
                            '[class.clr-row]': 'addGrid()',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDateContainer.ctorParameters = function () {
            return [
                { type: IfOpenService },
                { type: DateNavigationService },
                { type: DatepickerEnabledService },
                { type: DateFormControlService },
                { type: ClrCommonStringsService },
                { type: IfErrorService },
                { type: FocusService },
                { type: ControlClassService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: Boolean, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IS_NEW_FORMS_LAYOUT,] }] },
                { type: NgControlService },
                { type: i0.ElementRef }
            ];
        };
        ClrDateContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }],
            close: [{ type: i0.HostListener, args: ['body:keyup.escape', ['$event'],] }]
        };
        return ClrDateContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // There are four ways the datepicker value is set
    // 1. Value set by user typing into text input as a string ex: '01/28/2015'
    // 2. Value set explicitly by Angular Forms APIs as a string ex: '01/28/2015'
    // 3. Value set by user via datepicker UI as a Date Object
    // 4. Value set via `clrDate` input as a Date Object
    var ClrDateInput = /** @class */ (function (_super) {
        __extends(ClrDateInput, _super);
        function ClrDateInput(viewContainerRef, injector, el, renderer, control, container, dateIOService, dateNavigationService, datepickerEnabledService, dateFormControlService, platformId, focusService, newFormsLayout, datepickerFocusService) {
            var _this = _super.call(this, viewContainerRef, ClrDateContainer, injector, control, renderer, el) || this;
            _this.el = el;
            _this.renderer = renderer;
            _this.control = control;
            _this.container = container;
            _this.dateIOService = dateIOService;
            _this.dateNavigationService = dateNavigationService;
            _this.datepickerEnabledService = datepickerEnabledService;
            _this.dateFormControlService = dateFormControlService;
            _this.platformId = platformId;
            _this.focusService = focusService;
            _this.newFormsLayout = newFormsLayout;
            _this.datepickerFocusService = datepickerFocusService;
            _this.dateChange = new i0.EventEmitter(false);
            _this.index = 4;
            return _this;
        }
        Object.defineProperty(ClrDateInput.prototype, "date", {
            set: /**
             * @param {?} date
             * @return {?}
             */ function (date) {
                if (this.previousDateChange !== date) {
                    this.updateDate(this.getValidDateValueFromDate(date));
                }
                if (!this.initialClrDateInputValue) {
                    this.initialClrDateInputValue = date;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDateInput.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.setFormLayout();
                this.populateServicesFromContainerComponent();
                this.subscriptions.push(this.listenForUserSelectedDayChanges(), this.listenForControlValueChanges(), this.listenForTouchChanges(), this.listenForDirtyChanges(), this.listenForInputRefocus());
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // I don't know why I have to do this but after using the new HostWrapping Module I have to delay the processing
                // of the initial Input set by the user to here. If I do not 2 issues occur:
                // 1. The Input setter is called before ngOnInit. ngOnInit initializes the services without which the setter fails.
                // 2. The Renderer doesn't work before ngAfterViewInit (It used to before the new HostWrapping Module for some reason).
                // I need the renderer to set the value property on the input to make sure that if the user has supplied a Date
                // input object, we reflect it with the right date on the input field using the IO service. I am not sure if
                // these are major issues or not but just noting them down here.
                this.processInitialInputs();
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.setFocusStates = /**
         * @return {?}
         */
            function () {
                this.setFocus(true);
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.triggerValidation = /**
         * @return {?}
         */
            function () {
                _super.prototype.triggerValidation.call(this);
                this.setFocus(false);
            };
        Object.defineProperty(ClrDateInput.prototype, "placeholderText", {
            get: /**
             * @return {?}
             */ function () {
                return this.placeholder ? this.placeholder : this.dateIOService.placeholderText;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateInput.prototype, "inputType", {
            get: /**
             * @return {?}
             */ function () {
                return common.isPlatformBrowser(this.platformId) && this.usingNativeDatepicker() ? 'date' : 'text';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} target
         * @return {?}
         */
        ClrDateInput.prototype.onValueChange = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                /** @type {?} */
                var validDateValue = this.dateIOService.getDateValueFromDateString(target.value);
                if (this.usingClarityDatepicker() && validDateValue) {
                    this.updateDate(validDateValue, true);
                }
                else if (this.usingNativeDatepicker()) {
                    var _a = __read(target.value.split('-'), 3), year = _a[0], month = _a[1], day = _a[2];
                    this.updateDate(new Date(+year, +month - 1, +day), true);
                }
                else {
                    this.emitDateOutput(null);
                }
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.usingClarityDatepicker = /**
         * @return {?}
         */
            function () {
                return this.datepickerEnabledService.isEnabled;
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.usingNativeDatepicker = /**
         * @return {?}
         */
            function () {
                return !this.datepickerEnabledService.isEnabled;
            };
        /**
         * @param {?} focus
         * @return {?}
         */
        ClrDateInput.prototype.setFocus = /**
         * @param {?} focus
         * @return {?}
         */
            function (focus) {
                if (this.focusService) {
                    this.focusService.focused = focus;
                }
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.populateServicesFromContainerComponent = /**
         * @return {?}
         */
            function () {
                if (!this.container) {
                    this.dateIOService = this.getProviderFromContainer(DateIOService);
                    this.dateNavigationService = this.getProviderFromContainer(DateNavigationService);
                    this.datepickerEnabledService = this.getProviderFromContainer(DatepickerEnabledService);
                    this.dateFormControlService = this.getProviderFromContainer(DateFormControlService);
                }
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.processInitialInputs = /**
         * @return {?}
         */
            function () {
                if (this.datepickerHasFormControl()) {
                    this.updateDate(this.dateIOService.getDateValueFromDateString(this.control.value));
                }
                else {
                    this.updateDate(this.initialClrDateInputValue);
                }
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.setFormLayout = /**
         * @return {?}
         */
            function () {
                if (this.clrNewLayout !== undefined) {
                    this.newFormsLayout = !!this.clrNewLayout;
                }
            };
        /**
         * @param {?} value
         * @param {?=} setByUserInteraction
         * @return {?}
         */
        ClrDateInput.prototype.updateDate = /**
         * @param {?} value
         * @param {?=} setByUserInteraction
         * @return {?}
         */
            function (value, setByUserInteraction) {
                if (setByUserInteraction === void 0) {
                    setByUserInteraction = false;
                }
                /** @type {?} */
                var date = this.getValidDateValueFromDate(value);
                if (setByUserInteraction) {
                    this.emitDateOutput(date);
                }
                else {
                    this.previousDateChange = date;
                }
                if (this.dateNavigationService) {
                    this.dateNavigationService.selectedDay = date
                        ? new DayModel(date.getFullYear(), date.getMonth(), date.getDate())
                        : null;
                }
                this.updateInput(date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        ClrDateInput.prototype.updateInput = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (date) {
                    /** @type {?} */
                    var dateString = this.dateIOService.toLocaleDisplayFormatString(date);
                    if (this.datepickerHasFormControl() && dateString !== this.control.value) {
                        this.control.control.setValue(dateString);
                    }
                    else if (this.usingNativeDatepicker()) {
                        this.renderer.setProperty(this.el.nativeElement, 'valueAsDate', date);
                    }
                    else {
                        this.renderer.setProperty(this.el.nativeElement, 'value', dateString);
                    }
                }
                else {
                    this.renderer.setProperty(this.el.nativeElement, 'value', '');
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        ClrDateInput.prototype.getValidDateValueFromDate = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (this.dateIOService) {
                    /** @type {?} */
                    var dateString = this.dateIOService.toLocaleDisplayFormatString(date);
                    return this.dateIOService.getDateValueFromDateString(dateString);
                }
                else {
                    return null;
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        ClrDateInput.prototype.emitDateOutput = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (!datesAreEqual(date, this.previousDateChange)) {
                    this.dateChange.emit(date);
                    this.previousDateChange = date;
                }
                else if (!date && this.previousDateChange) {
                    this.dateChange.emit(null);
                    this.previousDateChange = null;
                }
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.datepickerHasFormControl = /**
         * @return {?}
         */
            function () {
                return !!this.control;
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.listenForControlValueChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return rxjs.of(this.datepickerHasFormControl())
                    .pipe(operators.filter(function (hasControl) { return hasControl; }), operators.switchMap(function () { return _this.control.valueChanges; }), 
                // only update date value if not being set by user
                operators.filter(function () { return !_this.datepickerFocusService.elementIsFocused(_this.el.nativeElement); }))
                    .subscribe(function (value) { return _this.updateDate(_this.dateIOService.getDateValueFromDateString(value)); });
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.listenForUserSelectedDayChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.dateNavigationService.selectedDayChange.subscribe(function (dayModel) { return _this.updateDate(dayModel.toDate(), true); });
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.listenForTouchChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.dateFormControlService.touchedChange
                    .pipe(operators.filter(function () { return _this.datepickerHasFormControl(); }))
                    .subscribe(function () { return _this.control.control.markAsTouched(); });
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.listenForDirtyChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.dateFormControlService.dirtyChange
                    .pipe(operators.filter(function () { return _this.datepickerHasFormControl(); }))
                    .subscribe(function () { return _this.control.control.markAsDirty(); });
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.listenForInputRefocus = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.dateNavigationService.selectedDayChange
                    .pipe(operators.filter(function (date) { return !!date; }))
                    .subscribe(function (v) { return _this.datepickerFocusService.focusInput(_this.el.nativeElement); });
            };
        ClrDateInput.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDate]',
                        host: {
                            '[class.date-input]': '!newFormsLayout',
                            '[class.clr-input]': 'newFormsLayout',
                        },
                        providers: [DatepickerFocusService],
                    },] }
        ];
        /** @nocollapse */
        ClrDateInput.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.Injector },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: ClrDateContainer, decorators: [{ type: i0.Optional }] },
                { type: DateIOService, decorators: [{ type: i0.Optional }] },
                { type: DateNavigationService, decorators: [{ type: i0.Optional }] },
                { type: DatepickerEnabledService, decorators: [{ type: i0.Optional }] },
                { type: DateFormControlService, decorators: [{ type: i0.Optional }] },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: FocusService, decorators: [{ type: i0.Optional }] },
                { type: Boolean, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IS_NEW_FORMS_LAYOUT,] }] },
                { type: DatepickerFocusService }
            ];
        };
        ClrDateInput.propDecorators = {
            placeholder: [{ type: i0.Input }],
            clrNewLayout: [{ type: i0.Input }],
            dateChange: [{ type: i0.Output, args: ['clrDateChange',] }],
            date: [{ type: i0.Input, args: ['clrDate',] }],
            setFocusStates: [{ type: i0.HostListener, args: ['focus',] }],
            triggerValidation: [{ type: i0.HostListener, args: ['blur',] }],
            placeholderText: [{ type: i0.HostBinding, args: ['attr.placeholder',] }],
            inputType: [{ type: i0.HostBinding, args: ['attr.type',] }],
            onValueChange: [{ type: i0.HostListener, args: ['change', ['$event.target'],] }]
        };
        return ClrDateInput;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // Literally any annotation would work here, but writing our own @HoneyBadger annotation feels overkill.
    /**
     * @abstract
     */
    var AbstractPopover = /** @class */ (function () {
        function AbstractPopover(injector, parentHost) {
            var _this = this;
            this.parentHost = parentHost;
            this.updateAnchor = false;
            this.popoverOptions = {};
            /*
                 * Until https://github.com/angular/angular/issues/8785 is supported, we don't have any way to instantiate
                 * a separate directive on the host. So let's do dirty but performant for now.
                 */
            this.closeOnOutsideClick = false;
            this.el = injector.get(i0.ElementRef);
            this.ifOpenService = injector.get(IfOpenService);
            this.renderer = injector.get(i0.Renderer2);
            // Default anchor is the parent host
            this.anchorElem = parentHost.nativeElement;
            this.popoverInstance = new Popover(this.el.nativeElement);
            this.subscription = this.ifOpenService.openChange.subscribe(function (change) {
                if (change) {
                    _this.anchor();
                    _this.attachESCListener();
                }
                else {
                    _this.release();
                    _this.detachESCListener();
                }
            });
            if (this.ifOpenService.open) {
                this.anchor();
                this.attachESCListener();
            }
        }
        /**
         * @return {?}
         */
        AbstractPopover.prototype.anchor = /**
         * @return {?}
         */
            function () {
                this.updateAnchor = true;
                // Ugh
                this.ignore = this.ifOpenService.originalEvent;
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.release = /**
         * @return {?}
         */
            function () {
                this.detachOutsideClickListener();
                this.popoverInstance.release();
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.updateAnchor) {
                    this.updateAnchor = false;
                    this.popoverInstance
                        .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                        .subscribe(function () {
                        // if a scroll event is detected, close the popover
                        _this.ifOpenService.open = false;
                    });
                    this.attachOutsideClickListener();
                }
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.release();
                this.detachESCListener();
                this.subscription.unsubscribe();
            };
        Object.defineProperty(AbstractPopover.prototype, "isOffScreen", {
            /*
               * Fallback to hide when *clrIfOpen is not being used
               */
            get: /*
                 * Fallback to hide when *clrIfOpen is not being used
                 */ 
            /**
             * @return {?}
             */
            function () {
                return this.ifOpenService.open ? false : true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        AbstractPopover.prototype.attachESCListener = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.popoverOptions.ignoreGlobalESCListener) {
                    this.documentESCListener = this.renderer.listen('document', 'keydown', function (event) {
                        if (event && event.key) {
                            if (event.key === 'Escape' || event.key === 'Esc') {
                                _this.ifOpenService.open = false;
                            }
                        }
                    });
                }
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.detachESCListener = /**
         * @return {?}
         */
            function () {
                if (this.documentESCListener) {
                    this.documentESCListener();
                    delete this.documentESCListener;
                }
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.attachOutsideClickListener = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.closeOnOutsideClick) {
                    this.hostClickListener = this.renderer.listen(this.el.nativeElement, 'click', function (event) { return (_this.ignore = event); });
                    if (this.ignoredElement) {
                        this.ignoredElementClickListener = this.renderer.listen(this.ignoredElement, 'click', function (event) { return (_this.ignore = event); });
                    }
                    this.documentClickListener = this.renderer.listen('document', 'click', function (event) {
                        if (event === _this.ignore) {
                            delete _this.ignore;
                        }
                        else {
                            _this.ifOpenService.open = false;
                        }
                    });
                }
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.detachOutsideClickListener = /**
         * @return {?}
         */
            function () {
                if (this.closeOnOutsideClick) {
                    if (this.hostClickListener) {
                        this.hostClickListener();
                        delete this.hostClickListener;
                    }
                    if (this.ignoredElementClickListener) {
                        this.ignoredElementClickListener();
                        delete this.ignoredElementClickListener;
                    }
                    if (this.documentClickListener) {
                        this.documentClickListener();
                        delete this.documentClickListener;
                    }
                }
            };
        AbstractPopover.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        AbstractPopover.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.SkipSelf }] }
            ];
        };
        AbstractPopover.propDecorators = {
            isOffScreen: [{ type: i0.HostBinding, args: ['class.is-off-screen',] }]
        };
        return AbstractPopover;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service manages which view is visible in the datepicker popover.
     */
    var ViewManagerService = /** @class */ (function () {
        function ViewManagerService() {
            this._currentView = "DAYVIEW" /* DAYVIEW */;
        }
        Object.defineProperty(ViewManagerService.prototype, "isDayView", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentView === "DAYVIEW" /* DAYVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewManagerService.prototype, "isYearView", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentView === "YEARVIEW" /* YEARVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewManagerService.prototype, "isMonthView", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentView === "MONTHVIEW" /* MONTHVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ViewManagerService.prototype.changeToMonthView = /**
         * @return {?}
         */
            function () {
                this._currentView = "MONTHVIEW" /* MONTHVIEW */;
            };
        /**
         * @return {?}
         */
        ViewManagerService.prototype.changeToYearView = /**
         * @return {?}
         */
            function () {
                this._currentView = "YEARVIEW" /* YEARVIEW */;
            };
        /**
         * @return {?}
         */
        ViewManagerService.prototype.changeToDayView = /**
         * @return {?}
         */
            function () {
                this._currentView = "DAYVIEW" /* DAYVIEW */;
            };
        ViewManagerService.decorators = [
            { type: i0.Injectable }
        ];
        return ViewManagerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatepickerViewManager = /** @class */ (function (_super) {
        __extends(ClrDatepickerViewManager, _super);
        function ClrDatepickerViewManager(parent, _injector, _viewManagerService) {
            var _this = _super.call(this, _injector, parent) || this;
            _this._viewManagerService = _viewManagerService;
            _this.configurePopover();
            return _this;
        }
        /**
         * Configure Popover Direction and Close indicators
         */
        /**
         * Configure Popover Direction and Close indicators
         * @return {?}
         */
        ClrDatepickerViewManager.prototype.configurePopover = /**
         * Configure Popover Direction and Close indicators
         * @return {?}
         */
            function () {
                this.anchorPoint = Point.BOTTOM_LEFT;
                this.popoverPoint = Point.LEFT_TOP;
                this.closeOnOutsideClick = true;
            };
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isMonthView", {
            /**
             * Returns if the current view is the monthpicker.
             */
            get: /**
             * Returns if the current view is the monthpicker.
             * @return {?}
             */ function () {
                return this._viewManagerService.isMonthView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isYearView", {
            /**
             * Returns if the current view is the yearpicker.
             */
            get: /**
             * Returns if the current view is the yearpicker.
             * @return {?}
             */ function () {
                return this._viewManagerService.isYearView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isDayView", {
            /**
             * Returns if the current view is the daypicker.
             */
            get: /**
             * Returns if the current view is the daypicker.
             * @return {?}
             */ function () {
                return this._viewManagerService.isDayView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatepickerViewManager.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-datepicker-view-manager',
                        template: "<!--\n* Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n* This software is released under MIT license.\n* The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<clr-monthpicker *ngIf=\"isMonthView\"></clr-monthpicker>\n<clr-yearpicker *ngIf=\"isYearView\"></clr-yearpicker>\n<clr-daypicker *ngIf=\"isDayView\"></clr-daypicker>\n",
                        providers: [ViewManagerService, DatepickerFocusService],
                        host: { '[class.datepicker]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatepickerViewManager.ctorParameters = function () {
            return [
                { type: i0.ElementRef, decorators: [{ type: i0.SkipSelf }] },
                { type: i0.Injector },
                { type: ViewManagerService }
            ];
        };
        return ClrDatepickerViewManager;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDay = /** @class */ (function () {
        function ClrDay(_dateNavigationService, _ifOpenService, dateFormControlService) {
            this._dateNavigationService = _dateNavigationService;
            this._ifOpenService = _ifOpenService;
            this.dateFormControlService = dateFormControlService;
        }
        Object.defineProperty(ClrDay.prototype, "dayView", {
            get: /**
             * @return {?}
             */ function () {
                return this._dayView;
            },
            /**
             * DayViewModel input which is used to build the Day View.
             */
            set: /**
             * DayViewModel input which is used to build the Day View.
             * @param {?} day
             * @return {?}
             */ function (day) {
                this._dayView = day;
                this.dayString = this._dayView.dayModel.toDateString();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
         */
        /**
         * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
         * @return {?}
         */
        ClrDay.prototype.onDayViewFocus = /**
         * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
         * @return {?}
         */
            function () {
                this._dateNavigationService.focusedDay = this.dayView.dayModel;
            };
        /**
         * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
         */
        /**
         * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
         * @return {?}
         */
        ClrDay.prototype.selectDay = /**
         * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var day = this.dayView.dayModel;
                this._dateNavigationService.notifySelectedDayChanged(day);
                this.dateFormControlService.markAsDirty();
                this._ifOpenService.open = false;
            };
        ClrDay.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-day',
                        template: "\n        <button\n            class=\"day-btn\"\n            type=\"button\"\n            [class.is-today]=\"dayView.isTodaysDate\"\n            [class.is-disabled]=\"dayView.isDisabled\"\n            [class.is-selected]=\"dayView.isSelected\"\n            [attr.tabindex]=\"dayView.tabIndex\"\n            (click)=\"selectDay()\"\n            (focus)=\"onDayViewFocus()\"\n            [attr.aria-label]=\"dayString\">\n            {{dayView.dayModel.date}}\n        </button>\n    ",
                        host: { '[class.day]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDay.ctorParameters = function () {
            return [
                { type: DateNavigationService },
                { type: IfOpenService },
                { type: DateFormControlService }
            ];
        };
        ClrDay.propDecorators = {
            dayView: [{ type: i0.Input, args: ['clrDayView',] }]
        };
        return ClrDay;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDaypicker = /** @class */ (function () {
        function ClrDaypicker(_viewManagerService, _dateNavigationService, _localeHelperService, commonStrings) {
            this._viewManagerService = _viewManagerService;
            this._dateNavigationService = _dateNavigationService;
            this._localeHelperService = _localeHelperService;
            this.commonStrings = commonStrings;
        }
        Object.defineProperty(ClrDaypicker.prototype, "monthAttrString", {
            get: /**
             * @return {?}
             */ function () {
                return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectMonthText, {
                    CALENDAR_MONTH: this.calendarMonth,
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "yearAttrString", {
            get: /**
             * @return {?}
             */ function () {
                return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectYearText, {
                    CALENDAR_YEAR: this.calendarYear.toString(),
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "ariaLiveMonth", {
            get: /**
             * @return {?}
             */ function () {
                return this.commonStrings.parse(this.commonStrings.keys.daypickerSRCurrentMonthPhrase, {
                    CURRENT_MONTH: this.calendarMonth,
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "updateAriaLiveYear", {
            get: /**
             * @return {?}
             */ function () {
                return this.commonStrings.parse(this.commonStrings.keys.daypickerSRCurrentYearPhrase, {
                    CURRENT_YEAR: this.calendarYear.toString(),
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the ViewManagerService to change to the monthpicker view.
         */
        /**
         * Calls the ViewManagerService to change to the monthpicker view.
         * @return {?}
         */
        ClrDaypicker.prototype.changeToMonthView = /**
         * Calls the ViewManagerService to change to the monthpicker view.
         * @return {?}
         */
            function () {
                this._viewManagerService.changeToMonthView();
            };
        /**
         * Calls the ViewManagerService to change to the yearpicker view.
         */
        /**
         * Calls the ViewManagerService to change to the yearpicker view.
         * @return {?}
         */
        ClrDaypicker.prototype.changeToYearView = /**
         * Calls the ViewManagerService to change to the yearpicker view.
         * @return {?}
         */
            function () {
                this._viewManagerService.changeToYearView();
            };
        Object.defineProperty(ClrDaypicker.prototype, "calendarMonth", {
            /**
             * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
             */
            get: /**
             * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
             * @return {?}
             */ function () {
                return this._localeHelperService.localeMonthsAbbreviated[this._dateNavigationService.displayedCalendar.month];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "calendarYear", {
            /**
             * Returns the year value of the calendar.
             */
            get: /**
             * Returns the year value of the calendar.
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar.year;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the DateNavigationService to move to the next month.
         */
        /**
         * Calls the DateNavigationService to move to the next month.
         * @return {?}
         */
        ClrDaypicker.prototype.nextMonth = /**
         * Calls the DateNavigationService to move to the next month.
         * @return {?}
         */
            function () {
                this._dateNavigationService.moveToNextMonth();
            };
        /**
         * Calls the DateNavigationService to move to the previous month.
         */
        /**
         * Calls the DateNavigationService to move to the previous month.
         * @return {?}
         */
        ClrDaypicker.prototype.previousMonth = /**
         * Calls the DateNavigationService to move to the previous month.
         * @return {?}
         */
            function () {
                this._dateNavigationService.moveToPreviousMonth();
            };
        /**
         * Calls the DateNavigationService to move to the current month.
         */
        /**
         * Calls the DateNavigationService to move to the current month.
         * @return {?}
         */
        ClrDaypicker.prototype.currentMonth = /**
         * Calls the DateNavigationService to move to the current month.
         * @return {?}
         */
            function () {
                this._dateNavigationService.moveToCurrentMonth();
            };
        ClrDaypicker.decorators = [
            { type: i0.Component, args: [{ selector: 'clr-daypicker', template: "<div class=\"calendar-header\">\n    <div aria-live=\"polite\" class=\"clr-sr-only\">\n      {{ ariaLiveMonth }}.  {{updateAriaLiveYear}}.\n    </div>\n    <div class=\"calendar-pickers\">\n        <button\n                class=\"calendar-btn monthpicker-trigger\"\n                type=\"button\" (click)=\"changeToMonthView()\"\n                [attr.aria-label]=\"monthAttrString\"\n                [attr.title]=\"monthAttrString\">\n                {{calendarMonth}}\n        </button>\n        <button\n                class=\"calendar-btn yearpicker-trigger\"\n                type=\"button\"\n                (click)=\"changeToYearView()\"\n                [attr.aria-label]=\"yearAttrString\"\n                [attr.title]=\"yearAttrString\">\n            {{calendarYear}}\n        </button>\n    </div>\n    <div class=\"calendar-switchers\">\n        <button\n            class=\"calendar-btn switcher\"\n            type=\"button\"\n            (click)=\"previousMonth()\"\n            [attr.aria-label]=\"commonStrings.keys.datepickerPreviousMonth\">\n            <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.keys.datepickerPreviousMonth\"></clr-icon>\n        </button>\n        <button\n            class=\"calendar-btn switcher\"\n            type=\"button\"\n            (click)=\"currentMonth()\"\n            [attr.aria-label]=\"commonStrings.keys.datepickerCurrentMonth\">\n            <clr-icon shape=\"event\" [attr.title]=\"commonStrings.keys.datepickerCurrentMonth\"></clr-icon>\n        </button>\n        <button\n            class=\"calendar-btn switcher\"\n            type=\"button\"\n            (click)=\"nextMonth()\"\n            [attr.aria-label]=\"commonStrings.keys.datepickerNextMonth\">\n            <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.keys.datepickerNextMonth\"></clr-icon>\n        </button>\n    </div>\n</div>\n<clr-calendar></clr-calendar>\n", host: { '[class.daypicker]': 'true' } }] }
        ];
        /** @nocollapse */
        ClrDaypicker.ctorParameters = function () {
            return [
                { type: ViewManagerService },
                { type: DateNavigationService },
                { type: LocaleHelperService },
                { type: ClrCommonStringsService }
            ];
        };
        return ClrDaypicker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrMonthpicker = /** @class */ (function () {
        function ClrMonthpicker(_viewManagerService, _localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
            this._viewManagerService = _viewManagerService;
            this._localeHelperService = _localeHelperService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this._focusedMonthIndex = this.calendarMonthIndex;
        }
        Object.defineProperty(ClrMonthpicker.prototype, "monthNames", {
            /**
             * Gets the months array which is used to rendered the monthpicker view.
             * Months are in the TranslationWidth.Wide format.
             */
            get: /**
             * Gets the months array which is used to rendered the monthpicker view.
             * Months are in the TranslationWidth.Wide format.
             * @return {?}
             */ function () {
                return this._localeHelperService.localeMonthsWide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrMonthpicker.prototype, "calendarMonthIndex", {
            /**
             * Gets the month value of the Calendar.
             */
            get: /**
             * Gets the month value of the Calendar.
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar.month;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the DateNavigationService to update the month value of the calendar.
         * Also changes the view to the daypicker.
         */
        /**
         * Calls the DateNavigationService to update the month value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} monthIndex
         * @return {?}
         */
        ClrMonthpicker.prototype.changeMonth = /**
         * Calls the DateNavigationService to update the month value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} monthIndex
         * @return {?}
         */
            function (monthIndex) {
                this._dateNavigationService.changeMonth(monthIndex);
                this._viewManagerService.changeToDayView();
            };
        /**
         * Compares the month passed to the focused month and returns the tab index.
         */
        /**
         * Compares the month passed to the focused month and returns the tab index.
         * @param {?} monthIndex
         * @return {?}
         */
        ClrMonthpicker.prototype.getTabIndex = /**
         * Compares the month passed to the focused month and returns the tab index.
         * @param {?} monthIndex
         * @return {?}
         */
            function (monthIndex) {
                return monthIndex === this._focusedMonthIndex ? 0 : -1;
            };
        /**
         * Handles the Keyboard arrow navigation for the monthpicker.
         */
        /**
         * Handles the Keyboard arrow navigation for the monthpicker.
         * @param {?} event
         * @return {?}
         */
        ClrMonthpicker.prototype.onKeyDown = /**
         * Handles the Keyboard arrow navigation for the monthpicker.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // NOTE: Didn't move this to the date navigation service because
                // the logic is fairly simple and it didn't make sense for me
                // to create extra observables just to move this logic to the service.
                if (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    if (keyCode === UP_ARROW && this._focusedMonthIndex > 0) {
                        event.preventDefault();
                        this._focusedMonthIndex--;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                    else if (keyCode === DOWN_ARROW && this._focusedMonthIndex < 11) {
                        event.preventDefault();
                        this._focusedMonthIndex++;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                    else if (keyCode === RIGHT_ARROW && this._focusedMonthIndex < 6) {
                        event.preventDefault();
                        this._focusedMonthIndex = this._focusedMonthIndex + 6;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                    else if (keyCode === LEFT_ARROW && this._focusedMonthIndex > 5) {
                        event.preventDefault();
                        this._focusedMonthIndex = this._focusedMonthIndex - 6;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                }
            };
        /**
         * Focuses on the current calendar month when the View is initialized.
         */
        /**
         * Focuses on the current calendar month when the View is initialized.
         * @return {?}
         */
        ClrMonthpicker.prototype.ngAfterViewInit = /**
         * Focuses on the current calendar month when the View is initialized.
         * @return {?}
         */
            function () {
                this._datepickerFocusService.focusCell(this._elRef);
            };
        ClrMonthpicker.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-monthpicker',
                        template: "\n        <button\n            type=\"button\"\n            class=\"calendar-btn month\"\n            *ngFor=\"let month of monthNames; let monthIndex = index\"\n            (click)=\"changeMonth(monthIndex)\"\n            [class.is-selected]=\"monthIndex === calendarMonthIndex\"\n            [attr.tabindex]=\"getTabIndex(monthIndex)\">\n            {{month}}\n        </button>\n    ",
                        host: {
                            '[class.monthpicker]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrMonthpicker.ctorParameters = function () {
            return [
                { type: ViewManagerService },
                { type: LocaleHelperService },
                { type: DateNavigationService },
                { type: DatepickerFocusService },
                { type: i0.ElementRef }
            ];
        };
        ClrMonthpicker.propDecorators = {
            onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ClrMonthpicker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @type {?} */
    var YEARS_TO_DISPLAY = 10;
    var YearRangeModel = /** @class */ (function () {
        function YearRangeModel(year) {
            this.year = year;
            this.yearRange = [];
            this.generateYearRange();
        }
        Object.defineProperty(YearRangeModel.prototype, "middleYear", {
            /**
             * Gets the number in the middle of the range.
             */
            get: /**
             * Gets the number in the middle of the range.
             * @return {?}
             */ function () {
                return this.yearRange[Math.floor(this.yearRange.length / 2)];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Generates the year range based on the year parameter.
         * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
         */
        /**
         * Generates the year range based on the year parameter.
         * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
         * @return {?}
         */
        YearRangeModel.prototype.generateYearRange = /**
         * Generates the year range based on the year parameter.
         * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
         * @return {?}
         */
            function () {
                /** @type {?} */
                var remainder = this.year % YEARS_TO_DISPLAY;
                /** @type {?} */
                var floor = this.year - remainder;
                /** @type {?} */
                var ceil = floor + YEARS_TO_DISPLAY;
                this.yearRange = this.generateRange(floor, ceil);
            };
        /**
         * Function which generate a range of numbers from floor to ceil.
         */
        /**
         * Function which generate a range of numbers from floor to ceil.
         * @param {?} floor
         * @param {?} ceil
         * @return {?}
         */
        YearRangeModel.prototype.generateRange = /**
         * Function which generate a range of numbers from floor to ceil.
         * @param {?} floor
         * @param {?} ceil
         * @return {?}
         */
            function (floor, ceil) {
                return Array.from({ length: ceil - floor }, function (v, k) { return k + floor; });
            };
        /**
         * Generates the YearRangeModel for the next decade.
         */
        /**
         * Generates the YearRangeModel for the next decade.
         * @return {?}
         */
        YearRangeModel.prototype.nextDecade = /**
         * Generates the YearRangeModel for the next decade.
         * @return {?}
         */
            function () {
                return new YearRangeModel(this.year + 10);
            };
        /**
         * Generates the YearRangeModel for the previous decade.
         */
        /**
         * Generates the YearRangeModel for the previous decade.
         * @return {?}
         */
        YearRangeModel.prototype.previousDecade = /**
         * Generates the YearRangeModel for the previous decade.
         * @return {?}
         */
            function () {
                return new YearRangeModel(this.year - 10);
            };
        /**
         * Generates the YearRangeModel for the current decade.
         */
        /**
         * Generates the YearRangeModel for the current decade.
         * @return {?}
         */
        YearRangeModel.prototype.currentDecade = /**
         * Generates the YearRangeModel for the current decade.
         * @return {?}
         */
            function () {
                return new YearRangeModel(new Date().getFullYear());
            };
        /**
         * Checks if the value is in the YearRangeModel.
         */
        /**
         * Checks if the value is in the YearRangeModel.
         * @param {?} value
         * @return {?}
         */
        YearRangeModel.prototype.inRange = /**
         * Checks if the value is in the YearRangeModel.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.yearRange.indexOf(value) > -1;
            };
        return YearRangeModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrYearpicker = /** @class */ (function () {
        function ClrYearpicker(_dateNavigationService, _viewManagerService, _datepickerFocusService, _elRef, commonStrings) {
            this._dateNavigationService = _dateNavigationService;
            this._viewManagerService = _viewManagerService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this.commonStrings = commonStrings;
            this.yearRangeModel = new YearRangeModel(this.calendarYear);
            this._focusedYear = this.calendarYear;
            this.updateRange(this.yearRangeModel);
        }
        Object.defineProperty(ClrYearpicker.prototype, "ariaLiveDecadeText", {
            get: /**
             * @return {?}
             */ function () {
                return this.commonStrings.parse(this.commonStrings.keys.daypickerSRCurrentDecadePhrase, {
                    DECADE_RANGE: this.decadeRange,
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrYearpicker.prototype, "calendarYear", {
            /**
             * Gets the year which the user is currently on.
             */
            get: /**
             * Gets the year which the user is currently on.
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar.year;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Increments the focus year by the value passed. Updates the YearRangeModel if the
         * new value is not in the current decade.
         */
        /**
         * Increments the focus year by the value passed. Updates the YearRangeModel if the
         * new value is not in the current decade.
         * @param {?} value
         * @return {?}
         */
        ClrYearpicker.prototype.incrementFocusYearBy = /**
         * Increments the focus year by the value passed. Updates the YearRangeModel if the
         * new value is not in the current decade.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._focusedYear = this._focusedYear + value;
                if (!this.yearRangeModel.inRange(this._focusedYear)) {
                    if (value > 0) {
                        this.yearRangeModel = this.yearRangeModel.nextDecade();
                    }
                    else {
                        this.yearRangeModel = this.yearRangeModel.previousDecade();
                    }
                }
                this._datepickerFocusService.focusCell(this._elRef);
            };
        /**
         * Calls the DateNavigationService to update the year value of the calendar.
         * Also changes the view to the daypicker.
         */
        /**
         * Calls the DateNavigationService to update the year value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} year
         * @return {?}
         */
        ClrYearpicker.prototype.changeYear = /**
         * Calls the DateNavigationService to update the year value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this._dateNavigationService.changeYear(year);
                this._viewManagerService.changeToDayView();
            };
        /**
         * Updates the YearRangeModel to the previous decade.
         */
        /**
         * Updates the YearRangeModel to the previous decade.
         * @return {?}
         */
        ClrYearpicker.prototype.previousDecade = /**
         * Updates the YearRangeModel to the previous decade.
         * @return {?}
         */
            function () {
                this.yearRangeModel = this.yearRangeModel.previousDecade();
                this.updateRange(this.yearRangeModel);
                // Year in the yearpicker is not focused because while navigating to a different decade,
                // you want the focus to remain on the decade switcher arrows.
            };
        /**
         * Updates the YearRangeModel to the current decade.
         */
        /**
         * Updates the YearRangeModel to the current decade.
         * @return {?}
         */
        ClrYearpicker.prototype.currentDecade = /**
         * Updates the YearRangeModel to the current decade.
         * @return {?}
         */
            function () {
                if (!this.yearRangeModel.inRange(this._dateNavigationService.today.year)) {
                    this.yearRangeModel = this.yearRangeModel.currentDecade();
                }
                this._datepickerFocusService.focusCell(this._elRef);
                this.updateRange(this.yearRangeModel);
            };
        /**
         * Updates the YearRangeModel to the next decade.
         */
        /**
         * Updates the YearRangeModel to the next decade.
         * @return {?}
         */
        ClrYearpicker.prototype.nextDecade = /**
         * Updates the YearRangeModel to the next decade.
         * @return {?}
         */
            function () {
                this.yearRangeModel = this.yearRangeModel.nextDecade();
                this.updateRange(this.yearRangeModel);
                // Year in the yearpicker is not focused because while navigating to a different decade,
                // you want the focus to remain on the decade switcher arrows.
            };
        /**
         * Compares the year passed to the focused year and returns the tab index.
         */
        /**
         * Compares the year passed to the focused year and returns the tab index.
         * @param {?} year
         * @return {?}
         */
        ClrYearpicker.prototype.getTabIndex = /**
         * Compares the year passed to the focused year and returns the tab index.
         * @param {?} year
         * @return {?}
         */
            function (year) {
                if (!this.yearRangeModel.inRange(this._focusedYear)) {
                    if (this.yearRangeModel.inRange(this.calendarYear)) {
                        this._focusedYear = this.calendarYear;
                    }
                    else {
                        this._focusedYear = this.yearRangeModel.middleYear;
                    }
                }
                return this._focusedYear === year ? 0 : -1;
            };
        /**
         * Handles the Keyboard arrow navigation for the yearpicker.
         */
        /**
         * Handles the Keyboard arrow navigation for the yearpicker.
         * @param {?} event
         * @return {?}
         */
        ClrYearpicker.prototype.onKeyDown = /**
         * Handles the Keyboard arrow navigation for the yearpicker.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // NOTE: Didn't move this to the date navigation service because
                // the logic is fairly simple and it didn't make sense for me
                // to create extra observables just to move this logic to the service.
                if (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    if (keyCode === UP_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(-1);
                    }
                    else if (keyCode === DOWN_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(1);
                    }
                    else if (keyCode === RIGHT_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(5);
                    }
                    else if (keyCode === LEFT_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(-5);
                    }
                }
            };
        /**
         * @param {?} yrm
         * @return {?}
         */
        ClrYearpicker.prototype.updateRange = /**
         * @param {?} yrm
         * @return {?}
         */
            function (yrm) {
                /** @type {?} */
                var floor = yrm.yearRange[0];
                /** @type {?} */
                var ceil = yrm.yearRange[yrm.yearRange.length - 1];
                this.decadeRange = floor + " to " + ceil;
            };
        /**
         * Focuses on the current calendar year when the View is initialized.
         */
        /**
         * Focuses on the current calendar year when the View is initialized.
         * @return {?}
         */
        ClrYearpicker.prototype.ngAfterViewInit = /**
         * Focuses on the current calendar year when the View is initialized.
         * @return {?}
         */
            function () {
                this._datepickerFocusService.focusCell(this._elRef);
                // update the value for  decade range
            };
        ClrYearpicker.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-yearpicker',
                        template: "\n        <div class=\"year-switchers\">\n          <div aria-live=\"polite\" class=\"clr-sr-only\">\n            {{ ariaLiveDecadeText  }}.\n          </div>\n          <button \n              class=\"calendar-btn switcher\" \n              type=\"button\" \n              (click)=\"previousDecade()\"\n              [attr.aria-label]=\"commonStrings.keys.datepickerPreviousDecade\">\n              <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.keys.datepickerPreviousDecade\"></clr-icon>\n          </button>\n          <button \n              class=\"calendar-btn switcher\" \n              type=\"button\" \n              (click)=\"currentDecade()\"\n              [attr.aria-label]=\"commonStrings.keys.datepickerCurrentDecade\">\n              <clr-icon shape=\"event\" [attr.title]=\"commonStrings.keys.datepickerCurrentDecade\"></clr-icon>\n          </button>\n          <button \n              class=\"calendar-btn switcher\" \n              type=\"button\" \n              (click)=\"nextDecade()\"\n              [attr.aria-label]=\"commonStrings.keys.datepickerNextDecade\">\n              <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.keys.datepickerNextDecade\"></clr-icon>\n          </button>\n        </div>\n        <div class=\"years\">\n            <button\n                *ngFor=\"let year of yearRangeModel.yearRange\"\n                type=\"button\"\n                class=\"calendar-btn year\"\n                [attr.tabindex]=\"getTabIndex(year)\"\n                [class.is-selected]=\"year === calendarYear\"\n                (click)=\"changeYear(year)\">\n                {{year}}\n            </button>\n        </div>\n    ",
                        host: {
                            '[class.yearpicker]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrYearpicker.ctorParameters = function () {
            return [
                { type: DateNavigationService },
                { type: ViewManagerService },
                { type: DatepickerFocusService },
                { type: i0.ElementRef },
                { type: ClrCommonStringsService }
            ];
        };
        ClrYearpicker.propDecorators = {
            onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ClrYearpicker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DATEPICKER_DIRECTIVES = [
        ClrDay,
        ClrDateContainer,
        ClrDateInput,
        ClrDatepickerViewManager,
        ClrMonthpicker,
        ClrYearpicker,
        ClrDaypicker,
        ClrCalendar,
    ];
    var ClrDatepickerModule = /** @class */ (function () {
        function ClrDatepickerModule() {
        }
        ClrDatepickerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ClrHostWrappingModule,
                            ClrConditionalModule,
                            ClrIconModule,
                            ClrFocusTrapModule,
                            ClrCommonFormsModule,
                        ],
                        declarations: [CLR_DATEPICKER_DIRECTIVES],
                        exports: [CLR_DATEPICKER_DIRECTIVES],
                        entryComponents: [ClrDateContainer],
                    },] }
        ];
        return ClrDatepickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrInputContainer = /** @class */ (function () {
        function ClrInputContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                _this.invalid = invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        /**
         * @return {?}
         */
        ClrInputContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrInputContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrInputContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrInputContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-input-container',
                        template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-input-wrapper\">\n                <ng-content select=\"[clrInput]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                    }] }
        ];
        /** @nocollapse */
        ClrInputContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrInputContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrInputContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrInput = /** @class */ (function (_super) {
        __extends(ClrInput, _super);
        function ClrInput(vcr, injector, control, renderer, el) {
            var _this = _super.call(this, vcr, ClrInputContainer, injector, control, renderer, el) || this;
            _this.index = 1;
            return _this;
        }
        ClrInput.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrInput]', host: { '[class.clr-input]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrInput.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.Injector },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        return ClrInput;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrInputModule = /** @class */ (function () {
        function ClrInputModule() {
        }
        ClrInputModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrInput, ClrInputContainer],
                        exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer],
                        entryComponents: [ClrInputContainer],
                    },] }
        ];
        return ClrInputModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TOGGLE_SERVICE = new i0.InjectionToken(undefined);
    /**
     * @return {?}
     */
    function ToggleServiceFactory() {
        return new rxjs.BehaviorSubject(false);
    }
    /** @type {?} */
    var TOGGLE_SERVICE_PROVIDER = { provide: TOGGLE_SERVICE, useFactory: ToggleServiceFactory };
    var ClrPasswordContainer = /** @class */ (function () {
        function ClrPasswordContainer(ifErrorService, layoutService, controlClassService, focusService, ngControlService, toggleService, commonStrings) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.focusService = focusService;
            this.ngControlService = ngControlService;
            this.toggleService = toggleService;
            this.commonStrings = commonStrings;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.show = false;
            this.focus = false;
            this._toggle = true;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                _this.invalid = invalid;
            }));
            this.subscriptions.push(this.focusService.focusChange.subscribe(function (state) {
                _this.focus = state;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        Object.defineProperty(ClrPasswordContainer.prototype, "clrToggle", {
            get: /**
             * @return {?}
             */ function () {
                return this._toggle;
            },
            set: /**
             * @param {?} state
             * @return {?}
             */ function (state) {
                this._toggle = state;
                if (!state) {
                    this.show = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.show = !this.show;
                this.toggleService.next(this.show);
            };
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrPasswordContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-password-container',
                        template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n      <div class=\"clr-input-wrapper\">\n        <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n          <ng-content select=\"[clrPassword]\"></ng-content>\n          <button\n            *ngIf=\"clrToggle\"\n            (click)=\"toggle()\"\n            [disabled]=\"control?.disabled\"\n            class=\"clr-input-group-icon-action\"\n            type=\"button\">\n            <clr-icon\n            [attr.shape]=\"show ? 'eye-hide' : 'eye'\"\n            [attr.title]=\"show ? commonStrings.keys.hide : commonStrings.keys.show\"></clr-icon>\n          </button>\n        </div>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n      </div>\n      <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n      <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n    </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [
                            IfErrorService,
                            NgControlService,
                            ControlIdService,
                            ControlClassService,
                            FocusService,
                            TOGGLE_SERVICE_PROVIDER,
                        ]
                    }] }
        ];
        /** @nocollapse */
        ClrPasswordContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: FocusService },
                { type: NgControlService },
                { type: rxjs.BehaviorSubject, decorators: [{ type: i0.Inject, args: [TOGGLE_SERVICE,] }] },
                { type: ClrCommonStringsService }
            ];
        };
        ClrPasswordContainer.propDecorators = {
            clrToggle: [{ type: i0.Input, args: ['clrToggle',] }],
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrPasswordContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrPassword = /** @class */ (function (_super) {
        __extends(ClrPassword, _super);
        function ClrPassword(vcr, injector, control, renderer, el, focusService, toggleService) {
            var _this = _super.call(this, vcr, ClrPasswordContainer, injector, control, renderer, el) || this;
            _this.focusService = focusService;
            _this.toggleService = toggleService;
            _this.index = 1;
            if (!_this.focusService) {
                throw new Error('clrPassword requires being wrapped in <clr-password-container>');
            }
            _this.subscriptions.push(_this.toggleService.subscribe(function (toggle) {
                renderer.setProperty(el.nativeElement, 'type', toggle ? 'text' : 'password');
            }));
            return _this;
        }
        /**
         * @return {?}
         */
        ClrPassword.prototype.triggerFocus = /**
         * @return {?}
         */
            function () {
                if (this.focusService) {
                    this.focusService.focused = true;
                }
            };
        /**
         * @return {?}
         */
        ClrPassword.prototype.triggerValidation = /**
         * @return {?}
         */
            function () {
                _super.prototype.triggerValidation.call(this);
                if (this.focusService) {
                    this.focusService.focused = false;
                }
            };
        ClrPassword.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPassword]', host: { '[class.clr-input]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrPassword.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.Injector },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: FocusService, decorators: [{ type: i0.Optional }] },
                { type: rxjs.BehaviorSubject, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [TOGGLE_SERVICE,] }] }
            ];
        };
        ClrPassword.propDecorators = {
            triggerFocus: [{ type: i0.HostListener, args: ['focus',] }],
            triggerValidation: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return ClrPassword;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrPasswordModule = /** @class */ (function () {
        function ClrPasswordModule() {
        }
        ClrPasswordModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrPassword, ClrPasswordContainer],
                        exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer],
                        entryComponents: [ClrPasswordContainer],
                    },] }
        ];
        return ClrPasswordModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadioWrapper = /** @class */ (function () {
        function ClrRadioWrapper() {
            // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
            // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
            // but we'd still need to insert a label
            this._dynamic = false;
        }
        /**
         * @return {?}
         */
        ClrRadioWrapper.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.label) {
                    this.label.disableGrid();
                }
            };
        ClrRadioWrapper.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-radio-wrapper',
                        template: "\n    <ng-content select=\"[clrRadio]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                        host: {
                            '[class.clr-radio-wrapper]': 'true',
                        },
                        providers: [ControlIdService]
                    }] }
        ];
        ClrRadioWrapper.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrRadioWrapper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadio = /** @class */ (function (_super) {
        __extends(ClrRadio, _super);
        function ClrRadio(vcr, injector, control, renderer, el) {
            return _super.call(this, vcr, ClrRadioWrapper, injector, control, renderer, el) || this;
        }
        ClrRadio.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrRadio]' },] }
        ];
        /** @nocollapse */
        ClrRadio.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.Injector },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        return ClrRadio;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadioContainer = /** @class */ (function () {
        function ClrRadioContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this.inline = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                _this.invalid = invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        Object.defineProperty(ClrRadioContainer.prototype, "clrInline", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline;
            },
            /*
             * Here we want to support the following cases
             * clrInline - true by presence
             * clrInline="true|false" - unless it is explicitly false, strings are considered true
             * [clrInline]="true|false" - expect a boolean
             */
            set: /*
               * Here we want to support the following cases
               * clrInline - true by presence
               * clrInline="true|false" - unless it is explicitly false, strings are considered true
               * [clrInline]="true|false" - expect a boolean
               */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === 'string') {
                    this.inline = value === 'false' ? false : true;
                }
                else {
                    this.inline = !!value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrRadioContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
            };
        /**
         * @return {?}
         */
        ClrRadioContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrRadioContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
            };
        ClrRadioContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-radio-container',
                        template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-radio-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [NgControlService, ControlClassService, IfErrorService]
                    }] }
        ];
        /** @nocollapse */
        ClrRadioContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrRadioContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }],
            clrInline: [{ type: i0.Input }]
        };
        return ClrRadioContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadioModule = /** @class */ (function () {
        function ClrRadioModule() {
        }
        ClrRadioModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
                        declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                        exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                        entryComponents: [ClrRadioWrapper],
                    },] }
        ];
        return ClrRadioModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSelectContainer = /** @class */ (function () {
        function ClrSelectContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.multi = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                _this.invalid = invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                if (control) {
                    _this.multi = control.valueAccessor instanceof forms.SelectMultipleControlValueAccessor;
                    _this.control = control;
                }
            }));
        }
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.wrapperClass = /**
         * @return {?}
         */
            function () {
                return this.multi ? 'clr-multiselect-wrapper' : 'clr-select-wrapper';
            };
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrSelectContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-select-container',
                        template: "    \n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div [ngClass]=\"wrapperClass()\">\n                <ng-content select=\"[clrSelect]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                    }] }
        ];
        /** @nocollapse */
        ClrSelectContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrSelectContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }],
            multiple: [{ type: i0.ContentChild, args: [forms.SelectMultipleControlValueAccessor,] }]
        };
        return ClrSelectContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSelect = /** @class */ (function (_super) {
        __extends(ClrSelect, _super);
        function ClrSelect(vcr, injector, control, renderer, el) {
            var _this = _super.call(this, vcr, ClrSelectContainer, injector, control, renderer, el) || this;
            _this.index = 1;
            return _this;
        }
        ClrSelect.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrSelect]', host: { '[class.clr-select]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrSelect.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.Injector },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        return ClrSelect;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSelectModule = /** @class */ (function () {
        function ClrSelectModule() {
        }
        ClrSelectModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrSelect, ClrSelectContainer],
                        exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer],
                        entryComponents: [ClrSelectContainer],
                    },] }
        ];
        return ClrSelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTextareaContainer = /** @class */ (function () {
        function ClrTextareaContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                _this.invalid = invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        /**
         * @return {?}
         */
        ClrTextareaContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrTextareaContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrTextareaContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrTextareaContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-textarea-container',
                        template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-textarea-wrapper\">\n                <ng-content select=\"[clrTextarea]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                    }] }
        ];
        /** @nocollapse */
        ClrTextareaContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrTextareaContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrTextareaContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTextarea = /** @class */ (function (_super) {
        __extends(ClrTextarea, _super);
        function ClrTextarea(vcr, injector, control, renderer, el) {
            var _this = _super.call(this, vcr, ClrTextareaContainer, injector, control, renderer, el) || this;
            _this.index = 1;
            return _this;
        }
        ClrTextarea.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrTextarea]', host: { '[class.clr-textarea]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrTextarea.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.Injector },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        return ClrTextarea;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTextareaModule = /** @class */ (function () {
        function ClrTextareaModule() {
        }
        ClrTextareaModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrTextarea, ClrTextareaContainer],
                        exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer],
                        entryComponents: [ClrTextareaContainer],
                    },] }
        ];
        return ClrTextareaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrFormsModule = /** @class */ (function () {
        function ClrFormsModule() {
        }
        ClrFormsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [
                            ClrCommonFormsModule,
                            ClrCheckboxModule,
                            ClrDatepickerModule,
                            ClrInputModule,
                            ClrPasswordModule,
                            ClrRadioModule,
                            ClrSelectModule,
                            ClrTextareaModule,
                        ],
                    },] }
        ];
        return ClrFormsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Expand = /** @class */ (function () {
        function Expand() {
            this.expandable = 0;
            // private _replace: boolean = false;
            this._replace = new rxjs.BehaviorSubject(false);
            this._loading = false;
            this._expanded = false;
            // TODO: Move this to the datagrid RowExpand.
            // I spent some time doing this but ran into a couple of issues
            // Will take care of this later.
            this._animate = new rxjs.Subject();
            this._expandChange = new rxjs.Subject();
        }
        Object.defineProperty(Expand.prototype, "replace", {
            get: /**
             * @return {?}
             */ function () {
                return this._replace.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} replaceValue
         * @return {?}
         */
        Expand.prototype.setReplace = /**
         * @param {?} replaceValue
         * @return {?}
         */
            function (replaceValue) {
                this._replace.next(replaceValue);
            };
        Object.defineProperty(Expand.prototype, "loading", {
            get: /**
             * @return {?}
             */ function () {
                return this._loading;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (value !== this._loading) {
                    this._loading = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Expand.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (value !== this._expanded) {
                    this._expanded = value;
                    this._animate.next();
                    this._expandChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Expand.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.expanded = !this._expanded;
            };
        Object.defineProperty(Expand.prototype, "animate", {
            get: /**
             * @return {?}
             */ function () {
                return this._animate.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Expand.prototype, "expandChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._expandChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} state
         * @return {?}
         */
        Expand.prototype.loadingStateChange = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                switch (state) {
                    case ClrLoadingState.LOADING:
                        this.loading = true;
                        break;
                    default:
                        this.loading = false;
                        this._animate.next();
                        break;
                }
            };
        Expand.decorators = [
            { type: i0.Injectable }
        ];
        return Expand;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * TODO: make this a reusable directive outside of Datagrid, like [clrLoading].
     */
    var ClrIfExpanded = /** @class */ (function () {
        function ClrIfExpanded(template, container, el, renderer, expand) {
            var _this = this;
            this.template = template;
            this.container = container;
            this.el = el;
            this.renderer = renderer;
            this.expand = expand;
            this._expanded = false;
            this.expandedChange = new i0.EventEmitter(true);
            /**
             * Subscriptions to all the services and queries changes
             */
            this._subscriptions = [];
            expand.expandable++;
            this._subscriptions.push(expand.expandChange.subscribe(function () {
                _this.updateView();
                _this.expandedChange.emit(_this.expand.expanded);
            }));
        }
        Object.defineProperty(ClrIfExpanded.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'boolean') {
                    this.expand.expanded = value;
                    this._expanded = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrIfExpanded.prototype.updateView = /**
         * @return {?}
         */
            function () {
                if (this.expand.expanded && this.container.length !== 0) {
                    return;
                }
                if (this.template) {
                    if (this.expand.expanded) {
                        // Should we pass a context? I don't see anything useful to pass right now,
                        // but we can come back to it in the future as a solution for additional features.
                        this.container.createEmbeddedView(this.template);
                    }
                    else {
                        // TODO: Move when we move the animation logic to Datagrid Row Expand
                        // We clear before the animation is over. Not ideal, but doing better would involve a much heavier
                        // process for very little gain. Once Angular animations are dynamic enough, we should be able to
                        // get the optimal behavior.
                        this.container.clear();
                    }
                }
                else {
                    try {
                        // If we don't have a template ref, we fallback to a crude display: none for now.
                        if (this.expand.expanded) {
                            this.renderer.setStyle(this.el.nativeElement, 'display', null);
                        }
                        else {
                            this.renderer.setStyle(this.el.nativeElement, 'display', 'none');
                        }
                    }
                    catch (e) {
                        // We catch the case where clrIfExpanded was put on a non-DOM element, and we just do nothing
                    }
                }
            };
        /**
         * @return {?}
         */
        ClrIfExpanded.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.updateView();
            };
        /**
         * @return {?}
         */
        ClrIfExpanded.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.expand.expandable--;
                this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrIfExpanded.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfExpanded]' },] }
        ];
        /** @nocollapse */
        ClrIfExpanded.ctorParameters = function () {
            return [
                { type: i0.TemplateRef, decorators: [{ type: i0.Optional }] },
                { type: i0.ViewContainerRef },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: Expand }
            ];
        };
        ClrIfExpanded.propDecorators = {
            expanded: [{ type: i0.Input, args: ['clrIfExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrIfExpandedChange',] }]
        };
        return ClrIfExpanded;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPAND_DIRECTIVES = [ClrIfExpanded];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfExpandModule = /** @class */ (function () {
        function ClrIfExpandModule() {
        }
        ClrIfExpandModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [EXPAND_DIRECTIVES], exports: [EXPAND_DIRECTIVES] },] }
        ];
        return ClrIfExpandModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_LOADING_DIRECTIVES = [ClrLoading];
    var ClrLoadingModule = /** @class */ (function () {
        function ClrLoadingModule() {
        }
        ClrLoadingModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CLR_LOADING_DIRECTIVES], exports: [CLR_LOADING_DIRECTIVES] },] }
        ];
        return ClrLoadingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var OutsideClick = /** @class */ (function () {
        function OutsideClick(el) {
            this.el = el;
            this.strict = false;
            this.outsideClick = new i0.EventEmitter(false);
        }
        /**
         * @param {?} event
         * @return {?}
         */
        OutsideClick.prototype.documentClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var target = event.target;
                // Get the element in the DOM on which the mouse was clicked
                /** @type {?} */
                var host = this.el.nativeElement;
                if (target === host) {
                    return;
                }
                if (!this.strict && host.contains(target)) {
                    return;
                }
                this.outsideClick.emit(event);
            };
        OutsideClick.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrOutsideClick]' },] }
        ];
        /** @nocollapse */
        OutsideClick.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        OutsideClick.propDecorators = {
            strict: [{ type: i0.Input, args: ['clrStrict',] }],
            outsideClick: [{ type: i0.Output, args: ['clrOutsideClick',] }],
            documentClick: [{ type: i0.HostListener, args: ['document:click', ['$event'],] }]
        };
        return OutsideClick;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var OUSTIDE_CLICK_DIRECTIVES = [OutsideClick];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrOutsideClickModule = /** @class */ (function () {
        function ClrOutsideClickModule() {
        }
        ClrOutsideClickModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [OUSTIDE_CLICK_DIRECTIVES], exports: [OUSTIDE_CLICK_DIRECTIVES] },] }
        ];
        return ClrOutsideClickModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DomAdapter = /** @class */ (function () {
        function DomAdapter() {
        }
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.userDefinedWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                element.classList.add('datagrid-cell-width-zero');
                /** @type {?} */
                var userDefinedWidth = this.clientRect(element).width;
                element.classList.remove('datagrid-cell-width-zero');
                return userDefinedWidth;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.scrollBarWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.offsetWidth - element.clientWidth;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.scrollWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.scrollWidth || 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.computedHeight = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return parseInt(getComputedStyle(element).getPropertyValue('height'), 10);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.clientRect = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                /** @type {?} */
                var elementClientRect = element.getBoundingClientRect();
                return {
                    top: parseInt(elementClientRect.top, 10),
                    bottom: parseInt(elementClientRect.bottom, 10),
                    left: parseInt(elementClientRect.left, 10),
                    right: parseInt(elementClientRect.right, 10),
                    width: parseInt(elementClientRect.width, 10),
                    height: parseInt(elementClientRect.height, 10),
                };
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.minWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return parseInt(getComputedStyle(element).getPropertyValue('min-width'), 10);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.focus = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                element.focus();
            };
        DomAdapter.decorators = [
            { type: i0.Injectable }
        ];
        return DomAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This class is used to convert an internal event
    // to an external event to be emitted.
    /**
     * @template T
     */
    var  
    // This class is used to convert an internal event
    // to an external event to be emitted.
    /**
     * @template T
     */
    ClrDragEvent = /** @class */ (function () {
        function ClrDragEvent(dragEvent) {
            this.dragPosition = dragEvent.dragPosition;
            this.group = dragEvent.group;
            this.dragDataTransfer = dragEvent.dragDataTransfer;
            this.dropPointPosition = dragEvent.dropPointPosition;
        }
        return ClrDragEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var DragEventType = {
        DRAG_START: 0,
        DRAG_MOVE: 1,
        DRAG_END: 2,
        DRAG_ENTER: 3,
        DRAG_LEAVE: 4,
        DROP: 5,
    };
    DragEventType[DragEventType.DRAG_START] = 'DRAG_START';
    DragEventType[DragEventType.DRAG_MOVE] = 'DRAG_MOVE';
    DragEventType[DragEventType.DRAG_END] = 'DRAG_END';
    DragEventType[DragEventType.DRAG_ENTER] = 'DRAG_ENTER';
    DragEventType[DragEventType.DRAG_LEAVE] = 'DRAG_LEAVE';
    DragEventType[DragEventType.DROP] = 'DROP';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DragAndDropEventBusService = /** @class */ (function () {
        function DragAndDropEventBusService() {
            this.dragStart = new rxjs.Subject();
            this.dragMove = new rxjs.Subject();
            this.dragEnd = new rxjs.Subject();
            this.drop = new rxjs.Subject();
        }
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragStarted", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragStart.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragMoved", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragMove.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragEnded", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragEnd.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dropped", {
            get: /**
             * @return {?}
             */ function () {
                return this.drop.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        DragAndDropEventBusService.prototype.broadcast = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.type) {
                    case DragEventType.DRAG_START:
                        this.dragStart.next(event);
                        break;
                    case DragEventType.DRAG_MOVE:
                        this.dragMove.next(event);
                        break;
                    case DragEventType.DRAG_END:
                        this.dragEnd.next(event);
                        break;
                    case DragEventType.DROP:
                        this.drop.next(event);
                        break;
                    default:
                        break;
                }
            };
        DragAndDropEventBusService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ DragAndDropEventBusService.ngInjectableDef = i0.defineInjectable({ factory: function DragAndDropEventBusService_Factory() { return new DragAndDropEventBusService(); }, token: DragAndDropEventBusService, providedIn: "root" });
        return DragAndDropEventBusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DragEventListenerService = /** @class */ (function () {
        function DragEventListenerService(ngZone, renderer, eventBus) {
            this.ngZone = ngZone;
            this.renderer = renderer;
            this.eventBus = eventBus;
            this.dragStart = new rxjs.Subject();
            this.dragMove = new rxjs.Subject();
            this.dragEnd = new rxjs.Subject();
            this.hasDragStarted = false;
        }
        Object.defineProperty(DragEventListenerService.prototype, "dragStarted", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragStart.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragEventListenerService.prototype, "dragMoved", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragMove.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragEventListenerService.prototype, "dragEnded", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragEnd.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} draggableEl
         * @return {?}
         */
        DragEventListenerService.prototype.attachDragListeners = /**
         * @param {?} draggableEl
         * @return {?}
         */
            function (draggableEl) {
                this.draggableEl = draggableEl;
                this.listeners = [
                    this.customDragEvent(this.draggableEl, 'mousedown', 'mousemove', 'mouseup'),
                    this.customDragEvent(this.draggableEl, 'touchstart', 'touchmove', 'touchend'),
                ];
            };
        /**
         * @return {?}
         */
        DragEventListenerService.prototype.detachDragListeners = /**
         * @return {?}
         */
            function () {
                if (this.listeners) {
                    this.listeners.map(function (event) { return event(); });
                }
                // In most cases, once users start dragging with mousedown/touchstart events,
                // they will end dragging at one point with mouseup/touchend.
                // However, there might be a few cases where mousedown/touchstart events get registered,
                // but the draggable element gets removed before user ends dragging.
                // In that case, we need to remove the attached listeners that happened during the mousedown/touchstart events.
                if (this.nestedListeners) {
                    this.nestedListeners.map(function (event) { return event(); });
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DragEventListenerService.prototype.getNativeEventObject = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if ((( /** @type {?} */(event))).hasOwnProperty('changedTouches')) {
                    return (( /** @type {?} */(event))).changedTouches[0];
                }
                else {
                    return event;
                }
            };
        /**
         * @param {?} element
         * @param {?} startOnEvent
         * @param {?} moveOnEvent
         * @param {?} endOnEvent
         * @return {?}
         */
        DragEventListenerService.prototype.customDragEvent = /**
         * @param {?} element
         * @param {?} startOnEvent
         * @param {?} moveOnEvent
         * @param {?} endOnEvent
         * @return {?}
         */
            function (element, startOnEvent, moveOnEvent, endOnEvent) {
                var _this = this;
                return this.renderer.listen(element, startOnEvent, function (startEvent) {
                    // save the initial point to initialPosition
                    // this will be used to calculate how far the draggable has been dragged from its initial position
                    _this.initialPosition = {
                        pageX: _this.getNativeEventObject(startEvent).pageX,
                        pageY: _this.getNativeEventObject(startEvent).pageY,
                    };
                    // Initialize nested listeners' property with a new empty array;
                    _this.nestedListeners = [];
                    // This is needed to disable selection during dragging (especially in EDGE/IE11).
                    _this.nestedListeners.push(_this.renderer.listen('document', 'selectstart', function (selectEvent) {
                        selectEvent.preventDefault();
                        selectEvent.stopImmediatePropagation();
                    }));
                    // Listen to mousemove/touchmove events outside of angular zone.
                    _this.nestedListeners.push(_this.ngZone.runOutsideAngular(function () {
                        return _this.renderer.listen('document', moveOnEvent, function (moveEvent) {
                            // Event.stopImmediatePropagation() is needed here to prevent nested draggables from getting dragged
                            // altogether. We shouldn't use Event.stopPropagation() here as we are listening to the events
                            // on the global element level.
                            // With Event.stopImmediatePropagation(), it registers the events sent from the inner most draggable
                            // first. Then immediately after that, it stops listening to the same type of events on the same
                            // element. So this will help us to not register the same events that would come from the parent
                            // level draggables eventually.
                            moveEvent.stopImmediatePropagation();
                            if (!_this.hasDragStarted) {
                                _this.hasDragStarted = true;
                                // Fire "dragstart"
                                _this.broadcast(moveEvent, DragEventType.DRAG_START);
                            }
                            else {
                                // Fire "dragmove"
                                _this.broadcast(moveEvent, DragEventType.DRAG_MOVE);
                            }
                        });
                    }));
                    // Listen to mouseup/touchend events.
                    _this.nestedListeners.push(_this.renderer.listen('document', endOnEvent, function (endEvent) {
                        if (_this.hasDragStarted) {
                            // Fire "dragend" only if dragstart is registered
                            _this.hasDragStarted = false;
                            _this.broadcast(endEvent, DragEventType.DRAG_END);
                        }
                        // We must remove the the nested listeners every time drag completes.
                        if (_this.nestedListeners) {
                            _this.nestedListeners.map(function (event) { return event(); });
                        }
                    }));
                });
            };
        /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
        DragEventListenerService.prototype.broadcast = /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
            function (event, eventType) {
                /** @type {?} */
                var dragEvent = this.generateDragEvent(event, eventType);
                switch (dragEvent.type) {
                    case DragEventType.DRAG_START:
                        this.dragStart.next(dragEvent);
                        break;
                    case DragEventType.DRAG_MOVE:
                        this.dragMove.next(dragEvent);
                        break;
                    case DragEventType.DRAG_END:
                        this.dragEnd.next(dragEvent);
                        break;
                    default:
                        break;
                }
                // The following properties are set after they are broadcasted to the DraggableGhost component.
                dragEvent.ghostElement = this.ghostElement;
                dragEvent.dropPointPosition = this.dropPointPosition;
                this.eventBus.broadcast(dragEvent);
            };
        /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
        DragEventListenerService.prototype.generateDragEvent = /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
            function (event, eventType) {
                /** @type {?} */
                var nativeEvent = this.getNativeEventObject(event);
                return {
                    type: eventType,
                    dragPosition: {
                        pageX: nativeEvent.pageX,
                        pageY: nativeEvent.pageY,
                        moveX: nativeEvent.pageX - this.initialPosition.pageX,
                        moveY: nativeEvent.pageY - this.initialPosition.pageY,
                    },
                    group: this.group,
                    dragDataTransfer: this.dragDataTransfer,
                    ghostElement: this.ghostElement,
                };
            };
        DragEventListenerService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DragEventListenerService.ctorParameters = function () {
            return [
                { type: i0.NgZone },
                { type: i0.Renderer2 },
                { type: DragAndDropEventBusService }
            ];
        };
        return DragEventListenerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This service is used to capture the state of clrDraggable element
    // at a certain event and passes it to clrDraggableGhost component.
    /**
     * @template T
     */
    var DraggableSnapshotService = /** @class */ (function () {
        function DraggableSnapshotService(domAdapter) {
            this.domAdapter = domAdapter;
        }
        /**
         * @param {?} el
         * @param {?} event
         * @return {?}
         */
        DraggableSnapshotService.prototype.capture = /**
         * @param {?} el
         * @param {?} event
         * @return {?}
         */
            function (el, event) {
                this.draggableElClientRect = this.domAdapter.clientRect(el);
                this.snapshotDragEvent = event;
            };
        /**
         * @return {?}
         */
        DraggableSnapshotService.prototype.discard = /**
         * @return {?}
         */
            function () {
                delete this.draggableElClientRect;
                delete this.snapshotDragEvent;
            };
        Object.defineProperty(DraggableSnapshotService.prototype, "hasDraggableState", {
            get: /**
             * @return {?}
             */ function () {
                return !!this.snapshotDragEvent && !!this.draggableElClientRect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DraggableSnapshotService.prototype, "clientRect", {
            get: /**
             * @return {?}
             */ function () {
                return this.draggableElClientRect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DraggableSnapshotService.prototype, "dragEvent", {
            get: /**
             * @return {?}
             */ function () {
                return this.snapshotDragEvent;
            },
            enumerable: true,
            configurable: true
        });
        DraggableSnapshotService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DraggableSnapshotService.ctorParameters = function () {
            return [
                { type: DomAdapter }
            ];
        };
        return DraggableSnapshotService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDraggableGhost = /** @class */ (function () {
        function ClrDraggableGhost(el, dragEventListener, draggableSnapshot, renderer, ngZone) {
            var _this = this;
            this.el = el;
            this.dragEventListener = dragEventListener;
            this.draggableSnapshot = draggableSnapshot;
            this.renderer = renderer;
            this.ngZone = ngZone;
            this.subscriptions = [];
            this.leaveAnimConfig = { value: 0, params: { top: '0px', left: '0px' } };
            if (!this.dragEventListener || !this.draggableSnapshot) {
                throw new Error('The clr-draggable-ghost component can only be used inside of a clrDraggable directive.');
            }
            this.draggableGhostEl = this.el.nativeElement;
            // Need to use Renderer2 as it runs outside of NgZone
            this.renderer.addClass(this.draggableGhostEl, 'draggable-ghost');
            // Register the ghost element in DragEventListener to pass in a ClrDragEvent.
            this.dragEventListener.ghostElement = this.draggableGhostEl;
            // Default ghost size gets the size of ClrDraggable element.
            this.setDefaultGhostSize(this.draggableGhostEl);
            /** @type {?} */
            var offset = {
                top: this.draggableSnapshot.hasDraggableState
                    ? this.draggableSnapshot.dragEvent.dragPosition.pageY - this.draggableSnapshot.clientRect.top
                    : 0,
                left: this.draggableSnapshot.hasDraggableState
                    ? this.draggableSnapshot.dragEvent.dragPosition.pageX - this.draggableSnapshot.clientRect.left
                    : 0,
            };
            /** @type {?} */
            var isAnimationConfigured = false;
            this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
                // On the first drag move event, we configure the animation as it's dependent on the first drag event.
                if (!isAnimationConfigured) {
                    if (_this.draggableSnapshot.hasDraggableState) {
                        _this.animateToOnLeave(_this.draggableSnapshot.clientRect.top + "px", _this.draggableSnapshot.clientRect.left + "px");
                    }
                    else {
                        _this.animateToOnLeave(event.dragPosition.pageY + "px", event.dragPosition.pageX + "px");
                    }
                    isAnimationConfigured = true;
                }
                // Position the draggable ghost.
                /** @type {?} */
                var topLeftPosition = _this.findTopLeftPosition(event.dragPosition, offset);
                _this.setPositionStyle(_this.draggableGhostEl, topLeftPosition.pageX, topLeftPosition.pageY);
                _this.dragEventListener.dropPointPosition = _this.findDropPointPosition(topLeftPosition);
            }));
        }
        /**
         * @param {?} el
         * @return {?}
         */
        ClrDraggableGhost.prototype.setDefaultGhostSize = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this.draggableSnapshot.hasDraggableState) {
                    this.setSizeStyle(el, this.draggableSnapshot.clientRect.width, this.draggableSnapshot.clientRect.height);
                }
            };
        /**
         * @param {?} top
         * @param {?} left
         * @return {?}
         */
        ClrDraggableGhost.prototype.animateToOnLeave = /**
         * @param {?} top
         * @param {?} left
         * @return {?}
         */
            function (top, left) {
                var _this = this;
                this.ngZone.run(function () {
                    _this.leaveAnimConfig = { value: 0, params: { top: top, left: left } };
                });
            };
        /**
         * @param {?} dragPosition
         * @param {?} offset
         * @return {?}
         */
        ClrDraggableGhost.prototype.findTopLeftPosition = /**
         * @param {?} dragPosition
         * @param {?} offset
         * @return {?}
         */
            function (dragPosition, offset) {
                return { pageX: dragPosition.pageX - offset.left, pageY: dragPosition.pageY - offset.top };
            };
        /**
         * @param {?} topLeftPosition
         * @return {?}
         */
        ClrDraggableGhost.prototype.findDropPointPosition = /**
         * @param {?} topLeftPosition
         * @return {?}
         */
            function (topLeftPosition) {
                if (this.draggableSnapshot.hasDraggableState) {
                    return {
                        pageX: topLeftPosition.pageX + this.draggableSnapshot.clientRect.width / 2,
                        pageY: topLeftPosition.pageY + this.draggableSnapshot.clientRect.height / 2,
                    };
                }
                else {
                    return topLeftPosition;
                }
            };
        /**
         * @param {?} el
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        ClrDraggableGhost.prototype.setSizeStyle = /**
         * @param {?} el
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (el, width, height) {
                this.renderer.setStyle(el, 'width', width + "px");
                this.renderer.setStyle(el, 'height', height + "px");
            };
        /**
         * @param {?} el
         * @param {?} left
         * @param {?} top
         * @return {?}
         */
        ClrDraggableGhost.prototype.setPositionStyle = /**
         * @param {?} el
         * @param {?} left
         * @param {?} top
         * @return {?}
         */
            function (el, left, top) {
                this.renderer.setStyle(el, 'left', left + "px");
                this.renderer.setStyle(el, 'top', top + "px");
                this.renderer.setStyle(el, 'visibility', 'visible');
            };
        /**
         * @return {?}
         */
        ClrDraggableGhost.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDraggableGhost.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-draggable-ghost',
                        template: "<ng-content></ng-content>",
                        animations: [
                            animations.trigger('leaveAnimation', [
                                animations.transition(':leave', [
                                    animations.style({ left: '*', top: '*' }),
                                    animations.animate('0.2s ease-in-out', animations.style({ top: '{{top}}', left: '{{left}}' })),
                                ]),
                            ]),
                        ]
                    }] }
        ];
        /** @nocollapse */
        ClrDraggableGhost.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragEventListenerService, decorators: [{ type: i0.Optional }] },
                { type: DraggableSnapshotService, decorators: [{ type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.NgZone }
            ];
        };
        ClrDraggableGhost.propDecorators = {
            leaveAnimConfig: [{ type: i0.HostBinding, args: ['@leaveAnimation',] }]
        };
        return ClrDraggableGhost;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This structural directive will be used mainly together with `clr-draggable-ghost` directive inside of clrDraggable
    // directive. The directive is responsible for instantiating `clr-draggable-ghost` directive only during dragging so
    // that Angular Change Detection is prevented from running if a component or directive is placed inside of the
    // `clr-draggable-ghost` directive.
    /**
     * @template T
     */
    var ClrIfDragged = /** @class */ (function () {
        function ClrIfDragged(template, container, dragEventListener) {
            var _this = this;
            this.template = template;
            this.container = container;
            this.dragEventListener = dragEventListener;
            this.subscriptions = [];
            if (!this.dragEventListener || !this.container) {
                throw new Error('The *clrIfDragged directive can only be used inside of a clrDraggable directive.');
            }
            this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
                _this.container.createEmbeddedView(_this.template);
            }));
            this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
                _this.container.clear();
            }));
        }
        /**
         * @return {?}
         */
        ClrIfDragged.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrIfDragged.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfDragged]' },] }
        ];
        /** @nocollapse */
        ClrIfDragged.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
                { type: DragEventListenerService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return ClrIfDragged;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This provider registers the drag handle element.
    // When it registers a element as a drag handle, it attaches that element to the listeners from ClrDragEventListener.
    // Also, it adds the "drag-handle" css class to the registered element through Renderer.
    /**
     * @template T
     */
    var DragHandleRegistrarService = /** @class */ (function () {
        function DragHandleRegistrarService(dragEventListener, renderer) {
            this.dragEventListener = dragEventListener;
            this.renderer = renderer;
        }
        Object.defineProperty(DragHandleRegistrarService.prototype, "defaultHandleEl", {
            get: /**
             * @return {?}
             */ function () {
                return this._defaultHandleEl;
            },
            set: /**
             * @param {?} el
             * @return {?}
             */ function (el) {
                this._defaultHandleEl = el; // defaultHandleEl will be usually the clrDraggable element.
                // If the customHandleEl has been registered,
                // don't make the defaultHandleEl the drag handle yet until the customHandleEl is unregistered.
                if (!this._customHandleEl) {
                    this.makeElementHandle(this._defaultHandleEl);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} el
         * @return {?}
         */
        DragHandleRegistrarService.prototype.makeElementHandle = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this._defaultHandleEl && this._defaultHandleEl !== el) {
                    // Before making an element the custom handle element,
                    // we should remove the existing drag-handle class from the draggable element.
                    this.renderer.removeClass(this._defaultHandleEl, 'drag-handle');
                }
                this.dragEventListener.attachDragListeners(el);
                this.renderer.addClass(el, 'drag-handle');
            };
        Object.defineProperty(DragHandleRegistrarService.prototype, "customHandleEl", {
            get: /**
             * @return {?}
             */ function () {
                return this._customHandleEl;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} el
         * @return {?}
         */
        DragHandleRegistrarService.prototype.registerCustomHandle = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                this.dragEventListener.detachDragListeners(); // removes the existing listeners
                this._customHandleEl = el;
                this.makeElementHandle(this._customHandleEl);
            };
        /**
         * @return {?}
         */
        DragHandleRegistrarService.prototype.unregisterCustomHandle = /**
         * @return {?}
         */
            function () {
                this.dragEventListener.detachDragListeners(); // removes the existing listeners
                this.renderer.removeClass(this._customHandleEl, 'drag-handle');
                delete this._customHandleEl;
                // if default handle is set, make that handle
                if (this._defaultHandleEl) {
                    this.makeElementHandle(this._defaultHandleEl);
                }
            };
        DragHandleRegistrarService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DragHandleRegistrarService.ctorParameters = function () {
            return [
                { type: DragEventListenerService },
                { type: i0.Renderer2 }
            ];
        };
        return DragHandleRegistrarService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This service class adds and removes the "in-drag" class to the document body element
    // through its public enter() and exit() methods.
    var GlobalDragModeService = /** @class */ (function () {
        function GlobalDragModeService(renderer) {
            this.renderer = renderer;
        }
        /**
         * @return {?}
         */
        GlobalDragModeService.prototype.enter = /**
         * @return {?}
         */
            function () {
                this.renderer.addClass(document.body, 'in-drag');
            };
        /**
         * @return {?}
         */
        GlobalDragModeService.prototype.exit = /**
         * @return {?}
         */
            function () {
                this.renderer.removeClass(document.body, 'in-drag');
            };
        GlobalDragModeService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        GlobalDragModeService.ctorParameters = function () {
            return [
                { type: i0.Renderer2 }
            ];
        };
        return GlobalDragModeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDraggable = /** @class */ (function () {
        function ClrDraggable(el, dragEventListener, dragHandleRegistrar, viewContainerRef, cfr, injector, draggableSnapshot, globalDragMode) {
            this.el = el;
            this.dragEventListener = dragEventListener;
            this.dragHandleRegistrar = dragHandleRegistrar;
            this.viewContainerRef = viewContainerRef;
            this.cfr = cfr;
            this.injector = injector;
            this.draggableSnapshot = draggableSnapshot;
            this.globalDragMode = globalDragMode;
            this.subscriptions = [];
            this.dragOn = false;
            this.dragStartEmitter = new i0.EventEmitter();
            this.dragMoveEmitter = new i0.EventEmitter();
            this.dragEndEmitter = new i0.EventEmitter();
            this.draggableEl = this.el.nativeElement;
            this.componentFactory = this.cfr.resolveComponentFactory(ClrDraggableGhost);
        }
        Object.defineProperty(ClrDraggable.prototype, "dataTransfer", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.dragEventListener.dragDataTransfer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDraggable.prototype, "group", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.dragEventListener.group = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        ClrDraggable.prototype.createDefaultGhost = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.draggableSnapshot.capture(this.draggableEl, event);
                // NOTE: The default ghost element will appear
                // next to the clrDraggable in the DOM as a sibling element.
                this.viewContainerRef.createComponent(this.componentFactory, 0, this.injector, [
                    [this.draggableEl.cloneNode(true)],
                ]);
            };
        /**
         * @return {?}
         */
        ClrDraggable.prototype.destroyDefaultGhost = /**
         * @return {?}
         */
            function () {
                this.viewContainerRef.clear();
                this.draggableSnapshot.discard();
            };
        /**
         * @return {?}
         */
        ClrDraggable.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.dragHandleRegistrar.defaultHandleEl = this.draggableEl;
                this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
                    _this.globalDragMode.enter();
                    _this.dragOn = true;
                    if (!_this.customGhost) {
                        _this.createDefaultGhost(event);
                    }
                    _this.dragStartEmitter.emit(new ClrDragEvent(event));
                }));
                this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
                    _this.dragMoveEmitter.emit(new ClrDragEvent(event));
                }));
                this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
                    _this.globalDragMode.exit();
                    _this.dragOn = false;
                    if (!_this.customGhost) {
                        _this.destroyDefaultGhost();
                    }
                    _this.dragEndEmitter.emit(new ClrDragEvent(event));
                }));
            };
        /**
         * @return {?}
         */
        ClrDraggable.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
                this.dragEventListener.detachDragListeners();
            };
        ClrDraggable.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDraggable]',
                        providers: [
                            DragEventListenerService,
                            DragHandleRegistrarService,
                            DraggableSnapshotService,
                            GlobalDragModeService,
                            DomAdapter,
                        ],
                        host: { '[class.draggable]': 'true', '[class.being-dragged]': 'dragOn' },
                    },] }
        ];
        /** @nocollapse */
        ClrDraggable.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragEventListenerService },
                { type: DragHandleRegistrarService },
                { type: i0.ViewContainerRef },
                { type: i0.ComponentFactoryResolver },
                { type: i0.Injector },
                { type: DraggableSnapshotService },
                { type: GlobalDragModeService }
            ];
        };
        ClrDraggable.propDecorators = {
            customGhost: [{ type: i0.ContentChild, args: [ClrIfDragged,] }],
            dataTransfer: [{ type: i0.Input, args: ['clrDraggable',] }],
            group: [{ type: i0.Input, args: ['clrGroup',] }],
            dragStartEmitter: [{ type: i0.Output, args: ['clrDragStart',] }],
            dragMoveEmitter: [{ type: i0.Output, args: ['clrDragMove',] }],
            dragEndEmitter: [{ type: i0.Output, args: ['clrDragEnd',] }]
        };
        return ClrDraggable;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDroppable = /** @class */ (function () {
        function ClrDroppable(el, eventBus, domAdapter, renderer) {
            this.el = el;
            this.eventBus = eventBus;
            this.domAdapter = domAdapter;
            this.renderer = renderer;
            this.isDraggableMatch = false;
            this._isDraggableOver = false;
            this._dropTolerance = { top: 0, right: 0, bottom: 0, left: 0 };
            this.dragStartEmitter = new i0.EventEmitter();
            this.dragMoveEmitter = new i0.EventEmitter();
            this.dragEndEmitter = new i0.EventEmitter();
            this.dragLeaveEmitter = new i0.EventEmitter();
            this.dragEnterEmitter = new i0.EventEmitter();
            this.dropEmitter = new i0.EventEmitter();
            this.droppableEl = this.el.nativeElement;
        }
        Object.defineProperty(ClrDroppable.prototype, "isDraggableOver", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // We need to add/remove this draggable-over class via Renderer2
                // because isDraggableOver is set outside of NgZone.
                if (value) {
                    this.renderer.addClass(this.droppableEl, 'draggable-over');
                }
                else {
                    this.renderer.removeClass(this.droppableEl, 'draggable-over');
                }
                this._isDraggableOver = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDroppable.prototype, "group", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._group = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?=} top
         * @param {?=} right
         * @param {?=} bottom
         * @param {?=} left
         * @return {?}
         */
        ClrDroppable.prototype.dropToleranceGenerator = /**
         * @param {?=} top
         * @param {?=} right
         * @param {?=} bottom
         * @param {?=} left
         * @return {?}
         */
            function (top, right, bottom, left) {
                if (top === void 0) {
                    top = 0;
                }
                if (right === void 0) {
                    right = top;
                }
                if (bottom === void 0) {
                    bottom = top;
                }
                if (left === void 0) {
                    left = right;
                }
                return { top: top, right: right, bottom: bottom, left: left };
            };
        Object.defineProperty(ClrDroppable.prototype, "dropTolerance", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // If user provides an object here and wants to manipulate/update properties individually,
                // the object must be immutable as we generate new object based user's given object.
                if (typeof value === 'number') {
                    this._dropTolerance = this.dropToleranceGenerator(value);
                }
                else if (typeof value === 'string') {
                    /** @type {?} */
                    var toleranceValues = value
                        .trim()
                        .split(/\s+/)
                        .map(function (tolerance) { return parseInt(tolerance, 10); });
                    this._dropTolerance = this.dropToleranceGenerator.apply(this, __spread(toleranceValues));
                }
                else if (value) {
                    // The value could be passed in as {left: 20, top: 30 }
                    // In this case, the rest of the direction properties should be 0.
                    // That's why we initialize properties with 0 first, then override with user's given value.
                    this._dropTolerance = __assign({}, this.dropToleranceGenerator(0), value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} subscription
         * @return {?}
         */
        ClrDroppable.prototype.unsubscribeFrom = /**
         * @param {?} subscription
         * @return {?}
         */
            function (subscription) {
                if (subscription) {
                    subscription.unsubscribe();
                }
            };
        /**
         * @param {?} draggableGroup
         * @return {?}
         */
        ClrDroppable.prototype.checkGroupMatch = /**
         * @param {?} draggableGroup
         * @return {?}
         */
            function (draggableGroup) {
                // Both Draggable and Droppable have clrGroup input.
                // The clrGroup input can be both a string key or array of string keys in Draggable and Droppable.
                // It's not match if Draggable has no defined value assigned to clrGroup, but Droppable has a defined clrGroup.
                if (!draggableGroup && this._group) {
                    return false;
                }
                // The same is true the other way round.
                if (!this._group && draggableGroup) {
                    return false;
                }
                // It's match if both Draggable and Droppable have no assigned value for clrGroup.
                if (!this._group && !draggableGroup) {
                    return true;
                }
                // It's match if both Draggable and Droppable have simple string keys that are matching.
                // It's match if Draggable's simple clrGroup key is matching with one of the clrGroup keys of Droppable. The
                // same is true the other way round.
                // it's match if one of the clrGroup keys of Droppable is matching with one of the clrGroup keys of Draggable.
                if (typeof draggableGroup === 'string') {
                    if (typeof this._group === 'string') {
                        return this._group === draggableGroup;
                    }
                    else {
                        return this._group.indexOf(draggableGroup) > -1;
                    }
                }
                else {
                    if (typeof this._group === 'string') {
                        return draggableGroup.indexOf(this._group) > -1;
                    }
                    else {
                        return (( /** @type {?} */(this._group))).some(function (groupKey) { return draggableGroup.indexOf(groupKey) > -1; });
                    }
                }
            };
        /**
         * @param {?} point
         * @return {?}
         */
        ClrDroppable.prototype.isInDropArea = /**
         * @param {?} point
         * @return {?}
         */
            function (point) {
                if (!point) {
                    return false;
                }
                if (!this.clientRect) {
                    this.clientRect = this.domAdapter.clientRect(this.droppableEl);
                }
                if (point.pageX >= this.clientRect.left - this._dropTolerance.left &&
                    point.pageX <= this.clientRect.right + this._dropTolerance.right &&
                    point.pageY >= this.clientRect.top - this._dropTolerance.top &&
                    point.pageY <= this.clientRect.bottom + this._dropTolerance.bottom) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @param {?} dragStartEvent
         * @return {?}
         */
        ClrDroppable.prototype.onDragStart = /**
         * @param {?} dragStartEvent
         * @return {?}
         */
            function (dragStartEvent) {
                var _this = this;
                // Check draggable and droppable have a matching group key.
                this.isDraggableMatch = this.checkGroupMatch(dragStartEvent.group);
                // Subscribe to dragMoved and dragEnded only if draggable and droppable have a matching group key.
                if (this.isDraggableMatch) {
                    this.dragStartEmitter.emit(new ClrDragEvent(dragStartEvent));
                    this.dragMoveSubscription = this.eventBus.dragMoved.subscribe(function (dragMoveEvent) {
                        _this.onDragMove(dragMoveEvent);
                    });
                    this.dragEndSubscription = this.eventBus.dragEnded.subscribe(function (dragEndEvent) {
                        _this.onDragEnd(dragEndEvent);
                    });
                }
            };
        /**
         * @param {?} dragMoveEvent
         * @return {?}
         */
        ClrDroppable.prototype.onDragMove = /**
         * @param {?} dragMoveEvent
         * @return {?}
         */
            function (dragMoveEvent) {
                /** @type {?} */
                var isInDropArea = this.isInDropArea(dragMoveEvent.dropPointPosition);
                if (!this._isDraggableOver && isInDropArea) {
                    this.isDraggableOver = true;
                    /** @type {?} */
                    var dragEnterEvent = __assign({}, dragMoveEvent, { type: DragEventType.DRAG_ENTER });
                    this.eventBus.broadcast(dragEnterEvent);
                    this.dragEnterEmitter.emit(new ClrDragEvent(dragEnterEvent));
                }
                else if (this._isDraggableOver && !isInDropArea) {
                    this.isDraggableOver = false;
                    /** @type {?} */
                    var dragLeaveEvent = __assign({}, dragMoveEvent, { type: DragEventType.DRAG_LEAVE });
                    this.eventBus.broadcast(dragLeaveEvent);
                    this.dragLeaveEmitter.emit(new ClrDragEvent(dragLeaveEvent));
                }
                this.dragMoveEmitter.emit(new ClrDragEvent(dragMoveEvent));
            };
        /**
         * @param {?} dragEndEvent
         * @return {?}
         */
        ClrDroppable.prototype.onDragEnd = /**
         * @param {?} dragEndEvent
         * @return {?}
         */
            function (dragEndEvent) {
                if (this._isDraggableOver) {
                    if (dragEndEvent.ghostElement) {
                        // By this point, the draggable ghost component is destroyed,
                        // but the element would be active until its animation completes.
                        // As such, once the ghost is dropped over, we will give it "dropped" class.
                        // This process cannot be done in the ghost component
                        // because any subscription to the drop event is ineffective or invalid
                        // as the component had been already destroyed.
                        this.renderer.addClass(dragEndEvent.ghostElement, 'dropped');
                    }
                    /** @type {?} */
                    var dropEvent = __assign({}, dragEndEvent, { type: DragEventType.DROP });
                    this.eventBus.broadcast(dropEvent);
                    this.dropEmitter.emit(new ClrDragEvent(dropEvent));
                    this.isDraggableOver = false;
                }
                this.dragEndEmitter.emit(new ClrDragEvent(dragEndEvent));
                this.unsubscribeFrom(this.dragMoveSubscription);
                this.unsubscribeFrom(this.dragEndSubscription);
                this.isDraggableMatch = false;
                delete this.clientRect;
            };
        /**
         * @return {?}
         */
        ClrDroppable.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.dragStartSubscription = this.eventBus.dragStarted.subscribe(function (dragStartEvent) {
                    _this.onDragStart(dragStartEvent);
                });
            };
        /**
         * @return {?}
         */
        ClrDroppable.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.unsubscribeFrom(this.dragStartSubscription);
                this.unsubscribeFrom(this.dragMoveSubscription);
                this.unsubscribeFrom(this.dragEndSubscription);
            };
        ClrDroppable.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDroppable]',
                        providers: [DomAdapter],
                        host: { '[class.droppable]': 'true', '[class.draggable-match]': 'isDraggableMatch' },
                    },] }
        ];
        /** @nocollapse */
        ClrDroppable.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragAndDropEventBusService },
                { type: DomAdapter },
                { type: i0.Renderer2 }
            ];
        };
        ClrDroppable.propDecorators = {
            group: [{ type: i0.Input, args: ['clrGroup',] }],
            dropTolerance: [{ type: i0.Input, args: ['clrDropTolerance',] }],
            dragStartEmitter: [{ type: i0.Output, args: ['clrDragStart',] }],
            dragMoveEmitter: [{ type: i0.Output, args: ['clrDragMove',] }],
            dragEndEmitter: [{ type: i0.Output, args: ['clrDragEnd',] }],
            dragLeaveEmitter: [{ type: i0.Output, args: ['clrDragLeave',] }],
            dragEnterEmitter: [{ type: i0.Output, args: ['clrDragEnter',] }],
            dropEmitter: [{ type: i0.Output, args: ['clrDrop',] }]
        };
        return ClrDroppable;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDragHandle = /** @class */ (function () {
        function ClrDragHandle(el, dragHandleRegistrar) {
            this.el = el;
            this.dragHandleRegistrar = dragHandleRegistrar;
            if (!this.dragHandleRegistrar) {
                // ClrDragHandleRegistrar is provided in ClrDraggable so we expect it to be present here
                // as clrDragHandle is required to be used only inside of a clrDraggable directive.
                throw new Error('The clrDragHandle directive can only be used inside of a clrDraggable directive.');
            }
            this.dragHandleRegistrar.registerCustomHandle(this.el.nativeElement);
        }
        /**
         * @return {?}
         */
        ClrDragHandle.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.dragHandleRegistrar.unregisterCustomHandle();
            };
        ClrDragHandle.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrDragHandle]', host: { '[class.drag-handle]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrDragHandle.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragHandleRegistrarService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return ClrDragHandle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DRAG_AND_DROP_DIRECTIVES = [
        ClrDraggable,
        ClrDroppable,
        ClrIfDragged,
        ClrDragHandle,
        ClrDraggableGhost,
    ];
    var ClrDragAndDropModule = /** @class */ (function () {
        function ClrDragAndDropModule() {
        }
        ClrDragAndDropModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [CLR_DRAG_AND_DROP_DIRECTIVES],
                        entryComponents: [ClrDraggableGhost],
                        exports: [CLR_DRAG_AND_DROP_DIRECTIVES],
                    },] }
        ];
        return ClrDragAndDropModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function isBooleanAttributeSet(value) {
        // for null just return false no need to check anything
        if (value === null) {
            return false;
        }
        if (typeof value === 'string') {
            // Empty string is valid, 'true' as string is also valid
            return value.length >= 0;
        }
        // Boolean value will be read as it is, everything else is false
        return typeof value === 'boolean' ? value : false;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSpinner = /** @class */ (function () {
        function ClrSpinner() {
        }
        Object.defineProperty(ClrSpinner.prototype, "spinnerClass", {
            /**
             * Default class for all spinners. This class is always true
             */
            get: /**
             * Default class for all spinners. This class is always true
             * @return {?}
             */ function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "inlineClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._inline;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrInline", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._inline = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "inverseClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._inverse;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrInverse", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._inverse = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "smallClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._small;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrSmall", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._small = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "mediumClass", {
            get: /**
             * @return {?}
             */ function () {
                if (this._small) {
                    return false;
                }
                return this._medium;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrMedium", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._medium = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "setAriaLive", {
            get: /**
             * @return {?}
             */ function () {
                if (isBooleanAttributeSet(this.assertive)) {
                    return 'assertive';
                }
                if (isBooleanAttributeSet(this.off)) {
                    return 'off';
                }
                return 'polite';
            },
            enumerable: true,
            configurable: true
        });
        ClrSpinner.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-spinner',
                        template: "\n    <ng-content></ng-content>\n  ",
                        host: {
                            '[attr.aria-live]': 'setAriaLive',
                            '[attr.aria-busy]': 'true',
                        }
                    }] }
        ];
        ClrSpinner.propDecorators = {
            spinnerClass: [{ type: i0.HostBinding, args: ['class.spinner',] }],
            inlineClass: [{ type: i0.HostBinding, args: ['class.spinner-inline',] }],
            clrInline: [{ type: i0.Input, args: ['clrInline',] }],
            inverseClass: [{ type: i0.HostBinding, args: ['class.spinner-inverse',] }],
            clrInverse: [{ type: i0.Input, args: ['clrInverse',] }],
            smallClass: [{ type: i0.HostBinding, args: ['class.spinner-sm',] }],
            clrSmall: [{ type: i0.Input, args: ['clrSmall',] }],
            mediumClass: [{ type: i0.HostBinding, args: ['class.spinner-md',] }],
            clrMedium: [{ type: i0.Input, args: ['clrMedium',] }],
            assertive: [{ type: i0.Input, args: ['clrAssertive',] }],
            off: [{ type: i0.Input, args: ['clrOff',] }]
        };
        return ClrSpinner;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_SPINNER_DIRECTIVES = [ClrSpinner];
    var ClrSpinnerModule = /** @class */ (function () {
        function ClrSpinnerModule() {
        }
        ClrSpinnerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [CLR_SPINNER_DIRECTIVES],
                        exports: [CLR_SPINNER_DIRECTIVES],
                    },] }
        ];
        return ClrSpinnerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridRowExpandAnimation = /** @class */ (function () {
        function DatagridRowExpandAnimation(el, domAdapter, renderer, expand) {
            var _this = this;
            this.el = el;
            this.domAdapter = domAdapter;
            this.renderer = renderer;
            this.expand = expand;
            if (expand && expand.animate) {
                expand.animate.subscribe(function () {
                    // We already had an animation waiting, so we just have to run in, not prepare again
                    if (_this.oldHeight) {
                        setTimeout(function () { return _this.run(); });
                    }
                    else {
                        _this.animate();
                    }
                });
            }
        }
        /*
           * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
           * They're working on it, but have no ETA.
           */
        /*
             * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
             * They're working on it, but have no ETA.
             */
        /**
         * @return {?}
         */
        DatagridRowExpandAnimation.prototype.animate = /*
             * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
             * They're working on it, but have no ETA.
             */
            /**
             * @return {?}
             */
            function () {
                var _this = this;
                // Check if we do have web-animations available. If not, just skip the animation.
                if (!this.el.nativeElement.animate) {
                    return;
                }
                // We had an animation running, we skip to the end
                if (this.running) {
                    this.running.finish();
                }
                this.oldHeight = this.domAdapter.computedHeight(this.el.nativeElement);
                // In case height has not yet been set. When starting expanded, for example.
                // See https://github.com/vmware/clarity/issues/2904
                if (isNaN(this.oldHeight)) {
                    this.oldHeight = 0;
                }
                // We set the height of the element immediately to avoid a flicker before the animation starts.
                this.renderer.setStyle(this.el.nativeElement, 'height', this.oldHeight + 'px');
                this.renderer.setStyle(this.el.nativeElement, 'overflow-y', 'hidden');
                setTimeout(function () {
                    if (_this.expand.loading) {
                        return;
                    }
                    _this.run();
                });
            };
        /**
         * @return {?}
         */
        DatagridRowExpandAnimation.prototype.run = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.renderer.setStyle(this.el.nativeElement, 'height', null);
                /** @type {?} */
                var newHeight = this.domAdapter.computedHeight(this.el.nativeElement);
                this.running = this.el.nativeElement.animate({ height: [this.oldHeight + 'px', newHeight + 'px'], easing: 'ease-in-out' }, { duration: 200 });
                this.running.onfinish = function () {
                    _this.renderer.setStyle(_this.el.nativeElement, 'overflow-y', null);
                    delete _this.running;
                };
                delete this.oldHeight;
            };
        DatagridRowExpandAnimation.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-row' },] }
        ];
        /** @nocollapse */
        DatagridRowExpandAnimation.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DomAdapter },
                { type: i0.Renderer2 },
                { type: Expand }
            ];
        };
        return DatagridRowExpandAnimation;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * @abstract
     */
    var  /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */ 
    /**
     * @abstract
     */
    CustomFilter = /** @class */ (function () {
        function CustomFilter() {
        }
        return CustomFilter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * This provider implements some form of synchronous debouncing through a lock pattern
     * to avoid emitting multiple state changes for a single user action.
     */
    var StateDebouncer = /** @class */ (function () {
        function StateDebouncer() {
            /**
             * The Observable that lets other classes subscribe to global state changes
             */
            this._change = new rxjs.Subject();
            /*
                 * This is the lock, to only emit once all the changes have finished processing
                 */
            this.nbChanges = 0;
        }
        Object.defineProperty(StateDebouncer.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        StateDebouncer.prototype.changeStart = /**
         * @return {?}
         */
            function () {
                this.nbChanges++;
            };
        /**
         * @return {?}
         */
        StateDebouncer.prototype.changeDone = /**
         * @return {?}
         */
            function () {
                if (--this.nbChanges === 0) {
                    this._change.next();
                }
            };
        StateDebouncer.decorators = [
            { type: i0.Injectable }
        ];
        return StateDebouncer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Page = /** @class */ (function () {
        function Page(stateDebouncer) {
            this.stateDebouncer = stateDebouncer;
            this.activated = false;
            /**
             * Page size, a value of 0 means no pagination
             */
            this._size = 0;
            /**
             * Total items (needed to guess the last page)
             */
            this._totalItems = 0;
            /**
             * The Observable that lets other classes subscribe to page changes
             */
            this._change = new rxjs.Subject();
            this._sizeChange = new rxjs.Subject();
            /**
             * Current page
             */
            this._current = 1;
        }
        Object.defineProperty(Page.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return this._size;
            },
            set: /**
             * @param {?} size
             * @return {?}
             */ function (size) {
                /** @type {?} */
                var oldSize = this._size;
                if (size !== oldSize) {
                    this.stateDebouncer.changeStart();
                    this._size = size;
                    if (size === 0) {
                        this._current = 1;
                    }
                    else {
                        // Yeap. That's the formula to keep the first item from the old page still
                        // displayed in the new one.
                        this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
                    }
                    // We always emit an event even if the current page index didn't change, because
                    // the size changing means the items inside the page are different
                    this._change.next(this._current);
                    this._sizeChange.next(this._size);
                    this.stateDebouncer.changeDone();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "totalItems", {
            get: /**
             * @return {?}
             */ function () {
                return this._totalItems;
            },
            set: /**
             * @param {?} total
             * @return {?}
             */ function (total) {
                this._totalItems = total;
                // If we have less items than before, we might need to change the current page
                if (this.current > this.last) {
                    this.current = this.last;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "last", {
            get: /**
             * @return {?}
             */ function () {
                if (this._last) {
                    return this._last;
                }
                // If the last page isn't known, we compute it from the last item's index
                if (this.size > 0 && this.totalItems) {
                    return Math.ceil(this.totalItems / this.size);
                }
                return 1;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                this._last = page;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "sizeChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._sizeChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                if (page !== this._current) {
                    this.stateDebouncer.changeStart();
                    this._current = page;
                    this._change.next(page);
                    this.stateDebouncer.changeDone();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Moves to the previous page if it exists
         */
        /**
         * Moves to the previous page if it exists
         * @return {?}
         */
        Page.prototype.previous = /**
         * Moves to the previous page if it exists
         * @return {?}
         */
            function () {
                if (this.current > 1) {
                    this.current--;
                }
            };
        /**
         * Moves to the next page if it exists
         */
        /**
         * Moves to the next page if it exists
         * @return {?}
         */
        Page.prototype.next = /**
         * Moves to the next page if it exists
         * @return {?}
         */
            function () {
                if (this.current < this.last) {
                    this.current++;
                }
            };
        Object.defineProperty(Page.prototype, "firstItem", {
            /**
             * Index of the first item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the first item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                if (this.size === 0) {
                    return 0;
                }
                return (this.current - 1) * this.size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "lastItem", {
            /**
             * Index of the last item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the last item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                if (this.size === 0) {
                    return this.totalItems - 1;
                }
                /** @type {?} */
                var lastInPage = this.current * this.size - 1;
                if (this.totalItems) {
                    lastInPage = Math.min(lastInPage, this.totalItems - 1);
                }
                return lastInPage;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Resets the page size to 0
         */
        /**
         * Resets the page size to 0
         * @return {?}
         */
        Page.prototype.resetPageSize = /**
         * Resets the page size to 0
         * @return {?}
         */
            function () {
                this.size = 0;
            };
        Page.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Page.ctorParameters = function () {
            return [
                { type: StateDebouncer }
            ];
        };
        return Page;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var FiltersProvider = /** @class */ (function () {
        function FiltersProvider(_page, stateDebouncer) {
            this._page = _page;
            this.stateDebouncer = stateDebouncer;
            /**
             * This subject is the list of filters that changed last, not the whole list.
             * We emit a list rather than just one filter to allow batch changes to several at once.
             */
            this._change = new rxjs.Subject();
            /**
             * List of all filters, whether they're active or not
             */
            this._all = [];
        }
        Object.defineProperty(FiltersProvider.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Tests if at least one filter is currently active
         */
        /**
         * Tests if at least one filter is currently active
         * @return {?}
         */
        FiltersProvider.prototype.hasActiveFilters = /**
         * Tests if at least one filter is currently active
         * @return {?}
         */
            function () {
                var e_1, _a;
                try {
                    // We do not use getActiveFilters() because this function will be called much more often
                    // and stopping the loop early might be relevant.
                    for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var filter = _c.value.filter;
                        if (filter && filter.isActive()) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return false;
            };
        /**
         * Returns a list of all currently active filters
         */
        /**
         * Returns a list of all currently active filters
         * @return {?}
         */
        FiltersProvider.prototype.getActiveFilters = /**
         * Returns a list of all currently active filters
         * @return {?}
         */
            function () {
                var e_2, _a;
                /** @type {?} */
                var ret = [];
                try {
                    for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var filter = _c.value.filter;
                        if (filter && filter.isActive()) {
                            ret.push(filter);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                return ret;
            };
        /**
         * Registers a filter, and returns a deregistration function
         */
        /**
         * Registers a filter, and returns a deregistration function
         * @template F
         * @param {?} filter
         * @return {?}
         */
        FiltersProvider.prototype.add = /**
         * Registers a filter, and returns a deregistration function
         * @template F
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                var _this = this;
                /** @type {?} */
                var index = this._all.length;
                /** @type {?} */
                var subscription = filter.changes.subscribe(function () { return _this.resetPageAndEmitFilterChange([filter]); });
                /** @type {?} */
                var hasUnregistered = false;
                /** @type {?} */
                var registered = new RegisteredFilter(filter, function () {
                    if (hasUnregistered) {
                        return;
                    }
                    subscription.unsubscribe();
                    _this._all.splice(index, 1);
                    if (filter.isActive()) {
                        _this.resetPageAndEmitFilterChange([]);
                    }
                    hasUnregistered = true;
                });
                this._all.push(registered);
                if (filter.isActive()) {
                    this.resetPageAndEmitFilterChange([filter]);
                }
                return registered;
            };
        /**
         * Accepts an item if it is accepted by all currently active filters
         */
        /**
         * Accepts an item if it is accepted by all currently active filters
         * @param {?} item
         * @return {?}
         */
        FiltersProvider.prototype.accepts = /**
         * Accepts an item if it is accepted by all currently active filters
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var e_3, _a;
                try {
                    for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var filter = _c.value.filter;
                        if (filter && filter.isActive() && !filter.accepts(item)) {
                            return false;
                        }
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
                return true;
            };
        /**
         * @param {?} filters
         * @return {?}
         */
        FiltersProvider.prototype.resetPageAndEmitFilterChange = /**
         * @param {?} filters
         * @return {?}
         */
            function (filters) {
                this.stateDebouncer.changeStart();
                // filtering may change the page number such that current page number doesn't exist in the filtered dataset.
                // So here we always set the current page to 1 so that it'll fetch first page's data with the given filter.
                this._page.current = 1;
                this._change.next(filters);
                this.stateDebouncer.changeDone();
            };
        FiltersProvider.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        FiltersProvider.ctorParameters = function () {
            return [
                { type: Page },
                { type: StateDebouncer }
            ];
        };
        return FiltersProvider;
    }());
    /**
     * @template T, F
     */
    var /**
     * @template T, F
     */ RegisteredFilter = /** @class */ (function () {
        function RegisteredFilter(filter, unregister) {
            this.filter = filter;
            this.unregister = unregister;
        }
        return RegisteredFilter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template T, F
     */
    var /**
     * @abstract
     * @template T, F
     */ DatagridFilterRegistrar = /** @class */ (function () {
        function DatagridFilterRegistrar(filters) {
            this.filters = filters;
        }
        Object.defineProperty(DatagridFilterRegistrar.prototype, "filter", {
            get: /**
             * @return {?}
             */ function () {
                return this.registered && this.registered.filter;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} filter
         * @return {?}
         */
        DatagridFilterRegistrar.prototype.setFilter = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                // If we previously had another filter, we unregister it
                this.deleteFilter();
                if (filter instanceof RegisteredFilter) {
                    this.registered = filter;
                }
                else if (filter) {
                    this.registered = this.filters.add(filter);
                }
            };
        /**
         * @return {?}
         */
        DatagridFilterRegistrar.prototype.deleteFilter = /**
         * @return {?}
         */
            function () {
                if (this.registered) {
                    this.registered.unregister();
                    delete this.registered;
                }
            };
        /**
         * @return {?}
         */
        DatagridFilterRegistrar.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.deleteFilter();
            };
        return DatagridFilterRegistrar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Custom filter that can be added in any column to override the default object property string filter.
     * The reason this is not just an input on DatagridColumn is because we need the filter's template to be projected,
     * since it can be anything (not just a text input).
     * @template T
     */
    var ClrDatagridFilter = /** @class */ (function (_super) {
        __extends(ClrDatagridFilter, _super);
        function ClrDatagridFilter(_filters, commonStrings, platformId) {
            var _this = _super.call(this, _filters) || this;
            _this.commonStrings = commonStrings;
            _this.platformId = platformId;
            _this.anchorPoint = Point.RIGHT_BOTTOM;
            _this.popoverPoint = Point.RIGHT_TOP;
            _this.popoverOptions = { allowMultipleOpen: true };
            /**
             * Tracks whether the filter dropdown is open or not
             */
            _this._open = false;
            _this.openChanged = new i0.EventEmitter(false);
            return _this;
        }
        Object.defineProperty(ClrDatagridFilter.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._open;
            },
            set: /**
             * @param {?} open
             * @return {?}
             */ function (open) {
                /** @type {?} */
                var boolOpen = !!open;
                if (boolOpen !== this._open) {
                    this._open = boolOpen;
                    this.openChanged.emit(boolOpen);
                    if (!boolOpen && common.isPlatformBrowser(this.platformId)) {
                        this.anchor.nativeElement.focus();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridFilter.prototype, "customFilter", {
            set: /**
             * @param {?} filter
             * @return {?}
             */ function (filter) {
                this.setFilter(filter);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridFilter.prototype, "active", {
            /**
             * Indicates if the filter is currently active
             */
            get: /**
             * Indicates if the filter is currently active
             * @return {?}
             */ function () {
                return !!this.filter && this.filter.isActive();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Shows/hides the filter dropdown
         */
        /**
         * Shows/hides the filter dropdown
         * @return {?}
         */
        ClrDatagridFilter.prototype.toggle = /**
         * Shows/hides the filter dropdown
         * @return {?}
         */
            function () {
                this.open = !this.open;
            };
        ClrDatagridFilter.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-filter',
                        // We register this component as a CustomFilter, for the parent column to detect it.
                        providers: [{ provide: CustomFilter, useExisting: ClrDatagridFilter }],
                        template: "\n        <button #anchor class=\"datagrid-filter-toggle\" (click)=\"toggle()\"\n            [class.datagrid-filter-open]=\"open\" [class.datagrid-filtered]=\"active\"\n            type=\"button\"></button>\n\n        <ng-template [(clrPopoverOld)]=\"open\" [clrPopoverOldAnchor]=\"anchor\" [clrPopoverOldAnchorPoint]=\"anchorPoint\"\n             [clrPopoverOldPopoverPoint]=\"popoverPoint\" [clrPopoverOldOptions]=\"popoverOptions\">\n            <div class=\"datagrid-filter\">\n                <!-- FIXME: this whole filter part needs a final design before we can try to have a cleaner DOM -->\n                <div class=\"datagrid-filter-close-wrapper\">\n                    <button type=\"button\" class=\"close\" (click)=\"open = false\">\n                        <clr-icon shape=\"close\" [attr.title]=\"commonStrings.keys.close\"></clr-icon>\n                    </button>\n                </div>\n    \n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridFilter.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: ClrCommonStringsService },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        ClrDatagridFilter.propDecorators = {
            anchor: [{ type: i0.ViewChild, args: ['anchor', { read: i0.ElementRef },] }],
            open: [{ type: i0.Input, args: ['clrDgFilterOpen',] }],
            openChanged: [{ type: i0.Output, args: ['clrDgFilterOpenChange',] }],
            customFilter: [{ type: i0.Input, args: ['clrDgFilter',] }]
        };
        return ClrDatagridFilter;
    }(DatagridFilterRegistrar));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Generic accessor for deep object properties
     * that can be specified as simple dot-separated strings.
     * @template T
     */
    var /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */ 
    /**
     * Generic accessor for deep object properties
     * that can be specified as simple dot-separated strings.
     * @template T
     */
    NestedProperty = /** @class */ (function () {
        function NestedProperty(prop) {
            this.prop = prop;
            if (prop.indexOf('.') >= 0) {
                this.splitProp = prop.split('.');
            }
        }
        // Safe getter for a deep object property, will not throw an error but return
        // undefined if one of the intermediate properties is null or undefined.
        // Safe getter for a deep object property, will not throw an error but return
        // undefined if one of the intermediate properties is null or undefined.
        /**
         * @param {?} item
         * @return {?}
         */
        NestedProperty.prototype.getPropValue =
            // Safe getter for a deep object property, will not throw an error but return
            // undefined if one of the intermediate properties is null or undefined.
            /**
             * @param {?} item
             * @return {?}
             */
            function (item) {
                var e_1, _a;
                if (this.splitProp) {
                    /** @type {?} */
                    var value = item;
                    try {
                        for (var _b = __values(this.splitProp), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var nestedProp = _c.value;
                            if (value == null || typeof value === 'undefined' || typeof value[nestedProp] === 'undefined') {
                                return undefined;
                            }
                            value = value[nestedProp];
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    return value;
                }
                else {
                    return item[this.prop];
                }
            };
        return NestedProperty;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ DatagridPropertyStringFilter = /** @class */ (function () {
        function DatagridPropertyStringFilter(prop, exact) {
            if (exact === void 0) {
                exact = false;
            }
            this.prop = prop;
            this.exact = exact;
            this.nestedProp = new NestedProperty(prop);
        }
        /**
         * @param {?} item
         * @param {?} search
         * @return {?}
         */
        DatagridPropertyStringFilter.prototype.accepts = /**
         * @param {?} item
         * @param {?} search
         * @return {?}
         */
            function (item, search) {
                /** @type {?} */
                var propValue = this.nestedProp.getPropValue(item);
                if (typeof propValue === 'undefined') {
                    return false;
                }
                else if (this.exact) {
                    return ('' + propValue).toLowerCase() === search;
                }
                else {
                    return ('' + propValue).toLowerCase().indexOf(search) >= 0;
                }
            };
        return DatagridPropertyStringFilter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ DatagridStringFilterImpl = /** @class */ (function () {
        function DatagridStringFilterImpl(filterFn) {
            this.filterFn = filterFn;
            /**
             * The Observable required as part of the Filter interface
             */
            this._changes = new rxjs.Subject();
            /**
             * Raw input value
             */
            this._rawValue = '';
            /**
             * Input value converted to lowercase
             */
            this._lowerCaseValue = '';
        }
        Object.defineProperty(DatagridStringFilterImpl.prototype, "changes", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridStringFilterImpl.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._rawValue;
            },
            /**
             * Common setter for the input value
             */
            set: /**
             * Common setter for the input value
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!value) {
                    value = '';
                }
                if (value !== this._rawValue) {
                    this._rawValue = value;
                    this._lowerCaseValue = value.toLowerCase().trim();
                    this._changes.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridStringFilterImpl.prototype, "lowerCaseValue", {
            get: /**
             * @return {?}
             */ function () {
                return this._lowerCaseValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Indicates if the filter is currently active, meaning the input is not empty
         */
        /**
         * Indicates if the filter is currently active, meaning the input is not empty
         * @return {?}
         */
        DatagridStringFilterImpl.prototype.isActive = /**
         * Indicates if the filter is currently active, meaning the input is not empty
         * @return {?}
         */
            function () {
                return !!this.value;
            };
        /**
         * Tests if an item matches a search text
         */
        /**
         * Tests if an item matches a search text
         * @param {?} item
         * @return {?}
         */
        DatagridStringFilterImpl.prototype.accepts = /**
         * Tests if an item matches a search text
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // We always test with the lowercase value of the input, to stay case insensitive
                return this.filterFn.accepts(item, this.lowerCaseValue);
            };
        Object.defineProperty(DatagridStringFilterImpl.prototype, "state", {
            get: /**
             * @return {?}
             */ function () {
                if (this.filterFn instanceof DatagridPropertyStringFilter) {
                    return {
                        property: this.filterFn.prop,
                        value: this.value,
                    };
                }
                return this;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} other
         * @return {?}
         */
        DatagridStringFilterImpl.prototype.equals = /**
         * @param {?} other
         * @return {?}
         */
            function (other) {
                if (other instanceof DatagridStringFilterImpl) {
                    if (other.filterFn instanceof DatagridPropertyStringFilter) {
                        return (this.filterFn instanceof DatagridPropertyStringFilter &&
                            other.filterFn.prop === this.filterFn.prop &&
                            other.value === this.value);
                    }
                    return other === this;
                }
                return false;
            };
        return DatagridStringFilterImpl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DatagridStringFilter = /** @class */ (function (_super) {
        __extends(DatagridStringFilter, _super);
        function DatagridStringFilter(filters, domAdapter) {
            var _this = _super.call(this, filters) || this;
            _this.domAdapter = domAdapter;
            /**
             * Indicates if the filter dropdown is open
             */
            _this.open = false;
            _this.filterValueChange = new i0.EventEmitter();
            return _this;
        }
        Object.defineProperty(DatagridStringFilter.prototype, "customStringFilter", {
            /**
             * Customizable filter logic based on a search text
             */
            set: /**
             * Customizable filter logic based on a search text
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value instanceof RegisteredFilter) {
                    this.setFilter(value);
                }
                else {
                    this.setFilter(new DatagridStringFilterImpl(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DatagridStringFilter.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.filterContainer.openChanged.subscribe(function (open) {
                    if (open) {
                        // We need the timeout because at the time this executes, the input isn't
                        // displayed yet.
                        setTimeout(function () {
                            _this.domAdapter.focus(_this.input.nativeElement);
                        });
                    }
                });
            };
        Object.defineProperty(DatagridStringFilter.prototype, "value", {
            /**
             * Common setter for the input value
             */
            get: /**
             * Common setter for the input value
             * @return {?}
             */ function () {
                return this.filter.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!this.filter) {
                    return;
                }
                if (!value) {
                    value = '';
                }
                if (value !== this.filter.value) {
                    this.filter.value = value;
                    this.filterValueChange.emit(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DatagridStringFilter.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open = false;
            };
        DatagridStringFilter.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-string-filter',
                        providers: [{ provide: CustomFilter, useExisting: DatagridStringFilter }],
                        template: "\n        <clr-dg-filter [clrDgFilter]=\"registered\" [(clrDgFilterOpen)]=\"open\">\n            <!--\n                Even though this *ngIf looks useless because the filter container already has one,\n                it prevents NgControlStatus and other directives automatically added by Angular\n                on inputs with NgModel from freaking out because of their host binding changing\n                mid-change detection when the input is destroyed.\n            -->\n            <input #input type=\"text\" name=\"search\" [(ngModel)]=\"value\" *ngIf=\"open\"\n                (keyup.enter)=\"close()\" (keyup.escape)=\"close()\"/>\n        </clr-dg-filter>\n    "
                    }] }
        ];
        /** @nocollapse */
        DatagridStringFilter.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: DomAdapter }
            ];
        };
        DatagridStringFilter.propDecorators = {
            customStringFilter: [{ type: i0.Input, args: ['clrDgStringFilter',] }],
            input: [{ type: i0.ViewChild, args: ['input',] }],
            filterContainer: [{ type: i0.ViewChild, args: [ClrDatagridFilter,] }],
            value: [{ type: i0.Input, args: ['clrFilterValue',] }],
            filterValueChange: [{ type: i0.Output, args: ['clrFilterValueChange',] }]
        };
        return DatagridStringFilter;
    }(DatagridFilterRegistrar));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ OompaLoompa = /** @class */ (function () {
        // FIXME: Request Injector once we move to Angular 4.2+, it'll allow easier refactors
        function OompaLoompa(cdr, willyWonka) {
            var _this = this;
            this.subscription = willyWonka.chocolate.subscribe(function () {
                if (_this.latestFlavor !== _this.flavor) {
                    cdr.detectChanges();
                }
            });
        }
        /**
         * @return {?}
         */
        OompaLoompa.prototype.ngAfterContentChecked = /**
         * @return {?}
         */
            function () {
                this.latestFlavor = this.flavor;
            };
        /**
         * @return {?}
         */
        OompaLoompa.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        return OompaLoompa;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var RowActionService = /** @class */ (function () {
        function RowActionService() {
            this.actionableCount = 0;
        }
        /**
         * @return {?}
         */
        RowActionService.prototype.register = /**
         * @return {?}
         */
            function () {
                this.actionableCount++;
            };
        /**
         * @return {?}
         */
        RowActionService.prototype.unregister = /**
         * @return {?}
         */
            function () {
                this.actionableCount--;
            };
        Object.defineProperty(RowActionService.prototype, "hasActionableRow", {
            /**
             * false means no rows with action
             */
            get: /**
             * false means no rows with action
             * @return {?}
             */ function () {
                return this.actionableCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        RowActionService.decorators = [
            { type: i0.Injectable }
        ];
        return RowActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
     * declarative API, we need to fight against change detection and its one-way flow. This is
     * currently the least dirty solution to do what we want.
     *
     * Do not modify or even use this class unless you know exactly what you're doing.
     * It has the potential to trigger change detection loops or kill app performances.
     */
    var /*
     * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
     * declarative API, we need to fight against change detection and its one-way flow. This is
     * currently the least dirty solution to do what we want.
     *
     * Do not modify or even use this class unless you know exactly what you're doing.
     * It has the potential to trigger change detection loops or kill app performances.
     */ WillyWonka = /** @class */ (function () {
        function WillyWonka() {
            this._chocolate = new rxjs.Subject();
        }
        Object.defineProperty(WillyWonka.prototype, "chocolate", {
            get: /**
             * @return {?}
             */ function () {
                return this._chocolate.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WillyWonka.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this._chocolate.next();
            };
        return WillyWonka;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridWillyWonka = /** @class */ (function (_super) {
        __extends(DatagridWillyWonka, _super);
        function DatagridWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DatagridWillyWonka.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-datagrid' },] }
        ];
        return DatagridWillyWonka;
    }(WillyWonka));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ActionableOompaLoompa = /** @class */ (function (_super) {
        __extends(ActionableOompaLoompa, _super);
        function ActionableOompaLoompa(cdr, willyWonka, rowActions) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.rowActions = rowActions;
            return _this;
        }
        Object.defineProperty(ActionableOompaLoompa.prototype, "flavor", {
            get: /**
             * @return {?}
             */ function () {
                return this.rowActions.hasActionableRow;
            },
            enumerable: true,
            configurable: true
        });
        ActionableOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
        ];
        /** @nocollapse */
        ActionableOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: DatagridWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: RowActionService }
            ];
        };
        return ActionableOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ExpandableRowsCount = /** @class */ (function () {
        function ExpandableRowsCount() {
            this.expandableCount = 0;
        }
        /**
         * @return {?}
         */
        ExpandableRowsCount.prototype.register = /**
         * @return {?}
         */
            function () {
                this.expandableCount++;
            };
        /**
         * @return {?}
         */
        ExpandableRowsCount.prototype.unregister = /**
         * @return {?}
         */
            function () {
                this.expandableCount--;
            };
        Object.defineProperty(ExpandableRowsCount.prototype, "hasExpandableRow", {
            /**
             * false means no rows with action
             */
            get: /**
             * false means no rows with action
             * @return {?}
             */ function () {
                return this.expandableCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        ExpandableRowsCount.decorators = [
            { type: i0.Injectable }
        ];
        return ExpandableRowsCount;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ExpandableOompaLoompa = /** @class */ (function (_super) {
        __extends(ExpandableOompaLoompa, _super);
        function ExpandableOompaLoompa(cdr, willyWonka, expandableCount) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.expandableCount = expandableCount;
            return _this;
        }
        Object.defineProperty(ExpandableOompaLoompa.prototype, "flavor", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandableCount.hasExpandableRow;
            },
            enumerable: true,
            configurable: true
        });
        ExpandableOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
        ];
        /** @nocollapse */
        ExpandableOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: DatagridWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: ExpandableRowsCount }
            ];
        };
        return ExpandableOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ DatagridPropertyComparator = /** @class */ (function () {
        function DatagridPropertyComparator(prop) {
            this.prop = prop;
            this.nestedProp = new NestedProperty(prop);
        }
        /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        DatagridPropertyComparator.prototype.compare = /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
            function (a, b) {
                /** @type {?} */
                var propA = this.nestedProp.getPropValue(a);
                /** @type {?} */
                var propB = this.nestedProp.getPropValue(b);
                if (typeof propA === 'string') {
                    propA = propA.toLowerCase();
                }
                if (typeof propB === 'string') {
                    propB = propB.toLowerCase();
                }
                if (typeof propA === 'undefined' || propA === null) {
                    if (typeof propB === 'undefined' || propB === null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else {
                    if (typeof propB === 'undefined' || propB === null) {
                        return -1;
                    }
                    else if (propA < propB) {
                        return -1;
                    }
                    else if (propA > propB) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
            };
        return DatagridPropertyComparator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {number} */
    var ClrDatagridSortOrder = {
        UNSORTED: 0,
        ASC: 1,
        DESC: -1,
    };
    ClrDatagridSortOrder[ClrDatagridSortOrder.UNSORTED] = 'UNSORTED';
    ClrDatagridSortOrder[ClrDatagridSortOrder.ASC] = 'ASC';
    ClrDatagridSortOrder[ClrDatagridSortOrder.DESC] = 'DESC';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var Sort = /** @class */ (function () {
        function Sort(stateDebouncer) {
            this.stateDebouncer = stateDebouncer;
            /**
             * Ascending order if false, descending if true
             */
            this._reverse = false;
            /**
             * The Observable that lets other classes subscribe to sort changes
             */
            this._change = new rxjs.Subject();
        }
        Object.defineProperty(Sort.prototype, "comparator", {
            get: /**
             * @return {?}
             */ function () {
                return this._comparator;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.stateDebouncer.changeStart();
                this._comparator = value;
                this.emitChange();
                this.stateDebouncer.changeDone();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sort.prototype, "reverse", {
            get: /**
             * @return {?}
             */ function () {
                return this._reverse;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.stateDebouncer.changeStart();
                this._reverse = value;
                this.emitChange();
                this.stateDebouncer.changeDone();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Sort.prototype.emitChange = /**
         * @return {?}
         */
            function () {
                this._change.next(this);
            };
        Object.defineProperty(Sort.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
         * optional forceReverse input parameter allows to override that toggling behavior by sorting in
         * reverse order if `true`.
         *
         * @memberof Sort
         */
        /**
         * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
         * optional forceReverse input parameter allows to override that toggling behavior by sorting in
         * reverse order if `true`.
         *
         * \@memberof Sort
         * @param {?} sortBy
         * @param {?=} forceReverse
         * @return {?}
         */
        Sort.prototype.toggle = /**
         * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
         * optional forceReverse input parameter allows to override that toggling behavior by sorting in
         * reverse order if `true`.
         *
         * \@memberof Sort
         * @param {?} sortBy
         * @param {?=} forceReverse
         * @return {?}
         */
            function (sortBy, forceReverse) {
                this.stateDebouncer.changeStart();
                // We modify private properties directly, to batch the change event
                if (this.comparator === sortBy) {
                    this._reverse = typeof forceReverse !== 'undefined' ? forceReverse || !this._reverse : !this._reverse;
                }
                else {
                    this._comparator = sortBy;
                    this._reverse = typeof forceReverse !== 'undefined' ? forceReverse : false;
                }
                this.emitChange();
                this.stateDebouncer.changeDone();
            };
        /**
         * Clears the current sorting order
         */
        /**
         * Clears the current sorting order
         * @return {?}
         */
        Sort.prototype.clear = /**
         * Clears the current sorting order
         * @return {?}
         */
            function () {
                this.comparator = null;
            };
        /**
         * Compares two objects according to the current comparator
         */
        /**
         * Compares two objects according to the current comparator
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        Sort.prototype.compare = /**
         * Compares two objects according to the current comparator
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
            function (a, b) {
                return (this.reverse ? -1 : 1) * this.comparator.compare(a, b);
            };
        Sort.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Sort.ctorParameters = function () {
            return [
                { type: StateDebouncer }
            ];
        };
        return Sort;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WrappedColumn = /** @class */ (function () {
        function WrappedColumn() {
            this._dynamic = false;
        }
        // the columns projected view (in memory)
        /**
         * @return {?}
         */
        WrappedColumn.prototype.ngAfterViewInit =
            // the columns projected view (in memory)
            /**
             * @return {?}
             */
            function () {
                // Create the cells view in memory, not the DOM.
                this.columnView = this.templateRef.createEmbeddedView(null);
            };
        WrappedColumn.decorators = [
            { type: i0.Component, args: [{
                        selector: 'dg-wrapped-column',
                        template: "        \n        <ng-template #columnPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                    }] }
        ];
        WrappedColumn.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['columnPortal',] }]
        };
        return WrappedColumn;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbCount = 0;
    /**
     * @template T
     */
    var ClrDatagridColumn = /** @class */ (function (_super) {
        __extends(ClrDatagridColumn, _super);
        function ClrDatagridColumn(_sort, filters, vcr, commonStrings) {
            var _this = _super.call(this, filters) || this;
            _this._sort = _sort;
            _this.vcr = vcr;
            _this.commonStrings = commonStrings;
            // deprecated: to be removed - START
            /**
             * Indicates if the column is currently sorted
             *
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            _this._sorted = false;
            /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            _this.sortedChange = new i0.EventEmitter();
            // deprecated: to be removed - END
            /**
             * Indicates how the column is currently sorted
             */
            _this._sortOrder = ClrDatagridSortOrder.UNSORTED;
            _this.sortOrderChange = new i0.EventEmitter();
            /**
             * A custom filter for this column that can be provided in the projected content
             */
            _this.customFilter = false;
            _this.filterValueChange = new i0.EventEmitter();
            _this._sortSubscription = _sort.change.subscribe(function (sort) {
                // We're only listening to make sure we emit an event when the column goes from sorted to unsorted
                if (_this.sortOrder !== ClrDatagridSortOrder.UNSORTED && sort.comparator !== _this._sortBy) {
                    _this._sortOrder = ClrDatagridSortOrder.UNSORTED;
                    _this.sortOrderChange.emit(_this._sortOrder);
                }
                // deprecated: to be removed - START
                if (_this.sorted && sort.comparator !== _this._sortBy) {
                    _this._sorted = false;
                    _this.sortedChange.emit(false);
                }
                // deprecated: to be removed - END
            });
            _this.columnId = 'dg-col-' + nbCount.toString(); // Approximate a GUID
            nbCount++;
            return _this;
        }
        Object.defineProperty(ClrDatagridColumn.prototype, "hidden", {
            /**
             * @property hidden
             *
             * @description
             * A property that allows the column to be hidden / shown with css
             * Note the default allows the ClrDatagridColumn to have an *ngIf on it. (EHCAIWC - will occur if its not
             * initialized)
             *
             * @default false
             *
             */
            get: /**
             * \@property hidden
             *
             * \@description
             * A property that allows the column to be hidden / shown with css
             * Note the default allows the ClrDatagridColumn to have an *ngIf on it. (EHCAIWC - will occur if its not
             * initialized)
             *
             * \@default false
             *
             * @return {?}
             */ function () {
                return !!this.hideable && this.hideable.hidden;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridColumn.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._sortSubscription.unsubscribe();
            };
        Object.defineProperty(ClrDatagridColumn.prototype, "field", {
            get: /**
             * @return {?}
             */ function () {
                return this._field;
            },
            set: /**
             * @param {?} field
             * @return {?}
             */ function (field) {
                if (typeof field === 'string') {
                    this._field = field;
                    if (!this.customFilter) {
                        this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
                    }
                    if (!this._sortBy) {
                        this._sortBy = new DatagridPropertyComparator(field);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortBy", {
            get: /**
             * @return {?}
             */ function () {
                return this._sortBy;
            },
            set: /**
             * @param {?} comparator
             * @return {?}
             */ function (comparator) {
                if (typeof comparator === 'string') {
                    this._sortBy = new DatagridPropertyComparator(comparator);
                }
                else {
                    if (comparator) {
                        this._sortBy = comparator;
                    }
                    else {
                        if (this._field) {
                            this._sortBy = new DatagridPropertyComparator(this._field);
                        }
                        else {
                            delete this._sortBy;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortable", {
            /**
             * Indicates if the column is sortable
             */
            get: /**
             * Indicates if the column is sortable
             * @return {?}
             */ function () {
                return !!this._sortBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sorted", {
            get: /**
             * @return {?}
             */ function () {
                return this._sorted;
            },
            /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            set: /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!value && this.sorted) {
                    this._sorted = false;
                    this._sort.clear();
                }
                else if (value && !this.sorted) {
                    this.sort();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortOrder", {
            get: /**
             * @return {?}
             */ function () {
                return this._sortOrder;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'undefined') {
                    return;
                }
                // only if the incoming order is different from the current one
                if (this._sortOrder === value) {
                    return;
                }
                switch (value) {
                    // the Unsorted case happens when the current state is either Asc or Desc
                    default:
                    case ClrDatagridSortOrder.UNSORTED:
                        this._sort.clear();
                        break;
                    case ClrDatagridSortOrder.ASC:
                        this.sort(false);
                        break;
                    case ClrDatagridSortOrder.DESC:
                        this.sort(true);
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "ariaSort", {
            get: /**
             * @return {?}
             */ function () {
                switch (this._sortOrder) {
                    default:
                    case ClrDatagridSortOrder.UNSORTED:
                        return 'none';
                    case ClrDatagridSortOrder.ASC:
                        return 'ascending';
                    case ClrDatagridSortOrder.DESC:
                        return 'descending';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sorts the datagrid based on this column
         */
        /**
         * Sorts the datagrid based on this column
         * @param {?=} reverse
         * @return {?}
         */
        ClrDatagridColumn.prototype.sort = /**
         * Sorts the datagrid based on this column
         * @param {?=} reverse
         * @return {?}
         */
            function (reverse) {
                if (!this.sortable) {
                    return;
                }
                this._sort.toggle(this._sortBy, reverse);
                // setting the private variable to not retrigger the setter logic
                this._sortOrder = this._sort.reverse ? ClrDatagridSortOrder.DESC : ClrDatagridSortOrder.ASC;
                this.sortOrderChange.emit(this._sortOrder);
                // deprecated: to be removed - START
                this._sorted = true;
                this.sortedChange.emit(true);
                // deprecated: to be removed - END
            };
        Object.defineProperty(ClrDatagridColumn.prototype, "asc", {
            /**
             * Indicates if the column is currently sorted in ascending order
             */
            get: /**
             * Indicates if the column is currently sorted in ascending order
             * @return {?}
             */ function () {
                // deprecated: if condition to be removed - START
                if (typeof this.sortOrder === 'undefined') {
                    return this.sorted && !this._sort.reverse;
                }
                else {
                    return this.sortOrder === ClrDatagridSortOrder.ASC;
                }
                // deprecated: if condition to be removed - END
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "desc", {
            /**
             * Indicates if the column is currently sorted in descending order
             */
            get: /**
             * Indicates if the column is currently sorted in descending order
             * @return {?}
             */ function () {
                // deprecated: if condition to be removed - START
                if (typeof this.sortOrder === 'undefined') {
                    return this.sorted && this._sort.reverse;
                }
                else {
                    return this.sortOrder === ClrDatagridSortOrder.DESC;
                }
                // deprecated: if condition to be removed - END
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "projectedFilter", {
            set: /**
             * @param {?} custom
             * @return {?}
             */ function (custom) {
                if (custom) {
                    this.deleteFilter();
                    this.customFilter = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "filterValue", {
            get: /**
             * @return {?}
             */ function () {
                return this.filter.value;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                this.updateFilterValue = newValue;
                this.filterValueChange.emit(this.filter.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "updateFilterValue", {
            set: /**
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                if (!this.filter) {
                    return;
                }
                if (!newValue) {
                    newValue = '';
                }
                if (newValue !== this.filter.value) {
                    this.filter.value = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridColumn.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.wrappedInjector = new HostWrapper(WrappedColumn, this.vcr);
            };
        Object.defineProperty(ClrDatagridColumn.prototype, "_view", {
            get: /**
             * @return {?}
             */ function () {
                return this.wrappedInjector.get(WrappedColumn, this.vcr).columnView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumn.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column',
                        template: "\n        <div class=\"datagrid-column-flex\">\n            <!-- I'm really not happy with that select since it's not very scalable -->\n            <ng-content select=\"clr-dg-filter, clr-dg-string-filter\"></ng-content>\n\n            <clr-dg-string-filter\n                    *ngIf=\"field && !customFilter\"\n                    [clrDgStringFilter]=\"registered\"\n                    [(clrFilterValue)]=\"filterValue\"></clr-dg-string-filter>\n\n            <ng-template #columnTitle>\n                <ng-content></ng-content>\n            </ng-template>\n\n            <button \n              class=\"datagrid-column-title\" \n              [attr.aria-label]=\"commonStrings.keys.sortColumn\"\n              *ngIf=\"sortable\" \n              (click)=\"sort()\" \n              type=\"button\">\n                <ng-container *ngTemplateOutlet=\"columnTitle\"></ng-container>\n            </button>\n\n            <span class=\"datagrid-column-title\" *ngIf=\"!sortable\">\n               <ng-container *ngTemplateOutlet=\"columnTitle\"></ng-container>\n            </span>\n\n            <clr-dg-column-separator></clr-dg-column-separator>\n        </div>\n    ",
                        host: {
                            '[class.datagrid-column]': 'true',
                            '[class.datagrid-column--hidden]': 'hidden',
                            '[attr.aria-sort]': 'ariaSort',
                            role: 'columnheader',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridColumn.ctorParameters = function () {
            return [
                { type: Sort },
                { type: FiltersProvider },
                { type: i0.ViewContainerRef },
                { type: ClrCommonStringsService }
            ];
        };
        ClrDatagridColumn.propDecorators = {
            field: [{ type: i0.Input, args: ['clrDgField',] }],
            sortBy: [{ type: i0.Input, args: ['clrDgSortBy',] }],
            sorted: [{ type: i0.Input, args: ['clrDgSorted',] }],
            sortedChange: [{ type: i0.Output, args: ['clrDgSortedChange',] }],
            sortOrder: [{ type: i0.Input, args: ['clrDgSortOrder',] }],
            sortOrderChange: [{ type: i0.Output, args: ['clrDgSortOrderChange',] }],
            asc: [{ type: i0.HostBinding, args: ['class.asc',] }],
            desc: [{ type: i0.HostBinding, args: ['class.desc',] }],
            projectedFilter: [{ type: i0.ContentChild, args: [CustomFilter,] }],
            updateFilterValue: [{ type: i0.Input, args: ['clrFilterValue',] }],
            filterValueChange: [{ type: i0.Output, args: ['clrFilterValueChange',] }]
        };
        return ClrDatagridColumn;
    }(DatagridFilterRegistrar));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var Items = /** @class */ (function () {
        function Items(_filters, _sort, _page) {
            this._filters = _filters;
            this._sort = _sort;
            this._page = _page;
            /**
             * Indicates if the data is currently loading
             */
            this.loading = false;
            // TODO: Verify that trackBy is registered for the *ngFor case too
            /**
             * Tracking function to identify objects. Default is reference equality.
             */
            this.trackBy = function (index, item) { return item; };
            /**
             * Whether we should use smart items for this datagrid or let the user handle
             * everything.
             */
            this._smart = false;
            /**
             * List of items currently displayed
             */
            this._displayed = [];
            /**
             * The Observable that lets other classes subscribe to items changes
             */
            this._change = new rxjs.Subject();
            this._allChanges = new rxjs.Subject();
        }
        /**
         * Cleans up our subscriptions to other providers
         */
        /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
        Items.prototype.destroy = /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
            function () {
                if (this._filtersSub) {
                    this._filtersSub.unsubscribe();
                }
                if (this._sortSub) {
                    this._sortSub.unsubscribe();
                }
                if (this._pageSub) {
                    this._pageSub.unsubscribe();
                }
            };
        Object.defineProperty(Items.prototype, "smart", {
            get: /**
             * @return {?}
             */ function () {
                return this._smart;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Items.prototype.smartenUp = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._smart = true;
                /*
                     * These observers trigger a chain of function: filter -> sort -> paginate
                     * An observer up the chain re-triggers all the operations that follow it.
                     */
                this._filtersSub = this._filters.change.subscribe(function () { return _this._filterItems(); });
                this._sortSub = this._sort.change.subscribe(function () {
                    // Special case, if the datagrid went from sorted to unsorted, we have to re-filter
                    // to get the original order back
                    if (!_this._sort.comparator) {
                        _this._filterItems();
                    }
                    else {
                        _this._sortItems();
                    }
                });
                this._pageSub = this._page.change.subscribe(function () { return _this._changePage(); });
            };
        Object.defineProperty(Items.prototype, "all", {
            get: /**
             * @return {?}
             */ function () {
                return this._all;
            },
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._all = items;
                this.emitAllChanges(items);
                if (this.smart) {
                    this._filterItems();
                }
                else {
                    this._displayed = items;
                    this.emitChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Manually recompute the list of displayed items
         */
        /**
         * Manually recompute the list of displayed items
         * @return {?}
         */
        Items.prototype.refresh = /**
         * Manually recompute the list of displayed items
         * @return {?}
         */
            function () {
                if (this.smart) {
                    this._filterItems();
                }
            };
        Object.defineProperty(Items.prototype, "displayed", {
            get: /**
             * @return {?}
             */ function () {
                // Ideally we could return an immutable array, but we don't have it in Clarity yet.
                return this._displayed;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Items.prototype.emitChange = /**
         * @return {?}
         */
            function () {
                this._change.next(this.displayed);
            };
        Object.defineProperty(Items.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} items
         * @return {?}
         */
        Items.prototype.emitAllChanges = /**
         * @param {?} items
         * @return {?}
         */
            function (items) {
                this._allChanges.next(items);
            };
        Object.defineProperty(Items.prototype, "allChanges", {
            get: /**
             * @return {?}
             */ function () {
                return this._allChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Items.prototype, "uninitialized", {
            /**
             * Checks if we don't have data to process yet, to abort early operations
             */
            get: /**
             * Checks if we don't have data to process yet, to abort early operations
             * @return {?}
             */ function () {
                return !this._all;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * FiltersProvider items from the raw list
         */
        /**
         * FiltersProvider items from the raw list
         * @return {?}
         */
        Items.prototype._filterItems = /**
         * FiltersProvider items from the raw list
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.uninitialized) {
                    return;
                }
                if (this._filters.hasActiveFilters()) {
                    this._filtered = this._all.filter(function (item) { return _this._filters.accepts(item); });
                }
                else {
                    // Work on a shallow copy of the array, to not modify the user's model
                    this._filtered = this._all.slice();
                }
                this._page.totalItems = this._filtered.length;
                this._sortItems();
            };
        /**
         * Sorts items in the filtered list
         */
        /**
         * Sorts items in the filtered list
         * @return {?}
         */
        Items.prototype._sortItems = /**
         * Sorts items in the filtered list
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.uninitialized) {
                    return;
                }
                if (this._sort.comparator) {
                    this._filtered.sort(function (a, b) { return _this._sort.compare(a, b); });
                }
                this._changePage();
            };
        /**
         * Extracts the current page from the sorted list
         */
        /**
         * Extracts the current page from the sorted list
         * @return {?}
         */
        Items.prototype._changePage = /**
         * Extracts the current page from the sorted list
         * @return {?}
         */
            function () {
                // If we know we have pagination but the page size hasn't been set yet, we wait for it.
                if (this.uninitialized || (this._page.activated && this._page.size === 0)) {
                    return;
                }
                if (this._page.size > 0) {
                    this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
                }
                else {
                    this._displayed = this._filtered;
                }
                this.emitChange();
            };
        Items.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Items.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: Sort },
                { type: Page }
            ];
        };
        return Items;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridItems = /** @class */ (function () {
        function ClrDatagridItems(template, differs, items, vcr) {
            var _this = this;
            this.template = template;
            this.differs = differs;
            this.items = items;
            this.vcr = vcr;
            this.differ = null;
            this.subscriptions = [];
            items.smartenUp();
            this.iterableProxy = new common.NgForOf(this.vcr, this.template, this.differs);
            this.subscriptions.push(items.change.subscribe(function (newItems) {
                _this.iterableProxy.ngForOf = newItems;
                _this.iterableProxy.ngDoCheck();
            }));
        }
        Object.defineProperty(ClrDatagridItems.prototype, "rawItems", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._rawItems = items ? items : []; // local copy for ngOnChange diffing
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridItems.prototype, "trackBy", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.iterableProxy.ngForTrackBy = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridItems.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (!this.differ) {
                    this.differ = this.differs.find(this._rawItems).create(this.iterableProxy.ngForTrackBy);
                }
                if (this.differ) {
                    /** @type {?} */
                    var changes = this.differ.diff(this._rawItems);
                    if (changes) {
                        // TODO: not very efficient right now,
                        // but premature optimization is the root of all evil.
                        this.items.all = this._rawItems;
                    }
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridItems.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDatagridItems.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDgItems][clrDgItemsOf]',
                    },] }
        ];
        /** @nocollapse */
        ClrDatagridItems.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.IterableDiffers },
                { type: Items },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrDatagridItems.propDecorators = {
            rawItems: [{ type: i0.Input, args: ['clrDgItemsOf',] }],
            trackBy: [{ type: i0.Input, args: ['clrDgItemsTrackBy',] }]
        };
        return ClrDatagridItems;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridPlaceholder = /** @class */ (function () {
        function ClrDatagridPlaceholder(items) {
            this.items = items;
        }
        Object.defineProperty(ClrDatagridPlaceholder.prototype, "emptyDatagrid", {
            /**
             * Tests if the datagrid is empty, meaning it doesn't contain any items
             */
            get: /**
             * Tests if the datagrid is empty, meaning it doesn't contain any items
             * @return {?}
             */ function () {
                return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridPlaceholder.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-placeholder',
                        template: "\n        <div\n            class=\"datagrid-placeholder\"\n            [class.datagrid-empty]=\"emptyDatagrid\">\n                <div class=\"datagrid-placeholder-image\" *ngIf=\"emptyDatagrid\"></div>\n                <ng-content *ngIf=\"emptyDatagrid\"></ng-content>\n        </div>\n    ",
                        host: { '[class.datagrid-placeholder-container]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridPlaceholder.ctorParameters = function () {
            return [
                { type: Items }
            ];
        };
        return ClrDatagridPlaceholder;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var POPOVER_HOST_ANCHOR = new i0.InjectionToken('POPOVER_HOST_ANCHOR');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SignpostIdService = /** @class */ (function () {
        function SignpostIdService() {
            this._id = new rxjs.Subject();
        }
        /**
         * @param {?} id
         * @return {?}
         */
        SignpostIdService.prototype.setId = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                this._id.next(id);
            };
        Object.defineProperty(SignpostIdService.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        SignpostIdService.decorators = [
            { type: i0.Injectable }
        ];
        return SignpostIdService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSignpostTrigger = /** @class */ (function () {
        function ClrSignpostTrigger(ifOpenService, renderer, el, commonStrings, signpostIdService, platformId) {
            var _this = this;
            this.ifOpenService = ifOpenService;
            this.renderer = renderer;
            this.el = el;
            this.commonStrings = commonStrings;
            this.signpostIdService = signpostIdService;
            this.platformId = platformId;
            this.subscriptions = [];
            this.subscriptions.push(this.ifOpenService.openChange.subscribe(function (isOpen) {
                if (isOpen) {
                    _this.renderer.addClass(_this.el.nativeElement, 'active');
                }
                else {
                    _this.renderer.removeClass(_this.el.nativeElement, 'active');
                    if (common.isPlatformBrowser(_this.platformId)) {
                        _this.el.nativeElement.focus();
                    }
                }
                _this.ariaExpanded = isOpen;
            }), this.signpostIdService.id.subscribe(function (idChange) { return (_this.ariaControl = idChange); }));
        }
        /**
         * @return {?}
         */
        ClrSignpostTrigger.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**********
         *
         * @description
         * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
         */
        /**
         * *******
         *
         * \@description
         * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
         * @param {?} event
         * @return {?}
         */
        ClrSignpostTrigger.prototype.onSignpostTriggerClick = /**
         * *******
         *
         * \@description
         * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.ifOpenService.toggleWithEvent(event);
            };
        ClrSignpostTrigger.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrSignpostTrigger]',
                        host: {
                            class: 'signpost-trigger',
                            '[attr.aria-label]': 'commonStrings.keys.signpostToggle',
                            '[attr.aria-expanded]': 'ariaExpanded',
                            '[attr.aria-controls]': 'ariaControl',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrSignpostTrigger.ctorParameters = function () {
            return [
                { type: IfOpenService },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: ClrCommonStringsService },
                { type: SignpostIdService },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        ClrSignpostTrigger.propDecorators = {
            onSignpostTriggerClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
        };
        return ClrSignpostTrigger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSignpost = /** @class */ (function () {
        function ClrSignpost(commonStrings) {
            this.commonStrings = commonStrings;
            /**
             * *******
             * \@property useCustomTrigger
             *
             * \@description
             * Flag used to determine if we need to use the default trigger or a user supplied trigger element.
             *
             */
            this.useCustomTrigger = false;
        }
        Object.defineProperty(ClrSignpost.prototype, "customTrigger", {
            /**********
             * @property signPostTrigger
             *
             * @description
             * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
             *
             */
            set: /**
             * *******
             * \@property signPostTrigger
             *
             * \@description
             * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
             *
             * @param {?} trigger
             * @return {?}
             */ function (trigger) {
                this.useCustomTrigger = !!trigger;
            },
            enumerable: true,
            configurable: true
        });
        ClrSignpost.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-signpost',
                        template: "\n        <ng-container *ngIf=\"!useCustomTrigger\">\n            <button\n                type=\"button\"\n                class=\"signpost-action btn btn-small btn-link\"\n                clrSignpostTrigger>\n                <clr-icon shape=\"info\" [attr.title]=\"commonStrings.keys.info\"></clr-icon>\n            </button>\n        </ng-container>\n        \n        <ng-content></ng-content>\n    ",
                        host: { '[class.signpost]': 'true' },
                        providers: [IfOpenService, { provide: POPOVER_HOST_ANCHOR, useExisting: i0.ElementRef }, SignpostIdService]
                    }] }
        ];
        /** @nocollapse */
        ClrSignpost.ctorParameters = function () {
            return [
                { type: ClrCommonStringsService }
            ];
        };
        ClrSignpost.propDecorators = {
            customTrigger: [{ type: i0.ContentChild, args: [ClrSignpostTrigger,] }]
        };
        return ClrSignpost;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * \@description
     * An \@Injectable provider class that enables
     *
     * 1. Managing, track hideability of DatagridColumns
     *
     */
    var HideableColumnService = /** @class */ (function () {
        function HideableColumnService() {
            /**
             * *******
             * \@property dgHiddenColumnMap
             *
             * \@description
             * An array of DatagridHideableColumn.
             * NOTE: because we can have columns w/o the *clrDgHideableColumn directive
             * this array will have empty spaces a.k.a nulls. This is needed to be able to map
             * DatagridCells to DatagridColumns in the RowRenderer.
             *
             */
            this._columnList = [];
            /**
             * *******
             *
             * \@property dgHiddenColumnMapChange
             *
             * \@description
             * A behavior subject that can broadcast updates to the column list.
             * NOTE: I am using BehaviorSubject because <clr-dg-column-toggle> is not getting the latest _columnListChange
             * on page load.
             *
             */
            this._columnListChange = new rxjs.BehaviorSubject(this._columnList);
        }
        Object.defineProperty(HideableColumnService.prototype, "canHideNextColumn", {
            /**********
             *
             * @property canHideNextColumn
             *
             * @description
             * Service function that is called by clr-dg-column-toggle component. Use this if you need to ask if you can hide
             * a column. It acts as a guard against hiding all the columns making sure there is at least one column displayed.
             *
             */
            get: /**
             * *******
             *
             * \@property canHideNextColumn
             *
             * \@description
             * Service function that is called by clr-dg-column-toggle component. Use this if you need to ask if you can hide
             * a column. It acts as a guard against hiding all the columns making sure there is at least one column displayed.
             *
             * @return {?}
             */ function () {
                /** @type {?} */
                var hiddenColumns = this._columnList.filter(function (column) { return column !== undefined; }).filter(function (column) { return column.hidden; });
                return this._columnList.length - hiddenColumns.length > 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HideableColumnService.prototype, "checkForAllColumnsVisible", {
            /**********
             *
             * @property checkForAllColumnsVisible
             *
             * @description
             * For when you need to know if the datagrid's columns are all showing.
             *
             */
            get: /**
             * *******
             *
             * \@property checkForAllColumnsVisible
             *
             * \@description
             * For when you need to know if the datagrid's columns are all showing.
             *
             * @return {?}
             */ function () {
                return !this._columnList.some(function (column) { return column && column.hidden; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HideableColumnService.prototype, "columnListChange", {
            /***********
             * @property columnListChange
             *
             * @description
             * A public property that enables subscribers to hear updates to the column map.
             * Use this if you need to do something whenever the Datagrid's column list is changed (i.e *ngIf on a column).
             *
             */
            get: /**
             * ********
             * \@property columnListChange
             *
             * \@description
             * A public property that enables subscribers to hear updates to the column map.
             * Use this if you need to do something whenever the Datagrid's column list is changed (i.e *ngIf on a column).
             *
             * @return {?}
             */ function () {
                return this._columnListChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**********
         *
         * @description
         * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
         * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
         *
         */
        /**
         * *******
         *
         * \@description
         * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
         * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
         *
         * @return {?}
         */
        HideableColumnService.prototype.getColumns = /**
         * *******
         *
         * \@description
         * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
         * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
         *
         * @return {?}
         */
            function () {
                return this._columnList;
            };
        /**********
         *
         * @description
         * Iterate through the current _columnList:
         * - if it has a DatagridHideableColumn and is hidden then show it.
         * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
         *
         */
        /**
         * *******
         *
         * \@description
         * Iterate through the current _columnList:
         * - if it has a DatagridHideableColumn and is hidden then show it.
         * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
         *
         * @return {?}
         */
        HideableColumnService.prototype.showHiddenColumns = /**
         * *******
         *
         * \@description
         * Iterate through the current _columnList:
         * - if it has a DatagridHideableColumn and is hidden then show it.
         * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
         *
         * @return {?}
         */
            function () {
                this._columnList.forEach(function (column) {
                    if (column && column.hidden === true) {
                        column.hidden = false;
                    }
                    if (column && column.lastVisibleColumn) {
                        column.lastVisibleColumn = false;
                    }
                });
            };
        /**
         *
         * @param columns: DatagridColumn[]
         *
         * @description
         * Creates an array of DatagridHideableColumn's || null based column array passed as param.
         * Is dependent on the order in @ContentChildren in Datagrid.
         *
         */
        /**
         *
         * \@description
         * Creates an array of DatagridHideableColumn's || null based column array passed as param.
         * Is dependent on the order in \@ContentChildren in Datagrid.
         *
         * @param {?} columns
         * @return {?}
         */
        HideableColumnService.prototype.updateColumnList = /**
         *
         * \@description
         * Creates an array of DatagridHideableColumn's || null based column array passed as param.
         * Is dependent on the order in \@ContentChildren in Datagrid.
         *
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                this._columnList = columns; // clear the list
                this.updateForLastVisibleColumn(); // Update our visibility state for UI
                this._columnListChange.next(this._columnList); // Broadcast it
            };
        /**********
         *
         * @description
         * Gets the current visible count for all columns.
         * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
         * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
         * lastVisibleColumn.
         *
         */
        /**
         * *******
         *
         * \@description
         * Gets the current visible count for all columns.
         * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
         * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
         * lastVisibleColumn.
         *
         * @return {?}
         */
        HideableColumnService.prototype.updateForLastVisibleColumn = /**
         * *******
         *
         * \@description
         * Gets the current visible count for all columns.
         * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
         * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
         * lastVisibleColumn.
         *
         * @return {?}
         */
            function () {
                // There is more than one column showing, make sure nothing is marked lastVisibleColumn
                if (this.canHideNextColumn) {
                    this._columnList.map(function (column) {
                        if (column && column.lastVisibleColumn) {
                            column.lastVisibleColumn = false;
                        }
                    });
                }
                else {
                    // The visibleCount is down to only one column showing. Find it and flag it as the lastVisibleColumn
                    this._columnList.map(function (column) {
                        if (column && !column.hidden) {
                            column.lastVisibleColumn = true;
                        }
                    });
                }
            };
        /**********
         *
         * @description
         * Return a HideableColumn in this._columnList for the given id.
         *
         *
         */
        /**
         * *******
         *
         * \@description
         * Return a HideableColumn in this._columnList for the given id.
         *
         *
         * @param {?} id
         * @return {?}
         */
        HideableColumnService.prototype.getColumnById = /**
         * *******
         *
         * \@description
         * Return a HideableColumn in this._columnList for the given id.
         *
         *
         * @param {?} id
         * @return {?}
         */
            function (id) {
                if (id) {
                    return this._columnList.find(function (column) { return column && column.id === id; });
                }
                return;
            };
        HideableColumnService.decorators = [
            { type: i0.Injectable }
        ];
        return HideableColumnService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WrappedCell = /** @class */ (function () {
        function WrappedCell() {
            this._dynamic = false;
        }
        // the cells projected view
        /**
         * @return {?}
         */
        WrappedCell.prototype.ngAfterViewInit =
            // the cells projected view
            /**
             * @return {?}
             */
            function () {
                this.cellView = this.templateRef.createEmbeddedView(null);
            };
        WrappedCell.decorators = [
            { type: i0.Component, args: [{
                        selector: 'dg-wrapped-cell',
                        template: "        \n        <ng-template #cellPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                    }] }
        ];
        WrappedCell.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['cellPortal',] }]
        };
        return WrappedCell;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridCell = /** @class */ (function () {
        function ClrDatagridCell(hideableColumnService, _el, _renderer, vcr) {
            this.hideableColumnService = hideableColumnService;
            this._el = _el;
            this._renderer = _renderer;
            this.vcr = vcr;
        }
        Object.defineProperty(ClrDatagridCell.prototype, "id", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                this.mapHideableColumn(this._id);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} columnId
         * @return {?}
         */
        ClrDatagridCell.prototype.mapHideableColumn = /**
         * @param {?} columnId
         * @return {?}
         */
            function (columnId) {
                var _this = this;
                if (!columnId) {
                    return;
                }
                /** @type {?} */
                var hideableColumn = this.hideableColumnService.getColumnById(this._id);
                this.setHiddenClass(hideableColumn.hidden);
                this.hiddenStateSubscription = hideableColumn.hiddenChangeState.subscribe(function () {
                    _this.setHiddenClass(hideableColumn.hidden);
                });
            };
        /**
         * @param {?} hideableColumnValue
         * @return {?}
         */
        ClrDatagridCell.prototype.setHiddenClass = /**
         * @param {?} hideableColumnValue
         * @return {?}
         */
            function (hideableColumnValue) {
                if (hideableColumnValue) {
                    this._renderer.addClass(this._el.nativeElement, 'datagrid-cell--hidden');
                }
                else {
                    this._renderer.removeClass(this._el.nativeElement, 'datagrid-cell--hidden');
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridCell.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.wrappedInjector = new HostWrapper(WrappedCell, this.vcr);
            };
        /**
         * @return {?}
         */
        ClrDatagridCell.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.hiddenStateSubscription) {
                    this.hiddenStateSubscription.unsubscribe();
                }
            };
        Object.defineProperty(ClrDatagridCell.prototype, "_view", {
            get: /**
             * @return {?}
             */ function () {
                return this.wrappedInjector.get(WrappedCell, this.vcr).cellView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridCell.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-cell',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.datagrid-cell]': 'true',
                            '[class.datagrid-signpost-trigger]': 'signpost.length > 0',
                            role: 'gridcell',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridCell.ctorParameters = function () {
            return [
                { type: HideableColumnService },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrDatagridCell.propDecorators = {
            signpost: [{ type: i0.ContentChildren, args: [ClrSignpost,] }]
        };
        return ClrDatagridCell;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {number} */
    var DatagridDisplayMode = {
        DISPLAY: 0,
        CALCULATE: 1,
    };
    DatagridDisplayMode[DatagridDisplayMode.DISPLAY] = 'DISPLAY';
    DatagridDisplayMode[DatagridDisplayMode.CALCULATE] = 'CALCULATE';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {number} */
    var DatagridRenderStep = {
        ALIGN_COLUMNS: 0,
        CALCULATE_MODE_ON: 1,
        CALCULATE_MODE_OFF: 2,
        CLEAR_WIDTHS: 3,
        COMPUTE_COLUMN_WIDTHS: 4,
        DETECT_STRICT_WIDTHS: 5,
    };
    DatagridRenderStep[DatagridRenderStep.ALIGN_COLUMNS] = 'ALIGN_COLUMNS';
    DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_ON] = 'CALCULATE_MODE_ON';
    DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_OFF] = 'CALCULATE_MODE_OFF';
    DatagridRenderStep[DatagridRenderStep.CLEAR_WIDTHS] = 'CLEAR_WIDTHS';
    DatagridRenderStep[DatagridRenderStep.COMPUTE_COLUMN_WIDTHS] = 'COMPUTE_COLUMN_WIDTHS';
    DatagridRenderStep[DatagridRenderStep.DETECT_STRICT_WIDTHS] = 'DETECT_STRICT_WIDTHS';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridRenderOrganizer = /** @class */ (function () {
        function DatagridRenderOrganizer() {
            this._renderStep = new rxjs.Subject();
            this.alreadySized = false;
            this.widths = [];
        }
        Object.defineProperty(DatagridRenderOrganizer.prototype, "renderStep", {
            get: /**
             * @return {?}
             */ function () {
                return this._renderStep.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} step
         * @return {?}
         */
        DatagridRenderOrganizer.prototype.filterRenderSteps = /**
         * @param {?} step
         * @return {?}
         */
            function (step) {
                return this.renderStep.pipe(operators.filter(function (testStep) { return step === testStep; }));
            };
        /**
         * @return {?}
         */
        DatagridRenderOrganizer.prototype.resize = /**
         * @return {?}
         */
            function () {
                this.widths.length = 0;
                this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_ON);
                if (this.alreadySized) {
                    this._renderStep.next(DatagridRenderStep.CLEAR_WIDTHS);
                }
                this._renderStep.next(DatagridRenderStep.DETECT_STRICT_WIDTHS);
                this._renderStep.next(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS);
                this._renderStep.next(DatagridRenderStep.ALIGN_COLUMNS);
                this.alreadySized = true;
                this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_OFF);
            };
        DatagridRenderOrganizer.decorators = [
            { type: i0.Injectable }
        ];
        return DatagridRenderOrganizer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DisplayModeService = /** @class */ (function () {
        function DisplayModeService(renderOrganizer) {
            var _this = this;
            this.subscriptions = [];
            this._view = new rxjs.BehaviorSubject(DatagridDisplayMode.DISPLAY);
            this.subscriptions.push(renderOrganizer
                .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_ON)
                .subscribe(function () { return _this._view.next(DatagridDisplayMode.CALCULATE); }));
            this.subscriptions.push(renderOrganizer
                .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_OFF)
                .subscribe(function () { return _this._view.next(DatagridDisplayMode.DISPLAY); }));
        }
        Object.defineProperty(DisplayModeService.prototype, "view", {
            get: /**
             * @return {?}
             */ function () {
                return this._view.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DisplayModeService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        DisplayModeService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DisplayModeService.ctorParameters = function () {
            return [
                { type: DatagridRenderOrganizer }
            ];
        };
        return DisplayModeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbSelection = 0;
    /** @enum {number} */
    var SelectionType = {
        None: 0,
        Single: 1,
        Multi: 2,
    };
    SelectionType[SelectionType.None] = 'None';
    SelectionType[SelectionType.Single] = 'Single';
    SelectionType[SelectionType.Multi] = 'Multi';
    /**
     * @template T
     */
    var Selection = /** @class */ (function () {
        function Selection(_items, _filters) {
            var _this = this;
            this._items = _items;
            this._filters = _filters;
            this.prevSelectionRefs = []; // Refs of selected items
            this._selectionType = SelectionType.None;
            this.rowSelectionMode = false;
            /**
             * Ignore items changes in the same change detection cycle.
             */
            // tslint:disable-next-line
            this.debounce = false;
            /**
             * Subscriptions to the other providers changes.
             */
            this.subscriptions = [];
            /**
             * The Observable that lets other classes subscribe to selection changes
             */
            this._change = new rxjs.Subject();
            this.id = 'clr-dg-selection' + nbSelection++;
            this.subscriptions.push(this._filters.change.subscribe(function () {
                if (!_this._selectable) {
                    return;
                }
                _this.clearSelection();
            }));
            this.subscriptions.push(this._items.allChanges.subscribe(function (updatedItems) {
                switch (_this.selectionType) {
                    case SelectionType.None: {
                        break;
                    }
                    case SelectionType.Single: {
                        /** @type {?} */
                        var newSingle_1;
                        /** @type {?} */
                        var trackBy_1 = _this._items.trackBy;
                        /** @type {?} */
                        var selectionUpdated_1 = false;
                        // if the currentSingle has been set before data was loaded, we look up and save the ref from current data set
                        if (_this.currentSingle && !_this.prevSingleSelectionRef) {
                            if (_this._items.all && _this._items.trackBy) {
                                /** @type {?} */
                                var lookup = _this._items.all.findIndex(function (maybe) { return maybe === _this.currentSingle; });
                                _this.prevSingleSelectionRef = _this._items.trackBy(lookup, _this.currentSingle);
                            }
                        }
                        updatedItems.forEach(function (item, index) {
                            /** @type {?} */
                            var ref = trackBy_1(index, item);
                            // If one of the updated items is the previously selectedSingle, set it as the new one
                            if (_this.prevSingleSelectionRef === ref) {
                                newSingle_1 = item;
                                selectionUpdated_1 = true;
                            }
                        });
                        // If we're using smart datagrids, we expect all items to be present in the updatedItems array.
                        // Therefore, we should delete the currentSingle if it used to be defined but doesn't exist anymore.
                        // No explicit "delete" is required, since newSingle would be undefined at this point.
                        // Marking it as selectionUpdated here will set currentSingle to undefined below in the setTimeout.
                        if (_this._items.smart && !newSingle_1) {
                            selectionUpdated_1 = true;
                        }
                        // TODO: Discussed this with Eudes and this is fine for now.
                        // But we need to figure out a different pattern for the
                        // child triggering the parent change detection problem.
                        // Using setTimeout for now to fix this.
                        setTimeout(function () {
                            if (selectionUpdated_1) {
                                _this.currentSingle = newSingle_1;
                            }
                        }, 0);
                        break;
                    }
                    case SelectionType.Multi: {
                        /** @type {?} */
                        var leftOver_1 = _this.current.slice();
                        /** @type {?} */
                        var trackBy_2 = _this._items.trackBy;
                        /** @type {?} */
                        var selectionUpdated_2 = false;
                        // if the current has been set before data was loaded, we look up and save the ref from current data set
                        if (_this.current.length > 0 && _this.prevSelectionRefs.length !== _this.current.length) {
                            if (_this._items.all && _this._items.trackBy) {
                                _this.prevSelectionRefs = [];
                                _this.current.forEach(function (item) {
                                    /** @type {?} */
                                    var lookup = _this._items.all.findIndex(function (maybe) { return maybe === item; });
                                    _this.prevSelectionRefs.push(_this._items.trackBy(lookup, item));
                                });
                            }
                        }
                        // TODO: revisit this when we work on https://github.com/vmware/clarity/issues/2342
                        // currently, the selection is cleared when filter is applied, so the logic inside
                        // the if statement below results in broken behavior.
                        if (leftOver_1.length > 0) {
                            updatedItems.forEach(function (item, index) {
                                /** @type {?} */
                                var ref = trackBy_2(index, item);
                                // Look in current selected refs array if item is selected, and update actual value
                                /** @type {?} */
                                var selectedIndex = _this.prevSelectionRefs.indexOf(ref);
                                if (selectedIndex > -1) {
                                    leftOver_1[selectedIndex] = item;
                                    selectionUpdated_2 = true;
                                }
                            });
                            // Filter out any unmatched items if we're using smart datagrids where we expect all items to be
                            // present
                            if (_this._items.smart) {
                                leftOver_1 = leftOver_1.filter(function (selected) { return updatedItems.indexOf(selected) > -1; });
                                if (_this.current.length !== leftOver_1.length) {
                                    selectionUpdated_2 = true;
                                }
                            }
                            // TODO: Discussed this with Eudes and this is fine for now.
                            // But we need to figure out a different pattern for the
                            // child triggering the parent change detection problem.
                            // Using setTimeout for now to fix this.
                            setTimeout(function () {
                                if (selectionUpdated_2) {
                                    _this.current = leftOver_1;
                                }
                            }, 0);
                        }
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }));
        }
        /**
         * @return {?}
         */
        Selection.prototype.clearSelection = /**
         * @return {?}
         */
            function () {
                this.current.length = 0;
                this.prevSelectionRefs = [];
                this._currentSingle = null;
                this.prevSingleSelectionRef = null;
                this.emitChange();
            };
        Object.defineProperty(Selection.prototype, "selectionType", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectionType;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === this.selectionType) {
                    return;
                }
                this._selectionType = value;
                if (value === SelectionType.None) {
                    delete this.current;
                }
                else {
                    this.updateCurrent([], false);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "_selectable", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectionType === SelectionType.Multi || this._selectionType === SelectionType.Single;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up our subscriptions to other providers
         */
        /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
        Selection.prototype.destroy = /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        Object.defineProperty(Selection.prototype, "currentSingle", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentSingle;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (value === this._currentSingle) {
                    return;
                }
                this._currentSingle = value;
                if (this._items.all && this._items.trackBy && value) {
                    /** @type {?} */
                    var lookup = this._items.all.findIndex(function (maybe) { return maybe === value; });
                    this.prevSingleSelectionRef = this._items.trackBy(lookup, value);
                }
                this.emitChange();
                // Ignore items changes in the same change detection cycle.
                // @TODO This can likely be removed!
                this.debounce = true;
                setTimeout(function () { return (_this.debounce = false); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.updateCurrent(value, true);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @param {?} emit
         * @return {?}
         */
        Selection.prototype.updateCurrent = /**
         * @param {?} value
         * @param {?} emit
         * @return {?}
         */
            function (value, emit) {
                var _this = this;
                this._current = value;
                if (emit) {
                    this.emitChange();
                    // Ignore items changes in the same change detection cycle.
                    // @TODO This can likely be removed!
                    this.debounce = true;
                    setTimeout(function () { return (_this.debounce = false); });
                }
            };
        /**
         * @return {?}
         */
        Selection.prototype.emitChange = /**
         * @return {?}
         */
            function () {
                if (this._selectionType === SelectionType.Single) {
                    this._change.next(this.currentSingle);
                }
                else if (this._selectionType === SelectionType.Multi) {
                    this._change.next(this.current);
                }
            };
        Object.defineProperty(Selection.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if an item is currently selected
         */
        /**
         * Checks if an item is currently selected
         * @param {?} item
         * @return {?}
         */
        Selection.prototype.isSelected = /**
         * Checks if an item is currently selected
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this._selectionType === SelectionType.Single) {
                    return this.currentSingle === item;
                }
                else if (this._selectionType === SelectionType.Multi) {
                    return this.current.indexOf(item) >= 0;
                }
                return false;
            };
        /**
         * Selects an item
         */
        /**
         * Selects an item
         * @param {?} item
         * @return {?}
         */
        Selection.prototype.selectItem = /**
         * Selects an item
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.current.push(item);
                if (this._items.trackBy) {
                    // Push selected ref onto array
                    /** @type {?} */
                    var lookup = this._items.all.findIndex(function (maybe) { return maybe === item; });
                    this.prevSelectionRefs.push(this._items.trackBy(lookup, item));
                }
            };
        /**
         * Deselects an item
         */
        /**
         * Deselects an item
         * @param {?} indexOfItem
         * @return {?}
         */
        Selection.prototype.deselectItem = /**
         * Deselects an item
         * @param {?} indexOfItem
         * @return {?}
         */
            function (indexOfItem) {
                this.current.splice(indexOfItem, 1);
                if (this._items.trackBy && indexOfItem < this.prevSelectionRefs.length) {
                    // Keep selected refs array in sync
                    this.prevSelectionRefs.splice(indexOfItem, 1);
                }
            };
        /**
         * Selects or deselects an item
         */
        /**
         * Selects or deselects an item
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
        Selection.prototype.setSelected = /**
         * Selects or deselects an item
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
            function (item, selected) {
                switch (this._selectionType) {
                    case SelectionType.None:
                        break;
                    case SelectionType.Single:
                        // in single selection, set currentSingle method should be used
                        break;
                    case SelectionType.Multi:
                        /** @type {?} */
                        var index = this.current.indexOf(item);
                        if (index >= 0 && !selected) {
                            this.deselectItem(index);
                            this.emitChange();
                        }
                        else if (index < 0 && selected) {
                            this.selectItem(item);
                            this.emitChange();
                        }
                        break;
                    default:
                        break;
                }
            };
        /**
         * Checks if all currently displayed items are selected
         */
        /**
         * Checks if all currently displayed items are selected
         * @return {?}
         */
        Selection.prototype.isAllSelected = /**
         * Checks if all currently displayed items are selected
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._selectionType !== SelectionType.Multi || !this._items.displayed) {
                    return false;
                }
                /** @type {?} */
                var displayedItems = this._items.displayed;
                /** @type {?} */
                var nbDisplayed = this._items.displayed.length;
                if (nbDisplayed < 1) {
                    return false;
                }
                /** @type {?} */
                var temp = displayedItems.filter(function (item) { return _this.current.indexOf(item) > -1; });
                return temp.length === displayedItems.length;
            };
        /**
         * Selects or deselects all currently displayed items
         */
        /**
         * Selects or deselects all currently displayed items
         * @return {?}
         */
        Selection.prototype.toggleAll = /**
         * Selects or deselects all currently displayed items
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
                    return;
                }
                /*
                     * If every currently displayed item is already selected, we clear them.
                     * If at least one item isn't selected, we select every currently displayed item.
                     */
                if (this.isAllSelected()) {
                    this._items.displayed.forEach(function (item) {
                        /** @type {?} */
                        var currentIndex = _this.current.indexOf(item);
                        if (currentIndex > -1) {
                            _this.deselectItem(currentIndex);
                        }
                    });
                }
                else {
                    this._items.displayed.forEach(function (item) {
                        if (_this.current.indexOf(item) < 0) {
                            _this.selectItem(item);
                        }
                    });
                }
                this.emitChange();
            };
        Selection.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Selection.ctorParameters = function () {
            return [
                { type: Items },
                { type: FiltersProvider }
            ];
        };
        return Selection;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WrappedRow = /** @class */ (function () {
        function WrappedRow() {
            this._dynamic = false;
        }
        // the rows projected view (in memory)
        /**
         * @return {?}
         */
        WrappedRow.prototype.ngAfterViewInit =
            // the rows projected view (in memory)
            /**
             * @return {?}
             */
            function () {
                // Create the cells view in memory, not the DOM.
                this.rowView = this.templateRef.createEmbeddedView(null);
            };
        WrappedRow.decorators = [
            { type: i0.Component, args: [{
                        selector: 'dg-wrapped-row',
                        template: "        \n        <ng-template #rowPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                    }] }
        ];
        WrappedRow.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['rowPortal',] }]
        };
        return WrappedRow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbRow = 0;
    /**
     * @template T
     */
    var ClrDatagridRow = /** @class */ (function () {
        function ClrDatagridRow(selection, rowActionService, globalExpandable, expand, hideableColumnService, displayMode, vcr, renderer, el, commonStrings) {
            var _this = this;
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.globalExpandable = globalExpandable;
            this.expand = expand;
            this.hideableColumnService = hideableColumnService;
            this.displayMode = displayMode;
            this.vcr = vcr;
            this.renderer = renderer;
            this.el = el;
            this.commonStrings = commonStrings;
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
            this._selected = false;
            this.selectedChanged = new i0.EventEmitter(false);
            this.expandedChange = new i0.EventEmitter(false);
            this.subscriptions = [];
            this.displayCells = false;
            nbRow++;
            this.id = 'clr-dg-row' + nbRow;
            this.radioId = 'clr-dg-row-rd' + nbRow;
            this.checkboxId = 'clr-dg-row-cb' + nbRow;
            this.subscriptions.push(rxjs.combineLatest(this.expand.replace, this.expand.expandChange).subscribe(function (_a) {
                var _b = __read(_a, 2), expandReplaceValue = _b[0], expandChangeValue = _b[1];
                if (expandReplaceValue && expandChangeValue) {
                    // replaced and expanding
                    _this.replaced = true;
                    _this.renderer.addClass(_this.el.nativeElement, 'datagrid-row-replaced');
                }
                else {
                    _this.replaced = false;
                    // Handles these cases: not replaced and collapsing & replaced and
                    // collapsing and not replaced and expanding.
                    _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-row-replaced');
                }
            }));
        }
        Object.defineProperty(ClrDatagridRow.prototype, "selected", {
            /**
             * Indicates if the row is selected
             */
            get: /**
             * Indicates if the row is selected
             * @return {?}
             */ function () {
                if (this.selection.selectionType === SelectionType.None) {
                    return this._selected;
                }
                else {
                    return this.selection.isSelected(this.item);
                }
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.selection.selectionType === SelectionType.None) {
                    this._selected = value;
                }
                else {
                    this.selection.setSelected(this.item, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?=} selected
         * @return {?}
         */
        ClrDatagridRow.prototype.toggle = /**
         * @param {?=} selected
         * @return {?}
         */
            function (selected) {
                if (selected === void 0) {
                    selected = !this.selected;
                }
                if (selected !== this.selected) {
                    this.selected = selected;
                    this.selectedChanged.emit(selected);
                }
            };
        Object.defineProperty(ClrDatagridRow.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this.expand.expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.expand.expanded = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                if (this.expand.expandable) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Make sure things get started
                /** @type {?} */
                var columnsList = this.hideableColumnService.getColumns();
                this.updateCellsForColumns(columnsList);
                // Triggered when the Cells list changes per row-renderer
                this.dgCells.changes.subscribe(function (cellList) {
                    /** @type {?} */
                    var columnList = _this.hideableColumnService.getColumns();
                    if (cellList.length === columnList.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                });
                // Used to set things up the first time but only after all the columns are ready.
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
                    // Prevents cell updates when cols and cells array are not aligned - only seems to run on init / first time.
                    if (columnList.length === _this.dgCells.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                }));
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.displayMode.view.subscribe(function (viewChange) {
                    // Listen for view changes and move cells around depending on the current displayType
                    // remove cell views from display view
                    for (var i = _this._scrollableCells.length; i > 0; i--) {
                        _this._scrollableCells.detach();
                    }
                    // remove cell views from calculated view
                    for (var i = _this._calculatedCells.length; i > 0; i--) {
                        _this._calculatedCells.detach();
                    }
                    if (viewChange === DatagridDisplayMode.CALCULATE) {
                        _this.displayCells = false;
                        _this.dgCells.forEach(function (cell) {
                            _this._calculatedCells.insert(cell._view);
                        });
                    }
                    else {
                        _this.displayCells = true;
                        _this.dgCells.forEach(function (cell) {
                            _this._scrollableCells.insert(cell._view);
                        });
                    }
                }));
            };
        /**********
         *
         * @description
         * 1. Maps the new columnListChange to the dgCells list by index
         * 2. Sets the hidden state on the cell
         * Take a Column list and use index to access the columns for hideable properties.
         *
         */
        /**
         * *******
         *
         * \@description
         * 1. Maps the new columnListChange to the dgCells list by index
         * 2. Sets the hidden state on the cell
         * Take a Column list and use index to access the columns for hideable properties.
         *
         * @param {?} columnList
         * @return {?}
         */
        ClrDatagridRow.prototype.updateCellsForColumns = /**
         * *******
         *
         * \@description
         * 1. Maps the new columnListChange to the dgCells list by index
         * 2. Sets the hidden state on the cell
         * Take a Column list and use index to access the columns for hideable properties.
         *
         * @param {?} columnList
         * @return {?}
         */
            function (columnList) {
                // Map cells to columns with Array.index
                this.dgCells.forEach(function (cell, index) {
                    /** @type {?} */
                    var currentColumn = columnList[index];
                    if (currentColumn) {
                        cell.id = currentColumn.id;
                    }
                });
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.wrappedInjector = new HostWrapper(WrappedRow, this.vcr);
            };
        Object.defineProperty(ClrDatagridRow.prototype, "_view", {
            get: /**
             * @return {?}
             */ function () {
                return this.wrappedInjector.get(WrappedRow, this.vcr).rowView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRow.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-row',
                        template: "<!--\n  We need to wrap the #rowContent in label element if we are in rowSelectionMode.\n  Clicking of that wrapper label will equate to clicking on the whole row, which triggers the checkbox to toggle.\n-->\n<label class=\"datagrid-row-clickable\" *ngIf=\"selection.rowSelectionMode\">\n  <ng-template [ngTemplateOutlet]=\"rowContent\"></ng-template>\n</label>\n\n<ng-template *ngIf=\"!selection.rowSelectionMode\" [ngTemplateOutlet]=\"rowContent\"></ng-template>\n\n<!--\n    We need the \"project into template\" hacks because we need this in 2 different places\n    depending on whether the details replace the row or not.\n-->\n<ng-template #detail>\n  <ng-content select=\"clr-dg-row-detail\"></ng-content>\n</ng-template>\n\n<ng-template #rowContent>\n  <div role=\"row\" [id]=\"id\" class=\"datagrid-row-master datagrid-row-flex\">\n    <div class=\"datagrid-row-sticky\">\n      <!-- Sticky elements here -->\n      <ng-container #stickyCells></ng-container> <!-- placeholder for projecting other sticky cells as pinned-->\n    </div>\n    <div class=\"datagrid-row-scrollable\" [ngClass]=\"{'is-replaced': replaced && expanded}\">\n      <div class=\"datagrid-scrolling-cells\">\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\" role=\"gridcell\">\n          <input clrCheckbox type=\"checkbox\" [ngModel]=\"selected\" (ngModelChange)=\"toggle($event)\" [id]=\"checkboxId\"\n                 [attr.aria-label]=\"commonStrings.keys.select\">\n        </div>\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\" role=\"gridcell\">\n            <!-- TODO: it would be better if in addition to the generic \"Select\" label, we could add aria-labelledby\n            to label the radio by the first cell in the row (typically an id or name).\n            It's pretty easy to label it with the whole row since we already have an id for it, but in most\n            cases the row is far too long to serve as a label, the screenreader reads every single cell content. -->\n            <input type=\"radio\" clrRadio [id]=\"radioId\" [name]=\"selection.id + '-radio'\" [value]=\"item\"\n                   [(ngModel)]=\"selection.currentSingle\" [checked]=\"selection.currentSingle === item\"\n                   [attr.aria-label]=\"commonStrings.keys.select\">\n        </div>\n        <div *ngIf=\"rowActionService.hasActionableRow\"\n             class=\"datagrid-row-actions datagrid-fixed-column datagrid-cell\" role=\"gridcell\">\n          <ng-content select=\"clr-dg-action-overflow\"></ng-content>\n        </div>\n        <div *ngIf=\"globalExpandable.hasExpandableRow\"\n             class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\" role=\"gridcell\">\n          <ng-container *ngIf=\"expand.expandable\">\n            <button (click)=\"toggleExpand()\" *ngIf=\"!expand.loading\" type=\"button\" class=\"datagrid-expandable-caret-button\">\n              <clr-icon shape=\"caret\"\n                        class=\"datagrid-expandable-caret-icon\"\n                        [attr.dir]=\"expand.expanded ? 'down' : 'right'\"\n                        [attr.title]=\"expand.expanded ? commonStrings.keys.collapse : commonStrings.keys.expand\"></clr-icon>\n            </button>\n            <clr-spinner *ngIf=\"expand.loading\" clrSmall>{{ commonStrings.keys.loading }}</clr-spinner>\n          </ng-container>\n        </div>\n        <ng-container #scrollableCells></ng-container>\n      </div>\n      <!-- details here when replace, re-visit when sticky container is used for pinned cells -->\n      <ng-template *ngIf=\"replaced && !expand.loading\"\n                   [ngTemplateOutlet]=\"detail\"></ng-template>\n    </div>\n    <ng-template *ngIf=\"!replaced && !expand.loading\"\n                 [ngTemplateOutlet]=\"detail\"></ng-template>\n  </div>\n</ng-template>\n\n<ng-container #calculatedCells></ng-container>\n",
                        host: {
                            '[class.datagrid-row]': 'true',
                            '[class.datagrid-selected]': 'selected',
                            '[attr.aria-owns]': 'id',
                            role: 'rowgroup',
                        },
                        providers: [Expand, { provide: LoadingListener, useExisting: Expand }]
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridRow.ctorParameters = function () {
            return [
                { type: Selection },
                { type: RowActionService },
                { type: ExpandableRowsCount },
                { type: Expand },
                { type: HideableColumnService },
                { type: DisplayModeService },
                { type: i0.ViewContainerRef },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: ClrCommonStringsService }
            ];
        };
        ClrDatagridRow.propDecorators = {
            item: [{ type: i0.Input, args: ['clrDgItem',] }],
            selected: [{ type: i0.Input, args: ['clrDgSelected',] }],
            selectedChanged: [{ type: i0.Output, args: ['clrDgSelectedChange',] }],
            expanded: [{ type: i0.Input, args: ['clrDgExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrDgExpandedChange',] }],
            dgCells: [{ type: i0.ContentChildren, args: [ClrDatagridCell,] }],
            _stickyCells: [{ type: i0.ViewChild, args: ['stickyCells', { read: i0.ViewContainerRef },] }],
            _scrollableCells: [{ type: i0.ViewChild, args: ['scrollableCells', { read: i0.ViewContainerRef },] }],
            _calculatedCells: [{ type: i0.ViewChild, args: ['calculatedCells', { read: i0.ViewContainerRef },] }]
        };
        return ClrDatagridRow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ColumnToggleButtonsService = /** @class */ (function () {
        function ColumnToggleButtonsService() {
            this.buttons = null;
            this.selectAllDisabled = false;
            this._selectAllButtonClicked = new rxjs.Subject();
        }
        Object.defineProperty(ColumnToggleButtonsService.prototype, "selectAllButtonClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectAllButtonClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColumnToggleButtonsService.prototype.buttonClicked = /**
         * @return {?}
         */
            function () {
                this._selectAllButtonClicked.next();
            };
        ColumnToggleButtonsService.decorators = [
            { type: i0.Injectable }
        ];
        return ColumnToggleButtonsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This provider aggregates state changes from the various providers of the Datagrid
     * @template T
     */
    var StateProvider = /** @class */ (function () {
        function StateProvider(filters, sort, page, debouncer) {
            var _this = this;
            this.filters = filters;
            this.sort = sort;
            this.page = page;
            this.debouncer = debouncer;
            /**
             * The Observable that lets other classes subscribe to global state changes
             */
            this.change = this.debouncer.change.pipe(operators.map(function () { return _this.state; }));
        }
        Object.defineProperty(StateProvider.prototype, "state", {
            /*
               * By making this a getter, we open the possibility for a setter in the future.
               * It's been requested a couple times.
               */
            get: /*
                 * By making this a getter, we open the possibility for a setter in the future.
                 * It's been requested a couple times.
                 */ 
            /**
             * @return {?}
             */
            function () {
                var e_1, _a;
                /** @type {?} */
                var state = {};
                if (this.page.size > 0) {
                    state.page = {
                        from: this.page.firstItem,
                        to: this.page.lastItem,
                        size: this.page.size,
                        current: this.page.current,
                    };
                }
                if (this.sort.comparator) {
                    if (this.sort.comparator instanceof DatagridPropertyComparator) {
                        /*
                                 * Special case for the default object property comparator,
                                 * we give the property name instead of the actual comparator.
                                 */
                        state.sort = { by: (( /** @type {?} */(this.sort.comparator))).prop, reverse: this.sort.reverse };
                    }
                    else {
                        state.sort = { by: this.sort.comparator, reverse: this.sort.reverse };
                    }
                }
                /** @type {?} */
                var activeFilters = this.filters.getActiveFilters();
                if (activeFilters.length > 0) {
                    state.filters = [];
                    try {
                        for (var activeFilters_1 = __values(activeFilters), activeFilters_1_1 = activeFilters_1.next(); !activeFilters_1_1.done; activeFilters_1_1 = activeFilters_1.next()) {
                            var filter = activeFilters_1_1.value;
                            if (filter.state) {
                                state.filters.push(filter.state);
                            }
                            else {
                                state.filters.push(filter);
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (activeFilters_1_1 && !activeFilters_1_1.done && (_a = activeFilters_1.return))
                                _a.call(activeFilters_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                }
                return state;
            },
            enumerable: true,
            configurable: true
        });
        StateProvider.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        StateProvider.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: Sort },
                { type: Page },
                { type: StateDebouncer }
            ];
        };
        return StateProvider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * \@description
     * Internal datagrid service that holds a reference to the clr-dg-table element and exposes a method to get height.
     */
    var TableSizeService = /** @class */ (function () {
        function TableSizeService(platformId) {
            this.platformId = platformId;
        }
        Object.defineProperty(TableSizeService.prototype, "tableRef", {
            get: /**
             * @return {?}
             */ function () {
                return this._tableRef;
            },
            set: /**
             * @param {?} element
             * @return {?}
             */ function (element) {
                this._tableRef = element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableSizeService.prototype, "table", {
            set: /**
             * @param {?} table
             * @return {?}
             */ function (table) {
                if (common.isPlatformBrowser(this.platformId) && table.nativeElement) {
                    this.tableRef = table.nativeElement.querySelector('.datagrid-table');
                }
            },
            enumerable: true,
            configurable: true
        });
        // Used when resizing columns to show the column border being dragged.
        // Used when resizing columns to show the column border being dragged.
        /**
         * @return {?}
         */
        TableSizeService.prototype.getColumnDragHeight =
            // Used when resizing columns to show the column border being dragged.
            /**
             * @return {?}
             */
            function () {
                if (!this.tableRef) {
                    return;
                }
                return this.tableRef.clientHeight + "px";
            };
        TableSizeService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        TableSizeService.ctorParameters = function () {
            return [
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        return TableSizeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagrid = /** @class */ (function () {
        function ClrDatagrid(columnService, organizer, items, expandableRows, selection, rowActionService, stateProvider, displayMode, renderer, el, page, commonStrings) {
            this.columnService = columnService;
            this.organizer = organizer;
            this.items = items;
            this.expandableRows = expandableRows;
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.stateProvider = stateProvider;
            this.displayMode = displayMode;
            this.renderer = renderer;
            this.el = el;
            this.page = page;
            this.commonStrings = commonStrings;
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
            /**
             * Output emitted whenever the data needs to be refreshed, based on user action or external ones
             */
            this.refresh = new i0.EventEmitter(false);
            this.selectedChanged = new i0.EventEmitter(false);
            this.singleSelectedChanged = new i0.EventEmitter(false);
            this.clrDgSingleSelectionAriaLabel = this.commonStrings.keys.singleSelectionAriaLabel;
            this.clrDgSingleActionableAriaLabel = this.commonStrings.keys.singleActionableAriaLabel;
            this.clrDetailExpandableAriaLabel = this.commonStrings.keys.detailExpandableAriaLabel;
            /**
             * Subscriptions to all the services and queries changes
             */
            this._subscriptions = [];
        }
        Object.defineProperty(ClrDatagrid.prototype, "loading", {
            /**
             * Freezes the datagrid while data is loading
             */
            get: /**
             * Freezes the datagrid while data is loading
             * @return {?}
             */ function () {
                return this.items.loading;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.items.loading = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Public method to re-trigger the computation of displayed items manually
         */
        /**
         * Public method to re-trigger the computation of displayed items manually
         * @return {?}
         */
        ClrDatagrid.prototype.dataChanged = /**
         * Public method to re-trigger the computation of displayed items manually
         * @return {?}
         */
            function () {
                this.items.refresh();
            };
        Object.defineProperty(ClrDatagrid.prototype, "selected", {
            /**
             * Array of all selected items
             */
            set: /**
             * Array of all selected items
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this.selection.selectionType = SelectionType.Multi;
                }
                else {
                    this.selection.selectionType = SelectionType.None;
                }
                this.selection.updateCurrent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "singleSelected", {
            /**
             * Selected item in single-select mode
             */
            set: /**
             * Selected item in single-select mode
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.selection.selectionType = SelectionType.Single;
                // the clrDgSingleSelected is updated in one of two cases:
                // 1. an explicit value is passed
                // 2. is being set to null or undefined, where previously it had a value
                if (value) {
                    this.selection.currentSingle = value;
                }
                else if (this.selection.currentSingle) {
                    this.selection.currentSingle = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "rowSelectionMode", {
            /**
             * Selection/Deselection on row click mode
             */
            set: /**
             * Selection/Deselection on row click mode
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.selection.rowSelectionMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "allSelected", {
            /**
             * Indicates if all currently displayed items are selected
             */
            get: /**
             * Indicates if all currently displayed items are selected
             * @return {?}
             */ function () {
                return this.selection.isAllSelected();
            },
            /**
             * Selects/deselects all currently displayed items
             * @param value
             */
            set: /**
             * Selects/deselects all currently displayed items
             * @param {?} value
             * @return {?}
             */ function (value) {
                /*
                     * This is a setter but we ignore the value.
                     * It's strange, but it lets us have an indeterminate state where only
                     * some of the items are selected.
                     */
                this.selection.toggleAll();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagrid.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.items.smart) {
                    this.items.all = this.rows.map(function (row) { return row.item; });
                }
                this._subscriptions.push(this.rows.changes.subscribe(function () {
                    if (!_this.items.smart) {
                        _this.items.all = _this.rows.map(function (row) { return row.item; });
                    }
                    _this.rows.forEach(function (row) {
                        _this._displayedRows.insert(row._view);
                    });
                }));
                this._subscriptions.push(this.columns.changes.subscribe(function (columns) {
                    _this.columnService.updateColumnList(_this.columns.map(function (col) { return col.hideable; }));
                }));
                // Get ColumnService ready for HideableColumns.
                this.columnService.updateColumnList(this.columns.map(function (col) { return col.hideable; }));
            };
        /**
         * Our setup happens in the view of some of our components, so we wait for it to be done before starting
         */
        /**
         * Our setup happens in the view of some of our components, so we wait for it to be done before starting
         * @return {?}
         */
        ClrDatagrid.prototype.ngAfterViewInit = /**
         * Our setup happens in the view of some of our components, so we wait for it to be done before starting
         * @return {?}
         */
            function () {
                var _this = this;
                // TODO: determine if we can get rid of provider wiring in view init so that subscriptions can be done earlier
                this.refresh.emit(this.stateProvider.state);
                this._subscriptions.push(this.stateProvider.change.subscribe(function (state) { return _this.refresh.emit(state); }), this.selection.change.subscribe(function (s) {
                    if (_this.selection.selectionType === SelectionType.Single) {
                        _this.singleSelectedChanged.emit(( /** @type {?} */(s)));
                    }
                    else if (_this.selection.selectionType === SelectionType.Multi) {
                        _this.selectedChanged.emit(( /** @type {?} */(s)));
                    }
                }), this.page.change.subscribe(function () {
                    _this.datagridTable.nativeElement.focus();
                }), 
                // A subscription that listens for displayMode changes on the datagrid
                this.displayMode.view.subscribe(function (viewChange) {
                    // Remove any projected columns from the projectedDisplayColumns container
                    for (var i = _this._projectedDisplayColumns.length; i > 0; i--) {
                        _this._projectedDisplayColumns.detach();
                    }
                    // Remove any projected columns from the projectedCalculationColumns container
                    for (var i = _this._projectedCalculationColumns.length; i > 0; i--) {
                        _this._projectedCalculationColumns.detach();
                    }
                    // Remove any projected rows from the calculationRows container
                    for (var i = _this._calculationRows.length; i > 0; i--) {
                        _this._calculationRows.detach();
                    }
                    // Remove any projected rows from the displayedRows container
                    for (var i = _this._displayedRows.length; i > 0; i--) {
                        _this._displayedRows.detach();
                    }
                    if (viewChange === DatagridDisplayMode.DISPLAY) {
                        // Set state, style for the datagrid to DISPLAY and insert row & columns into containers
                        _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                        _this.columns.forEach(function (column) {
                            _this._projectedDisplayColumns.insert(column._view);
                        });
                        _this.rows.forEach(function (row) {
                            _this._displayedRows.insert(row._view);
                        });
                    }
                    else {
                        // Set state, style for the datagrid to CALCULATE and insert row & columns into containers
                        _this.renderer.addClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                        _this.columns.forEach(function (column) {
                            _this._projectedCalculationColumns.insert(column._view);
                        });
                        _this.rows.forEach(function (row) {
                            _this._calculationRows.insert(row._view);
                        });
                    }
                }));
            };
        /**
         * @return {?}
         */
        ClrDatagrid.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        ClrDatagrid.prototype.resize = /**
         * @return {?}
         */
            function () {
                this.organizer.resize();
            };
        ClrDatagrid.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-datagrid',
                        template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-content select=\"clr-dg-action-bar\"></ng-content>\n<div class=\"datagrid\" #datagrid>\n    <div class=\"datagrid-table-wrapper\">\n      <div role=\"grid\" class=\"datagrid-table\" tabindex=\"-1\" #datagridTable>\n        <div role=\"rowgroup\" class=\"datagrid-header\">\n          <div role=\"row\" class=\"datagrid-row\">\n            <div class=\"datagrid-row-master datagrid-row-flex\">\n              <div class=\"datagrid-row-sticky\">\n                <!-- Sticky elements here -->\n              </div>\n              <div class=\"datagrid-row-scrollable\">\n                <!--header for datagrid where you can select multiple rows -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                     *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n                            <span class=\"datagrid-column-title\">\n                                <input clrCheckbox type=\"checkbox\" [(ngModel)]=\"allSelected\"\n                                       [attr.aria-label]=\"commonStrings.keys.selectAll\">\n                            </span>\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <!-- header for datagrid where you can select one row only -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                     *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\" [attr.aria-label]=\"clrDgSingleSelectionAriaLabel\">\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <!-- header for single row action; only displayType if we have at least one actionable row in datagrid -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-row-actions datagrid-fixed-column\"\n                     *ngIf=\"rowActionService.hasActionableRow\" [attr.aria-label]=\"clrDgSingleActionableAriaLabel\">\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <!-- header for carets; only displayType if we have at least one expandable row in datagrid -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-expandable-caret datagrid-fixed-column\"\n                     *ngIf=\"expandableRows.hasExpandableRow\" [attr.aria-label]=\"clrDetailExpandableAriaLabel\">\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <ng-container #projectedDisplayColumns></ng-container>\n              </div>\n            </div>\n          </div>\n        </div>\n        <ng-container #displayedRows></ng-container>\n        <!-- Custom placeholder overrides the default empty one -->\n        <ng-content select=\"clr-dg-placeholder\"></ng-content>\n        <clr-dg-placeholder *ngIf=\"!placeholder\"></clr-dg-placeholder>\n      </div>\n    </div>\n</div>\n<ng-content select=\"clr-dg-footer\"></ng-content>\n<div class=\"datagrid-spinner\" *ngIf=\"loading\">\n    <clr-spinner clrMedium>Loading</clr-spinner>\n</div>\n\n<div class=\"datagrid-calculation-table\">\n    <div class=\"datagrid-calculation-header\">\n        <ng-container #projectedCalculationColumns></ng-container>\n    </div>\n    <ng-container #calculationRows></ng-container>\n</div>\n",
                        providers: [
                            Selection,
                            Sort,
                            FiltersProvider,
                            Page,
                            Items,
                            DatagridRenderOrganizer,
                            RowActionService,
                            ExpandableRowsCount,
                            HideableColumnService,
                            StateDebouncer,
                            StateProvider,
                            ColumnToggleButtonsService,
                            TableSizeService,
                            DisplayModeService,
                        ],
                        host: { '[class.datagrid-host]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagrid.ctorParameters = function () {
            return [
                { type: HideableColumnService },
                { type: DatagridRenderOrganizer },
                { type: Items },
                { type: ExpandableRowsCount },
                { type: Selection },
                { type: RowActionService },
                { type: StateProvider },
                { type: DisplayModeService },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: Page },
                { type: ClrCommonStringsService }
            ];
        };
        ClrDatagrid.propDecorators = {
            loading: [{ type: i0.Input, args: ['clrDgLoading',] }],
            refresh: [{ type: i0.Output, args: ['clrDgRefresh',] }],
            iterator: [{ type: i0.ContentChild, args: [ClrDatagridItems,] }],
            selected: [{ type: i0.Input, args: ['clrDgSelected',] }],
            selectedChanged: [{ type: i0.Output, args: ['clrDgSelectedChange',] }],
            singleSelected: [{ type: i0.Input, args: ['clrDgSingleSelected',] }],
            singleSelectedChanged: [{ type: i0.Output, args: ['clrDgSingleSelectedChange',] }],
            clrDgSingleSelectionAriaLabel: [{ type: i0.Input }],
            clrDgSingleActionableAriaLabel: [{ type: i0.Input }],
            clrDetailExpandableAriaLabel: [{ type: i0.Input }],
            rowSelectionMode: [{ type: i0.Input, args: ['clrDgRowSelection',] }],
            placeholder: [{ type: i0.ContentChild, args: [ClrDatagridPlaceholder,] }],
            columns: [{ type: i0.ContentChildren, args: [ClrDatagridColumn,] }],
            rows: [{ type: i0.ContentChildren, args: [ClrDatagridRow,] }],
            scrollableColumns: [{ type: i0.ViewChild, args: ['scrollableColumns', { read: i0.ViewContainerRef },] }],
            datagridTable: [{ type: i0.ViewChild, args: ['datagridTable', { read: i0.ElementRef },] }],
            _projectedDisplayColumns: [{ type: i0.ViewChild, args: ['projectedDisplayColumns', { read: i0.ViewContainerRef },] }],
            _projectedCalculationColumns: [{ type: i0.ViewChild, args: ['projectedCalculationColumns', { read: i0.ViewContainerRef },] }],
            _displayedRows: [{ type: i0.ViewChild, args: ['displayedRows', { read: i0.ViewContainerRef },] }],
            _calculationRows: [{ type: i0.ViewChild, args: ['calculationRows', { read: i0.ViewContainerRef },] }]
        };
        return ClrDatagrid;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridActionBar = /** @class */ (function () {
        function ClrDatagridActionBar() {
        }
        ClrDatagridActionBar.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-action-bar',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: { '[class.datagrid-action-bar]': 'true' }
                    }] }
        ];
        return ClrDatagridActionBar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var clrDgActionId = 0;
    var ClrDatagridActionOverflow = /** @class */ (function () {
        function ClrDatagridActionOverflow(rowActionService, commonStrings, elementRef, platformId, zone) {
            this.rowActionService = rowActionService;
            this.commonStrings = commonStrings;
            this.elementRef = elementRef;
            this.platformId = platformId;
            this.zone = zone;
            this.anchorPoint = Point.RIGHT_CENTER;
            this.popoverPoint = Point.LEFT_CENTER;
            /**
             * Tracks whether the action overflow menu is open or not
             */
            this._open = false;
            this.openChanged = new i0.EventEmitter(false);
            this.rowActionService.register();
            this.popoverId = 'clr-action-menu' + clrDgActionId++;
        }
        /**
         * @return {?}
         */
        ClrDatagridActionOverflow.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.rowActionService.unregister();
            };
        Object.defineProperty(ClrDatagridActionOverflow.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._open;
            },
            set: /**
             * @param {?} open
             * @return {?}
             */ function (open) {
                var _this = this;
                /** @type {?} */
                var boolOpen = !!open;
                if (boolOpen !== this._open) {
                    this._open = boolOpen;
                    this.openChanged.emit(boolOpen);
                    if (boolOpen && common.isPlatformBrowser(this.platformId)) {
                        this.zone.runOutsideAngular(function () {
                            setTimeout(function () {
                                /** @type {?} */
                                var firstButton = _this.elementRef.nativeElement.querySelector('button.action-item');
                                if (firstButton) {
                                    firstButton.focus();
                                }
                            });
                        });
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Shows/hides the action overflow menu
         */
        /**
         * Shows/hides the action overflow menu
         * @param {?} event
         * @return {?}
         */
        ClrDatagridActionOverflow.prototype.toggle = /**
         * Shows/hides the action overflow menu
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.openingEvent = event;
                this.open = !this.open;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ClrDatagridActionOverflow.prototype.close = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /*
                     * Because this listener is added synchronously, before the event finishes bubbling up the DOM,
                     * we end up firing on the very click that just opened the menu,
                     * potentially closing it immediately every time. So we just ignore it.
                     */
                if (event === this.openingEvent) {
                    delete this.openingEvent;
                    return;
                }
                this.open = false;
            };
        ClrDatagridActionOverflow.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-action-overflow',
                        template: "\n        <button (click)=\"toggle($event)\" type=\"button\" class=\"datagrid-action-toggle\" #anchor role=\"button\" \n                    aria-haspopup=\"true\" [attr.aria-controls]=\"popoverId\" [attr.aria-expanded]=\"open\">\n            <clr-icon shape=\"ellipsis-vertical\" [attr.title]=\"commonStrings.keys.rowActions\"></clr-icon>\n        </button>\n        <ng-template [(clrPopoverOld)]=\"open\" [clrPopoverOldAnchor]=\"anchor\" [clrPopoverOldAnchorPoint]=\"anchorPoint\"\n                     [clrPopoverOldPopoverPoint]=\"popoverPoint\">\n            <div class=\"datagrid-action-overflow\" (clrOutsideClick)=\"close($event)\" [clrStrict]=\"true\" \n                    role=\"menu\" [attr.id]=\"popoverId\" [attr.aria-hidden]=\"!open\">\n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridActionOverflow.ctorParameters = function () {
            return [
                { type: RowActionService },
                { type: ClrCommonStringsService },
                { type: i0.ElementRef },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: i0.NgZone }
            ];
        };
        ClrDatagridActionOverflow.propDecorators = {
            open: [{ type: i0.Input, args: ['clrDgActionOverflowOpen',] }],
            openChanged: [{ type: i0.Output, args: ['clrDgActionOverflowOpenChange',] }]
        };
        return ClrDatagridActionOverflow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MIN_COLUMN_WIDTH = 96;
    // This service allows DatagridHeaderRenderer and ClrDatagridColumnSeparator
    // to share column resize data with each other.
    var ColumnResizerService = /** @class */ (function () {
        function ColumnResizerService(el, domAdapter, organizer) {
            this.el = el;
            this.domAdapter = domAdapter;
            this.organizer = organizer;
            this._resizedBy = 0;
        }
        Object.defineProperty(ColumnResizerService.prototype, "resizedBy", {
            get: /**
             * @return {?}
             */ function () {
                return this._resizedBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnResizerService.prototype, "minColumnWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.domAdapter.minWidth(this.el.nativeElement) || MIN_COLUMN_WIDTH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnResizerService.prototype, "maxResizeRange", {
            get: /**
             * @return {?}
             */ function () {
                return this.widthBeforeResize - this.minColumnWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColumnResizerService.prototype.startResize = /**
         * @return {?}
         */
            function () {
                this._resizedBy = 0;
                this.isWithinMaxResizeRange = true;
                this.widthBeforeResize = this.domAdapter.clientRect(this.el.nativeElement).width;
            };
        /**
         * @return {?}
         */
        ColumnResizerService.prototype.endResize = /**
         * @return {?}
         */
            function () {
                this.organizer.resize();
            };
        Object.defineProperty(ColumnResizerService.prototype, "widthAfterResize", {
            get: /**
             * @return {?}
             */ function () {
                return this.widthBeforeResize + this._resizedBy;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        ColumnResizerService.prototype.calculateResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var moveX = event.dragPosition.moveX;
                // returns the resize amount within the allowed range
                if (moveX < -this.maxResizeRange) {
                    this._resizedBy = -this.maxResizeRange;
                    this.isWithinMaxResizeRange = false;
                }
                else {
                    this._resizedBy = moveX;
                    this.isWithinMaxResizeRange = true;
                }
            };
        ColumnResizerService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        ColumnResizerService.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DomAdapter },
                { type: DatagridRenderOrganizer }
            ];
        };
        return ColumnResizerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NB_INSTANCES = 0;
    /** @type {?} */
    var UNIQUE_ID = new i0.InjectionToken('UNIQUE_ID');
    /**
     * @return {?}
     */
    function uniqueIdFactory() {
        return 'clr-id-' + NB_INSTANCES++;
    }
    /** @type {?} */
    var UNIQUE_ID_PROVIDER = {
        provide: UNIQUE_ID,
        useFactory: uniqueIdFactory,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridColumnSeparator = /** @class */ (function () {
        // Every column draggable separator should have its own unique ID
        // in order to not conflict with other draggables/droppables.
        function ClrDatagridColumnSeparator(columnResizerService, renderer, tableSizeService, document, columnSeparatorId) {
            this.columnResizerService = columnResizerService;
            this.renderer = renderer;
            this.tableSizeService = tableSizeService;
            this.document = document;
            this.columnSeparatorId = columnSeparatorId;
        }
        /**
         * @param {?} resizeTrackerEl
         * @return {?}
         */
        ClrDatagridColumnSeparator.prototype.showTracker = /**
         * @param {?} resizeTrackerEl
         * @return {?}
         */
            function (resizeTrackerEl) {
                this.columnResizerService.startResize();
                /** @type {?} */
                var tableHeight = this.tableSizeService.getColumnDragHeight();
                this.renderer.setStyle(resizeTrackerEl, 'height', tableHeight);
                this.renderer.setStyle(resizeTrackerEl, 'display', 'block');
            };
        /**
         * @param {?} event
         * @param {?} resizeTrackerEl
         * @return {?}
         */
        ClrDatagridColumnSeparator.prototype.moveTracker = /**
         * @param {?} event
         * @param {?} resizeTrackerEl
         * @return {?}
         */
            function (event, resizeTrackerEl) {
                this.columnResizerService.calculateResize(event);
                this.renderer.setStyle(resizeTrackerEl, 'transform', "translateX(" + this.columnResizerService.resizedBy + "px)");
                this.renderer.setStyle(this.document.body, 'cursor', 'col-resize');
                this.redFlagTracker(resizeTrackerEl);
            };
        /**
         * @param {?} resizeTrackerEl
         * @return {?}
         */
        ClrDatagridColumnSeparator.prototype.hideTracker = /**
         * @param {?} resizeTrackerEl
         * @return {?}
         */
            function (resizeTrackerEl) {
                this.columnResizerService.endResize();
                this.renderer.setStyle(resizeTrackerEl, 'display', 'none');
                this.renderer.setStyle(resizeTrackerEl, 'transform', "translateX(0px)");
                this.renderer.setStyle(this.document.body, 'cursor', 'auto');
            };
        /**
         * @param {?} resizeTrackerEl
         * @return {?}
         */
        ClrDatagridColumnSeparator.prototype.redFlagTracker = /**
         * @param {?} resizeTrackerEl
         * @return {?}
         */
            function (resizeTrackerEl) {
                /** @type {?} */
                var isWithinMaxResizeRange;
                if (isWithinMaxResizeRange !== this.columnResizerService.isWithinMaxResizeRange) {
                    isWithinMaxResizeRange = this.columnResizerService.isWithinMaxResizeRange;
                    if (!isWithinMaxResizeRange) {
                        this.renderer.addClass(resizeTrackerEl, 'exceeded-max');
                    }
                    else {
                        this.renderer.removeClass(resizeTrackerEl, 'exceeded-max');
                    }
                }
            };
        ClrDatagridColumnSeparator.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column-separator',
                        template: "\n    <div class=\"datagrid-column-handle\" aria-hidden=\"true\"\n      clrDraggable \n      [clrGroup]=\"columnSeparatorId\" \n      (clrDragStart)=\"showTracker(resizeTrackerEl)\" \n      (clrDragMove)=\"moveTracker($event, resizeTrackerEl)\" \n      (clrDragEnd)=\"hideTracker(resizeTrackerEl)\"></div>\n    <div class=\"datagrid-column-resize-tracker\" #resizeTrackerEl></div>\n    ",
                        host: {
                            '[class.datagrid-column-separator]': 'true',
                        },
                        providers: [UNIQUE_ID_PROVIDER]
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridColumnSeparator.ctorParameters = function () {
            return [
                { type: ColumnResizerService },
                { type: i0.Renderer2 },
                { type: TableSizeService },
                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] },
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] }
            ];
        };
        return ClrDatagridColumnSeparator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridColumnToggleButton = /** @class */ (function () {
        function ClrDatagridColumnToggleButton(toggleButtons) {
            this.toggleButtons = toggleButtons;
        }
        ClrDatagridColumnToggleButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column-toggle-button',
                        template: "\n        <button class=\"btn btn-sm btn-link\"\n            (click)=\"toggleButtons.buttonClicked()\"\n            [disabled]=\"toggleButtons.selectAllDisabled\"\n            type=\"button\">\n            <ng-content></ng-content>\n        </button>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridColumnToggleButton.ctorParameters = function () {
            return [
                { type: ColumnToggleButtonsService }
            ];
        };
        return ClrDatagridColumnToggleButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridColumnToggleTitle = /** @class */ (function () {
        function ClrDatagridColumnToggleTitle() {
        }
        ClrDatagridColumnToggleTitle.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column-toggle-title',
                        template: "<ng-content></ng-content>"
                    }] }
        ];
        return ClrDatagridColumnToggleTitle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridColumnToggle = /** @class */ (function () {
        function ClrDatagridColumnToggle(hideableColumnService, columnToggleButtons, commonStrings, platformId, zone) {
            this.hideableColumnService = hideableColumnService;
            this.columnToggleButtons = columnToggleButtons;
            this.commonStrings = commonStrings;
            this.platformId = platformId;
            this.zone = zone;
            this.subscriptions = [];
            /**
             *
             * Popover init
             */
            this.anchorPoint = Point.TOP_LEFT;
            this.popoverPoint = Point.LEFT_BOTTOM;
            this.open = false;
            /**
             * *
             * DatagridHideableColumnModel init
             */
            this.columns = [];
        }
        Object.defineProperty(ClrDatagridColumnToggle.prototype, "allColumnsVisible", {
            get: /**
             * @return {?}
             */ function () {
                return this._allColumnsVisible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._allColumnsVisible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
                    // Reset the list of columns
                    _this.columns.length = 0;
                    _this.hideableColumnService.updateForLastVisibleColumn();
                    _this.allColumnsVisible = _this.hideableColumnService.checkForAllColumnsVisible;
                    _this.columnToggleButtons.selectAllDisabled = _this.allColumnsVisible;
                    // Add only the hidden columns to the toggler.
                    columnList.forEach(function (col) {
                        if (col) {
                            _this.columns.push(col);
                        }
                    });
                }));
                this.subscriptions.push(this.columnToggleButtons.selectAllButtonClicked.subscribe(function () {
                    _this.selectAll();
                }));
            };
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.selectAll = /**
         * @return {?}
         */
            function () {
                this.hideableColumnService.showHiddenColumns();
                this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
                this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
                if (this.allSelectedElement) {
                    this.allSelectedElement.nativeElement.focus();
                }
            };
        /**
         * @param {?} event
         * @param {?} column
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.toggleColumn = /**
         * @param {?} event
         * @param {?} column
         * @return {?}
         */
            function (event, column) {
                column.hidden = !event;
                this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
                this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
                this.hideableColumnService.updateForLastVisibleColumn();
            };
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.toggleUI = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.open = !this.open;
                if (this.open && common.isPlatformBrowser(this.platformId) && this.menuDescriptionElement) {
                    this.zone.runOutsideAngular(function () {
                        setTimeout(function () {
                            _this.menuDescriptionElement.nativeElement.focus();
                        });
                    });
                }
            };
        // Without tracking the checkboxes get rerendered on model update, which leads
        // to loss of focus after checkbox toggle.
        // Without tracking the checkboxes get rerendered on model update, which leads
        // to loss of focus after checkbox toggle.
        /**
         * @param {?} index
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.trackByFn =
            // Without tracking the checkboxes get rerendered on model update, which leads
            // to loss of focus after checkbox toggle.
            /**
             * @param {?} index
             * @return {?}
             */
            function (index) {
                return index;
            };
        ClrDatagridColumnToggle.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column-toggle',
                        template: "\n        <button\n                #anchor\n                (click)=\"toggleUI()\"\n                class=\"btn btn-sm btn-link column-toggle--action\"\n                type=\"button\">\n            <clr-icon shape=\"view-columns\" [attr.title]=\"commonStrings.keys.pickColumns\"></clr-icon>\n        </button>\n        <div class=\"column-switch\"\n             *clrPopoverOld=\"open; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint\">\n            <div class=\"switch-header\">\n                <div class=\"sr-only\" tabindex=\"-1\" #menuDescription>{{commonStrings.keys.showColumnsMenuDescription}}</div>\n                <div class=\"sr-only\" tabindex=\"-1\" #allSelected>{{commonStrings.keys.allColumnsSelected}}</div>\n                <ng-container *ngIf=\"!title\">Show Columns</ng-container>\n                <ng-content select=\"clr-dg-column-toggle-title\"></ng-content>\n                <button\n                    class=\"btn btn-sm btn-link\"\n                    (click)=\"toggleUI()\"\n                    type=\"button\">\n                    <clr-icon shape=\"close\" [attr.title]=\"commonStrings.keys.close\"></clr-icon>\n                </button>\n            </div>\n            <ul class=\"switch-content list-unstyled\">\n                <li *ngFor=\"let column of columns;trackBy: trackByFn\">\n                    <clr-checkbox-wrapper>\n                        <input clrCheckbox type=\"checkbox\"\n                          [disabled]=\"column.lastVisibleColumn\"\n                          [ngModel]=\"!column.hidden\"\n                          (ngModelChange)=\"toggleColumn($event, column)\">\n                        <label><ng-template [ngTemplateOutlet]=\"column.template\"></ng-template></label>\n                    </clr-checkbox-wrapper>\n                </li>\n            </ul>\n            <div class=\"switch-footer\" *ngIf=\"buttons.length > 0\">\n                <ng-content select=\"clr-dg-column-toggle-button\"></ng-content>\n            </div>\n            <div class=\"switch-footer\" *ngIf=\"buttons.length === 0\">\n                <div>\n                    <button\n                            class=\"btn btn-sm btn-link p6 text-uppercase\"\n                            [disabled]=\"allColumnsVisible\"\n                            (click)=\"selectAll()\"\n                            type=\"button\">Select All\n                    </button>\n                </div>\n            </div>\n        </div>\n    ",
                        host: { '[class.column-switch-wrapper]': 'true', '[class.active]': 'open' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridColumnToggle.ctorParameters = function () {
            return [
                { type: HideableColumnService },
                { type: ColumnToggleButtonsService },
                { type: ClrCommonStringsService },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: i0.NgZone }
            ];
        };
        ClrDatagridColumnToggle.propDecorators = {
            title: [{ type: i0.ContentChild, args: [ClrDatagridColumnToggleTitle,] }],
            buttons: [{ type: i0.ContentChildren, args: [ClrDatagridColumnToggleButton,] }],
            menuDescriptionElement: [{ type: i0.ViewChild, args: ['menuDescription', { read: i0.ElementRef },] }],
            allSelectedElement: [{ type: i0.ViewChild, args: ['allSelected', { read: i0.ElementRef },] }]
        };
        return ClrDatagridColumnToggle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * I don't think this deserves to be in IfExpanded itself,
     * so I'm adding a second directive on the same selector for now just for the datagrid
     */
    var DatagridDetailRegisterer = /** @class */ (function () {
        function DatagridDetailRegisterer(expandableRowsCount) {
            this.expandableRowsCount = expandableRowsCount;
            if (this.expandableRowsCount) {
                this.expandableRowsCount.register();
            }
        }
        /**
         * @return {?}
         */
        DatagridDetailRegisterer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.expandableRowsCount) {
                    this.expandableRowsCount.unregister();
                }
            };
        DatagridDetailRegisterer.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfExpanded]' },] }
        ];
        /** @nocollapse */
        DatagridDetailRegisterer.ctorParameters = function () {
            return [
                { type: ExpandableRowsCount, decorators: [{ type: i0.Optional }] }
            ];
        };
        return DatagridDetailRegisterer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridFooter = /** @class */ (function () {
        function ClrDatagridFooter(selection, hideableColumnService, cdr) {
            this.selection = selection;
            this.hideableColumnService = hideableColumnService;
            this.cdr = cdr;
            this.subscriptions = [];
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
        }
        /**
         * @return {?}
         */
        ClrDatagridFooter.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (change) {
                    /** @type {?} */
                    var hiddenColumnsInSub = change.filter(function (col) { return col; });
                    if (hiddenColumnsInSub.length > 0) {
                        _this.activeToggler = true;
                    }
                }));
                /** @type {?} */
                var hiddenColumns = this.hideableColumnService.getColumns().filter(function (col) { return col; });
                if (hiddenColumns.length > 0) {
                    this.activeToggler = true;
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridFooter.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) {
                    sub.unsubscribe();
                });
            };
        ClrDatagridFooter.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-footer',
                        template: "\n        <ng-container\n            *ngIf=\"(selection.selectionType === SELECTION_TYPE.Multi) && (selection.current.length > 0)\">\n          <div class=\"clr-form-control-disabled\">\n              <clr-checkbox-wrapper class=\"datagrid-footer-select\">\n                <input clrCheckbox type=\"checkbox\" checked=\"checked\" disabled>\n                <label>{{selection.current.length}}</label>\n            </clr-checkbox-wrapper>\n          </div>\n        </ng-container>\n        <ng-content select=\"clr-dg-column-toggle\"></ng-content>\n        <clr-dg-column-toggle *ngIf=\"!toggle && activeToggler\"></clr-dg-column-toggle>\n        <div class=\"datagrid-footer-description\">\n            <ng-content></ng-content>\n        </div>\n        <ng-content select=\"clr-dg-pagination\"></ng-content>\n    ",
                        host: {
                            '[class.datagrid-footer]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridFooter.ctorParameters = function () {
            return [
                { type: Selection },
                { type: HideableColumnService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        ClrDatagridFooter.propDecorators = {
            toggle: [{ type: i0.ContentChild, args: [ClrDatagridColumnToggle,] }]
        };
        return ClrDatagridFooter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * \@description
     * A utility class for that adds hide/show functionality to a column, its cells and enables a toggler in the
     * DatagridColumnToggle Component.
     *
     */
    var /**
     *
     * \@description
     * A utility class for that adds hide/show functionality to a column, its cells and enables a toggler in the
     * DatagridColumnToggle Component.
     *
     */ DatagridHideableColumnModel = /** @class */ (function () {
        /**
         *
         * @description
         * The init function for DatagridHideableColumnModel instances that does the following:
         *
         * 1. Set values for the private variables that enable a hideable column
         * 2. Broadcast the next hidden change for anyone (already) subscribed to this DatagridHideableColumnModel
         *
         */
        function DatagridHideableColumnModel(_template, _id, _hidden) {
            if (_hidden === void 0) {
                _hidden = false;
            }
            this._template = _template;
            this._id = _id;
            this._hidden = _hidden;
            /**
             * \@property hiddenChanges
             *
             * \@description
             * A stream of state changes an instance of DatagridHideableColumnModel will broadcast to subscribers.
             *
             */
            this.hiddenChangesState = new rxjs.Subject();
            // Flag this true when the service only has one visible column open.
            this.lastVisibleColumn = false;
        }
        Object.defineProperty(DatagridHideableColumnModel.prototype, "template", {
            /**
             *
             * @description
             * A getter function that returns an TemplateRef of the DatagridColumn that is hideable. This is currently used to
             * populate the DatagridColumnToggle UI with the correct Column name.
             *
             */
            get: /**
             *
             * \@description
             * A getter function that returns an TemplateRef of the DatagridColumn that is hideable. This is currently used to
             * populate the DatagridColumnToggle UI with the correct Column name.
             *
             * @return {?}
             */ function () {
                return this._template;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridHideableColumnModel.prototype, "id", {
            /**
             *
             * @description
             * public function that returns the id of a HideableCOlumn instance. Used by the HideableCOlumnService for passing
             * state and actions between DateGridColumns, DataGridCells & the DatagridColumnToggle Components.
             *
             */
            get: /**
             *
             * \@description
             * public function that returns the id of a HideableCOlumn instance. Used by the HideableCOlumnService for passing
             * state and actions between DateGridColumns, DataGridCells & the DatagridColumnToggle Components.
             *
             * @return {?}
             */ function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridHideableColumnModel.prototype, "hidden", {
            /**
             *
             * @description
             * A getter that returns the hidden value of a DatagridHideableColumnModel instance.
             *
             */
            get: /**
             *
             * \@description
             * A getter that returns the hidden value of a DatagridHideableColumnModel instance.
             *
             * @return {?}
             */ function () {
                return this._hidden;
            },
            /**
             *
             * @description
             * The setter for setting the hidden state of a DatagridHideableColumnModel instance.
             * It also broadcasts the change after its set.
             *
             */
            set: /**
             *
             * \@description
             * The setter for setting the hidden state of a DatagridHideableColumnModel instance.
             * It also broadcasts the change after its set.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._hidden === value) {
                    return;
                }
                this._hidden = value;
                this.hiddenChangesState.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridHideableColumnModel.prototype, "hiddenChangeState", {
            /**
             *
             * @description
             * An Observable for the HideableColumns hidden changes.
             *
             */
            get: /**
             *
             * \@description
             * An Observable for the HideableColumns hidden changes.
             *
             * @return {?}
             */ function () {
                return this.hiddenChangesState.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        return DatagridHideableColumnModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridHideableColumn = /** @class */ (function () {
        /**
         * @description
         * Used the DatagridColumn to get and set an id for this HiddenColumn
         *
         */
        function ClrDatagridHideableColumn(templateRef, viewContainerRef, dgColumn) {
            var _this = this;
            this.templateRef = templateRef;
            this.viewContainerRef = viewContainerRef;
            this.dgColumn = dgColumn;
            this.hiddenChange = new i0.EventEmitter();
            this.columnId = dgColumn.columnId;
            // Use the templateRef to create this view
            this.viewContainerRef.createEmbeddedView(this.templateRef);
            // Create instance of the utility class DatagridHideableColumn.
            // Note this is on the parent instance of DatagridColumn.
            this.dgColumn.hideable = new DatagridHideableColumnModel(this.templateRef, this.columnId, this._hidden);
            this.dgColumn.hideable.hiddenChangeState.subscribe(function (state) { return _this.hiddenChange.emit(state); });
        }
        Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHideableColumn", {
            /**
             *
             * @description
             * Setter fn for the @Input with the same name as this structural directive.
             * It allows the user to pre-configure the column's hide/show state. { hidden: true }
             * It's more verbose but has more Clarity.
             *
             *
             * @example
             * *clrDgHideableColumn
             * *clrDgHideableColumn={hidden: false}
             * *clrDgHideableColumn={hidden: true}
             *
             */
            set: /**
             *
             * \@description
             * Setter fn for the \@Input with the same name as this structural directive.
             * It allows the user to pre-configure the column's hide/show state. { hidden: true }
             * It's more verbose but has more Clarity.
             *
             *
             * \@example
             * *clrDgHideableColumn
             * *clrDgHideableColumn={hidden: false}
             * *clrDgHideableColumn={hidden: true}
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.clrDgHidden = value && value.hidden ? value.hidden : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHidden", {
            set: /**
             * @param {?} hidden
             * @return {?}
             */ function (hidden) {
                this._hidden = hidden ? hidden : false;
                if (this.dgColumn.hideable) {
                    this.dgColumn.hideable.hidden = this._hidden;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridHideableColumn.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrDgHideableColumn]' },] }
        ];
        /** @nocollapse */
        ClrDatagridHideableColumn.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef },
                { type: ClrDatagridColumn }
            ];
        };
        ClrDatagridHideableColumn.propDecorators = {
            clrDgHideableColumn: [{ type: i0.Input, args: ['clrDgHideableColumn',] }],
            clrDgHidden: [{ type: i0.Input, args: ['clrDgHidden',] }],
            hiddenChange: [{ type: i0.Output, args: ['clrDgHiddenChange',] }]
        };
        return ClrDatagridHideableColumn;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridItemsTrackBy = /** @class */ (function () {
        function ClrDatagridItemsTrackBy(_items) {
            this._items = _items;
        }
        Object.defineProperty(ClrDatagridItemsTrackBy.prototype, "trackBy", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._items) {
                    this._items.trackBy = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridItemsTrackBy.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[ngForTrackBy]',
                    },] }
        ];
        /** @nocollapse */
        ClrDatagridItemsTrackBy.ctorParameters = function () {
            return [
                { type: Items, decorators: [{ type: i0.Optional }] }
            ];
        };
        ClrDatagridItemsTrackBy.propDecorators = {
            trackBy: [{ type: i0.Input, args: ['ngForTrackBy',] }]
        };
        return ClrDatagridItemsTrackBy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridPageSize = /** @class */ (function () {
        function ClrDatagridPageSize(page) {
            this.page = page;
        }
        /**
         * @return {?}
         */
        ClrDatagridPageSize.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.pageSizeOptions || this.pageSizeOptions.length === 0) {
                    this.pageSizeOptions = [this.page.size];
                }
            };
        ClrDatagridPageSize.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-page-size',
                        template: "\n    <ng-content></ng-content>\n    <div class=\"clr-select-wrapper\">\n      <select [class.clr-page-size-select]=\"true\" [(ngModel)]=\"page.size\">\n        <option *ngFor=\"let option of pageSizeOptions\" [ngValue]=\"option\">{{option}}</option>\n      </select>\n    </div>\n  "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridPageSize.ctorParameters = function () {
            return [
                { type: Page }
            ];
        };
        ClrDatagridPageSize.propDecorators = {
            pageSizeOptions: [{ type: i0.Input, args: ['clrPageSizeOptions',] }]
        };
        return ClrDatagridPageSize;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridPagination = /** @class */ (function () {
        function ClrDatagridPagination(page, commonStrings) {
            this.page = page;
            this.commonStrings = commonStrings;
            this.currentChanged = new i0.EventEmitter(false);
            this.page.activated = true;
        }
        /**********
         * Subscription to the Page service for page changes.
         * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
         */
        /**
         * *******
         * Subscription to the Page service for page changes.
         * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
         * @return {?}
         */
        ClrDatagridPagination.prototype.ngOnInit = /**
         * *******
         * Subscription to the Page service for page changes.
         * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
         * @return {?}
         */
            function () {
                var _this = this;
                /*
                 * Default page size is 10.
                 * The reason we set it here and not in the provider itself is because
                 * we don't want pagination if this component isn't present in the datagrid.
                 */
                if (!this.page.size) {
                    this.page.size = 10;
                }
                this._pageSubscription = this.page.change.subscribe(function (current) { return _this.currentChanged.emit(current); });
            };
        /**
         * @return {?}
         */
        ClrDatagridPagination.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.page.resetPageSize();
                if (this._pageSubscription) {
                    this._pageSubscription.unsubscribe();
                }
            };
        Object.defineProperty(ClrDatagridPagination.prototype, "pageSize", {
            /**
             * Page size
             */
            get: /**
             * Page size
             * @return {?}
             */ function () {
                return this.page.size;
            },
            set: /**
             * @param {?} size
             * @return {?}
             */ function (size) {
                if (typeof size === 'number') {
                    this.page.size = size;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "totalItems", {
            /**
             * Total items (needed to guess the last page)
             */
            get: /**
             * Total items (needed to guess the last page)
             * @return {?}
             */ function () {
                return this.page.totalItems;
            },
            set: /**
             * @param {?} total
             * @return {?}
             */ function (total) {
                if (typeof total === 'number') {
                    this.page.totalItems = total;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "lastPage", {
            /**
             * Last page
             */
            get: /**
             * Last page
             * @return {?}
             */ function () {
                return this.page.last;
            },
            set: /**
             * @param {?} last
             * @return {?}
             */ function (last) {
                if (typeof last === 'number') {
                    this.page.last = last;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "currentPage", {
            /**
             * Current page
             */
            get: /**
             * Current page
             * @return {?}
             */ function () {
                return this.page.current;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                if (typeof page === 'number') {
                    this.page.current = page;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Moves to the previous page if it exists
         */
        /**
         * Moves to the previous page if it exists
         * @return {?}
         */
        ClrDatagridPagination.prototype.previous = /**
         * Moves to the previous page if it exists
         * @return {?}
         */
            function () {
                this.page.previous();
            };
        /**
         * Moves to the next page if it exists
         */
        /**
         * Moves to the next page if it exists
         * @return {?}
         */
        ClrDatagridPagination.prototype.next = /**
         * Moves to the next page if it exists
         * @return {?}
         */
            function () {
                this.page.next();
            };
        Object.defineProperty(ClrDatagridPagination.prototype, "firstItem", {
            /**
             * Index of the first item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the first item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                return this.page.firstItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "lastItem", {
            /**
             * Index of the last item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the last item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                return this.page.lastItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "middlePages", {
            /**
             * Conditionally adds page numbers before and after the current page
             */
            get: /**
             * Conditionally adds page numbers before and after the current page
             * @return {?}
             */ function () {
                /** @type {?} */
                var middlePages = [];
                if (this.page.current > 1) {
                    middlePages.push(this.page.current - 1);
                }
                middlePages.push(this.page.current);
                if (this.page.current < this.page.last) {
                    middlePages.push(this.page.current + 1);
                }
                return middlePages;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * We only update the pagination's current page on blur of the input field, or
         * when they press enter.
         */
        /**
         * We only update the pagination's current page on blur of the input field, or
         * when they press enter.
         * @param {?} event
         * @return {?}
         */
        ClrDatagridPagination.prototype.updateCurrentPage = /**
         * We only update the pagination's current page on blur of the input field, or
         * when they press enter.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var parsed = parseInt(event.target.value, 10);
                // if the input value, is not a number, we don't update the page
                if (!isNaN(parsed)) {
                    if (parsed < 1) {
                        this.page.current = 1;
                    }
                    else if (parsed > this.page.last) {
                        this.page.current = this.page.last;
                    }
                    else {
                        this.page.current = parsed;
                    }
                }
                /**
                 * Set the input's value to the new current page. This is needed because the code
                 * above may have changed the value from what the user entered in.
                 */
                this.currentPageInputRef.nativeElement.value = this.page.current;
            };
        ClrDatagridPagination.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-pagination',
                        template: "\n    <div class=\"pagination-size\" *ngIf=\"_pageSizeComponent\">\n      <ng-content select=\"clr-dg-page-size\"></ng-content>\n    </div>\n    <div class=\"pagination-description\">\n      <ng-content></ng-content>\n    </div>\n    <div class=\"pagination-list\" *ngIf=\"page.last > 1\">\n      <button\n        type=\"button\" \n        class=\"pagination-first\" \n        [disabled]=\"page.current <= 1\" \n        (click)=\"page.current = 1\"\n        [attr.aria-label]=\"commonStrings.keys.firstPage\"\n        >\n        <clr-icon shape=\"step-forward-2 down\"></clr-icon>\n      </button>\n      <button \n        type=\"button\"\n        class=\"pagination-previous\" \n        [disabled]=\"page.current <= 1\" \n        (click)=\"page.current = page.current - 1\"\n        [attr.aria-label]=\"commonStrings.keys.previousPage\"\n        >\n        <clr-icon shape=\"angle left\"></clr-icon>\n      </button>\n      <input \n        #currentPageInput \n        type=\"text\" \n        class=\"pagination-current\" \n        [size]=\"page.last.toString().length\" \n        [value]=\"page.current\"\n        (keydown.enter)=\"updateCurrentPage($event)\" \n        (blur)=\"updateCurrentPage($event)\"\n        [attr.aria-label]=\"commonStrings.keys.currentPage\"\n        />\n        &nbsp;/&nbsp;<span [attr.aria-label]=\"commonStrings.keys.totalPages\">{{page.last}}</span>\n      <button \n        type=\"button\"\n        class=\"pagination-next\" \n        [disabled]=\"page.current >= page.last\" \n        (click)=\"page.current = page.current + 1\"\n        [attr.aria-label]=\"commonStrings.keys.nextPage\"\n        >\n        <clr-icon shape=\"angle right\"></clr-icon>\n      </button>\n      <button \n        type=\"button\" \n        class=\"pagination-last\" \n        [disabled]=\"page.current >= page.last\" \n        (click)=\"page.current = page.last\"\n        [attr.aria-label]=\"commonStrings.keys.lastPage\"\n        >\n        <clr-icon shape=\"step-forward-2 up\"></clr-icon>\n      </button>\n    </div>\n    ",
                        host: { '[class.pagination]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridPagination.ctorParameters = function () {
            return [
                { type: Page },
                { type: ClrCommonStringsService }
            ];
        };
        ClrDatagridPagination.propDecorators = {
            _pageSizeComponent: [{ type: i0.ContentChild, args: [ClrDatagridPageSize,] }],
            currentPageInputRef: [{ type: i0.ViewChild, args: ['currentPageInput',] }],
            pageSize: [{ type: i0.Input, args: ['clrDgPageSize',] }],
            totalItems: [{ type: i0.Input, args: ['clrDgTotalItems',] }],
            lastPage: [{ type: i0.Input, args: ['clrDgLastPage',] }],
            currentPage: [{ type: i0.Input, args: ['clrDgPage',] }],
            currentChanged: [{ type: i0.Output, args: ['clrDgPageChange',] }]
        };
        return ClrDatagridPagination;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Generic bland container serving various purposes for Datagrid.
     * For instance, it can help span a text over multiple rows in detail view.
     * @template T
     */
    var ClrDatagridRowDetail = /** @class */ (function () {
        function ClrDatagridRowDetail(selection, rowActionService, expand, hideableColumnService, expandableRows) {
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.expand = expand;
            this.hideableColumnService = hideableColumnService;
            this.expandableRows = expandableRows;
            /* reference to the enum so that template can access it */
            this.SELECTION_TYPE = SelectionType;
            this.subscriptions = [];
            this.replacedRow = false;
        }
        Object.defineProperty(ClrDatagridRowDetail.prototype, "replace", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.expand.setReplace(!!value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridRowDetail.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var columnsList = this.hideableColumnService.getColumns();
                this.updateCellsForColumns(columnsList);
                // Triggered when the Cells list changes per row-renderer
                this.subscriptions.push(this.cells.changes.subscribe(function (cellList) {
                    /** @type {?} */
                    var columnList = _this.hideableColumnService.getColumns();
                    if (cellList.length === columnList.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                }));
                // Used to set things up the first time but only after all the columns are ready.
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
                    // Prevents cell updates when cols and cells array are not aligned
                    if (columnList.length === _this.cells.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                }));
                this.subscriptions.push(this.expand.replace.subscribe(function (replaceChange) {
                    _this.replacedRow = replaceChange;
                }));
            };
        /**
         * @param {?} columnList
         * @return {?}
         */
        ClrDatagridRowDetail.prototype.updateCellsForColumns = /**
         * @param {?} columnList
         * @return {?}
         */
            function (columnList) {
                this.cells.forEach(function (cell, index) {
                    /** @type {?} */
                    var currentColumn = columnList[index];
                    if (currentColumn) {
                        cell.id = currentColumn.id;
                    }
                });
            };
        /**
         * @return {?}
         */
        ClrDatagridRowDetail.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDatagridRowDetail.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-row-detail',
                        template: "\n        <ng-container *ngIf=\"!replacedRow\">\n            <!-- space for multiselection state -->\n            <div class=\"datagrid-cell datagrid-select datagrid-fixed-column\"\n                *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n            </div>\n            <!-- space for single selection state -->\n            <div class=\"datagrid-cell datagrid-select datagrid-fixed-column\"\n                *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\">\n            </div>\n            <!-- space for single row action; only displayType if we have at least one actionable row in datagrid -->\n            <div class=\"datagrid-cell datagrid-row-actions datagrid-fixed-column\"\n                *ngIf=\"rowActionService.hasActionableRow\">\n            </div>\n            <!-- space for expandable caret action; only displayType if we have at least one expandable row in datagrid -->\n            <div *ngIf=\"expandableRows.hasExpandableRow\"\n                        class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\">\n            </div>\n        </ng-container>\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.datagrid-row-flex]': 'true',
                            '[class.datagrid-row-detail]': 'true',
                            '[class.datagrid-container]': 'cells.length === 0',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridRowDetail.ctorParameters = function () {
            return [
                { type: Selection },
                { type: RowActionService },
                { type: Expand },
                { type: HideableColumnService },
                { type: ExpandableRowsCount }
            ];
        };
        ClrDatagridRowDetail.propDecorators = {
            cells: [{ type: i0.ContentChildren, args: [ClrDatagridCell,] }],
            replace: [{ type: i0.Input, args: ['clrDgReplace',] }]
        };
        return ClrDatagridRowDetail;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var STRICT_WIDTH_CLASS = 'datagrid-fixed-width';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridCellRenderer = /** @class */ (function () {
        function DatagridCellRenderer(el, renderer, organizer) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.subscriptions = [];
            this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
        }
        /**
         * @return {?}
         */
        DatagridCellRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        DatagridCellRenderer.prototype.clearWidth = /**
         * @return {?}
         */
            function () {
                this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                this.renderer.setStyle(this.el.nativeElement, 'width', null);
            };
        /**
         * @param {?} strict
         * @param {?} value
         * @return {?}
         */
        DatagridCellRenderer.prototype.setWidth = /**
         * @param {?} strict
         * @param {?} value
         * @return {?}
         */
            function (strict, value) {
                if (strict) {
                    this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                }
                else {
                    this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                }
                this.renderer.setStyle(this.el.nativeElement, 'width', value + 'px');
            };
        DatagridCellRenderer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-cell' },] }
        ];
        /** @nocollapse */
        DatagridCellRenderer.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: DatagridRenderOrganizer }
            ];
        };
        return DatagridCellRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridHeaderRenderer = /** @class */ (function () {
        function DatagridHeaderRenderer(el, renderer, organizer, domAdapter, columnResizerService) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.organizer = organizer;
            this.domAdapter = domAdapter;
            this.columnResizerService = columnResizerService;
            this.resizeEmitter = new i0.EventEmitter();
            this.widthSet = false;
            this.subscriptions = [];
            this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
            this.subscriptions.push(this.organizer
                .filterRenderSteps(DatagridRenderStep.DETECT_STRICT_WIDTHS)
                .subscribe(function () { return _this.detectStrictWidth(); }));
        }
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.clearWidth = /**
         * @return {?}
         */
            function () {
                // remove the width only if we set it, and it is not changed by dragging.
                if (this.widthSet && !this.columnResizerService.resizedBy) {
                    this.renderer.setStyle(this.el.nativeElement, 'width', null);
                }
            };
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.detectStrictWidth = /**
         * @return {?}
         */
            function () {
                if (this.columnResizerService.resizedBy) {
                    this.strictWidth = this.columnResizerService.widthAfterResize;
                }
                else {
                    this.strictWidth = this.domAdapter.userDefinedWidth(this.el.nativeElement);
                }
            };
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.computeWidth = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var width = this.strictWidth;
                if (!width) {
                    width = this.domAdapter.scrollWidth(this.el.nativeElement);
                }
                return width;
            };
        /**
         * @param {?} width
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.setWidth = /**
         * @param {?} width
         * @return {?}
         */
            function (width) {
                if (this.strictWidth) {
                    if (this.columnResizerService.resizedBy) {
                        this.resizeEmitter.emit(width);
                        this.renderer.setStyle(this.el.nativeElement, 'width', width + 'px');
                        this.widthSet = false;
                    }
                    // Don't set width if there is a user-defined one. Just add the strict width class.
                    this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                    return;
                }
                this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                this.renderer.setStyle(this.el.nativeElement, 'width', width + 'px');
                this.widthSet = true;
            };
        DatagridHeaderRenderer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-column', providers: [ColumnResizerService] },] }
        ];
        /** @nocollapse */
        DatagridHeaderRenderer.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: DatagridRenderOrganizer },
                { type: DomAdapter },
                { type: ColumnResizerService }
            ];
        };
        DatagridHeaderRenderer.propDecorators = {
            resizeEmitter: [{ type: i0.Output, args: ['clrDgColumnResize',] }]
        };
        return DatagridHeaderRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NoopDomAdapter = /** @class */ (function () {
        function NoopDomAdapter() {
        }
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.userDefinedWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.scrollBarWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.scrollWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.computedHeight = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.clientRect = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    width: 0,
                    height: 0,
                };
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.minWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.focus = /**
         * @param {?} element
         * @return {?}
         */
            function (element) { };
        NoopDomAdapter.decorators = [
            { type: i0.Injectable }
        ];
        return NoopDomAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // Fixes build error
    // @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
    /** @type {?} */
    var domAdapterFactory = function (platformId) {
        if (common.isPlatformBrowser(platformId)) {
            return new DomAdapter();
        }
        else {
            return new NoopDomAdapter();
        }
    };
    // Fixes build error
    // @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
    /**
     * @template T
     */
    var DatagridMainRenderer = /** @class */ (function () {
        function DatagridMainRenderer(organizer, items, page, domAdapter, el, renderer, tableSizeService) {
            var _this = this;
            this.organizer = organizer;
            this.items = items;
            this.page = page;
            this.domAdapter = domAdapter;
            this.el = el;
            this.renderer = renderer;
            this.tableSizeService = tableSizeService;
            this._heightSet = false;
            this.subscriptions = [];
            /**
             * Indicates if we want to re-compute columns width. This should only happen:
             * 1) When headers change, with columns being added or removed
             * 2) When rows are lazily loaded for the first time
             */
            this.columnsSizesStable = false;
            this.shouldStabilizeColumns = true;
            this.subscriptions.push(this.organizer
                .filterRenderSteps(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS)
                .subscribe(function () { return _this.computeHeadersWidth(); }));
            this.subscriptions.push(this.page.sizeChange.subscribe(function () {
                if (_this._heightSet) {
                    _this.resetDatagridHeight();
                }
            }));
            this.subscriptions.push(this.items.change.subscribe(function () { return (_this.shouldStabilizeColumns = true); }));
        }
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.headers.changes.subscribe(function () {
                    // TODO: only re-stabilize if a column was added or removed. Reordering is fine.
                    _this.columnsSizesStable = false;
                    _this.stabilizeColumns();
                }));
            };
        // Initialize and set Table width for horizontal scrolling here.
        // Initialize and set Table width for horizontal scrolling here.
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngAfterViewInit =
            // Initialize and set Table width for horizontal scrolling here.
            /**
             * @return {?}
             */
            function () {
                this.tableSizeService.table = this.el;
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.shouldStabilizeColumns) {
                    this.stabilizeColumns();
                }
                if (this.shouldComputeHeight()) {
                    setTimeout(function () {
                        _this.computeDatagridHeight();
                    });
                }
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.shouldComputeHeight = /**
         * @return {?}
         */
            function () {
                if (!this._heightSet && this.page.size > 0) {
                    if (this.items.displayed.length === this.page.size) {
                        return true;
                    }
                }
                return false;
            };
        /**
         * Computes the height of the datagrid.
         *
         * NOTE: We had to choose to set the height instead of the min-height because
         * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
         * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
         * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
         *
         * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
         */
        /**
         * Computes the height of the datagrid.
         *
         * NOTE: We had to choose to set the height instead of the min-height because
         * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
         * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
         * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
         *
         * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
         * @return {?}
         */
        DatagridMainRenderer.prototype.computeDatagridHeight = /**
         * Computes the height of the datagrid.
         *
         * NOTE: We had to choose to set the height instead of the min-height because
         * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
         * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
         * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
         *
         * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
         * @return {?}
         */
            function () {
                // IE doesn't return correct value for getComputedStyle(element).getPropertyValue("height")
                /** @type {?} */
                var value = this.domAdapter.clientRect(this.el.nativeElement).height;
                this.renderer.setStyle(this.el.nativeElement, 'height', value + 'px');
                this._heightSet = true;
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.resetDatagridHeight = /**
         * @return {?}
         */
            function () {
                this.renderer.setStyle(this.el.nativeElement, 'height', '');
                this._heightSet = false;
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * Makes each header compute its width.
         */
        /**
         * Makes each header compute its width.
         * @return {?}
         */
        DatagridMainRenderer.prototype.computeHeadersWidth = /**
         * Makes each header compute its width.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var nbColumns = this.headers.length;
                /** @type {?} */
                var allStrict = true;
                this.headers.forEach(function (header, index) {
                    // On the last header column check whether all columns have strict widths.
                    // If all columns have strict widths, remove the strict width from the last column and make it the column's
                    // minimum width so that when all previous columns shrink, it will get a flexible width and cover the empty
                    // gap in the Datagrid.
                    if (!header.strictWidth) {
                        allStrict = false;
                    }
                    if (nbColumns === index + 1 && allStrict) {
                        delete header.strictWidth;
                    }
                    _this.organizer.widths[index] = { px: header.computeWidth(), strict: !!header.strictWidth };
                });
                this.headers.forEach(function (header, index) { return header.setWidth(_this.organizer.widths[index].px); });
            };
        /**
         * Triggers a whole re-rendring cycle to set column sizes, if needed.
         */
        /**
         * Triggers a whole re-rendring cycle to set column sizes, if needed.
         * @return {?}
         */
        DatagridMainRenderer.prototype.stabilizeColumns = /**
         * Triggers a whole re-rendring cycle to set column sizes, if needed.
         * @return {?}
         */
            function () {
                this.shouldStabilizeColumns = false;
                if (this.columnsSizesStable) {
                    // Nothing to do.
                    return;
                }
                // Resize when the rows are loaded.
                if (this.items.displayed.length > 0) {
                    this.organizer.resize();
                    this.columnsSizesStable = true;
                }
            };
        DatagridMainRenderer.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'clr-datagrid',
                        providers: [{ provide: DomAdapter, useFactory: domAdapterFactory, deps: [i0.PLATFORM_ID] }],
                    },] }
        ];
        /** @nocollapse */
        DatagridMainRenderer.ctorParameters = function () {
            return [
                { type: DatagridRenderOrganizer },
                { type: Items },
                { type: Page },
                { type: DomAdapter },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: TableSizeService }
            ];
        };
        DatagridMainRenderer.propDecorators = {
            headers: [{ type: i0.ContentChildren, args: [DatagridHeaderRenderer,] }],
            columns: [{ type: i0.ContentChildren, args: [ClrDatagridColumn,] }]
        };
        return DatagridMainRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridRowRenderer = /** @class */ (function () {
        function DatagridRowRenderer(organizer) {
            var _this = this;
            this.organizer = organizer;
            this.subscriptions = [];
            this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.ALIGN_COLUMNS).subscribe(function () { return _this.setWidths(); }));
        }
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.setWidths = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.organizer.widths.length !== this.cells.length) {
                    return;
                }
                this.cells.forEach(function (cell, index) {
                    /** @type {?} */
                    var width = _this.organizer.widths[index];
                    cell.setWidth(width.strict, width.px);
                });
            };
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.cells.changes.subscribe(function () {
                    _this.setWidths();
                });
            };
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.setWidths();
            };
        DatagridRowRenderer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-row, clr-dg-row-detail' },] }
        ];
        /** @nocollapse */
        DatagridRowRenderer.ctorParameters = function () {
            return [
                { type: DatagridRenderOrganizer }
            ];
        };
        DatagridRowRenderer.propDecorators = {
            cells: [{ type: i0.ContentChildren, args: [DatagridCellRenderer,] }]
        };
        return DatagridRowRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DATAGRID_DIRECTIVES = [
        // Core
        ClrDatagrid,
        ClrDatagridActionBar,
        ClrDatagridActionOverflow,
        ClrDatagridColumn,
        ClrDatagridColumnSeparator,
        ClrDatagridColumnToggle,
        ClrDatagridHideableColumn,
        ClrDatagridFilter,
        ClrDatagridItems,
        ClrDatagridItemsTrackBy,
        ClrDatagridRow,
        ClrDatagridRowDetail,
        DatagridDetailRegisterer,
        ClrDatagridCell,
        ClrDatagridFooter,
        ClrDatagridPagination,
        ClrDatagridPageSize,
        ClrDatagridPlaceholder,
        ClrDatagridColumnToggleButton,
        ClrDatagridColumnToggleTitle,
        WrappedCell,
        WrappedColumn,
        WrappedRow,
        // Renderers
        DatagridMainRenderer,
        DatagridHeaderRenderer,
        DatagridRowRenderer,
        DatagridCellRenderer,
        // Chocolate
        DatagridWillyWonka,
        ActionableOompaLoompa,
        ExpandableOompaLoompa,
        // Animation hack
        DatagridRowExpandAnimation,
        // Built-in shortcuts
        DatagridStringFilter,
    ];
    var ClrDatagridModule = /** @class */ (function () {
        function ClrDatagridModule() {
        }
        ClrDatagridModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ClrIconModule,
                            ClrFormsModule,
                            forms.FormsModule,
                            ClrCommonPopoverModule,
                            ClrLoadingModule,
                            ClrOutsideClickModule,
                            ClrDragAndDropModule,
                            ClrSpinnerModule,
                        ],
                        declarations: [CLR_DATAGRID_DIRECTIVES],
                        exports: [CLR_DATAGRID_DIRECTIVES, ClrIfExpandModule],
                        entryComponents: [WrappedCell, WrappedColumn, WrappedRow],
                    },] }
        ];
        return ClrDatagridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackBlock = /** @class */ (function () {
        /*
           * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
           * querying for children StackBlocks, but this feature is not available when downgrading
           * the component for Angular 1.
           */
        function ClrStackBlock(parent, uniqueId, commonStrings) {
            this.parent = parent;
            this.uniqueId = uniqueId;
            this.commonStrings = commonStrings;
            this.expanded = false;
            this.expandedChange = new i0.EventEmitter(false);
            this.expandable = false;
            this.focused = false;
            this._changedChildren = 0;
            this._fullyInitialized = false;
            this._changed = false;
            if (parent) {
                parent.addChild();
            }
        }
        Object.defineProperty(ClrStackBlock.prototype, "getChangedValue", {
            get: /**
             * @return {?}
             */ function () {
                return this._changed || (this._changedChildren > 0 && !this.expanded);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "setChangedValue", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._changed = value;
                if (this.parent && this._fullyInitialized) {
                    if (value) {
                        this.parent._changedChildren++;
                    }
                    else {
                        this.parent._changedChildren--;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrStackBlock.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // in order to access the parent ClrStackBlock's properties,
                // the child ClrStackBlock has to be fully initialized at first.
                this._fullyInitialized = true;
            };
        /**
         * @return {?}
         */
        ClrStackBlock.prototype.addChild = /**
         * @return {?}
         */
            function () {
                this.expandable = true;
            };
        /**
         * @return {?}
         */
        ClrStackBlock.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                if (this.expandable) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        Object.defineProperty(ClrStackBlock.prototype, "caretDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.expanded ? 'down' : 'right';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "caretTitle", {
            get: /**
             * @return {?}
             */ function () {
                return this.expanded ? this.commonStrings.keys.collapse : this.commonStrings.keys.expand;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "role", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandable ? 'button' : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "tabIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandable ? '0' : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "onStackLabelFocus", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandable && !this.expanded && this.focused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "ariaExpanded", {
            get: /**
             * @return {?}
             */ function () {
                if (!this.expandable) {
                    return null;
                }
                else {
                    return this.expanded ? 'true' : 'false';
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrStackBlock.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-block',
                        template: "\n    <dt class=\"stack-block-label\"\n        (click)=\"toggleExpand()\"\n        (keyup.enter)=\"toggleExpand()\"\n        (keyup.space)=\"toggleExpand()\"\n        (focus)=\"focused = true\"\n        (blur)=\"focused = false\"\n        [id]=\"uniqueId\"\n        [attr.role]=\"role\"\n        [attr.tabindex]=\"tabIndex\"\n        [attr.aria-expanded]=\"ariaExpanded\">\n      <clr-icon shape=\"caret\"\n                class=\"stack-block-caret\"\n                *ngIf=\"expandable\"\n                [attr.dir]=\"caretDirection\"\n                [attr.title]=\"caretTitle\"></clr-icon>\n      <span class=\"clr-sr-only\" *ngIf=\"getChangedValue\">{{commonStrings.keys.stackViewChanged}}</span>\n      <ng-content select=\"clr-stack-label\"></ng-content>\n    </dt>\n    <dd class=\"stack-block-content\">\n      <ng-content></ng-content>\n    </dd>\n    <!-- FIXME: remove this string concatenation when boolean states are supported -->\n    <div [@collapse]=\"''+!expanded\" class=\"stack-children\" >\n      <ng-content select=\"clr-stack-block\"></ng-content>\n    </div>\n  ",
                        // Make sure the host has the proper class for styling purposes
                        host: { '[class.stack-block]': 'true' },
                        animations: [
                            animations.trigger('collapse', [
                                animations.state('true', animations.style({ height: 0, display: 'none' })),
                                animations.transition('true => false', [animations.animate('0.2s ease-in-out', animations.style({ height: '*', display: '*' }))]),
                                animations.transition('false => true', [animations.style({ height: '*', display: '*' }), animations.animate('0.2s ease-in-out')]),
                            ]),
                        ],
                        providers: [UNIQUE_ID_PROVIDER],
                        styles: ["\n        :host { display: block; }\n    "]
                    }] }
        ];
        /** @nocollapse */
        ClrStackBlock.ctorParameters = function () {
            return [
                { type: ClrStackBlock, decorators: [{ type: i0.SkipSelf }, { type: i0.Optional }] },
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] },
                { type: ClrCommonStringsService }
            ];
        };
        ClrStackBlock.propDecorators = {
            expanded: [{ type: i0.HostBinding, args: ['class.stack-block-expanded',] }, { type: i0.Input, args: ['clrSbExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrSbExpandedChange',] }],
            expandable: [{ type: i0.HostBinding, args: ['class.stack-block-expandable',] }, { type: i0.Input, args: ['clrSbExpandable',] }],
            getChangedValue: [{ type: i0.HostBinding, args: ['class.stack-block-changed',] }],
            setChangedValue: [{ type: i0.Input, args: ['clrSbNotifyChange',] }],
            onStackLabelFocus: [{ type: i0.HostBinding, args: ['class.on-focus',] }]
        };
        return ClrStackBlock;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackView = /** @class */ (function () {
        function ClrStackView() {
            /**
             * Undocumented experimental feature: inline editing.
             */
            this.editable = false;
            this.save = new i0.EventEmitter(false);
            this._editMode = false;
            this.editingChange = new i0.EventEmitter(false);
            /**
             * End of undocumented experimental feature.
             */
        }
        Object.defineProperty(ClrStackView.prototype, "editing", {
            get: /**
             * @return {?}
             */ function () {
                return this.editable && this._editMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.editable) {
                    this._editMode = value;
                    this.editingChange.emit(value);
                    if (!value) {
                        this.save.emit(null);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrStackView.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-view',
                        template: "\n        <ng-content select=\"clr-stack-header\"></ng-content>\n        <dl class=\"stack-view\"><ng-content></ng-content></dl>\n    ",
                        styles: ["\n        :host { display: block; }\n    "]
                    }] }
        ];
        ClrStackView.propDecorators = {
            save: [{ type: i0.Output, args: ['clrStackSave',] }]
        };
        return ClrStackView;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackHeader = /** @class */ (function () {
        function ClrStackHeader(stackView) {
            this.stackView = stackView;
        }
        ClrStackHeader.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-header',
                        template: "\n        <h4 class=\"stack-header\">\n            <span class=\"stack-title\"><ng-content></ng-content></span>\n            \n            <span class=\"stack-actions\">\n                <ng-content select=\".stack-action\"></ng-content>\n                <!-- Undocumented experimental feature: inline editing. -->\n                <button *ngIf=\"stackView.editable\" class=\"stack-action btn btn-sm btn-link\" \n                        (click)=\"stackView.editing = !stackView.editing\" type=\"button\">\n                        Edit\n                </button>\n                <!-- End of undocumented experimental feature. -->\n            </span>\n        </h4>\n    ",
                        styles: ["\n        :host { display: block; }\n    "]
                    }] }
        ];
        /** @nocollapse */
        ClrStackHeader.ctorParameters = function () {
            return [
                { type: ClrStackView }
            ];
        };
        return ClrStackHeader;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var StackControl = /** @class */ (function () {
        function StackControl(stackView) {
            var _this = this;
            this.stackView = stackView;
            this.modelChange = new i0.EventEmitter(false);
            // Make the ClrStackView editable, since it contains a StackControl
            this.stackView.editable = true;
            this.stackView.editingChange.subscribe(function (editing) {
                // Edit mode was closed
                if (!editing) {
                    _this.modelChange.emit(_this.model);
                }
            });
        }
        return StackControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackInput = /** @class */ (function (_super) {
        __extends(ClrStackInput, _super);
        function ClrStackInput(stackView) {
            var _this = _super.call(this, stackView) || this;
            _this.stackView = stackView;
            _this.type = 'text';
            return _this;
        }
        ClrStackInput.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-input',
                        inputs: ['model: clrModel', 'type'],
                        outputs: ['modelChange: clrModelChange'],
                        template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <input [type]=\"type\" *ngIf=\"stackView.editing\" [(ngModel)]=\"model\"/>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrStackInput.ctorParameters = function () {
            return [
                { type: ClrStackView }
            ];
        };
        return ClrStackInput;
    }(StackControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackSelect = /** @class */ (function (_super) {
        __extends(ClrStackSelect, _super);
        function ClrStackSelect(stackView) {
            var _this = _super.call(this, stackView) || this;
            _this.stackView = stackView;
            return _this;
        }
        ClrStackSelect.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-select',
                        inputs: ['model: clrModel'],
                        outputs: ['modelChange: clrModelChange'],
                        template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <div class=\"select\" *ngIf=\"stackView.editing\" >\n            <select [(ngModel)]=\"model\">\n                <ng-content></ng-content>\n            </select>\n        </div>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrStackSelect.ctorParameters = function () {
            return [
                { type: ClrStackView }
            ];
        };
        return ClrStackSelect;
    }(StackControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackViewCustomTags = /** @class */ (function () {
        function ClrStackViewCustomTags() {
        }
        ClrStackViewCustomTags.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-stack-label, clr-stack-content' },] }
        ];
        return ClrStackViewCustomTags;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackContentInput = /** @class */ (function () {
        function ClrStackContentInput(uniqueId) {
            this.uniqueId = uniqueId;
        }
        ClrStackContentInput.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrStackInput]',
                        host: {
                            '[class.clr-input]': 'true',
                            '[attr.aria-labelledby]': 'uniqueId',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrStackContentInput.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] }
            ];
        };
        return ClrStackContentInput;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_STACK_VIEW_DIRECTIVES = [
        ClrStackView,
        ClrStackHeader,
        ClrStackBlock,
        ClrStackContentInput,
        ClrStackViewCustomTags,
        /**
         * Undocumented experimental feature: inline editing.
         */
        ClrStackInput,
        ClrStackSelect,
    ];
    var ClrStackViewModule = /** @class */ (function () {
        function ClrStackViewModule() {
        }
        ClrStackViewModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule],
                        declarations: [CLR_STACK_VIEW_DIRECTIVES],
                        exports: [CLR_STACK_VIEW_DIRECTIVES],
                    },] }
        ];
        return ClrStackViewModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {number} */
    var ClrSelectedState = {
        // WARNING! Unselected has the value 0,
        // so it's actually the only one that will evaluate to false if cast to a boolean.
        // Don't mess with the order!
        UNSELECTED: 0,
        SELECTED: 1,
        INDETERMINATE: 2,
    };
    ClrSelectedState[ClrSelectedState.UNSELECTED] = 'UNSELECTED';
    ClrSelectedState[ClrSelectedState.SELECTED] = 'SELECTED';
    ClrSelectedState[ClrSelectedState.INDETERMINATE] = 'INDETERMINATE';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template T
     */
    var /**
     * @abstract
     * @template T
     */ TreeNodeModel = /** @class */ (function () {
        function TreeNodeModel() {
            this.selected = new rxjs.BehaviorSubject(ClrSelectedState.UNSELECTED);
            /*
               * Being able to push this down to the RecursiveTreeNodeModel would require too much work on the angular components
               * right now for them to know which kind of model they are using. So I'm lifting the public properties to this
               * abstract parent class for now and we can revisit it later, when we're not facing such a close deadline.
               */
            this.loading = false;
        }
        /**
         * @return {?}
         */
        TreeNodeModel.prototype.destroy = /**
         * @return {?}
         */
            function () {
                // Just to be safe
                this.selected.complete();
            };
        // Propagate by default when eager, don't propagate in the lazy-loaded tree.
        // Propagate by default when eager, don't propagate in the lazy-loaded tree.
        /**
         * @param {?} state
         * @param {?} propagateUp
         * @param {?} propagateDown
         * @return {?}
         */
        TreeNodeModel.prototype.setSelected =
            // Propagate by default when eager, don't propagate in the lazy-loaded tree.
            /**
             * @param {?} state
             * @param {?} propagateUp
             * @param {?} propagateDown
             * @return {?}
             */
            function (state, propagateUp, propagateDown) {
                if (state === this.selected.value) {
                    return;
                }
                this.selected.next(state);
                if (propagateDown && state !== ClrSelectedState.INDETERMINATE && this.children) {
                    this.children.forEach(function (child) { return child.setSelected(state, false, true); });
                }
                if (propagateUp && this.parent) {
                    this.parent._updateSelectionFromChildren();
                }
            };
        /**
         * @param {?} propagate
         * @return {?}
         */
        TreeNodeModel.prototype.toggleSelection = /**
         * @param {?} propagate
         * @return {?}
         */
            function (propagate) {
                // Both unselected and indeterminate toggle to selected
                /** @type {?} */
                var newState = this.selected.value === ClrSelectedState.SELECTED ? ClrSelectedState.UNSELECTED : ClrSelectedState.SELECTED;
                // NOTE: we always propagate selection up in this method because it is only called when the user takes an action.
                // It should never be called from lifecycle hooks or app-provided inputs.
                this.setSelected(newState, true, propagate);
            };
        /**
         * @return {?}
         */
        TreeNodeModel.prototype.computeSelectionStateFromChildren = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                /** @type {?} */
                var oneSelected = false;
                /** @type {?} */
                var oneUnselected = false;
                try {
                    // Using a good old for loop to exit as soon as we can tell, for better performance on large trees.
                    for (var _b = __values(this.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        switch (child.selected.value) {
                            case ClrSelectedState.INDETERMINATE:
                                return ClrSelectedState.INDETERMINATE;
                            case ClrSelectedState.SELECTED:
                                oneSelected = true;
                                if (oneUnselected) {
                                    return ClrSelectedState.INDETERMINATE;
                                }
                                break;
                            case ClrSelectedState.UNSELECTED:
                            default:
                                // Default is the same as unselected, in case an undefined somehow made it all the way here.
                                oneUnselected = true;
                                if (oneSelected) {
                                    return ClrSelectedState.INDETERMINATE;
                                }
                                break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                if (!oneSelected) {
                    return ClrSelectedState.UNSELECTED;
                }
                else if (!oneUnselected) {
                    return ClrSelectedState.SELECTED;
                }
            };
        /*
         * Internal, but needs to be called by other nodes
         */
        /*
           * Internal, but needs to be called by other nodes
           */
        /**
         * @return {?}
         */
        TreeNodeModel.prototype._updateSelectionFromChildren = /*
           * Internal, but needs to be called by other nodes
           */
            /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var newState = this.computeSelectionStateFromChildren();
                if (newState === this.selected.value) {
                    return;
                }
                this.selected.next(newState);
                if (this.parent) {
                    this.parent._updateSelectionFromChildren();
                }
            };
        return TreeNodeModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * A declarative model is built by traversing the Angular component tree.
     * Declarative = Tree node components dictate the model
     */
    /**
     * @template T
     */
    var /*
     * A declarative model is built by traversing the Angular component tree.
     * Declarative = Tree node components dictate the model
     */ 
    /**
     * @template T
     */
    DeclarativeTreeNodeModel = /** @class */ (function (_super) {
        __extends(DeclarativeTreeNodeModel, _super);
        function DeclarativeTreeNodeModel(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            if (parent) {
                parent._addChild(_this);
            }
            _this.children = [];
            return _this;
        }
        /**
         * @param {?} child
         * @return {?}
         */
        DeclarativeTreeNodeModel.prototype._addChild = /**
         * @param {?} child
         * @return {?}
         */
            function (child) {
                this.children.push(child);
            };
        /**
         * @param {?} child
         * @return {?}
         */
        DeclarativeTreeNodeModel.prototype._removeChild = /**
         * @param {?} child
         * @return {?}
         */
            function (child) {
                /** @type {?} */
                var index = this.children.indexOf(child);
                if (index > -1) {
                    this.children.splice(index, 1);
                }
            };
        /**
         * @return {?}
         */
        DeclarativeTreeNodeModel.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this.parent) {
                    this.parent._removeChild(this);
                }
                _super.prototype.destroy.call(this);
            };
        return DeclarativeTreeNodeModel;
    }(TreeNodeModel));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var TreeFeaturesService = /** @class */ (function () {
        function TreeFeaturesService() {
            this.selectable = false;
            this.eager = true;
        }
        TreeFeaturesService.decorators = [
            { type: i0.Injectable }
        ];
        return TreeFeaturesService;
    }());
    /**
     * @template T
     * @param {?} existing
     * @return {?}
     */
    function treeFeaturesFactory(existing) {
        return existing || new TreeFeaturesService();
    }
    /** @type {?} */
    var TREE_FEATURES_PROVIDER = {
        provide: TreeFeaturesService,
        useFactory: treeFeaturesFactory,
        /*
           * The Optional + SkipSelf pattern ensures that in case of nested components, only the root one will
           * instantiate a new service and all its children will reuse the root's instance.
           * If there are several roots (in this case, several independent trees on a page), each root will instantiate
           * its own service so they won't interfere with one another.
           *
           * TL;DR - Optional + SkipSelf = 1 instance of TreeFeaturesService per tree.
           */
        deps: [[new i0.Optional(), new i0.SkipSelf(), TreeFeaturesService]],
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrTreeNode = /** @class */ (function () {
        function ClrTreeNode(nodeId, parent, featuresService, expandService, commonStrings, injector) {
            this.nodeId = nodeId;
            this.featuresService = featuresService;
            this.expandService = expandService;
            this.commonStrings = commonStrings;
            this.STATES = ClrSelectedState;
            this.skipEmitChange = false;
            this.selectedChange = new i0.EventEmitter(false);
            this.expandedChange = new i0.EventEmitter();
            this.subscriptions = [];
            if (this.featuresService.recursion) {
                // I'm completely stuck, we have to hack into private properties until either
                // https://github.com/angular/angular/issues/14935 or https://github.com/angular/angular/issues/15998
                // are fixed
                this._model = (( /** @type {?} */(injector))).view.context.clrModel;
            }
            else {
                // Force cast for now, not sure how to tie the correct type here to featuresService.recursion
                this._model = new DeclarativeTreeNodeModel(parent ? ( /** @type {?} */(parent._model)) : null);
            }
        }
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.isExpandable = /**
         * @return {?}
         */
            function () {
                if (typeof this.expandable !== 'undefined') {
                    return this.expandable;
                }
                return !!this.expandService.expandable || this._model.children.length > 0;
            };
        Object.defineProperty(ClrTreeNode.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._model.selected.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.featuresService.selectable = true;
                // Gracefully handle falsy states like null or undefined because it's just easier than answering questions.
                // This shouldn't happen with strict typing on the app's side, but it's not up to us.
                if (value === null || typeof value === 'undefined') {
                    value = ClrSelectedState.UNSELECTED;
                }
                // We match booleans to the corresponding ClrSelectedState
                if (typeof value === 'boolean') {
                    value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
                }
                // We propagate only if the tree is in smart mode, and skip emitting the output when we set the input
                // See https://github.com/vmware/clarity/issues/3073
                this.skipEmitChange = true;
                this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
                this.skipEmitChange = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "treeNodeRole", {
            get: /**
             * @return {?}
             */ function () {
                return this._model.parent ? 'treeitem' : 'tree';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "rootAriaMultiSelectable", {
            get: /**
             * @return {?}
             */ function () {
                if (this._model.parent || !this.featuresService.selectable) {
                    return null;
                }
                else {
                    return true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "ariaSelected", {
            get: /**
             * @return {?}
             */ function () {
                return this.featuresService.selectable ? this._model.selected.value === ClrSelectedState.SELECTED : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "expanded", {
            // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
            // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
            // case, you can't use a structural directive, it would need to go on an ng-container.
            get: 
            // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
            // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
            // case, you can't use a structural directive, it would need to go on an ng-container.
            /**
             * @return {?}
             */
            function () {
                return this.expandService.expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.expandService.expanded = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this._model.selected.pipe(operators.filter(function () { return !_this.skipEmitChange; })).subscribe(function (value) { return _this.selectedChange.emit(value); }));
                this.subscriptions.push(this.expandService.expandChange.subscribe(function (value) { return _this.expandedChange.emit(value); }));
            };
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._model.destroy();
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrTreeNode.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tree-node',
                        template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"clr-tree-node-content-container\">\n  <button\n    *ngIf=\"isExpandable() && !_model.loading && !expandService.loading\"\n    type=\"button\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle()\"\n    [attr.aria-expanded]=\"expandService.expanded\">\n    <clr-icon\n      class=\"clr-treenode-caret-icon\"\n      shape=\"caret\"\n      [attr.dir]=\"expandService.expanded ? 'down' : 'right'\"\n      [attr.title]=\"expandService.expanded ? commonStrings.keys.collapse : commonStrings.keys.expand\"></clr-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || _model.loading\">\n        <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input type=\"checkbox\" id=\"{{nodeId}}-check\" class=\"clr-checkbox\" [attr.aria-labelledby]=\"nodeId\"\n           [checked]=\"_model.selected.value === STATES.SELECTED\"\n           [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n           (change)=\"_model.toggleSelection(featuresService.eager)\">\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\"></label>\n  </div>\n  <div class=\"clr-treenode-content\" [id]=\"nodeId\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"clr-treenode-children\"\n     [@childNodesState]=\"expandService.expanded ? 'expanded' : 'collapsed'\"\n     [attr.role]=\"isExpandable() ? 'group' : null\">\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n",
                        providers: [UNIQUE_ID_PROVIDER, TREE_FEATURES_PROVIDER, Expand, { provide: LoadingListener, useExisting: Expand }],
                        animations: [
                            animations.trigger('childNodesState', [
                                animations.state('expanded', animations.style({ height: '*', 'overflow-y': 'hidden' })),
                                animations.state('collapsed', animations.style({ height: 0, 'overflow-y': 'hidden' })),
                                animations.transition('expanded <=> collapsed', animations.animate('0.2s ease-in-out')),
                            ]),
                        ],
                        host: { '[class.clr-tree-node]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrTreeNode.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] },
                { type: ClrTreeNode, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
                { type: TreeFeaturesService },
                { type: Expand },
                { type: ClrCommonStringsService },
                { type: i0.Injector }
            ];
        };
        ClrTreeNode.propDecorators = {
            selected: [{ type: i0.Input, args: ['clrSelected',] }],
            selectedChange: [{ type: i0.Output, args: ['clrSelectedChange',] }],
            treeNodeRole: [{ type: i0.HostBinding, args: ['attr.role',] }],
            rootAriaMultiSelectable: [{ type: i0.HostBinding, args: ['attr.aria-multiselectable',] }],
            ariaSelected: [{ type: i0.HostBinding, args: ['attr.aria-selected',] }],
            expandable: [{ type: i0.Input, args: ['clrExpandable',] }],
            expanded: [{ type: i0.Input, args: ['clrExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrExpandedChange',] }]
        };
        return ClrTreeNode;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrTree = /** @class */ (function () {
        // This component can also be used just to declare providers once for trees with multiple root nodes.
        function ClrTree(featuresService) {
            this.featuresService = featuresService;
        }
        Object.defineProperty(ClrTree.prototype, "lazy", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.featuresService.eager = !value;
            },
            enumerable: true,
            configurable: true
        });
        ClrTree.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tree',
                        template: "\n    <ng-content></ng-content>\n    <clr-recursive-children *ngIf=\"featuresService.recursion\"\n                            [children]=\"featuresService.recursion.root\"></clr-recursive-children>\n  ",
                        providers: [TREE_FEATURES_PROVIDER]
                    }] }
        ];
        /** @nocollapse */
        ClrTree.ctorParameters = function () {
            return [
                { type: TreeFeaturesService }
            ];
        };
        ClrTree.propDecorators = {
            lazy: [{ type: i0.Input, args: ['clrLazy',] }]
        };
        return ClrTree;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * @template T
     * @param {?} o
     * @return {?}
     */
    function isPromise(o) {
        // Shamelessly copied from every open-source project out there.
        return o && typeof (( /** @type {?} */(o))).then === 'function';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * A recursive model is built received from the app and traversed to create the corresponding components.
     * Recursive = Model dictates the tree node components
     */
    /**
     * @template T
     */
    var /*
     * A recursive model is built received from the app and traversed to create the corresponding components.
     * Recursive = Model dictates the tree node components
     */ 
    /**
     * @template T
     */
    RecursiveTreeNodeModel = /** @class */ (function (_super) {
        __extends(RecursiveTreeNodeModel, _super);
        function RecursiveTreeNodeModel(model, parent, getChildren) {
            var _this = _super.call(this) || this;
            _this.getChildren = getChildren;
            _this.childrenFetched = false;
            _this._children = [];
            _this.model = model;
            _this.parent = parent;
            return _this;
        }
        /**
         * @return {?}
         */
        RecursiveTreeNodeModel.prototype.clearChildren = /**
         * @return {?}
         */
            function () {
                this._children.forEach(function (child) { return child.destroy(); });
                delete this._children;
                this.childrenFetched = false;
            };
        /**
         * @return {?}
         */
        RecursiveTreeNodeModel.prototype.fetchChildren = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.childrenFetched) {
                    return;
                }
                /** @type {?} */
                var asyncChildren = this.getChildren(this.model);
                if (isPromise(asyncChildren)) {
                    this.loading = true;
                    asyncChildren.then(function (raw) {
                        _this._children = _this.wrapChildren(raw);
                        _this.loading = false;
                    });
                }
                else if (rxjs.isObservable(asyncChildren)) {
                    this.loading = true;
                    this.subscription = asyncChildren.subscribe(function (raw) {
                        _this._children = _this.wrapChildren(raw);
                        _this.loading = false;
                    });
                }
                else if (asyncChildren) {
                    // Synchronous case
                    this._children = this.wrapChildren(asyncChildren);
                }
                else {
                    this._children = [];
                }
                this.childrenFetched = true;
            };
        /**
         * @param {?} rawModels
         * @return {?}
         */
        RecursiveTreeNodeModel.prototype.wrapChildren = /**
         * @param {?} rawModels
         * @return {?}
         */
            function (rawModels) {
                var _this = this;
                return rawModels.map(function (m) { return new RecursiveTreeNodeModel(m, _this, _this.getChildren); });
            };
        Object.defineProperty(RecursiveTreeNodeModel.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                this.fetchChildren();
                return this._children;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._children = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RecursiveTreeNodeModel.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this.subscription) {
                    this.subscription.unsubscribe();
                }
                _super.prototype.destroy.call(this);
            };
        return RecursiveTreeNodeModel;
    }(TreeNodeModel));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrRecursiveForOf = /** @class */ (function () {
        function ClrRecursiveForOf(template, featuresService) {
            this.template = template;
            this.featuresService = featuresService;
        }
        // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
        // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
        /**
         * @return {?}
         */
        ClrRecursiveForOf.prototype.ngOnChanges =
            // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
            /**
             * @return {?}
             */
            function () {
                var _this = this;
                /** @type {?} */
                var wrapped;
                if (Array.isArray(this.nodes)) {
                    wrapped = this.nodes.map(function (node) { return new RecursiveTreeNodeModel(node, null, _this.getChildren); });
                }
                else {
                    wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren)];
                }
                this.featuresService.recursion = {
                    template: this.template,
                    root: wrapped,
                };
            };
        ClrRecursiveForOf.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrRecursiveFor][clrRecursiveForOf]' },] }
        ];
        /** @nocollapse */
        ClrRecursiveForOf.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: TreeFeaturesService }
            ];
        };
        ClrRecursiveForOf.propDecorators = {
            nodes: [{ type: i0.Input, args: ['clrRecursiveForOf',] }],
            getChildren: [{ type: i0.Input, args: ['clrRecursiveForGetChildren',] }]
        };
        return ClrRecursiveForOf;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var RecursiveChildren = /** @class */ (function () {
        function RecursiveChildren(featuresService, expandService) {
            var _this = this;
            this.featuresService = featuresService;
            this.expandService = expandService;
            if (expandService) {
                this.subscription = this.expandService.expandChange.subscribe(function (value) {
                    if (!value && _this.parent && !_this.featuresService.eager && _this.featuresService.recursion) {
                        // In the case of lazy-loading recursive trees, we clear the children on collapse.
                        // This is better in case they change between two user interaction, and that way
                        // the app itself can decide whether to cache them or not.
                        (( /** @type {?} */(_this.parent))).clearChildren();
                    }
                });
            }
        }
        /**
         * @return {?}
         */
        RecursiveChildren.prototype.shouldRender = /**
         * @return {?}
         */
            function () {
                return (this.featuresService.recursion &&
                    // In the smart case, we eagerly render all the recursive children
                    // to make sure two-way bindings for selection are available.
                    // They will be hidden with CSS by the parent.
                    (this.featuresService.eager || !this.expandService || this.expandService.expanded));
            };
        /**
         * @param {?} node
         * @return {?}
         */
        RecursiveChildren.prototype.getContext = /**
         * @param {?} node
         * @return {?}
         */
            function (node) {
                return {
                    $implicit: node.model,
                    clrModel: node,
                };
            };
        /**
         * @return {?}
         */
        RecursiveChildren.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscription) {
                    this.subscription.unsubscribe();
                }
            };
        RecursiveChildren.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-recursive-children',
                        template: "\n    <ng-container *ngIf=\"shouldRender()\">\n      <ng-container *ngFor=\"let child of parent?.children || children\">\n        <ng-container *ngTemplateOutlet=\"featuresService.recursion.template; context: getContext(child)\"></ng-container>\n      </ng-container>\n    </ng-container>\n  "
                    }] }
        ];
        /** @nocollapse */
        RecursiveChildren.ctorParameters = function () {
            return [
                { type: TreeFeaturesService },
                { type: Expand, decorators: [{ type: i0.Optional }] }
            ];
        };
        RecursiveChildren.propDecorators = {
            parent: [{ type: i0.Input, args: ['parent',] }],
            children: [{ type: i0.Input, args: ['children',] }]
        };
        return RecursiveChildren;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_TREE_VIEW_DIRECTIVES = [ClrTree, ClrTreeNode, ClrRecursiveForOf];
    var ClrTreeViewModule = /** @class */ (function () {
        function ClrTreeViewModule() {
        }
        ClrTreeViewModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrLoadingModule],
                        declarations: [CLR_TREE_VIEW_DIRECTIVES, RecursiveChildren],
                        exports: [CLR_TREE_VIEW_DIRECTIVES, ClrIfExpandModule],
                    },] }
        ];
        return ClrTreeViewModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDataModule = /** @class */ (function () {
        function ClrDataModule() {
        }
        ClrDataModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule] },] }
        ];
        return ClrDataModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ FocusableItem = /** @class */ (function () {
        function FocusableItem() {
        }
        return FocusableItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} implementation
     * @return {?}
     */
    function customFocusableItemProvider(implementation) {
        return [
            UNIQUE_ID_PROVIDER,
            implementation,
            {
                provide: FocusableItem,
                useExisting: implementation,
            },
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {string} */
    var ArrowKeyDirection = {
        UP: 'up',
        DOWN: 'down',
        LEFT: 'left',
        RIGHT: 'right',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var FocusService$1 = /** @class */ (function () {
        function FocusService(renderer) {
            this.renderer = renderer;
            this._unlistenFuncs = [];
        }
        Object.defineProperty(FocusService.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} first
         * @return {?}
         */
        FocusService.prototype.reset = /**
         * @param {?} first
         * @return {?}
         */
            function (first) {
                this._current = first;
            };
        /**
         * @param {?} el
         * @return {?}
         */
        FocusService.prototype.listenToArrowKeys = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                var _this = this;
                // The following listeners return false when there was an action to take for the key pressed,
                // in order to prevent the default behavior of that key.
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowup', function (event) { return !_this.move(ArrowKeyDirection.UP, event); }));
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowdown', function (event) { return !_this.move(ArrowKeyDirection.DOWN, event); }));
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowleft', function (event) { return !_this.move(ArrowKeyDirection.LEFT, event); }));
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowright', function (event) { return !_this.move(ArrowKeyDirection.RIGHT, event); }));
            };
        /**
         * @param {?} el
         * @return {?}
         */
        FocusService.prototype.registerContainer = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                var _this = this;
                this.renderer.setAttribute(el, 'tabindex', '0');
                this.listenToArrowKeys(el);
                // The following listeners return false when there was an action to take for the key pressed,
                // in order to prevent the default behavior of that key.
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.space', function () { return !_this.activateCurrent(); }));
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.enter', function () { return !_this.activateCurrent(); }));
            };
        /**
         * @param {?} item
         * @return {?}
         */
        FocusService.prototype.moveTo = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.current) {
                    this.current.blur();
                }
                item.focus();
                this._current = item;
            };
        /**
         * @param {?} direction
         * @param {?=} event
         * @return {?}
         */
        FocusService.prototype.move = /**
         * @param {?} direction
         * @param {?=} event
         * @return {?}
         */
            function (direction, event) {
                var _this = this;
                if (event === void 0) {
                    event = undefined;
                }
                if (this.current) {
                    // We want to prevent default behavior that results from the keydown,
                    // which may undesirably move the cursor around when using a screen reader
                    if (event) {
                        event.preventDefault();
                    }
                    /** @type {?} */
                    var next = this.current[direction];
                    if (next) {
                        // Turning the value into an Observable isn't great, but it's the fastest way to avoid code duplication.
                        // If performance ever matters for this, we can refactor using additional private methods.
                        /** @type {?} */
                        var nextObs = rxjs.isObservable(next) ? next : rxjs.of(next);
                        nextObs.subscribe(function (item) {
                            _this.moveTo(item);
                            return true;
                        });
                    }
                }
                return false;
            };
        /**
         * @return {?}
         */
        FocusService.prototype.activateCurrent = /**
         * @return {?}
         */
            function () {
                if (this.current && this.current.activate) {
                    this.current.activate();
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        FocusService.prototype.detachListeners = /**
         * @return {?}
         */
            function () {
                this._unlistenFuncs.forEach(function (unlisten) { return unlisten(); });
            };
        FocusService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        FocusService.ctorParameters = function () {
            return [
                { type: i0.Renderer2 }
            ];
        };
        return FocusService;
    }());
    /**
     * @param {?} existing
     * @param {?} renderer
     * @return {?}
     */
    function clrFocusServiceFactory(existing, renderer) {
        return existing || new FocusService$1(renderer);
    }
    /** @type {?} */
    var FOCUS_SERVICE_PROVIDER = {
        provide: FocusService$1,
        useFactory: clrFocusServiceFactory,
        deps: [[new i0.Optional(), new i0.SkipSelf(), FocusService$1], i0.Renderer2],
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Links a set of focusable items to a parent along one direction
     * @param {?} items
     * @param {?} parent
     * @param {?} direction
     * @return {?}
     */
    function linkParent(items, parent, direction) {
        items.forEach(function (item) { return (item[direction] = parent); });
    }
    /**
     * Double-links a set of focusable items vertically, possibly looping
     * @param {?} items
     * @param {?=} loop
     * @return {?}
     */
    function linkVertical(items, loop) {
        if (loop === void 0) {
            loop = true;
        }
        items.forEach(function (item, index) {
            if (index > 0) {
                item.up = items[index - 1];
            }
            if (index < items.length - 1) {
                item.down = items[index + 1];
            }
        });
        if (loop && items.length > 1) {
            items[0].up = items[items.length - 1];
            items[items.length - 1].down = items[0];
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} observable
     * @param {?=} onSubscribe
     * @param {?=} onUnsubscribe
     * @return {?}
     */
    function wrapObservable(observable, onSubscribe, onUnsubscribe) {
        return rxjs.Observable.create(function (observer) {
            onSubscribe(observer);
            /** @type {?} */
            var subscription = observable.subscribe(observer);
            return function () {
                subscription.unsubscribe();
                if (onUnsubscribe) {
                    onUnsubscribe(observer);
                }
            };
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DropdownFocusHandler = /** @class */ (function () {
        function DropdownFocusHandler(id, renderer, parent, ifOpenService, focusService, platformId) {
            this.id = id;
            this.renderer = renderer;
            this.parent = parent;
            this.ifOpenService = ifOpenService;
            this.focusService = focusService;
            this.platformId = platformId;
            this._unlistenFuncs = [];
            this.focusBackOnTrigger = false;
            this.resetChildren();
            this.moveToFirstItemWhenOpen();
            if (!this.parent) {
                this.handleRootFocus();
            }
        }
        /**
         * If the dropdown was opened by clicking on the trigger, we automatically move to the first item
         */
        /**
         * If the dropdown was opened by clicking on the trigger, we automatically move to the first item
         * @return {?}
         */
        DropdownFocusHandler.prototype.moveToFirstItemWhenOpen = /**
         * If the dropdown was opened by clicking on the trigger, we automatically move to the first item
         * @return {?}
         */
            function () {
                var _this = this;
                this.ifOpenService.openChange.subscribe(function (open) {
                    if (open && _this.ifOpenService.originalEvent) {
                        // Even if we properly waited for ngAfterViewInit, the container still wouldn't be attached to the DOM.
                        // So setTimeout is the only way to wait for the container to be ready to move focus to first item.
                        setTimeout(function () {
                            _this.focusService.moveTo(_this);
                            if (_this.parent) {
                                _this.focusService.move(ArrowKeyDirection.RIGHT);
                            }
                            else {
                                _this.focusService.move(ArrowKeyDirection.DOWN);
                            }
                        });
                    }
                });
            };
        /**
         * Focus on the menu when it opens, and focus back on the root trigger when the whole dropdown becomes closed
         */
        /**
         * Focus on the menu when it opens, and focus back on the root trigger when the whole dropdown becomes closed
         * @return {?}
         */
        DropdownFocusHandler.prototype.handleRootFocus = /**
         * Focus on the menu when it opens, and focus back on the root trigger when the whole dropdown becomes closed
         * @return {?}
         */
            function () {
                var _this = this;
                this.ifOpenService.openChange.subscribe(function (open) {
                    if (!open) {
                        // We reset the state of the focus service both on initialization and when closing.
                        _this.focusService.reset(_this);
                        // But we only actively focus the trigger when closing, not on initialization.
                        if (_this.focusBackOnTrigger) {
                            _this.focus();
                        }
                    }
                    _this.focusBackOnTrigger = open;
                });
            };
        Object.defineProperty(DropdownFocusHandler.prototype, "trigger", {
            get: /**
             * @return {?}
             */ function () {
                return this._trigger;
            },
            set: /**
             * @param {?} el
             * @return {?}
             */ function (el) {
                var _this = this;
                this._trigger = el;
                this.renderer.setAttribute(el, 'id', this.id);
                if (this.parent) {
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowright', function (event) { return _this.ifOpenService.toggleWithEvent(event); }));
                }
                else {
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowup', function (event) { return _this.ifOpenService.toggleWithEvent(event); }));
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowdown', function (event) { return _this.ifOpenService.toggleWithEvent(event); }));
                    this.focusService.listenToArrowKeys(el);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DropdownFocusHandler.prototype, "container", {
            get: /**
             * @return {?}
             */ function () {
                return this._container;
            },
            set: /**
             * @param {?} el
             * @return {?}
             */ function (el) {
                var _this = this;
                this._container = el;
                // whether root container or not, tab key should always toggle (i.e. close) the container
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.tab', function (event) { return _this.ifOpenService.toggleWithEvent(event); }));
                if (this.parent) {
                    // if it's a nested container, pressing esc has the same effect as pressing left key, which closes the current
                    // popup and moves up to its parent. Here, we stop propagation so that the parent container
                    // doesn't receive the esc keydown
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.esc', function (event) {
                        _this.focusService.move(ArrowKeyDirection.LEFT, event);
                        event.stopPropagation();
                    }));
                }
                else {
                    // The root container is the only one we register to the focus service, others do not need focus
                    this.focusService.registerContainer(el);
                    // The root container will simply close the container when esc key is pressed
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.esc', function (event) { return _this.ifOpenService.toggleWithEvent(event); }));
                    // When the user moves focus outside of the menu, we close the dropdown
                    this._unlistenFuncs.push(this.renderer.listen(el, 'blur', function (event) {
                        // we clear out any existing focus on the items
                        _this.children.pipe(operators.take(1)).subscribe(function (items) { return items.forEach(function (item) { return item.blur(); }); });
                        // event.relatedTarget is null in IE11. In that case we use document.activeElement which correctly points
                        // to the element we want to check. Note that other browsers might point document.activeElement to the
                        // wrong element. This is ok, because all the other browsers we support relies on event.relatedTarget.
                        /** @type {?} */
                        var target = event.relatedTarget || document.activeElement;
                        // If the user clicks on an item which triggers the blur, we don't want to close it since it may open a submenu.
                        // In the case of needing to close it (i.e. user selected an item and the dropdown menu is set to close on
                        // selection), dropdown-item.ts handles it.
                        if (target && common.isPlatformBrowser(_this.platformId)) {
                            if (el.contains(target) || target === _this.trigger) {
                                return;
                            }
                        }
                        // We let the user move focus to where the want, we don't force the focus back on the trigger
                        _this.focusBackOnTrigger = false;
                        _this.ifOpenService.open = false;
                    }));
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DropdownFocusHandler.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (this.trigger && common.isPlatformBrowser(this.platformId)) {
                    this.trigger.focus();
                }
            };
        /**
         * @return {?}
         */
        DropdownFocusHandler.prototype.blur = /**
         * @return {?}
         */
            function () {
                if (this.trigger && common.isPlatformBrowser(this.platformId)) {
                    this.trigger.blur();
                }
            };
        /**
         * @return {?}
         */
        DropdownFocusHandler.prototype.activate = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId)) {
                    this.trigger.click();
                }
            };
        /**
         * @return {?}
         */
        DropdownFocusHandler.prototype.openAndGetChildren = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return wrapObservable(this.children, function () { return (_this.ifOpenService.open = true); });
            };
        /**
         * @return {?}
         */
        DropdownFocusHandler.prototype.closeAndGetThis = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return wrapObservable(rxjs.of(this), function () { return (_this.ifOpenService.open = false); });
            };
        /**
         * @return {?}
         */
        DropdownFocusHandler.prototype.resetChildren = /**
         * @return {?}
         */
            function () {
                this.children = new rxjs.ReplaySubject(1);
                if (this.parent) {
                    this.right = this.openAndGetChildren().pipe(operators.map(function (all) { return all[0]; }));
                }
                else {
                    this.down = this.openAndGetChildren().pipe(operators.map(function (all) { return all[0]; }));
                    this.up = this.openAndGetChildren().pipe(operators.map(function (all) { return all[all.length - 1]; }));
                }
            };
        /**
         * @param {?} children
         * @return {?}
         */
        DropdownFocusHandler.prototype.addChildren = /**
         * @param {?} children
         * @return {?}
         */
            function (children) {
                linkVertical(children);
                if (this.parent) {
                    linkParent(children, this.closeAndGetThis(), ArrowKeyDirection.LEFT);
                }
                this.children.next(children);
            };
        /**
         * @return {?}
         */
        DropdownFocusHandler.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._unlistenFuncs.forEach(function (unlisten) { return unlisten(); });
                this.focusService.detachListeners();
            };
        DropdownFocusHandler.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DropdownFocusHandler.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] },
                { type: i0.Renderer2 },
                { type: DropdownFocusHandler, decorators: [{ type: i0.SkipSelf }, { type: i0.Optional }] },
                { type: IfOpenService },
                { type: FocusService$1 },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        return DropdownFocusHandler;
    }());
    /** @type {?} */
    var DROPDOWN_FOCUS_HANDLER_PROVIDER = customFocusableItemProvider(DropdownFocusHandler);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var RootDropdownService = /** @class */ (function () {
        function RootDropdownService() {
            this._changes = new rxjs.Subject();
        }
        Object.defineProperty(RootDropdownService.prototype, "changes", {
            get: /**
             * @return {?}
             */ function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RootDropdownService.prototype.closeMenus = /**
         * @return {?}
         */
            function () {
                this._changes.next(false);
            };
        RootDropdownService.decorators = [
            { type: i0.Injectable }
        ];
        return RootDropdownService;
    }());
    /**
     * @param {?} existing
     * @return {?}
     */
    function clrRootDropdownFactory(existing) {
        return existing || new RootDropdownService();
    }
    /** @type {?} */
    var ROOT_DROPDOWN_PROVIDER = {
        provide: RootDropdownService,
        useFactory: clrRootDropdownFactory,
        deps: [[new i0.Optional(), new i0.SkipSelf(), RootDropdownService]],
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdown = /** @class */ (function () {
        function ClrDropdown(parent, ifOpenService, cdr, dropdownService) {
            var _this = this;
            this.parent = parent;
            this.ifOpenService = ifOpenService;
            this.cdr = cdr;
            this.subscriptions = [];
            this.isMenuClosable = true;
            this.subscriptions.push(dropdownService.changes.subscribe(function (value) { return (_this.ifOpenService.open = value); }));
            this.subscriptions.push(ifOpenService.openChange.subscribe(function (value) { return _this.cdr.markForCheck(); }));
        }
        /**
         * @return {?}
         */
        ClrDropdown.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDropdown.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dropdown',
                        template: '<ng-content></ng-content>',
                        host: {
                            '[class.dropdown]': 'true',
                            // FIXME: remove this as soon as we stop supporting this old <div class="dropdown-menu"> syntax
                            '[class.open]': 'ifOpenService.open',
                        },
                        providers: [
                            IfOpenService,
                            ROOT_DROPDOWN_PROVIDER,
                            { provide: POPOVER_HOST_ANCHOR, useExisting: i0.ElementRef },
                            FOCUS_SERVICE_PROVIDER,
                            DROPDOWN_FOCUS_HANDLER_PROVIDER,
                        ]
                    }] }
        ];
        /** @nocollapse */
        ClrDropdown.ctorParameters = function () {
            return [
                { type: ClrDropdown, decorators: [{ type: i0.SkipSelf }, { type: i0.Optional }] },
                { type: IfOpenService },
                { type: i0.ChangeDetectorRef },
                { type: RootDropdownService }
            ];
        };
        ClrDropdown.propDecorators = {
            isMenuClosable: [{ type: i0.Input, args: ['clrCloseMenuOnItemClick',] }]
        };
        return ClrDropdown;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var BasicFocusableItem = /** @class */ (function () {
        function BasicFocusableItem(id, el, renderer, platformId) {
            this.id = id;
            this.el = el;
            this.renderer = renderer;
            this.platformId = platformId;
            this.disabled = false;
            renderer.setAttribute(el.nativeElement, 'id', id);
            renderer.setAttribute(el.nativeElement, 'tabindex', '-1');
        }
        /**
         * @return {?}
         */
        BasicFocusableItem.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId)) {
                    this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
                    this.el.nativeElement.focus();
                }
            };
        /**
         * @return {?}
         */
        BasicFocusableItem.prototype.blur = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId)) {
                    this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '-1');
                    this.el.nativeElement.blur();
                }
            };
        /**
         * @return {?}
         */
        BasicFocusableItem.prototype.activate = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId)) {
                    this.el.nativeElement.click();
                }
            };
        BasicFocusableItem.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        BasicFocusableItem.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        return BasicFocusableItem;
    }());
    /** @type {?} */
    var BASIC_FOCUSABLE_ITEM_PROVIDER = [
        UNIQUE_ID_PROVIDER,
        {
            provide: FocusableItem,
            useClass: BasicFocusableItem,
        },
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdownItem = /** @class */ (function () {
        function ClrDropdownItem(dropdown, el, _dropdownService, renderer, focusableItem) {
            this.dropdown = dropdown;
            this.el = el;
            this._dropdownService = _dropdownService;
            this.renderer = renderer;
            this.focusableItem = focusableItem;
            this.setByDeprecatedDisabled = false;
        }
        Object.defineProperty(ClrDropdownItem.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.focusableItem.disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // Empty string attribute evaluates to false but should disable the item, so we need to add a special case for it.
                this.focusableItem.disabled = !!value || value === '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDropdownItem.prototype, "disabledDeprecated", {
            get: /**
             * @return {?}
             */ function () {
                return this.focusableItem.disabled;
            },
            /*
             * @deprecated since 3.0, remove in 4.0. the presence of this attribute makes it not-focusable in IE11. Use [clrDisabled] input instead.
             */
            set: /*
               * @deprecated since 3.0, remove in 4.0. the presence of this attribute makes it not-focusable in IE11. Use [clrDisabled] input instead.
               */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                // Empty string attribute evaluates to false but should disable the item, so we need to add a special case for it.
                this.focusableItem.disabled = !!value || value === '';
                this.setByDeprecatedDisabled = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDropdownItem.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.unlisten = this.renderer.listen(this.el.nativeElement, 'click', function () { return _this.onDropdownItemClick(); });
            };
        /**
         * @return {?}
         */
        ClrDropdownItem.prototype.onDropdownItemClick = /**
         * @return {?}
         */
            function () {
                if (this.dropdown.isMenuClosable && !this.el.nativeElement.classList.contains('disabled')) {
                    this._dropdownService.closeMenus();
                }
            };
        /**
         * @return {?}
         */
        ClrDropdownItem.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.unlisten();
            };
        ClrDropdownItem.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDropdownItem]',
                        host: {
                            '[class.disabled]': 'disabled',
                            '[class.dropdown-item]': 'true',
                            '[attr.role]': '"menuitem"',
                            '[attr.aria-disabled]': 'disabled',
                            '[attr.disabled]': "(disabled && setByDeprecatedDisabled)? '' : null",
                        },
                        providers: [BASIC_FOCUSABLE_ITEM_PROVIDER],
                    },] }
        ];
        /** @nocollapse */
        ClrDropdownItem.ctorParameters = function () {
            return [
                { type: ClrDropdown },
                { type: i0.ElementRef },
                { type: RootDropdownService },
                { type: i0.Renderer2 },
                { type: FocusableItem }
            ];
        };
        ClrDropdownItem.propDecorators = {
            disabled: [{ type: i0.Input, args: ['clrDisabled',] }],
            disabledDeprecated: [{ type: i0.Input, args: ['disabled',] }]
        };
        return ClrDropdownItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdownMenu = /** @class */ (function (_super) {
        __extends(ClrDropdownMenu, _super);
        function ClrDropdownMenu(injector, parentHost, nested, focusHandler) {
            var _this = this;
            if (!parentHost) {
                throw new Error('clr-dropdown-menu should only be used inside of a clr-dropdown');
            }
            _this = _super.call(this, injector, parentHost) || this;
            if (!nested) {
                // Default positioning for normal dropdown is bottom-left
                _this.anchorPoint = Point.BOTTOM_LEFT;
                _this.popoverPoint = Point.LEFT_TOP;
            }
            else {
                // Default positioning for nested dropdown is right-top
                _this.anchorPoint = Point.RIGHT_TOP;
                _this.popoverPoint = Point.LEFT_TOP;
            }
            _this.popoverOptions.allowMultipleOpen = true;
            _this.popoverOptions.ignoreGlobalESCListener = true;
            _this.closeOnOutsideClick = true;
            _this.focusHandler = focusHandler;
            return _this;
        }
        Object.defineProperty(ClrDropdownMenu.prototype, "position", {
            set: /**
             * @param {?} position
             * @return {?}
             */ function (position) {
                // set the popover values based on menu position
                switch (position) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_RIGHT;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_LEFT;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_RIGHT;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-top':
                        this.anchorPoint = Point.RIGHT_TOP;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-bottom':
                        this.anchorPoint = Point.RIGHT_BOTTOM;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'left-top':
                        this.anchorPoint = Point.LEFT_TOP;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'left-bottom':
                        this.anchorPoint = Point.LEFT_BOTTOM;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    default:
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDropdownMenu.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.focusHandler.container = this.el.nativeElement;
                this.items.changes.subscribe(function () { return _this.focusHandler.addChildren(_this.items.toArray()); });
                // I saw this on GitHub as a solution to avoid code duplication because of missed QueryList changes
                this.items.notifyOnChanges();
            };
        /**
         * @return {?}
         */
        ClrDropdownMenu.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                this.focusHandler.resetChildren();
            };
        ClrDropdownMenu.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dropdown-menu',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.dropdown-menu]': 'true',
                            '[attr.role]': '"menu"',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDropdownMenu.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
                { type: ClrDropdownMenu, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
                { type: DropdownFocusHandler }
            ];
        };
        ClrDropdownMenu.propDecorators = {
            position: [{ type: i0.Input, args: ['clrPosition',] }],
            items: [{ type: i0.ContentChildren, args: [FocusableItem,] }]
        };
        return ClrDropdownMenu;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdownTrigger = /** @class */ (function () {
        function ClrDropdownTrigger(dropdown, ifOpenService, el, focusHandler) {
            this.ifOpenService = ifOpenService;
            this.isRootLevelToggle = true;
            // if the containing dropdown has a parent, then this is not the root level one
            if (dropdown.parent) {
                this.isRootLevelToggle = false;
            }
            focusHandler.trigger = el.nativeElement;
        }
        Object.defineProperty(ClrDropdownTrigger.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifOpenService.open;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        ClrDropdownTrigger.prototype.onDropdownTriggerClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.ifOpenService.toggleWithEvent(event);
            };
        ClrDropdownTrigger.decorators = [
            { type: i0.Directive, args: [{
                        // We support both selectors for legacy reasons
                        selector: '[clrDropdownTrigger],[clrDropdownToggle]',
                        host: {
                            '[class.dropdown-toggle]': 'isRootLevelToggle',
                            '[class.dropdown-item]': '!isRootLevelToggle',
                            '[class.expandable]': '!isRootLevelToggle',
                            '[class.active]': 'active',
                            '[attr.aria-haspopup]': '"menu"',
                            '[attr.aria-expanded]': 'active',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrDropdownTrigger.ctorParameters = function () {
            return [
                { type: ClrDropdown },
                { type: IfOpenService },
                { type: i0.ElementRef },
                { type: DropdownFocusHandler }
            ];
        };
        ClrDropdownTrigger.propDecorators = {
            onDropdownTriggerClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
        };
        return ClrDropdownTrigger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DROPDOWN_DIRECTIVES = [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem];
    var ClrDropdownModule = /** @class */ (function () {
        function ClrDropdownModule() {
        }
        ClrDropdownModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule],
                        declarations: [CLR_DROPDOWN_DIRECTIVES],
                        exports: [CLR_DROPDOWN_DIRECTIVES, ClrConditionalModule, ClrIconModule],
                    },] }
        ];
        return ClrDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // @TODO Make this an enum
    /** @type {?} */
    var ALERT_TYPES = ['info', 'warning', 'danger', 'success'];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AlertIconAndTypesService = /** @class */ (function () {
        function AlertIconAndTypesService(commonStrings) {
            this.commonStrings = commonStrings;
            this.defaultIconShape = 'info-circle';
            this._alertIconShape = '';
            this._alertType = 'info';
        }
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertType", {
            get: /**
             * @return {?}
             */ function () {
                return this._alertType;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (ALERT_TYPES.indexOf(val) > -1) {
                    this._alertType = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconShape", {
            get: /**
             * @return {?}
             */ function () {
                if ('' === this._alertIconShape) {
                    return this.iconInfoFromType(this._alertType).shape;
                }
                return this._alertIconShape;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (!val) {
                    this._alertIconShape = '';
                }
                else if (val !== this._alertIconShape) {
                    this._alertIconShape = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconTitle", {
            get: /**
             * @return {?}
             */ function () {
                return this.iconInfoFromType(this._alertType).title;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} type
         * @return {?}
         */
        AlertIconAndTypesService.prototype.iconInfoFromType = /**
         * @param {?} type
         * @return {?}
         */
            function (type) {
                /** @type {?} */
                var returnObj = { shape: '', cssClass: '', title: '' };
                switch (type) {
                    case 'warning':
                        returnObj.shape = 'exclamation-triangle';
                        returnObj.cssClass = 'alert-warning';
                        returnObj.title = this.commonStrings.keys.warning;
                        break;
                    case 'danger':
                        returnObj.shape = 'exclamation-circle';
                        returnObj.cssClass = 'alert-danger';
                        returnObj.title = this.commonStrings.keys.danger;
                        break;
                    case 'success':
                        returnObj.shape = 'check-circle';
                        returnObj.cssClass = 'alert-success';
                        returnObj.title = this.commonStrings.keys.success;
                        break;
                    default:
                        returnObj.shape = this.defaultIconShape;
                        returnObj.cssClass = 'alert-info';
                        returnObj.title = this.commonStrings.keys.info;
                        break;
                }
                return returnObj;
            };
        AlertIconAndTypesService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        AlertIconAndTypesService.ctorParameters = function () {
            return [
                { type: ClrCommonStringsService }
            ];
        };
        return AlertIconAndTypesService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var MultiAlertService = /** @class */ (function () {
        function MultiAlertService() {
            this.allAlerts = new i0.QueryList();
            this._current = 0;
            /**
             * The Observable that lets other classes subscribe to changes
             */
            this._change = new rxjs.Subject();
        }
        Object.defineProperty(MultiAlertService.prototype, "changes", {
            get: /**
             * @return {?}
             */ function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} index
             * @return {?}
             */ function (index) {
                if (index !== this._current) {
                    this._current = index;
                    this._change.next(index);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "activeAlerts", {
            get: /**
             * @return {?}
             */ function () {
                return this.allAlerts.filter(function (alert) { return !alert._closed; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "currentAlert", {
            get: /**
             * @return {?}
             */ function () {
                return this.activeAlerts[this.current];
            },
            set: /**
             * @param {?} alert
             * @return {?}
             */ function (alert) {
                this.current = this.activeAlerts.indexOf(alert);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "count", {
            get: /**
             * @return {?}
             */ function () {
                return this.activeAlerts.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} alerts
         * @return {?}
         */
        MultiAlertService.prototype.manage = /**
         * @param {?} alerts
         * @return {?}
         */
            function (alerts) {
                var _this = this;
                if (this.subscription) {
                    this.subscription.unsubscribe();
                }
                this.allAlerts = alerts;
                this.subscription = this.allAlerts.changes.subscribe(function () {
                    if (_this.current >= _this.allAlerts.length) {
                        _this.current = Math.max(0, _this.allAlerts.length - 1);
                    }
                });
            };
        /**
         * @return {?}
         */
        MultiAlertService.prototype.next = /**
         * @return {?}
         */
            function () {
                this.current = this.current === this.activeAlerts.length - 1 ? 0 : this.current + 1;
            };
        /**
         * @return {?}
         */
        MultiAlertService.prototype.previous = /**
         * @return {?}
         */
            function () {
                if (this.activeAlerts.length === 0) {
                    return;
                }
                this.current = this.current === 0 ? this.activeAlerts.length - 1 : this.current - 1;
            };
        /**
         * @return {?}
         */
        MultiAlertService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.previous();
            };
        /**
         * @return {?}
         */
        MultiAlertService.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this.subscription) {
                    this.subscription.unsubscribe();
                }
            };
        MultiAlertService.decorators = [
            { type: i0.Injectable }
        ];
        return MultiAlertService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlert = /** @class */ (function () {
        function ClrAlert(iconService, cdr, multiAlertService, commonStrings) {
            this.iconService = iconService;
            this.cdr = cdr;
            this.multiAlertService = multiAlertService;
            this.commonStrings = commonStrings;
            this.isSmall = false;
            this.closable = true;
            this.isAppLevel = false;
            // Aria
            this.clrCloseButtonAriaLabel = this.commonStrings.keys.alertCloseButtonAriaLabel;
            this._closed = false;
            this._closedChanged = new i0.EventEmitter(false);
            /**
             * clrPolite is not used in the code. Is here just to provide
             * code complition and also mark component what type AriaLive
             * will be used.
             */
            this.polite = true;
            this.previouslyHidden = false;
            this.hidden = false;
        }
        Object.defineProperty(ClrAlert.prototype, "alertType", {
            get: /**
             * @return {?}
             */ function () {
                return this.iconService.alertType;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this.iconService.alertType = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "setAriaLive", {
            /**
             * There is an order on how the attributes will take effect.
             * Assertive, Off, Polite.
             *
             * Polite is default if non is passed.
             *
             * In the case of setting all of them to true. Assertive will be used.
             *
             */
            get: /**
             * There is an order on how the attributes will take effect.
             * Assertive, Off, Polite.
             *
             * Polite is default if non is passed.
             *
             * In the case of setting all of them to true. Assertive will be used.
             *
             * @return {?}
             */ function () {
                if (isBooleanAttributeSet(this.assertive)) {
                    return 'assertive';
                }
                if (isBooleanAttributeSet(this.off)) {
                    return 'off';
                }
                return 'polite';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "alertIconShape", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.iconService.alertIconShape = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "alertClass", {
            get: /**
             * @return {?}
             */ function () {
                return this.iconService.iconInfoFromType(this.iconService.alertType).cssClass;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlert.prototype.detectChangesIfNeeded = /**
         * @return {?}
         */
            function () {
                if (this.previouslyHidden !== this.hidden) {
                    this.previouslyHidden = this.hidden;
                    this.cdr.detectChanges();
                }
            };
        Object.defineProperty(ClrAlert.prototype, "isHidden", {
            get: /**
             * @return {?}
             */ function () {
                if (this.multiAlertService) {
                    // change detection issue in production mode causes currentAlert to be undefined when only the first alert exists
                    // https://github.com/vmware/clarity/issues/2430
                    if (this.multiAlertService.currentAlert === this || this.multiAlertService.count === 0) {
                        if (this.hidden === true) {
                            this.previouslyHidden = true;
                            this.hidden = false;
                        }
                    }
                    else if (this.hidden === false) {
                        this.previouslyHidden = false;
                        this.hidden = true;
                    }
                    this.detectChangesIfNeeded();
                }
                return this.hidden;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlert.prototype.close = /**
         * @return {?}
         */
            function () {
                if (!this.closable) {
                    return;
                }
                this._closed = true;
                if (this.multiAlertService) {
                    this.multiAlertService.close();
                }
                this._closedChanged.emit(true);
            };
        /**
         * @return {?}
         */
        ClrAlert.prototype.open = /**
         * @return {?}
         */
            function () {
                this._closed = false;
                this._closedChanged.emit(false);
            };
        ClrAlert.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alert',
                        providers: [AlertIconAndTypesService],
                        template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n    *ngIf=\"!_closed\"\n    class=\"alert\"\n    [ngClass]=\"alertClass\"\n    [class.alert-hidden]=\"isHidden\"\n    [class.alert-sm]=\"isSmall\"\n    [class.alert-app-level]=\"isAppLevel\"\n    [attr.aria-live]=\"setAriaLive\">\n    <div class=\"alert-items\">\n        <ng-content></ng-content>\n    </div>\n    <button \n        type=\"button\" \n        class=\"close\" \n        *ngIf=\"closable\" \n        (click)=\"close()\" \n        [attr.aria-label]=\"clrCloseButtonAriaLabel\"\n        >\n        <clr-icon shape=\"close\"></clr-icon>\n    </button>\n</div>\n",
                        styles: [':host { display: block; }']
                    }] }
        ];
        /** @nocollapse */
        ClrAlert.ctorParameters = function () {
            return [
                { type: AlertIconAndTypesService },
                { type: i0.ChangeDetectorRef },
                { type: MultiAlertService, decorators: [{ type: i0.Optional }] },
                { type: ClrCommonStringsService }
            ];
        };
        ClrAlert.propDecorators = {
            isSmall: [{ type: i0.Input, args: ['clrAlertSizeSmall',] }],
            closable: [{ type: i0.Input, args: ['clrAlertClosable',] }],
            isAppLevel: [{ type: i0.Input, args: ['clrAlertAppLevel',] }],
            clrCloseButtonAriaLabel: [{ type: i0.Input }],
            _closed: [{ type: i0.Input, args: ['clrAlertClosed',] }],
            _closedChanged: [{ type: i0.Output, args: ['clrAlertClosedChange',] }],
            alertType: [{ type: i0.Input, args: ['clrAlertType',] }],
            polite: [{ type: i0.Input, args: ['clrPolite',] }],
            assertive: [{ type: i0.Input, args: ['clrAssertive',] }],
            off: [{ type: i0.Input, args: ['clrOff',] }],
            alertIconShape: [{ type: i0.Input, args: ['clrAlertIcon',] }]
        };
        return ClrAlert;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlertItem = /** @class */ (function () {
        function ClrAlertItem(iconService) {
            this.iconService = iconService;
        }
        ClrAlertItem.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alert-item',
                        template: "\n        <div class=\"alert-icon-wrapper\">\n            <clr-icon class=\"alert-icon\" \n              [attr.shape]=\"iconService.alertIconShape\" \n              [attr.title]=\"iconService.alertIconTitle\"></clr-icon>\n        </div>\n        <ng-content></ng-content>\n    ",
                        host: { class: 'alert-item' }
                    }] }
        ];
        /** @nocollapse */
        ClrAlertItem.ctorParameters = function () {
            return [
                { type: AlertIconAndTypesService }
            ];
        };
        return ClrAlertItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlerts = /** @class */ (function () {
        function ClrAlerts(multiAlertService) {
            this.multiAlertService = multiAlertService;
            this.currentAlertIndexChange = new i0.EventEmitter(false);
            this.currentAlertChange = new i0.EventEmitter(false);
        }
        Object.defineProperty(ClrAlerts.prototype, "_inputCurrentIndex", {
            /**
             * Input/Output to support two way binding on current alert index
             */
            set: /**
             * Input/Output to support two way binding on current alert index
             * @param {?} index
             * @return {?}
             */ function (index) {
                if (Number.isInteger(index) && index >= 0) {
                    this.multiAlertService.current = index;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlertIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.current;
            },
            set: /**
             * @param {?} index
             * @return {?}
             */ function (index) {
                this.multiAlertService.current = index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlert", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.currentAlert;
            },
            /**
             * Input/Output to support two way binding on current alert instance
             */
            set: /**
             * Input/Output to support two way binding on current alert instance
             * @param {?} alert
             * @return {?}
             */ function (alert) {
                if (alert) {
                    this.multiAlertService.currentAlert = alert;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "alerts", {
            /**
             * Ensure we are only dealing with alerts that have not been closed yet
             */
            get: /**
             * Ensure we are only dealing with alerts that have not been closed yet
             * @return {?}
             */ function () {
                return this.allAlerts.filter(function (alert) {
                    return alert.isHidden === false;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlertType", {
            get: /**
             * @return {?}
             */ function () {
                if (this.multiAlertService.currentAlert) {
                    return this.multiAlertService.currentAlert.alertType;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlerts.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.multiAlertService.manage(this.allAlerts);
                this.multiAlertService.changes.subscribe(function (index) {
                    _this.currentAlertIndexChange.next(index);
                    _this.currentAlertChange.next(_this.multiAlertService.currentAlert);
                });
            };
        /**
         * @return {?}
         */
        ClrAlerts.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.multiAlertService.destroy();
            };
        ClrAlerts.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alerts',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-alerts-pager\n        *ngIf=\"multiAlertService.count > 1\"\n        [clrCurrentAlertIndex]=\"currentAlertIndex\">\n</clr-alerts-pager>\n<ng-content select=\"clr-alert\"></ng-content>\n",
                        providers: [MultiAlertService],
                        host: {
                            '[class.alerts]': 'true',
                            '[class.alert-danger]': "this.currentAlertType == 'danger'",
                            '[class.alert-info]': "this.currentAlertType == 'info'",
                            '[class.alert-success]': "this.currentAlertType == 'success'",
                            '[class.alert-warning]': "this.currentAlertType == 'warning'",
                        },
                        styles: [':host { display: block }']
                    }] }
        ];
        /** @nocollapse */
        ClrAlerts.ctorParameters = function () {
            return [
                { type: MultiAlertService }
            ];
        };
        ClrAlerts.propDecorators = {
            allAlerts: [{ type: i0.ContentChildren, args: [ClrAlert,] }],
            _inputCurrentIndex: [{ type: i0.Input, args: ['clrCurrentAlertIndex',] }],
            currentAlertIndexChange: [{ type: i0.Output, args: ['clrCurrentAlertIndexChange',] }],
            currentAlert: [{ type: i0.Input, args: ['clrCurrentAlert',] }],
            currentAlertChange: [{ type: i0.Output, args: ['clrCurrentAlertChange',] }]
        };
        return ClrAlerts;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlertsPager = /** @class */ (function () {
        function ClrAlertsPager(multiAlertService, commonStrings) {
            this.multiAlertService = multiAlertService;
            this.commonStrings = commonStrings;
            this.currentAlertChange = new i0.EventEmitter(false);
            this.currentAlertIndexChange = new i0.EventEmitter();
        }
        Object.defineProperty(ClrAlertsPager.prototype, "currentAlert", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.currentAlert;
            },
            /**
             * Input/Output to support two way binding on current alert instance
             */
            set: /**
             * Input/Output to support two way binding on current alert instance
             * @param {?} alert
             * @return {?}
             */ function (alert) {
                if (alert) {
                    this.multiAlertService.currentAlert = alert;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlertsPager.prototype, "currentAlertIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.current;
            },
            /**
             * Input/Output to support two way binding on current alert index
             */
            set: /**
             * Input/Output to support two way binding on current alert index
             * @param {?} index
             * @return {?}
             */ function (index) {
                this.multiAlertService.current = index;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.multiAlertServiceChanges = this.multiAlertService.changes.subscribe(function (index) {
                    _this.currentAlertIndexChange.emit(index);
                    _this.currentAlertChange.emit(_this.multiAlertService.activeAlerts[index]);
                });
            };
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.pageUp = /**
         * @return {?}
         */
            function () {
                this.multiAlertService.next();
            };
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.pageDown = /**
         * @return {?}
         */
            function () {
                this.multiAlertService.previous();
            };
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.multiAlertServiceChanges.unsubscribe();
            };
        ClrAlertsPager.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alerts-pager',
                        template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"alerts-pager-control\">\n    <div class=\"alerts-page-down\">\n        <button class=\"alerts-pager-button\" (click)=\"pageDown()\">\n            <clr-icon shape=\"caret left\" [attr.title]=\"commonStrings.keys.previous\"></clr-icon>\n        </button>\n    </div>\n    <div class=\"alerts-pager-text\">\n        {{this.multiAlertService.current+1}} / {{this.multiAlertService.count}}\n    </div>\n    <div class=\"alerts-page-up\">\n        <button class=\"alerts-pager-button\" (click)=\"pageUp()\">\n            <clr-icon shape=\"caret right\" [attr.title]=\"commonStrings.keys.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n",
                        host: { '[class.alerts-pager]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrAlertsPager.ctorParameters = function () {
            return [
                { type: MultiAlertService },
                { type: ClrCommonStringsService }
            ];
        };
        ClrAlertsPager.propDecorators = {
            currentAlert: [{ type: i0.Input, args: ['clrCurrentAlert',] }],
            currentAlertChange: [{ type: i0.Output, args: ['clrCurrentAlertChange',] }],
            currentAlertIndex: [{ type: i0.Input, args: ['clrCurrentAlertIndex',] }],
            currentAlertIndexChange: [{ type: i0.Output, args: ['clrCurrentAlertIndexChange',] }]
        };
        return ClrAlertsPager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_ALERT_DIRECTIVES = [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager];
    var ClrAlertModule = /** @class */ (function () {
        function ClrAlertModule() {
        }
        ClrAlertModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrDropdownModule],
                        declarations: [CLR_ALERT_DIRECTIVES],
                        exports: [CLR_ALERT_DIRECTIVES],
                    },] }
        ];
        return ClrAlertModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrEmphasisModule = /** @class */ (function () {
        function ClrEmphasisModule() {
        }
        ClrEmphasisModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrAlertModule] },] }
        ];
        return ClrEmphasisModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ResponsiveNavCodes = /** @class */ (function () {
        function ResponsiveNavCodes() {
        }
        ResponsiveNavCodes.NAV_LEVEL_1 = 1;
        ResponsiveNavCodes.NAV_LEVEL_2 = 2;
        ResponsiveNavCodes.NAV_CLOSE_ALL = 'NAV_CLOSE_ALL';
        ResponsiveNavCodes.NAV_OPEN = 'NAV_OPEN';
        ResponsiveNavCodes.NAV_CLOSE = 'NAV_CLOSE';
        ResponsiveNavCodes.NAV_TOGGLE = 'NAV_TOGGLE';
        ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU = 'open-hamburger-menu';
        ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU = 'open-overflow-menu';
        ResponsiveNavCodes.NAV_CLASS_TRIGGER_1 = 'header-hamburger-trigger';
        ResponsiveNavCodes.NAV_CLASS_TRIGGER_2 = 'header-overflow-trigger';
        ResponsiveNavCodes.NAV_CLASS_LEVEL_1 = 'clr-nav-level-1';
        ResponsiveNavCodes.NAV_CLASS_LEVEL_2 = 'clr-nav-level-2';
        return ResponsiveNavCodes;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ResponsiveNavControlMessage = /** @class */ (function () {
        function ResponsiveNavControlMessage(_controlCode, _navLevel) {
            this._controlCode = _controlCode;
            this._navLevel = _navLevel;
        }
        Object.defineProperty(ResponsiveNavControlMessage.prototype, "controlCode", {
            get: /**
             * @return {?}
             */ function () {
                return this._controlCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResponsiveNavControlMessage.prototype, "navLevel", {
            get: /**
             * @return {?}
             */ function () {
                return this._navLevel;
            },
            enumerable: true,
            configurable: true
        });
        return ResponsiveNavControlMessage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ResponsiveNavigationService = /** @class */ (function () {
        function ResponsiveNavigationService() {
            this.responsiveNavList = [];
            this.registerNavSubject = new rxjs.ReplaySubject();
            this.controlNavSubject = new rxjs.Subject();
            this.closeAllNavs(); // We start with all navs closed
        }
        Object.defineProperty(ResponsiveNavigationService.prototype, "registeredNavs", {
            get: /**
             * @return {?}
             */ function () {
                return this.registerNavSubject.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResponsiveNavigationService.prototype, "navControl", {
            get: /**
             * @return {?}
             */ function () {
                return this.controlNavSubject.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.registerNav = /**
         * @param {?} navLevel
         * @return {?}
         */
            function (navLevel) {
                if (!navLevel || this.isNavRegistered(navLevel)) {
                    return;
                }
                this.responsiveNavList.push(navLevel);
                this.registerNavSubject.next(this.responsiveNavList);
            };
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.isNavRegistered = /**
         * @param {?} navLevel
         * @return {?}
         */
            function (navLevel) {
                if (this.responsiveNavList.indexOf(navLevel) > -1) {
                    console.error('Multiple clr-nav-level ' + navLevel + ' attributes found. Please make sure that only one exists');
                    return true;
                }
                return false;
            };
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.unregisterNav = /**
         * @param {?} navLevel
         * @return {?}
         */
            function (navLevel) {
                /** @type {?} */
                var index = this.responsiveNavList.indexOf(navLevel);
                if (index > -1) {
                    this.responsiveNavList.splice(index, 1);
                    this.registerNavSubject.next(this.responsiveNavList);
                }
            };
        /**
         * @param {?} controlCode
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.sendControlMessage = /**
         * @param {?} controlCode
         * @param {?} navLevel
         * @return {?}
         */
            function (controlCode, navLevel) {
                /** @type {?} */
                var message = new ResponsiveNavControlMessage(controlCode, navLevel);
                this.controlNavSubject.next(message);
            };
        /**
         * @return {?}
         */
        ResponsiveNavigationService.prototype.closeAllNavs = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var message = new ResponsiveNavControlMessage(ResponsiveNavCodes.NAV_CLOSE_ALL, -999);
                this.controlNavSubject.next(message);
            };
        ResponsiveNavigationService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        ResponsiveNavigationService.ctorParameters = function () { return []; };
        /** @nocollapse */ ResponsiveNavigationService.ngInjectableDef = i0.defineInjectable({ factory: function ResponsiveNavigationService_Factory() { return new ResponsiveNavigationService(); }, token: ResponsiveNavigationService, providedIn: "root" });
        return ResponsiveNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrMainContainer = /** @class */ (function () {
        function ClrMainContainer(elRef, responsiveNavService) {
            this.elRef = elRef;
            this.responsiveNavService = responsiveNavService;
        }
        /**
         * @return {?}
         */
        ClrMainContainer.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._classList = this.elRef.nativeElement.classList;
                this._subscription = this.responsiveNavService.navControl.subscribe({
                    next: function (message) {
                        _this.processMessage(message);
                    },
                });
            };
        /**
         * @param {?} message
         * @return {?}
         */
        ClrMainContainer.prototype.processMessage = /**
         * @param {?} message
         * @return {?}
         */
            function (message) {
                /** @type {?} */
                var navClass = ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
                if (message.controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL) {
                    this._classList.remove(ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
                    this._classList.remove(ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
                }
                else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                    this.controlNav(message.controlCode, navClass);
                }
                else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                    navClass = ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
                    this.controlNav(message.controlCode, navClass);
                }
            };
        /**
         * @param {?} controlCode
         * @param {?} navClass
         * @return {?}
         */
        ClrMainContainer.prototype.controlNav = /**
         * @param {?} controlCode
         * @param {?} navClass
         * @return {?}
         */
            function (controlCode, navClass) {
                if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
                    this._classList.add(navClass);
                }
                else if (controlCode === ResponsiveNavCodes.NAV_CLOSE) {
                    this._classList.remove(navClass);
                }
                else if (controlCode === ResponsiveNavCodes.NAV_TOGGLE) {
                    this._classList.toggle(navClass);
                }
            };
        /**
         * @return {?}
         */
        ClrMainContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        ClrMainContainer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-main-container', host: { '[class.main-container]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrMainContainer.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResponsiveNavigationService }
            ];
        };
        return ClrMainContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_LAYOUT_DIRECTIVES = [ClrMainContainer];
    var ClrMainContainerModule = /** @class */ (function () {
        function ClrMainContainerModule() {
        }
        ClrMainContainerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule],
                        declarations: [CLR_LAYOUT_DIRECTIVES],
                        exports: [CLR_LAYOUT_DIRECTIVES],
                    },] }
        ];
        return ClrMainContainerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var MainContainerWillyWonka = /** @class */ (function (_super) {
        __extends(MainContainerWillyWonka, _super);
        function MainContainerWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MainContainerWillyWonka.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-main-container' },] }
        ];
        return MainContainerWillyWonka;
    }(WillyWonka));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NavDetectionOompaLoompa = /** @class */ (function (_super) {
        __extends(NavDetectionOompaLoompa, _super);
        function NavDetectionOompaLoompa(cdr, willyWonka, responsiveNavService) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-header should only be used inside of a clr-main-container');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.responsiveNavService = responsiveNavService;
            return _this;
        }
        Object.defineProperty(NavDetectionOompaLoompa.prototype, "flavor", {
            // NavDetectionOompaLoompa is the addition of the nav levels
            // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
            get: 
            // NavDetectionOompaLoompa is the addition of the nav levels
            // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
            /**
             * @return {?}
             */
            function () {
                return this.responsiveNavService.responsiveNavList.reduce(function (sum, navLevel) { return sum + navLevel; }, 0);
            },
            enumerable: true,
            configurable: true
        });
        NavDetectionOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-header' },] }
        ];
        /** @nocollapse */
        NavDetectionOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: MainContainerWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: ResponsiveNavigationService }
            ];
        };
        return NavDetectionOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrHeader = /** @class */ (function () {
        function ClrHeader(responsiveNavService) {
            var _this = this;
            this.responsiveNavService = responsiveNavService;
            this.isNavLevel1OnPage = false;
            this.isNavLevel2OnPage = false;
            this.responsiveNavCodes = ResponsiveNavCodes;
            this._subscription = this.responsiveNavService.registeredNavs.subscribe({
                next: function (navLevelList) {
                    _this.initializeNavTriggers(navLevelList);
                },
            });
        }
        // reset triggers. handles cases when an application has different nav levels on different pages.
        // reset triggers. handles cases when an application has different nav levels on different pages.
        /**
         * @return {?}
         */
        ClrHeader.prototype.resetNavTriggers =
            // reset triggers. handles cases when an application has different nav levels on different pages.
            /**
             * @return {?}
             */
            function () {
                this.isNavLevel1OnPage = false;
                this.isNavLevel2OnPage = false;
            };
        // decides which triggers to show on the header
        // decides which triggers to show on the header
        /**
         * @param {?} navList
         * @return {?}
         */
        ClrHeader.prototype.initializeNavTriggers =
            // decides which triggers to show on the header
            /**
             * @param {?} navList
             * @return {?}
             */
            function (navList) {
                var _this = this;
                this.resetNavTriggers();
                if (navList.length > 2) {
                    console.error('More than 2 Nav Levels detected.');
                    return;
                }
                navList.forEach(function (navLevel) {
                    if (navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                        _this.isNavLevel1OnPage = true;
                    }
                    else if (navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                        _this.isNavLevel2OnPage = true;
                    }
                });
            };
        // closes the nav that is open
        // closes the nav that is open
        /**
         * @return {?}
         */
        ClrHeader.prototype.closeOpenNav =
            // closes the nav that is open
            /**
             * @return {?}
             */
            function () {
                this.responsiveNavService.closeAllNavs();
            };
        // toggles the nav that is open
        // toggles the nav that is open
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ClrHeader.prototype.toggleNav =
            // toggles the nav that is open
            /**
             * @param {?} navLevel
             * @return {?}
             */
            function (navLevel) {
                this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_TOGGLE, navLevel);
            };
        /**
         * @return {?}
         */
        ClrHeader.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        ClrHeader.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-header',
                        template: "\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel1OnPage\"\n            class=\"header-hamburger-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_1)\">\n            <span></span>\n        </button>\n        <ng-content></ng-content>\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel2OnPage\"\n            class=\"header-overflow-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_2)\">\n            <span></span>\n        </button>\n        <div class=\"header-backdrop\" (click)=\"closeOpenNav()\"></div>\n    ",
                        host: { '[class.header]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrHeader.ctorParameters = function () {
            return [
                { type: ResponsiveNavigationService }
            ];
        };
        return ClrHeader;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrNavLevel = /** @class */ (function () {
        function ClrNavLevel(responsiveNavService, elementRef) {
            this.responsiveNavService = responsiveNavService;
            this.elementRef = elementRef;
        }
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.level !== ResponsiveNavCodes.NAV_LEVEL_1 && this.level !== ResponsiveNavCodes.NAV_LEVEL_2) {
                    console.error('Nav Level can only be 1 or 2');
                    return;
                }
                this.responsiveNavService.registerNav(this.level);
                this.addNavClass(this.level);
            };
        /**
         * @param {?} level
         * @return {?}
         */
        ClrNavLevel.prototype.addNavClass = /**
         * @param {?} level
         * @return {?}
         */
            function (level) {
                /** @type {?} */
                var navHostClassList = this.elementRef.nativeElement.classList;
                if (level === ResponsiveNavCodes.NAV_LEVEL_1) {
                    navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_1);
                }
                else if (level === ResponsiveNavCodes.NAV_LEVEL_2) {
                    navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_2);
                }
            };
        Object.defineProperty(ClrNavLevel.prototype, "level", {
            get: /**
             * @return {?}
             */ function () {
                return this._level;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrNavLevel.prototype, "responsiveNavCodes", {
            // getter to access the responsive navigation codes from the template
            get: 
            // getter to access the responsive navigation codes from the template
            /**
             * @return {?}
             */
            function () {
                return ResponsiveNavCodes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.open = /**
         * @return {?}
         */
            function () {
                this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, this.level);
            };
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.close = /**
         * @return {?}
         */
            function () {
                this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, this.level);
            };
        // TODO: Figure out whats the best way to do this. Possible methods
        // 1. HostListener (current solution)
        // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
        // why
        // TODO: Figure out whats the best way to do this. Possible methods
        // 1. HostListener (current solution)
        // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
        // why
        /**
         * @param {?} target
         * @return {?}
         */
        ClrNavLevel.prototype.onMouseClick =
            // TODO: Figure out whats the best way to do this. Possible methods
            // 1. HostListener (current solution)
            // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
            // why
            /**
             * @param {?} target
             * @return {?}
             */
            function (target) {
                /** @type {?} */
                var current = target;
                // Get the element in the DOM on which the mouse was clicked
                /** @type {?} */
                var navHost = this.elementRef.nativeElement;
                // Start checking if current and navHost are equal.
                // If not traverse to the parentNode and check again.
                while (current) {
                    if (current === navHost) {
                        return;
                    }
                    else if (current.classList.contains('nav-link')) {
                        this.close();
                        return;
                    }
                    current = current.parentNode;
                }
            };
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.responsiveNavService.unregisterNav(this.level);
            };
        ClrNavLevel.decorators = [
            { type: i0.Directive, args: [{ selector: '[clr-nav-level]' },] }
        ];
        /** @nocollapse */
        ClrNavLevel.ctorParameters = function () {
            return [
                { type: ResponsiveNavigationService },
                { type: i0.ElementRef }
            ];
        };
        ClrNavLevel.propDecorators = {
            _level: [{ type: i0.Input, args: ['clr-nav-level',] }],
            onMouseClick: [{ type: i0.HostListener, args: ['click', ['$event.target'],] }]
        };
        return ClrNavLevel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_NAVIGATION_DIRECTIVES = [
        ClrHeader,
        ClrNavLevel,
        NavDetectionOompaLoompa,
        MainContainerWillyWonka,
    ];
    var ClrNavigationModule = /** @class */ (function () {
        function ClrNavigationModule() {
        }
        ClrNavigationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrDropdownModule],
                        declarations: [CLR_NAVIGATION_DIRECTIVES],
                        exports: [CLR_NAVIGATION_DIRECTIVES],
                    },] }
        ];
        return ClrNavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TemplateRefContainer = /** @class */ (function () {
        function TemplateRefContainer() {
        }
        TemplateRefContainer.decorators = [
            { type: i0.Component, args: [{
                        template: "\n      <ng-template>\n        <ng-content></ng-content>\n      </ng-template>\n    "
                    }] }
        ];
        TemplateRefContainer.propDecorators = {
            template: [{ type: i0.ViewChild, args: [i0.TemplateRef,] }]
        };
        return TemplateRefContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TEMPLATE_REF_DIRECTIVES = [TemplateRefContainer];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTemplateRefModule = /** @class */ (function () {
        function ClrTemplateRefModule() {
        }
        ClrTemplateRefModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [TEMPLATE_REF_DIRECTIVES],
                        entryComponents: [TEMPLATE_REF_DIRECTIVES],
                        exports: [TEMPLATE_REF_DIRECTIVES],
                    },] }
        ];
        return ClrTemplateRefModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TabsWillyWonka = /** @class */ (function (_super) {
        __extends(TabsWillyWonka, _super);
        function TabsWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TabsWillyWonka.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-tabs' },] }
        ];
        return TabsWillyWonka;
    }(WillyWonka));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ActiveOompaLoompa = /** @class */ (function (_super) {
        __extends(ActiveOompaLoompa, _super);
        function ActiveOompaLoompa(cdr, willyWonka, id, ifActive) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clrTabLink and clr-tab-content should only be used inside of a clr-tabs');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.ifActive = ifActive;
            _this.id = id;
            return _this;
        }
        Object.defineProperty(ActiveOompaLoompa.prototype, "flavor", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActive.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ActiveOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrTabLink], clr-tab-content' },] }
        ];
        /** @nocollapse */
        ActiveOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: TabsWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: IfActiveService }
            ];
        };
        return ActiveOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // TODO: if we find more components that could use this, consider moving this to utils
    var AriaService = /** @class */ (function () {
        function AriaService() {
        }
        AriaService.decorators = [
            { type: i0.Injectable }
        ];
        return AriaService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TabsService = /** @class */ (function () {
        function TabsService() {
            this._children = [];
        }
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsService.prototype.register = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this._children.push(tab);
            };
        Object.defineProperty(TabsService.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsService.prototype, "activeTab", {
            get: /**
             * @return {?}
             */ function () {
                return this.children.find(function (tab) {
                    return tab.active;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsService.prototype, "overflowTabs", {
            get: /**
             * @return {?}
             */ function () {
                return this.children.filter(function (tab) {
                    return tab.tabLink.inOverflow === true;
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsService.prototype.unregister = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                /** @type {?} */
                var index = this.children.indexOf(tab);
                if (index > -1) {
                    this.children.splice(index, 1);
                }
            };
        TabsService.decorators = [
            { type: i0.Injectable }
        ];
        return TabsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbTabContentComponents = 0;
    var ClrTabContent = /** @class */ (function () {
        /* tslint:enable:no-unused-variable */
        function ClrTabContent(ifActiveService, id, ariaService, tabsService) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.ariaService = ariaService;
            this.tabsService = tabsService;
            if (!this.tabContentId) {
                this.tabContentId = 'clr-tab-content-' + nbTabContentComponents++;
            }
        }
        Object.defineProperty(ClrTabContent.prototype, "templateRef", {
            // The template must be applied on the top-down phase of view-child initialization to prevent
            // components in the content from initializing before a content container exists.
            // Some child components need their container for sizing calculations.
            /* tslint:disable:no-unused-variable */
            set: 
            // The template must be applied on the top-down phase of view-child initialization to prevent
            // components in the content from initializing before a content container exists.
            // Some child components need their container for sizing calculations.
            /* tslint:disable:no-unused-variable */
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.viewRef = this.tabsService.tabContentViewContainer.createEmbeddedView(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "ariaLabelledBy", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaLabelledBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "tabContentId", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaControls;
            },
            set: /**
             * @param {?} id
             * @return {?}
             */ function (id) {
                this.ariaService.ariaControls = id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTabContent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var index = this.tabsService.tabContentViewContainer.indexOf(this.viewRef);
                if (index > -1) {
                    this.tabsService.tabContentViewContainer.remove(index);
                }
            };
        ClrTabContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tab-content',
                        template: "\n    <ng-template #tabContentProjectedRef>\n      <section [id]=\"tabContentId\" role=\"tabpanel\" class=\"tab-content\" [class.active]=\"active\"\n               [hidden]=\"!active\"\n               [attr.aria-labelledby]=\"ariaLabelledBy\"\n               [attr.aria-expanded]=\"active\"\n               [attr.aria-hidden]=\"!active\">\n        <ng-content></ng-content>\n      </section>\n    </ng-template>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrTabContent.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: AriaService },
                { type: TabsService }
            ];
        };
        ClrTabContent.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['tabContentProjectedRef',] }],
            tabContentId: [{ type: i0.Input, args: ['id',] }]
        };
        return ClrTabContent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbTabsComponent = 0;
    /** @type {?} */
    var TABS_ID = new i0.InjectionToken('TABS_ID');
    /**
     * @return {?}
     */
    function tokenFactory$1() {
        return 'clr-tabs-' + nbTabsComponent++;
    }
    /** @type {?} */
    var TABS_ID_PROVIDER = {
        provide: TABS_ID,
        useFactory: tokenFactory$1,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbTabLinkComponents = 0;
    var ClrTabLink = /** @class */ (function () {
        function ClrTabLink(ifActiveService, id, ariaService, el, cfr, viewContainerRef, tabsId) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.ariaService = ariaService;
            this.el = el;
            this.cfr = cfr;
            this.viewContainerRef = viewContainerRef;
            this.tabsId = tabsId;
            if (!this.tabLinkId) {
                this.tabLinkId = 'clr-tab-link-' + nbTabLinkComponents++;
            }
            // Tab links can be rendered in one of two places: in the main area or inside the overflow dropdown menu.
            // Here, we create a container so that its template can be used to create embeddedView on the fly.
            // See TabsService's renderView() method and how it's used in Tabs class for an example.
            /** @type {?} */
            var factory = this.cfr.resolveComponentFactory(TemplateRefContainer);
            this.templateRefContainer = this.viewContainerRef.createComponent(factory, 1, undefined, [
                [this.el.nativeElement],
            ]).instance;
        }
        Object.defineProperty(ClrTabLink.prototype, "ariaControls", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaControls;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabLink.prototype, "tabLinkId", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaLabelledBy;
            },
            set: /**
             * @param {?} id
             * @return {?}
             */ function (id) {
                this.ariaService.ariaLabelledBy = id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTabLink.prototype.activate = /**
         * @return {?}
         */
            function () {
                this.ifActiveService.current = this.id;
            };
        Object.defineProperty(ClrTabLink.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTabLink.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrTabLink]',
                        host: {
                            '[id]': 'tabLinkId',
                            '[attr.aria-selected]': 'active',
                            '[attr.aria-hidden]': 'false',
                            '[attr.aria-controls]': 'ariaControls',
                            '[class.btn]': 'true',
                            '[class.btn-link]': '!inOverflow',
                            '[class.nav-link]': '!inOverflow',
                            '[class.nav-item]': '!inOverflow',
                            '[class.active]': 'active',
                            role: 'tab',
                            type: 'button',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrTabLink.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: AriaService },
                { type: i0.ElementRef },
                { type: i0.ComponentFactoryResolver },
                { type: i0.ViewContainerRef },
                { type: Number, decorators: [{ type: i0.Inject, args: [TABS_ID,] }] }
            ];
        };
        ClrTabLink.propDecorators = {
            inOverflow: [{ type: i0.Input, args: ['clrTabLinkInOverflow',] }],
            tabLinkId: [{ type: i0.Input, args: ['id',] }],
            activate: [{ type: i0.HostListener, args: ['click',] }]
        };
        return ClrTabLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTab = /** @class */ (function () {
        function ClrTab(ifActiveService, id, tabsService) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.tabsService = tabsService;
            tabsService.register(this);
        }
        /**
         * @return {?}
         */
        ClrTab.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.tabsService.unregister(this);
            };
        Object.defineProperty(ClrTab.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTab.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tab',
                        template: "\n        <ng-content></ng-content>\n    ",
                        providers: [IF_ACTIVE_ID_PROVIDER, AriaService]
                    }] }
        ];
        /** @nocollapse */
        ClrTab.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: TabsService }
            ];
        };
        ClrTab.propDecorators = {
            tabLink: [{ type: i0.ContentChild, args: [ClrTabLink,] }],
            tabContent: [{ type: i0.ContentChild, args: [ClrTabContent,] }]
        };
        return ClrTab;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTabOverflowContent = /** @class */ (function (_super) {
        __extends(ClrTabOverflowContent, _super);
        function ClrTabOverflowContent(injector, parentHost) {
            var _this = _super.call(this, injector, parentHost) || this;
            _this.anchorPoint = Point.BOTTOM_RIGHT;
            _this.popoverPoint = Point.RIGHT_TOP;
            _this.closeOnOutsideClick = true;
            return _this;
        }
        ClrTabOverflowContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tab-overflow-content',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.dropdown-menu]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrTabOverflowContent.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.SkipSelf }] }
            ];
        };
        return ClrTabOverflowContent;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTabs = /** @class */ (function () {
        /* tslint:enable:no-unused-variable */
        function ClrTabs(ifActiveService, ifOpenService, tabsService, tabsId, commonStrings) {
            this.ifActiveService = ifActiveService;
            this.ifOpenService = ifOpenService;
            this.tabsService = tabsService;
            this.tabsId = tabsId;
            this.commonStrings = commonStrings;
        }
        Object.defineProperty(ClrTabs.prototype, "tabContentViewContainer", {
            /* tslint:disable:no-unused-variable */
            set: /* tslint:disable:no-unused-variable */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.tabsService.tabContentViewContainer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "activeTabInOverflow", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "tabIds", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabsService.children.map(function (tab) { return tab.tabLink.tabLinkId; }).join(' ');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTabs.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                if (typeof this.ifActiveService.current === 'undefined') {
                    this.tabLinkDirectives.first.activate();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ClrTabs.prototype.toggleOverflow = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.ifOpenService.toggleWithEvent(event);
            };
        ClrTabs.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tabs',
                        template: "\n        <ul class=\"nav\" role=\"tablist\" [attr.aria-owns]=\"tabIds\">\n            <!--tab links-->\n            <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                <ng-container *ngIf=\"link.tabsId === tabsId && !link.inOverflow\"\n                              [ngTemplateOutlet]=\"link.templateRefContainer.template\">\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"tabsService.overflowTabs.length > 0\">\n                <div class=\"tabs-overflow bottom-right\" [class.open]=\"ifOpenService.open\"\n                     (click)=\"toggleOverflow($event)\">\n                    <li role=\"presentation\" class=\"nav-item\">\n                        <button class=\"btn btn-link nav-link dropdown-toggle\" type=\"button\" [class.active]=\"activeTabInOverflow\">\n                            <clr-icon shape=\"ellipsis-horizontal\"\n                              [class.is-info]=\"ifOpenService.open\"\n                              [attr.title]=\"commonStrings.keys.more\"></clr-icon>\n                        </button>\n                    </li>\n                    <!--tab links in overflow menu-->\n                    <clr-tab-overflow-content>\n                        <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                            <ng-container *ngIf=\"link.tabsId === tabsId && link.inOverflow\"\n                                          [ngTemplateOutlet]=\"link.templateRefContainer.template\">\n                            </ng-container>\n                        </ng-container>\n                    </clr-tab-overflow-content>\n                </div>\n            </ng-container>\n        </ul>\n        <ng-container #tabContentViewContainer></ng-container>\n    ",
                        providers: [IfActiveService, IfOpenService, TabsService, TABS_ID_PROVIDER]
                    }] }
        ];
        /** @nocollapse */
        ClrTabs.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: IfOpenService },
                { type: TabsService },
                { type: Number, decorators: [{ type: i0.Inject, args: [TABS_ID,] }] },
                { type: ClrCommonStringsService }
            ];
        };
        ClrTabs.propDecorators = {
            tabLinkDirectives: [{ type: i0.ContentChildren, args: [ClrTabLink, { descendants: true },] }],
            tabContents: [{ type: i0.ContentChildren, args: [ClrTabContent, { descendants: true },] }],
            tabContentViewContainer: [{ type: i0.ViewChild, args: ['tabContentViewContainer', { read: i0.ViewContainerRef },] }]
        };
        return ClrTabs;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_TABS_DIRECTIVES = [
        ClrTabContent,
        ClrTab,
        ClrTabs,
        ClrTabOverflowContent,
        ClrTabLink,
        TabsWillyWonka,
        ActiveOompaLoompa,
    ];
    var ClrTabsModule = /** @class */ (function () {
        function ClrTabsModule() {
        }
        ClrTabsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule],
                        declarations: [CLR_TABS_DIRECTIVES],
                        exports: [CLR_TABS_DIRECTIVES, ClrConditionalModule],
                    },] }
        ];
        return ClrTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavGroupRegistrationService = /** @class */ (function () {
        function VerticalNavGroupRegistrationService() {
            this.navGroupCount = 0;
        }
        /**
         * @return {?}
         */
        VerticalNavGroupRegistrationService.prototype.registerNavGroup = /**
         * @return {?}
         */
            function () {
                this.navGroupCount++;
            };
        /**
         * @return {?}
         */
        VerticalNavGroupRegistrationService.prototype.unregisterNavGroup = /**
         * @return {?}
         */
            function () {
                this.navGroupCount--;
            };
        VerticalNavGroupRegistrationService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavGroupRegistrationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavIconService = /** @class */ (function () {
        function VerticalNavIconService() {
            this._icons = 0;
        }
        Object.defineProperty(VerticalNavIconService.prototype, "hasIcons", {
            get: /**
             * @return {?}
             */ function () {
                return this._icons > 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        VerticalNavIconService.prototype.registerIcon = /**
         * @return {?}
         */
            function () {
                this._icons++;
            };
        /**
         * @return {?}
         */
        VerticalNavIconService.prototype.unregisterIcon = /**
         * @return {?}
         */
            function () {
                this._icons--;
            };
        VerticalNavIconService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavIconService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavService = /** @class */ (function () {
        function VerticalNavService() {
            this._animateOnCollapsed = new rxjs.Subject();
            this._collapsedChanged = new rxjs.Subject();
            this._collapsed = false;
            this._collapsible = false;
        }
        Object.defineProperty(VerticalNavService.prototype, "animateOnCollapsed", {
            get: /**
             * @return {?}
             */ function () {
                return this._animateOnCollapsed.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsedChanged", {
            get: /**
             * @return {?}
             */ function () {
                return this._collapsedChanged.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsed", {
            get: /**
             * @return {?}
             */ function () {
                return this._collapsed;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this.collapsible && this._collapsed !== value) {
                    this.updateCollapseBehavior(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsible", {
            get: /**
             * @return {?}
             */ function () {
                return this._collapsible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this._collapsible !== value) {
                    if (!value && this.collapsed) {
                        this.updateCollapseBehavior(false);
                    }
                    this._collapsible = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        VerticalNavService.prototype.updateCollapseBehavior = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._animateOnCollapsed.next(value);
                this._collapsed = value;
                this._collapsedChanged.next(value);
            };
        VerticalNavService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNav = /** @class */ (function () {
        function ClrVerticalNav(_navService, _navIconService, _navGroupRegistrationService, commonStrings) {
            var _this = this;
            this._navService = _navService;
            this._navIconService = _navIconService;
            this._navGroupRegistrationService = _navGroupRegistrationService;
            this.commonStrings = commonStrings;
            this._collapsedChanged = new i0.EventEmitter(true);
            this._sub = this._navService.collapsedChanged.subscribe(function (value) {
                _this._collapsedChanged.emit(value);
            });
        }
        Object.defineProperty(ClrVerticalNav.prototype, "collapsible", {
            get: /**
             * @return {?}
             */ function () {
                return this._navService.collapsible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._navService.collapsible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "collapsed", {
            get: /**
             * @return {?}
             */ function () {
                return this._navService.collapsed;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._navService.collapsed = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "hasNavGroups", {
            get: /**
             * @return {?}
             */ function () {
                return this._navGroupRegistrationService.navGroupCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "hasIcons", {
            get: /**
             * @return {?}
             */ function () {
                return this._navIconService.hasIcons;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrVerticalNav.prototype.toggleByButton = /**
         * @return {?}
         */
            function () {
                this.collapsed = !this.collapsed;
            };
        /**
         * @return {?}
         */
        ClrVerticalNav.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._sub.unsubscribe();
            };
        ClrVerticalNav.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-vertical-nav',
                        template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<button type=\"button\" class=\"nav-trigger\"\n        [class.on-collapse]=\"collapsed\"\n        (click)=\"toggleByButton()\"\n        *ngIf=\"collapsible\">\n    <clr-icon shape=\"angle-double\"\n              class=\"nav-trigger-icon\"\n              [attr.dir]=\"(this.collapsed) ? 'right' : 'left'\"\n              [attr.title]=\"(this.collapsed) ? commonStrings.keys.expand : commonStrings.keys.collapse\"></clr-icon>\n</button>\n<!-- Click handler on .nav-content is bad but required :-( -->\n<div class=\"nav-content\">\n    <ng-content></ng-content>\n    <button (click)=\"collapsed = false\" class=\"nav-btn\" *ngIf=\"collapsible && collapsed\"></button>\n</div>\n",
                        providers: [VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService],
                        host: {
                            class: 'clr-vertical-nav',
                            '[class.is-collapsed]': 'collapsed',
                            '[class.has-nav-groups]': 'hasNavGroups',
                            '[class.has-icons]': 'hasIcons',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrVerticalNav.ctorParameters = function () {
            return [
                { type: VerticalNavService },
                { type: VerticalNavIconService },
                { type: VerticalNavGroupRegistrationService },
                { type: ClrCommonStringsService }
            ];
        };
        ClrVerticalNav.propDecorators = {
            collapsible: [{ type: i0.Input, args: ['clrVerticalNavCollapsible',] }],
            collapsed: [{ type: i0.Input, args: ['clrVerticalNavCollapsed',] }],
            _collapsedChanged: [{ type: i0.Output, args: ['clrVerticalNavCollapsedChange',] }]
        };
        return ClrVerticalNav;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavGroupService = /** @class */ (function () {
        function VerticalNavGroupService() {
            this._expandChange = new rxjs.Subject();
        }
        Object.defineProperty(VerticalNavGroupService.prototype, "expandChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._expandChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        VerticalNavGroupService.prototype.expand = /**
         * @return {?}
         */
            function () {
                this._expandChange.next(true);
            };
        VerticalNavGroupService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPANDED_STATE = 'expanded';
    /** @type {?} */
    var COLLAPSED_STATE = 'collapsed';
    var ClrVerticalNavGroup = /** @class */ (function () {
        function ClrVerticalNavGroup(_itemExpand, _navGroupRegistrationService, _navGroupService, _navService, commonStrings) {
            var _this = this;
            this._itemExpand = _itemExpand;
            this._navGroupRegistrationService = _navGroupRegistrationService;
            this._navGroupService = _navGroupService;
            this._navService = _navService;
            this.commonStrings = commonStrings;
            this.wasExpanded = false;
            this.expandedChange = new i0.EventEmitter(true);
            this._subscriptions = [];
            this._expandAnimationState = COLLAPSED_STATE;
            this._navGroupRegistrationService.registerNavGroup();
            // FIXME: This subscription handles a corner case
            // Vertical Nav collapse requires the animation to run first and then
            // remove the nodes from the DOM. If the user directly sets the input
            // on the clrIfExpanded directive, we have no chance to run the animation
            // and wait for it to complete. This subscription makes sure that the
            // animation states are correct for that edge case.
            this._subscriptions.push(this._itemExpand.expandChange.subscribe(function (value) {
                if (value && _this.expandAnimationState === COLLAPSED_STATE) {
                    if (_this._navService.collapsed) {
                        _this._navService.collapsed = false;
                    }
                    _this.expandAnimationState = EXPANDED_STATE;
                }
                else if (!value && _this.expandAnimationState === EXPANDED_STATE) {
                    _this.expandAnimationState = COLLAPSED_STATE;
                }
            }));
            // 1. If the nav is collapsing, close the open nav group + save its state
            // 2. If the nav is expanding, expand the nav group if the previous state was expanded
            this._subscriptions.push(this._navService.animateOnCollapsed.subscribe(function (goingToCollapse) {
                if (goingToCollapse && _this.expanded) {
                    _this.wasExpanded = true;
                    _this.expandAnimationState = COLLAPSED_STATE;
                }
                else if (!goingToCollapse && _this.wasExpanded) {
                    _this.expandGroup();
                    _this.wasExpanded = false;
                }
            }));
            // If a link is clicked, expand the nav group
            this._subscriptions.push(this._navGroupService.expandChange.subscribe(function (expand) {
                if (expand && !_this.expanded) {
                    _this.expandGroup();
                }
            }));
        }
        Object.defineProperty(ClrVerticalNavGroup.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemExpand.expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._itemExpand.expanded !== value) {
                    this._itemExpand.expanded = value;
                    this.expandedChange.emit(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNavGroup.prototype, "userExpandedInput", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this.expanded !== value) {
                    // We have to call toggleExpand because some cases require animations to occur first
                    // Directly setting the Expand service value skips the animation and can result in
                    // nodes in the DOM but the nav group still being collapsed
                    this.toggleExpand();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.expandGroup = /**
         * @return {?}
         */
            function () {
                this.expanded = true;
                // Expanded animation occurs after Expand.expand is set to true
                this.expandAnimationState = EXPANDED_STATE;
            };
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.collapseGroup = /**
         * @return {?}
         */
            function () {
                // If a Vertical Nav Group toggle button is clicked while the Vertical Nav is in Collapsed state,
                // the Vertical Nav should be expanded first.
                this.expandAnimationState = COLLAPSED_STATE;
            };
        // closes a group after the collapse animation
        // closes a group after the collapse animation
        /**
         * @param {?} $event
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.expandAnimationDone =
            // closes a group after the collapse animation
            /**
             * @param {?} $event
             * @return {?}
             */
            function ($event) {
                if ($event.toState === COLLAPSED_STATE) {
                    this.expanded = false;
                }
            };
        Object.defineProperty(ClrVerticalNavGroup.prototype, "expandAnimationState", {
            get: /**
             * @return {?}
             */ function () {
                return this._expandAnimationState;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._expandAnimationState) {
                    this._expandAnimationState = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                if (this.expanded) {
                    this.collapseGroup();
                }
                else {
                    // If nav is collasped, first open the nav
                    if (this._navService.collapsed) {
                        this._navService.collapsed = false;
                    }
                    // then expand the nav group
                    this.expandGroup();
                }
            };
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // This makes sure that if someone marks a nav group expanded in a collapsed nav
                // the expanded property is switched back to collapsed state.
                if (this._navService.collapsed && this.expanded) {
                    this.wasExpanded = true;
                    this.expandAnimationState = COLLAPSED_STATE;
                }
            };
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
                this._navGroupRegistrationService.unregisterNavGroup();
            };
        ClrVerticalNavGroup.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-vertical-nav-group',
                        template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"nav-group-content\">\n    <ng-content select=\"[clrVerticalNavLink]\"></ng-content>\n    <button\n        class=\"nav-group-trigger\"\n        type=\"button\"\n        (click)=\"toggleExpand()\">\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <div class=\"nav-group-text\">\n            <ng-content></ng-content>\n        </div>\n        <clr-icon shape=\"caret\"\n                  class=\"nav-group-trigger-icon\"\n                  [attr.dir]=\"(this.expanded) ? 'down' : 'right'\"\n                  [attr.title]=\"(this.expanded) ? commonStrings.keys.collapse : commonStrings.keys.expand\">\n        </clr-icon>\n    </button>\n</div>\n<!--TODO: This animation needs to be added to the clr-vertical-nav-group-children component-->\n<div class=\"nav-group-children\"\n     [@clrExpand]=\"expandAnimationState\"\n     (@clrExpand.done)=\"expandAnimationDone($event)\">\n    <ng-content select=\"[clrIfExpanded], clr-vertical-nav-group-children\"></ng-content>\n</div>\n",
                        providers: [Expand, VerticalNavGroupService],
                        animations: [
                            animations.trigger('clrExpand', [
                                animations.state(EXPANDED_STATE, animations.style({ height: '*' })),
                                animations.state(COLLAPSED_STATE, animations.style({ height: 0, 'overflow-y': 'hidden', visibility: 'hidden' })),
                                animations.transition(EXPANDED_STATE + " <=> " + COLLAPSED_STATE, animations.animate('0.2s ease-in-out')),
                            ]),
                        ],
                        host: { class: 'nav-group' }
                    }] }
        ];
        /** @nocollapse */
        ClrVerticalNavGroup.ctorParameters = function () {
            return [
                { type: Expand },
                { type: VerticalNavGroupRegistrationService },
                { type: VerticalNavGroupService },
                { type: VerticalNavService },
                { type: ClrCommonStringsService }
            ];
        };
        ClrVerticalNavGroup.propDecorators = {
            expanded: [{ type: i0.HostBinding, args: ['class.is-expanded',] }],
            userExpandedInput: [{ type: i0.Input, args: ['clrVerticalNavGroupExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrVerticalNavGroupExpandedChange',] }]
        };
        return ClrVerticalNavGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNavGroupChildren = /** @class */ (function () {
        function ClrVerticalNavGroupChildren() {
        }
        ClrVerticalNavGroupChildren.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-vertical-nav-group-children',
                        template: "\n        <ng-content></ng-content>\n    "
                    }] }
        ];
        return ClrVerticalNavGroupChildren;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNavIcon = /** @class */ (function () {
        function ClrVerticalNavIcon(_verticalNavIconService) {
            this._verticalNavIconService = _verticalNavIconService;
            this._verticalNavIconService.registerIcon();
        }
        /**
         * @return {?}
         */
        ClrVerticalNavIcon.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._verticalNavIconService.unregisterIcon();
            };
        ClrVerticalNavIcon.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrVerticalNavIcon]', host: { class: 'nav-icon' } },] }
        ];
        /** @nocollapse */
        ClrVerticalNavIcon.ctorParameters = function () {
            return [
                { type: VerticalNavIconService }
            ];
        };
        return ClrVerticalNavIcon;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNavLink = /** @class */ (function () {
        function ClrVerticalNavLink(_navGroupService) {
            this._navGroupService = _navGroupService;
        }
        /**
         * @return {?}
         */
        ClrVerticalNavLink.prototype.expandParentNavGroup = /**
         * @return {?}
         */
            function () {
                if (this._navGroupService) {
                    this._navGroupService.expand();
                }
            };
        ClrVerticalNavLink.decorators = [
            { type: i0.Component, args: [{
                        selector: '[clrVerticalNavLink]',
                        template: "\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <span class=\"nav-text\">\n            <ng-content></ng-content>    \n        </span>\n    ",
                        host: { class: 'nav-link' }
                    }] }
        ];
        /** @nocollapse */
        ClrVerticalNavLink.ctorParameters = function () {
            return [
                { type: VerticalNavGroupService, decorators: [{ type: i0.Optional }] }
            ];
        };
        ClrVerticalNavLink.propDecorators = {
            expandParentNavGroup: [{ type: i0.HostListener, args: ['click',] }]
        };
        return ClrVerticalNavLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_VERTICAL_NAV_DIRECTIVES = [
        ClrVerticalNav,
        ClrVerticalNavLink,
        ClrVerticalNavGroup,
        ClrVerticalNavGroupChildren,
        ClrVerticalNavIcon,
    ];
    var ClrVerticalNavModule = /** @class */ (function () {
        function ClrVerticalNavModule() {
        }
        ClrVerticalNavModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrIfExpandModule],
                        declarations: [CLR_VERTICAL_NAV_DIRECTIVES],
                        exports: [CLR_VERTICAL_NAV_DIRECTIVES, ClrIfExpandModule, ClrIconModule],
                    },] }
        ];
        return ClrVerticalNavModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLayoutModule = /** @class */ (function () {
        function ClrLayoutModule() {
        }
        ClrLayoutModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule] },] }
        ];
        return ClrLayoutModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ScrollingService = /** @class */ (function () {
        function ScrollingService(_document) {
            this._document = _document;
        }
        /**
         * @return {?}
         */
        ScrollingService.prototype.stopScrolling = /**
         * @return {?}
         */
            function () {
                this._document.body.classList.add('no-scrolling');
            };
        /**
         * @return {?}
         */
        ScrollingService.prototype.resumeScrolling = /**
         * @return {?}
         */
            function () {
                if (this._document.body.classList.contains('no-scrolling')) {
                    this._document.body.classList.remove('no-scrolling');
                }
            };
        ScrollingService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        ScrollingService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        return ScrollingService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrModal = /** @class */ (function () {
        function ClrModal(_scrollingService, commonStrings, platformId, modalId) {
            this._scrollingService = _scrollingService;
            this.commonStrings = commonStrings;
            this.platformId = platformId;
            this.modalId = modalId;
            this._open = false;
            this._openChanged = new i0.EventEmitter(false);
            this.closable = true;
            this.staticBackdrop = true;
            this.skipAnimation = 'false';
            // presently this is only used by wizards
            this.bypassScrollService = false;
            this.stopClose = false;
            this.altClose = new i0.EventEmitter(false);
        }
        // Detect when _open is set to true and set no-scrolling to true
        // Detect when _open is set to true and set no-scrolling to true
        /**
         * @param {?} changes
         * @return {?}
         */
        ClrModal.prototype.ngOnChanges =
            // Detect when _open is set to true and set no-scrolling to true
            /**
             * @param {?} changes
             * @return {?}
             */
            function (changes) {
                if (!this.bypassScrollService && changes && changes.hasOwnProperty('_open')) {
                    if (changes._open.currentValue) {
                        this._scrollingService.stopScrolling();
                    }
                    else {
                        this._scrollingService.resumeScrolling();
                    }
                }
            };
        /**
         * @return {?}
         */
        ClrModal.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._scrollingService.resumeScrolling();
            };
        /**
         * @return {?}
         */
        ClrModal.prototype.open = /**
         * @return {?}
         */
            function () {
                if (this._open) {
                    return;
                }
                this._open = true;
                this._openChanged.emit(true);
            };
        /**
         * @return {?}
         */
        ClrModal.prototype.close = /**
         * @return {?}
         */
            function () {
                if (this.stopClose) {
                    this.altClose.emit(false);
                    return;
                }
                if (!this.closable || !this._open) {
                    return;
                }
                this._open = false;
                // todo: remove this after animation bug is fixed https://github.com/angular/angular/issues/15798
                // this was handled by the fadeDone event below, but that AnimationEvent is not firing in Angular 4.0.
                this._openChanged.emit(false);
                // SPECME
                this.focusTrap.setPreviousFocus(); // Handles moving focus back to the element that had it before.
            };
        // TODO Investigate if we can decouple from animation events
        // TODO Investigate if we can decouple from animation events
        /**
         * @param {?} e
         * @return {?}
         */
        ClrModal.prototype.fadeDone =
            // TODO Investigate if we can decouple from animation events
            /**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                if (e.toState === 'void') {
                    this._openChanged.emit(false);
                }
                else if (e.toState === 'false' && common.isPlatformBrowser(this.platformId) && this.modalTitle) {
                    this.modalTitle.nativeElement.focus();
                }
            };
        ClrModal.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-modal',
                        viewProviders: [ScrollingService],
                        template: "\n<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div clrFocusTrap class=\"modal\" *ngIf=\"_open\">\n    <!--fixme: revisit when ngClass works with exit animation-->\n    <div [@fadeDown]=\"skipAnimation\" (@fadeDown.done)=\"fadeDone($event)\"\n         class=\"modal-dialog\"\n         [class.modal-sm]=\"size == 'sm'\"\n         [class.modal-lg]=\"size == 'lg'\"\n         [class.modal-xl]=\"size == 'xl'\"\n         role=\"dialog\"\n         aria-modal=\"true\"\n         [attr.aria-hidden]=\"!_open\"\n         [attr.aria-labelledby]=\"modalId\">\n      <div class=\"clr-sr-only\">{{commonStrings.keys.modalContentStart}}</div>\n      <div class=\"modal-content-wrapper\">\n        <!-- only used in wizards -->\n        <ng-content select=\".modal-nav\"></ng-content>\n\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <button type=\"button\" [attr.aria-label]=\"commonStrings.keys.close\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n              <clr-icon shape=\"close\"></clr-icon>\n            </button>\n            <div class=\"modal-title-wrapper\" tabindex=\"0\" id=\"{{modalId}}\" #modalTitle>\n              <ng-content select=\".modal-title\"></ng-content>\n            </div>\n          </div>\n          <ng-content select=\".modal-body\"></ng-content>\n          <ng-content select=\".modal-footer\"></ng-content>\n        </div>\n      </div>\n      <div class=\"clr-sr-only\">{{commonStrings.keys.modalContentEnd}}</div>\n    </div>\n\n    <div [@fade] class=\"modal-backdrop\"\n         aria-hidden=\"true\"\n         (click)=\"staticBackdrop || close()\"></div>\n</div>\n\n",
                        animations: [
                            animations.trigger('fadeDown', [
                                animations.transition('* => false', [animations.style({ opacity: 0, transform: 'translate(0, -25%)' }), animations.animate('0.2s ease-in-out')]),
                                animations.transition('false => *', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0, transform: 'translate(0, -25%)' }))]),
                            ]),
                            animations.trigger('fade', [
                                animations.transition('void => *', [animations.style({ opacity: 0 }), animations.animate('0.2s ease-in-out', animations.style({ opacity: 0.85 }))]),
                                animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0 }))]),
                            ]),
                        ],
                        providers: [UNIQUE_ID_PROVIDER],
                        styles: ["\n        :host { display: none; }\n        :host.open { display: inline; }\n    "]
                    }] }
        ];
        /** @nocollapse */
        ClrModal.ctorParameters = function () {
            return [
                { type: ScrollingService },
                { type: ClrCommonStringsService },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] }
            ];
        };
        ClrModal.propDecorators = {
            focusTrap: [{ type: i0.ViewChild, args: [FocusTrapDirective,] }],
            modalTitle: [{ type: i0.ViewChild, args: ['modalTitle',] }],
            _open: [{ type: i0.HostBinding, args: ['class.open',] }, { type: i0.Input, args: ['clrModalOpen',] }],
            _openChanged: [{ type: i0.Output, args: ['clrModalOpenChange',] }],
            closable: [{ type: i0.Input, args: ['clrModalClosable',] }],
            size: [{ type: i0.Input, args: ['clrModalSize',] }],
            staticBackdrop: [{ type: i0.Input, args: ['clrModalStaticBackdrop',] }],
            skipAnimation: [{ type: i0.Input, args: ['clrModalSkipAnimation',] }],
            bypassScrollService: [{ type: i0.Input, args: ['clrModalOverrideScrollService',] }],
            stopClose: [{ type: i0.Input, args: ['clrModalPreventClose',] }],
            altClose: [{ type: i0.Output, args: ['clrModalAlternateClose',] }],
            close: [{ type: i0.HostListener, args: ['body:keyup.escape',] }]
        };
        return ClrModal;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Allows modal overflow area to be scrollable via keyboard.
     * The modal body will focus with keyboard navigation only.
     * This allows inner focusable items to be focused without
     * the overflow scroll being focused.
     */
    var ClrModalBody = /** @class */ (function () {
        function ClrModalBody() {
            this._mouseDown = false;
        }
        /**
         * @param {?} event
         * @return {?}
         */
        ClrModalBody.prototype.focus = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._mouseDown) {
                    event.target.blur();
                }
            };
        /**
         * @return {?}
         */
        ClrModalBody.prototype.mouseDown = /**
         * @return {?}
         */
            function () {
                this._mouseDown = true;
            };
        /**
         * @return {?}
         */
        ClrModalBody.prototype.mouseUp = /**
         * @return {?}
         */
            function () {
                this._mouseDown = false;
            };
        ClrModalBody.decorators = [
            { type: i0.Directive, args: [{
                        selector: '.modal-body',
                        host: {
                            '[attr.tabindex]': '"0"',
                        },
                    },] }
        ];
        ClrModalBody.propDecorators = {
            focus: [{ type: i0.HostListener, args: ['focus', ['$event'],] }],
            mouseDown: [{ type: i0.HostListener, args: ['mousedown',] }],
            mouseUp: [{ type: i0.HostListener, args: ['mouseup',] }]
        };
        return ClrModalBody;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_MODAL_DIRECTIVES = [ClrModal, ClrModalBody];
    var ClrModalModule = /** @class */ (function () {
        function ClrModalModule() {
        }
        ClrModalModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrFocusTrapModule],
                        declarations: [CLR_MODAL_DIRECTIVES],
                        exports: [CLR_MODAL_DIRECTIVES],
                    },] }
        ];
        return ClrModalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SIGNPOST_POSITIONS = {
        'top-left': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_RIGHT, offsetY: -10, offsetX: 0 },
        'top-middle': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_CENTER, offsetY: -10, offsetX: 0 },
        'top-right': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_LEFT, offsetY: -10, offsetX: 0 },
        'right-top': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_BOTTOM, offsetY: 2, offsetX: 14 },
        'right-middle': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
        'right-bottom': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_TOP, offsetY: -1, offsetX: 14 },
        'bottom-right': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_LEFT, offsetY: 9, offsetX: -1 },
        'bottom-middle': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_CENTER, offsetY: 9, offsetX: 12 },
        'bottom-left': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_RIGHT, offsetY: 9, offsetX: 0 },
        'left-bottom': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_TOP, offsetY: 0, offsetX: -14 },
        'left-middle': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_CENTER, offsetY: 4, offsetX: -14 },
        'left-top': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_BOTTOM, offsetY: 0, offsetX: -14 },
        default: { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // aka where the arrow / pointer is at in relation to the anchor
    /** @type {?} */
    var POSITIONS = [
        'top-left',
        'top-middle',
        'top-right',
        'right-top',
        'right-middle',
        'right-bottom',
        'bottom-right',
        'bottom-middle',
        'bottom-left',
        'left-bottom',
        'left-middle',
        'left-top',
    ];
    var ClrSignpostContent = /** @class */ (function (_super) {
        __extends(ClrSignpostContent, _super);
        function ClrSignpostContent(injector, parentHost, commonStrings, signpostContentId, signpostIdService) {
            var _this = _super.call(this, injector, parentHost) || this;
            _this.signpostContentId = signpostContentId;
            _this.signpostIdService = signpostIdService;
            if (!parentHost) {
                throw new Error('clr-signpost-content should only be used inside of a clr-signpost');
            }
            _this.commonStrings = commonStrings;
            // Defaults
            _this.position = 'right-middle';
            _this.closeOnOutsideClick = true;
            _this.signpostIdService.setId(signpostContentId);
            return _this;
        }
        /**********
         *
         * @description
         * Close function that uses the signpost instance to toggle the state of the content popover.
         *
         */
        /**
         * *******
         *
         * \@description
         * Close function that uses the signpost instance to toggle the state of the content popover.
         *
         * @return {?}
         */
        ClrSignpostContent.prototype.close = /**
         * *******
         *
         * \@description
         * Close function that uses the signpost instance to toggle the state of the content popover.
         *
         * @return {?}
         */
            function () {
                this.ifOpenService.open = false;
            };
        Object.defineProperty(ClrSignpostContent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this._position;
            },
            /*********
             *
             * @description
             * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
             * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
             * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
             * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
             * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
             * There are 12 possible positions to place a ClrSignpostContent container:
             * - top-left
             * - top-middle
             * - top-right
             * - right-top
             * - right-middle
             * - right-bottom
             * - bottom-right
             * - bottom-middle
             * - bottom-left
             * - left-bottom
             * - left-middle
             * - left-top
             *
             * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
             * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
             * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
             * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
             *
             * @param newPosition
             */
            set: /**
             * ******
             *
             * \@description
             * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
             * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
             * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
             * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
             * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
             * There are 12 possible positions to place a ClrSignpostContent container:
             * - top-left
             * - top-middle
             * - top-right
             * - right-top
             * - right-middle
             * - right-bottom
             * - bottom-right
             * - bottom-middle
             * - bottom-left
             * - left-bottom
             * - left-middle
             * - left-top
             *
             * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
             * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
             * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
             * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
             *
             * @param {?} position
             * @return {?}
             */ function (position) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, this.position);
                if (position && POSITIONS.indexOf(position) > -1) {
                    this._position = position;
                }
                else {
                    this._position = 'right-middle';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, this.position);
                /** @type {?} */
                var setPosition = SIGNPOST_POSITIONS[this.position];
                this.anchorPoint = setPosition.anchorPoint;
                this.popoverPoint = setPosition.popoverPoint;
                this.popoverOptions.offsetY = setPosition.offsetY;
                this.popoverOptions.offsetX = setPosition.offsetX;
            },
            enumerable: true,
            configurable: true
        });
        ClrSignpostContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-signpost-content',
                        template: "\n      <div class=\"signpost-wrap\">\n          <div class=\"popover-pointer\"></div>\n          <div class=\"signpost-content-body\">\n              <ng-content></ng-content>\n          </div>\n          <div class=\"signpost-content-header\">\n              <button type=\"button\" [attr.aria-label]=\"commonStrings.keys.signpostClose\" class=\"signpost-action close\"\n                      (click)=\"close()\" [attr.aria-controls]=\"signpostContentId\">\n                  <clr-icon shape=\"close\" [attr.title]=\"commonStrings.keys.close\"></clr-icon>\n              </button>\n          </div>\n      </div>\n  ",
                        host: { '[class.signpost-content]': 'true', '[id]': 'signpostContentId' },
                        providers: [UNIQUE_ID_PROVIDER]
                    }] }
        ];
        /** @nocollapse */
        ClrSignpostContent.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
                { type: ClrCommonStringsService },
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] },
                { type: SignpostIdService }
            ];
        };
        ClrSignpostContent.propDecorators = {
            position: [{ type: i0.Input, args: ['clrPosition',] }]
        };
        return ClrSignpostContent;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_SIGNPOST_DIRECTIVES = [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger];
    var ClrSignpostModule = /** @class */ (function () {
        function ClrSignpostModule() {
        }
        ClrSignpostModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule, ClrIconModule],
                        declarations: [CLR_SIGNPOST_DIRECTIVES],
                        exports: [CLR_SIGNPOST_DIRECTIVES, ClrConditionalModule],
                    },] }
        ];
        return ClrSignpostModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TooltipIdService = /** @class */ (function () {
        function TooltipIdService() {
            this._id = new rxjs.Subject();
        }
        /**
         * @param {?} id
         * @return {?}
         */
        TooltipIdService.prototype.updateId = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                this._id.next(id);
            };
        Object.defineProperty(TooltipIdService.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        TooltipIdService.decorators = [
            { type: i0.Injectable }
        ];
        return TooltipIdService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTooltip = /** @class */ (function () {
        function ClrTooltip() {
        }
        ClrTooltip.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tooltip',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.tooltip]': 'true',
                        },
                        providers: [
                            IfOpenService,
                            { provide: POPOVER_HOST_ANCHOR, useExisting: i0.ElementRef },
                            // TODO: consider centralizing the unique id string on a service that provides ariaAttributes that need it
                            // AriaService in layout/tabs/providers might be a good starting point.
                            UNIQUE_ID_PROVIDER,
                            TooltipIdService,
                        ]
                    }] }
        ];
        return ClrTooltip;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var POSITIONS$1 = ['bottom-left', 'bottom-right', 'top-left', 'top-right', 'right', 'left'];
    /** @type {?} */
    var SIZES = ['xs', 'sm', 'md', 'lg'];
    var ClrTooltipContent = /** @class */ (function (_super) {
        __extends(ClrTooltipContent, _super);
        function ClrTooltipContent(injector, parentHost, uniqueId, tooltipIdService) {
            var _this = _super.call(this, injector, parentHost) || this;
            _this.uniqueId = uniqueId;
            _this.tooltipIdService = tooltipIdService;
            if (!parentHost) {
                throw new Error('clr-tooltip-content should only be used inside of a clr-tooltip');
            }
            // Defaults
            _this.position = 'right';
            _this.size = 'sm';
            // Set the default id in case consumer does not supply a custom id.
            _this.updateId(uniqueId);
            return _this;
        }
        Object.defineProperty(ClrTooltipContent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this._position;
            },
            set: /**
             * @param {?} position
             * @return {?}
             */ function (position) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.position);
                if (position && POSITIONS$1.indexOf(position) > -1) {
                    this._position = position;
                }
                else {
                    this._position = 'right';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.position);
                // set the popover values based on direction
                switch (position) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_CENTER;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_CENTER;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_CENTER;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'right':
                        this.anchorPoint = Point.RIGHT_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'left':
                        this.anchorPoint = Point.LEFT_CENTER;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    default:
                        this.anchorPoint = Point.RIGHT_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTooltipContent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value ? this.updateId(value) : this.updateId('');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} id
         * @return {?}
         */
        ClrTooltipContent.prototype.updateId = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                this._id = id;
                this.tooltipIdService.updateId(id);
            };
        Object.defineProperty(ClrTooltipContent.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return this._size;
            },
            set: /**
             * @param {?} size
             * @return {?}
             */ function (size) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.size);
                if (size && SIZES.indexOf(size) > -1) {
                    this._size = size;
                }
                else {
                    this._size = 'sm';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.size);
            },
            enumerable: true,
            configurable: true
        });
        ClrTooltipContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tooltip-content',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.tooltip-content]': 'true',
                            '[style.opacity]': '1',
                            '[attr.role]': '"tooltip"',
                            '[id]': 'id',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrTooltipContent.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] },
                { type: TooltipIdService }
            ];
        };
        ClrTooltipContent.propDecorators = {
            id: [{ type: i0.Input }],
            position: [{ type: i0.Input, args: ['clrPosition',] }],
            size: [{ type: i0.Input, args: ['clrSize',] }]
        };
        return ClrTooltipContent;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTooltipTrigger = /** @class */ (function () {
        function ClrTooltipTrigger(ifOpenService, tooltipIdService) {
            var _this = this;
            this.ifOpenService = ifOpenService;
            this.tooltipIdService = tooltipIdService;
            this.subs = [];
            // The aria-described by comes from the id of content. It
            this.subs.push(this.tooltipIdService.id.subscribe(function (tooltipId) { return (_this.ariaDescribedBy = tooltipId); }));
        }
        /**
         * @return {?}
         */
        ClrTooltipTrigger.prototype.showTooltip = /**
         * @return {?}
         */
            function () {
                this.ifOpenService.open = true;
            };
        /**
         * @return {?}
         */
        ClrTooltipTrigger.prototype.hideTooltip = /**
         * @return {?}
         */
            function () {
                this.ifOpenService.open = false;
            };
        /**
         * @return {?}
         */
        ClrTooltipTrigger.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subs.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrTooltipTrigger.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrTooltipTrigger]',
                        host: {
                            tabindex: '0',
                            '[class.tooltip-trigger]': 'true',
                            '[attr.aria-describedby]': 'ariaDescribedBy',
                            '[attr.role]': '"button"',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrTooltipTrigger.ctorParameters = function () {
            return [
                { type: IfOpenService },
                { type: TooltipIdService }
            ];
        };
        ClrTooltipTrigger.propDecorators = {
            showTooltip: [{ type: i0.HostListener, args: ['mouseenter',] }, { type: i0.HostListener, args: ['focus',] }],
            hideTooltip: [{ type: i0.HostListener, args: ['mouseleave',] }, { type: i0.HostListener, args: ['blur',] }]
        };
        return ClrTooltipTrigger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_TOOLTIP_DIRECTIVES = [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent];
    var ClrTooltipModule = /** @class */ (function () {
        function ClrTooltipModule() {
        }
        ClrTooltipModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule],
                        declarations: [CLR_TOOLTIP_DIRECTIVES],
                        exports: [CLR_TOOLTIP_DIRECTIVES, ClrConditionalModule, ClrIconModule],
                    },] }
        ];
        return ClrTooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrPopoverModule = /** @class */ (function () {
        function ClrPopoverModule() {
        }
        ClrPopoverModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule] },] }
        ];
        return ClrPopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ButtonHubService = /** @class */ (function () {
        function ButtonHubService() {
            this.buttonsReady = false;
            this._previousBtnClicked = new rxjs.Subject();
            this._nextBtnClicked = new rxjs.Subject();
            this._dangerBtnClicked = new rxjs.Subject();
            this._cancelBtnClicked = new rxjs.Subject();
            this._finishBtnClicked = new rxjs.Subject();
            this._customBtnClicked = new rxjs.Subject();
        }
        Object.defineProperty(ButtonHubService.prototype, "previousBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._previousBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "nextBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._nextBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "dangerBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._dangerBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "cancelBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._cancelBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "finishBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._finishBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "customBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._customBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} buttonType
         * @return {?}
         */
        ButtonHubService.prototype.buttonClicked = /**
         * @param {?} buttonType
         * @return {?}
         */
            function (buttonType) {
                if ('previous' === buttonType) {
                    this._previousBtnClicked.next();
                }
                else if ('next' === buttonType) {
                    this._nextBtnClicked.next();
                }
                else if ('finish' === buttonType) {
                    this._finishBtnClicked.next();
                }
                else if ('danger' === buttonType) {
                    this._dangerBtnClicked.next();
                }
                else if ('cancel' === buttonType) {
                    this._cancelBtnClicked.next();
                }
                else {
                    this._customBtnClicked.next(buttonType);
                }
            };
        ButtonHubService.decorators = [
            { type: i0.Injectable }
        ];
        return ButtonHubService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * PageCollectionService manages the collection of pages assigned to the wizard and offers
     * a number of functions useful across the wizards providers and subcomponents -- all related
     * to essentially lookups on the collection of pages.
     *
     * The easiest way to access PageCollectionService is via the wizard. The
     * following example would allow you to access your instance of the wizard from your host
     * component and thereby access the page collection via YourHostComponent.wizard.pageCollection.
     *
     * \@example
     * <clr-wizard #wizard ...>
     *
     * \@example
     * export class YourHostComponent {
     * \@ViewChild("wizard") wizard: Wizard;
     *   ...
     * }
     *
     * The heart of the page collection is the query list of pages, which it is assigned as a
     * reference to the Wizard.pages QueryList when the wizard is created.
     *
     */
    var PageCollectionService = /** @class */ (function () {
        function PageCollectionService() {
            // used by the navService to navigate back to first possible step after
            // pages are reset
            /**
             *
             * \@memberof PageCollectionService
             */
            this._pagesReset = new rxjs.Subject();
        }
        Object.defineProperty(PageCollectionService.prototype, "pagesAsArray", {
            /**
             * Converts the PageCollectionService.pages QueryList to an array and returns it.
             *
             * Useful for many instances when you would prefer a QueryList to act like an array.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Converts the PageCollectionService.pages QueryList to an array and returns it.
             *
             * Useful for many instances when you would prefer a QueryList to act like an array.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                return this.pages ? this.pages.toArray() : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "pagesCount", {
            /**
             * Returns the length of the pages query list.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the length of the pages query list.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                return this.pages ? this.pages.length : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "penultimatePage", {
            /**
             * Returns the next-to-last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the next-to-last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                /** @type {?} */
                var pageCount = this.pagesCount;
                if (pageCount < 2) {
                    return;
                }
                return this.pagesAsArray[pageCount - 2];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "lastPage", {
            /**
             * Returns the last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                /** @type {?} */
                var pageCount = this.pagesCount;
                if (pageCount < 1) {
                    return;
                }
                return this.pagesAsArray[pageCount - 1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "firstPage", {
            /**
             * Returns the first page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the first page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                if (!this.pagesCount) {
                    return;
                }
                return this.pagesAsArray[0];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
         * object that matches the ID passed. Note that IDs here should include the prefix
         * "clr-wizard-page-".
         *
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * @memberof PageCollectionService
         */
        /**
         * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
         * object that matches the ID passed. Note that IDs here should include the prefix
         * "clr-wizard-page-".
         *
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * \@memberof PageCollectionService
         * @param {?} id
         * @return {?}
         */
        PageCollectionService.prototype.getPageById = /**
         * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
         * object that matches the ID passed. Note that IDs here should include the prefix
         * "clr-wizard-page-".
         *
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * \@memberof PageCollectionService
         * @param {?} id
         * @return {?}
         */
            function (id) {
                /** @type {?} */
                var foundPages = this.pages.filter(function (page) { return id === page.id; });
                return this.checkResults(foundPages, id);
            };
        /**
         * Accepts s number as a parameter and treats that number as the index of the page
         * you're looking for in the collection of pages. Returns a  wizard page object.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts s number as a parameter and treats that number as the index of the page
         * you're looking for in the collection of pages. Returns a  wizard page object.
         *
         * \@memberof PageCollectionService
         * @param {?} index
         * @return {?}
         */
        PageCollectionService.prototype.getPageByIndex = /**
         * Accepts s number as a parameter and treats that number as the index of the page
         * you're looking for in the collection of pages. Returns a  wizard page object.
         *
         * \@memberof PageCollectionService
         * @param {?} index
         * @return {?}
         */
            function (index) {
                /** @type {?} */
                var pageCount = this.pagesCount;
                /** @type {?} */
                var pagesLastIndex = pageCount > 1 ? pageCount - 1 : 0;
                if (index < 0) {
                    throw new Error('Cannot retrieve page with index of ' + index);
                }
                if (index > pagesLastIndex) {
                    throw new Error('Page index is greater than length of pages array.');
                }
                return this.pagesAsArray[index];
            };
        /**
         * Takes a wizard page object as a parameter and returns its index in the
         * collection of pages.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and returns its index in the
         * collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getPageIndex = /**
         * Takes a wizard page object as a parameter and returns its index in the
         * collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var index = this.pagesAsArray.indexOf(page);
                if (index < 0) {
                    throw new Error('Requested page cannot be found in collection of pages.');
                }
                return index;
            };
        /**
         * Consolidates guard logic that prevents a couple of unfortunate edge cases with
         * look ups on the collection of pages.
         *
         * @memberof PageCollectionService
         */
        /**
         * Consolidates guard logic that prevents a couple of unfortunate edge cases with
         * look ups on the collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} results
         * @param {?} requestedPageId
         * @return {?}
         */
        PageCollectionService.prototype.checkResults = /**
         * Consolidates guard logic that prevents a couple of unfortunate edge cases with
         * look ups on the collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} results
         * @param {?} requestedPageId
         * @return {?}
         */
            function (results, requestedPageId) {
                /** @type {?} */
                var foundPagesCount = results.length || 0;
                if (foundPagesCount > 1) {
                    throw new Error('More than one page has the requested id ' + requestedPageId + '.');
                }
                else if (foundPagesCount < 1) {
                    throw new Error('No page can be found with the id ' + requestedPageId + '.');
                }
                else {
                    return results[0];
                }
            };
        /**
         * Accepts two numeric indexes and returns an array of wizard page objects that include
         * all wizard pages in the page collection from the first index to the second.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts two numeric indexes and returns an array of wizard page objects that include
         * all wizard pages in the page collection from the first index to the second.
         *
         * \@memberof PageCollectionService
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
        PageCollectionService.prototype.pageRange = /**
         * Accepts two numeric indexes and returns an array of wizard page objects that include
         * all wizard pages in the page collection from the first index to the second.
         *
         * \@memberof PageCollectionService
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
            function (start, end) {
                /** @type {?} */
                var pages = [];
                if (start < 0 || end < 0) {
                    return [];
                }
                if (start === null || typeof start === 'undefined' || isNaN(start)) {
                    return [];
                }
                if (end === null || typeof end === 'undefined' || isNaN(end)) {
                    return [];
                }
                if (end > this.pagesCount) {
                    end = this.pagesCount;
                }
                pages = this.pagesAsArray;
                if (end - start === 0) {
                    // just return the one page they want
                    return [this.getPageByIndex(start)];
                }
                // slice end does not include item referenced by end index, which is weird for users
                // incrementing end index here to correct that so users and other methods
                // don't have to think about it
                end = end + 1;
                // slice does not return the last one in the range but it does include the first one
                // does not modify original array
                return pages.slice(start, end);
            };
        /**
         * Accepts two wizard page objects and returns those page objects with all other page
         * objects between them in the page collection. It doesn't care which page is ahead of the
         * other in the parameters. It will be smart enough to figure that out  on its own.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts two wizard page objects and returns those page objects with all other page
         * objects between them in the page collection. It doesn't care which page is ahead of the
         * other in the parameters. It will be smart enough to figure that out  on its own.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @param {?} otherPage
         * @return {?}
         */
        PageCollectionService.prototype.getPageRangeFromPages = /**
         * Accepts two wizard page objects and returns those page objects with all other page
         * objects between them in the page collection. It doesn't care which page is ahead of the
         * other in the parameters. It will be smart enough to figure that out  on its own.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @param {?} otherPage
         * @return {?}
         */
            function (page, otherPage) {
                /** @type {?} */
                var pageIndex = this.getPageIndex(page);
                /** @type {?} */
                var otherPageIndex = this.getPageIndex(otherPage);
                /** @type {?} */
                var startIndex;
                /** @type {?} */
                var endIndex;
                if (pageIndex <= otherPageIndex) {
                    startIndex = pageIndex;
                    endIndex = otherPageIndex;
                }
                else {
                    startIndex = otherPageIndex;
                    endIndex = pageIndex;
                }
                return this.pageRange(startIndex, endIndex);
            };
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately before it in the page collection. Returns null if there is
         * no page before the page it is passed.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately before it in the page collection. Returns null if there is
         * no page before the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getPreviousPage = /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately before it in the page collection. Returns null if there is
         * no page before the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var myPageIndex = this.getPageIndex(page);
                /** @type {?} */
                var previousPageIndex = myPageIndex - 1;
                if (previousPageIndex < 0) {
                    return null;
                }
                return this.getPageByIndex(previousPageIndex);
            };
        /**
         * Accepts a wizard page object as a parameter and returns a Boolean that says if
         * the page you sent it is complete.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts a wizard page object as a parameter and returns a Boolean that says if
         * the page you sent it is complete.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.previousPageIsCompleted = /**
         * Accepts a wizard page object as a parameter and returns a Boolean that says if
         * the page you sent it is complete.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var previousPage;
                if (!page) {
                    return false;
                }
                previousPage = this.getPreviousPage(page);
                if (null === previousPage) {
                    // page is the first page. no previous page.
                    return true;
                }
                return previousPage.completed;
            };
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately after it in the page collection. Returns null if there is
         * no page after the page it is passed.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately after it in the page collection. Returns null if there is
         * no page after the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getNextPage = /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately after it in the page collection. Returns null if there is
         * no page after the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var myPageIndex = this.getPageIndex(page);
                /** @type {?} */
                var nextPageIndex = myPageIndex + 1;
                if (nextPageIndex >= this.pagesAsArray.length) {
                    return null;
                }
                return this.getPageByIndex(nextPageIndex);
            };
        /**
         * Takes a wizard page object as a parameter and generates a step item id from the
         * page ID. Returns the generated step item ID as a string.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and generates a step item id from the
         * page ID. Returns the generated step item ID as a string.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getStepItemIdForPage = /**
         * Takes a wizard page object as a parameter and generates a step item id from the
         * page ID. Returns the generated step item ID as a string.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var pageId = page.id;
                /** @type {?} */
                var pageIdParts = pageId.split('-').reverse();
                pageIdParts[1] = 'step';
                return pageIdParts.reverse().join('-');
            };
        /**
         * Generally only used internally to mark that a specific page has been "committed".
         * This involves marking the page complete and firing the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
         * mark completed as a parameter.
         *
         * @memberof PageCollectionService
         */
        /**
         * Generally only used internally to mark that a specific page has been "committed".
         * This involves marking the page complete and firing the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
         * mark completed as a parameter.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.commitPage = /**
         * Generally only used internally to mark that a specific page has been "committed".
         * This involves marking the page complete and firing the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
         * mark completed as a parameter.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var pageHasOverrides = page.stopNext || page.preventDefault;
                page.completed = true;
                if (!pageHasOverrides) {
                    // prevent loop of event emission; alternate flows work off
                    // of event emitters this is how they break that cycle.
                    page.onCommit.emit(page.id);
                }
            };
        Object.defineProperty(PageCollectionService.prototype, "pagesReset", {
            /**
             * An observable that the navigation service listens to in order to know when
             * the page collection completed states have been reset to false so that way it
             * can also reset the navigation to make the first page in the page collection
             * current/active.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * An observable that the navigation service listens to in order to know when
             * the page collection completed states have been reset to false so that way it
             * can also reset the navigation to make the first page in the page collection
             * current/active.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                return this._pagesReset.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets all completed states of the pages in the page collection to false and
         * notifies the navigation service to likewise reset the navigation.
         *
         * @memberof PageCollectionService
         */
        /**
         * Sets all completed states of the pages in the page collection to false and
         * notifies the navigation service to likewise reset the navigation.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        PageCollectionService.prototype.reset = /**
         * Sets all completed states of the pages in the page collection to false and
         * notifies the navigation service to likewise reset the navigation.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
            function () {
                this.pagesAsArray.forEach(function (page) {
                    page.completed = false;
                });
                this._pagesReset.next(true);
            };
        /**
         * Rolls through all the pages in the page collection to make sure there are no
         * incomplete pages sandwiched between completed pages in the workflow. Identifies
         * the first incomplete page index and sets all pages behind it to a completed
         * state of false.
         *
         * @memberof PageCollectionService
         */
        /**
         * Rolls through all the pages in the page collection to make sure there are no
         * incomplete pages sandwiched between completed pages in the workflow. Identifies
         * the first incomplete page index and sets all pages behind it to a completed
         * state of false.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        PageCollectionService.prototype.updateCompletedStates = /**
         * Rolls through all the pages in the page collection to make sure there are no
         * incomplete pages sandwiched between completed pages in the workflow. Identifies
         * the first incomplete page index and sets all pages behind it to a completed
         * state of false.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var firstIncompleteIndex = this.findFirstIncompletePageIndex();
                if (firstIncompleteIndex === this.pagesAsArray.length - 1) {
                    // all complete no need to do anything
                    return;
                }
                this.pagesAsArray.forEach(function (page, index) {
                    if (index > firstIncompleteIndex) {
                        page.completed = false;
                    }
                });
            };
        /**
         * Retrieves the index of the first incomplete page in the page collection.
         *
         * @memberof PageCollectionService
         */
        /**
         * Retrieves the index of the first incomplete page in the page collection.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        PageCollectionService.prototype.findFirstIncompletePageIndex = /**
         * Retrieves the index of the first incomplete page in the page collection.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var returnIndex = null;
                this.pagesAsArray.forEach(function (page, index) {
                    if (null === returnIndex && false === page.completed) {
                        returnIndex = index;
                    }
                });
                // fallthrough, all completed, return last page
                if (null === returnIndex) {
                    returnIndex = this.pagesCount - 1;
                }
                return returnIndex;
            };
        /**
         * @return {?}
         */
        PageCollectionService.prototype.findFirstIncompletePage = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var myIncompleteIndex = this.findFirstIncompletePageIndex();
                return this.pagesAsArray[myIncompleteIndex];
            };
        PageCollectionService.decorators = [
            { type: i0.Injectable }
        ];
        return PageCollectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Performs navigation functions for a wizard and manages the current page. Presented as a
     * separate service to encapsulate the behavior of navigating and completing the wizard so
     * that it can be shared across the wizard and its sub-components.
     *
     * The easiest way to access the navigation service is there a reference on your wizard. The
     * Following example would allow you to access your instance of the wizard from your host
     * component and thereby access the navigation service via YourHostComponent.wizard.navService.
     *
     * \@example
     * <clr-wizard #wizard ...>
     *
     * \@example
     * export class YourHostComponent {
     * \@ViewChild("wizard") wizard: Wizard;
     *   ...
     * }
     *
     */
    var WizardNavigationService = /** @class */ (function () {
        /**
         * Creates an instance of WizardNavigationService. Also sets up subscriptions
         * that listen to the button service to determine when a button has been clicked
         * in the wizard. Is also responsible for taking action when the page collection
         * requests that navigation be reset to its pristine state.
         *
         * @memberof WizardNavigationService
         */
        function WizardNavigationService(pageCollection, buttonService) {
            var _this = this;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            /**
             *
             * \@memberof WizardNavigationService
             */
            this._currentChanged = new rxjs.Subject();
            /**
             * A Boolean flag used by the ClrWizardPage to avoid a race condition when pages are
             * loading and there is no current page defined.
             *
             * \@memberof WizardNavigationService
             */
            this.navServiceLoaded = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.forceForward (clrWizardForceForwardNavigation) input. When true,
             * navigating backwards in the stepnav menu will reset any skipped pages' completed
             * state to false.
             *
             * This is useful when a wizard executes validation on a page-by-page basis when
             * the next button is clicked.
             *
             * \@memberof WizardNavigationService
             */
            this.forceForwardNavigation = false;
            /**
             * \@memberof WizardNavigationService
             */
            this._movedToNextPage = new rxjs.Subject();
            /**
             * \@memberof WizardNavigationService
             */
            this._wizardFinished = new rxjs.Subject();
            /**
             * \@memberof WizardNavigationService
             */
            this._movedToPreviousPage = new rxjs.Subject();
            /**
             * \@memberof WizardNavigationService
             */
            this._cancelWizard = new rxjs.Subject();
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopCancel (clrWizardPreventDefaultCancel) input. When true, the cancel
             * routine is subverted and must be reinstated in the host component calling Wizard.close()
             * at some point.
             *
             * \@memberof WizardNavigationService
             */
            this.wizardHasAltCancel = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopNext (clrWizardPreventDefaultNext) input. When true, the next and finish
             * routines are subverted and must be reinstated in the host component calling Wizard.next(),
             * Wizard.forceNext(), Wizard.finish(), or Wizard.forceFinish().
             *
             * \@memberof WizardNavigationService
             */
            this.wizardHasAltNext = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopNavigation (clrWizardPreventNavigation) input. When true, all
             * navigational elements in the wizard are disabled.
             *
             * This is intended to freeze the wizard in place. Events are not fired so this is
             * not a way to implement alternate functionality for navigation.
             *
             * \@memberof WizardNavigationService
             */
            this.wizardStopNavigation = false;
            /**
             * A boolean flag shared with the stepnav items that prevents user clicks on
             * stepnav items from navigating the wizard.
             *
             * \@memberof WizardNavigationService
             */
            this.wizardDisableStepnav = false;
            this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(function () {
                /** @type {?} */
                var currentPage = _this.currentPage;
                if (_this.currentPageIsFirst || currentPage.previousStepDisabled) {
                    return;
                }
                currentPage.previousButtonClicked.emit(currentPage);
                if (!currentPage.preventDefault) {
                    _this.previous();
                }
            });
            this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('next');
            });
            this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('danger');
            });
            this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('finish');
            });
            this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe(function (type) {
                if (!_this.wizardStopNavigation) {
                    _this.currentPage.customButtonClicked.emit(type);
                }
            });
            this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(function () {
                if (_this.wizardStopNavigation) {
                    return;
                }
                if (_this.currentPage.preventDefault) {
                    _this.currentPage.pageOnCancel.emit(_this.currentPage);
                }
                else {
                    _this.cancel();
                }
            });
            this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(function () {
                _this.setFirstPageCurrent();
            });
        }
        /**
         *
         * @memberof WizardNavigationService
         */
        /**
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.ngOnDestroy = /**
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this.previousButtonSubscription.unsubscribe();
                this.nextButtonSubscription.unsubscribe();
                this.dangerButtonSubscription.unsubscribe();
                this.finishButtonSubscription.unsubscribe();
                this.customButtonSubscription.unsubscribe();
                this.cancelButtonSubscription.unsubscribe();
                this.pagesResetSubscription.unsubscribe();
            };
        Object.defineProperty(WizardNavigationService.prototype, "currentPageChanged", {
            /**
             * An Observable that is predominantly used amongst the subcomponents and services
             * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
             * (clrWizardPageOnLoad) output instead of this Observable.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * An Observable that is predominantly used amongst the subcomponents and services
             * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
             * (clrWizardPageOnLoad) output instead of this Observable.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                // TODO: MAKE SURE EXTERNAL OUTPUTS SAY 'CHANGE' NOT 'CHANGED'
                // A BREAKING CHANGE SO AWAITING MINOR RELEASE
                return this._currentChanged.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageTitle", {
            /**
             * @memberof WizardNavigationService
             */
            get: /**
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                // when the querylist of pages is empty. this is the first place it fails...
                if (!this.currentPage) {
                    return null;
                }
                return this.currentPage.title;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageIsFirst", {
            /**
             * Returns a Boolean that tells you whether or not the current page is the first
             * page in the Wizard.
             *
             * This is helpful for determining whether a page is navigable.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Returns a Boolean that tells you whether or not the current page is the first
             * page in the Wizard.
             *
             * This is helpful for determining whether a page is navigable.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this.pageCollection.firstPage === this.currentPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageIsLast", {
            /**
             * Returns a Boolean that tells you whether or not the current page is the
             * last page in the Wizard.
             *
             * This is used to determine which buttons should display in the wizard footer.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Returns a Boolean that tells you whether or not the current page is the
             * last page in the Wizard.
             *
             * This is used to determine which buttons should display in the wizard footer.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this.pageCollection.lastPage === this.currentPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPage", {
            /**
             * Returns the ClrWizardPage object of the current page or null.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Returns the ClrWizardPage object of the current page or null.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                if (!this._currentPage) {
                    return null;
                }
                return this._currentPage;
            },
            /**
             * Accepts a ClrWizardPage object, since that object to be the current/active
             * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
             * event for that page.
             *
             * Note that all of this work is bypassed if the ClrWizardPage object is already
             * the current page.
             *
             * @memberof WizardNavigationService
             */
            set: /**
             * Accepts a ClrWizardPage object, since that object to be the current/active
             * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
             * event for that page.
             *
             * Note that all of this work is bypassed if the ClrWizardPage object is already
             * the current page.
             *
             * \@memberof WizardNavigationService
             * @param {?} page
             * @return {?}
             */ function (page) {
                if (this._currentPage !== page && !this.wizardStopNavigation) {
                    this._currentPage = page;
                    page.onLoad.emit(page.id);
                    this._currentChanged.next(page);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "movedToNextPage", {
            /**
             * An observable used internally to alert the wizard that forward navigation
             * has occurred. It is recommended that you use the Wizard.onMoveNext
             * (clrWizardOnNext) output instead of this one.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * An observable used internally to alert the wizard that forward navigation
             * has occurred. It is recommended that you use the Wizard.onMoveNext
             * (clrWizardOnNext) output instead of this one.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._movedToNextPage.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "wizardFinished", {
            /**
             * An observable used internally to alert the wizard that the nav service
             * has approved completion of the wizard.
             *
             * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
             * output instead of this one.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * An observable used internally to alert the wizard that the nav service
             * has approved completion of the wizard.
             *
             * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
             * output instead of this one.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._wizardFinished.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is a public function that can be used to programmatically advance
         * the user to the next page.
         *
         * When invoked, this method will move the wizard to the next page after
         * successful validation. Note that this method goes through all checks
         * and event emissions as if Wizard.next(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.next(false).
         *
         * @memberof WizardNavigationService
         */
        /**
         * This is a public function that can be used to programmatically advance
         * the user to the next page.
         *
         * When invoked, this method will move the wizard to the next page after
         * successful validation. Note that this method goes through all checks
         * and event emissions as if Wizard.next(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.next(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.next = /**
         * This is a public function that can be used to programmatically advance
         * the user to the next page.
         *
         * When invoked, this method will move the wizard to the next page after
         * successful validation. Note that this method goes through all checks
         * and event emissions as if Wizard.next(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.next(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                if (this.currentPageIsLast) {
                    this.checkAndCommitCurrentPage('finish');
                }
                else {
                    this.checkAndCommitCurrentPage('next');
                }
            };
        /**
         * Bypasses checks and most event emissions to force a page to navigate forward.
         *
         * Comparable to calling Wizard.next() or Wizard.forceNext().
         *
         * @memberof WizardNavigationService
         */
        /**
         * Bypasses checks and most event emissions to force a page to navigate forward.
         *
         * Comparable to calling Wizard.next() or Wizard.forceNext().
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.forceNext = /**
         * Bypasses checks and most event emissions to force a page to navigate forward.
         *
         * Comparable to calling Wizard.next() or Wizard.forceNext().
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var currentPage = this.currentPage;
                /** @type {?} */
                var nextPage = this.pageCollection.getNextPage(currentPage);
                // catch errant null or undefineds that creep in
                if (!nextPage) {
                    throw new Error('The wizard has no next page to go to.');
                }
                if (this.wizardStopNavigation) {
                    return;
                }
                if (!currentPage.completed) {
                    // this is a state that alt next flows can get themselves in...
                    this.pageCollection.commitPage(currentPage);
                }
                this.currentPage = nextPage;
            };
        /**
         * Accepts a button/action type as a parameter. Encapsulates all logic for
         * event emissions, state of the current page, and wizard and page level overrides.
         *
         * Avoid calling this function directly unless you really know what you're doing.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Accepts a button/action type as a parameter. Encapsulates all logic for
         * event emissions, state of the current page, and wizard and page level overrides.
         *
         * Avoid calling this function directly unless you really know what you're doing.
         *
         * \@memberof WizardNavigationService
         * @param {?} buttonType
         * @return {?}
         */
        WizardNavigationService.prototype.checkAndCommitCurrentPage = /**
         * Accepts a button/action type as a parameter. Encapsulates all logic for
         * event emissions, state of the current page, and wizard and page level overrides.
         *
         * Avoid calling this function directly unless you really know what you're doing.
         *
         * \@memberof WizardNavigationService
         * @param {?} buttonType
         * @return {?}
         */
            function (buttonType) {
                /** @type {?} */
                var currentPage = this.currentPage;
                /** @type {?} */
                var iAmTheLastPage;
                /** @type {?} */
                var isNext;
                /** @type {?} */
                var isDanger;
                /** @type {?} */
                var isDangerNext;
                /** @type {?} */
                var isDangerFinish;
                /** @type {?} */
                var isFinish;
                if (!currentPage.readyToComplete || this.wizardStopNavigation) {
                    return;
                }
                iAmTheLastPage = this.currentPageIsLast;
                isNext = buttonType === 'next';
                isDanger = buttonType === 'danger';
                isDangerNext = isDanger && !iAmTheLastPage;
                isDangerFinish = isDanger && iAmTheLastPage;
                isFinish = buttonType === 'finish' || isDangerFinish;
                if (isFinish && !iAmTheLastPage) {
                    return;
                }
                currentPage.primaryButtonClicked.emit(buttonType);
                if (isFinish) {
                    currentPage.finishButtonClicked.emit(currentPage);
                }
                else if (isDanger) {
                    currentPage.dangerButtonClicked.emit();
                }
                else if (isNext) {
                    currentPage.nextButtonClicked.emit();
                }
                if (currentPage.stopNext || currentPage.preventDefault) {
                    currentPage.onCommit.emit(currentPage.id);
                    return;
                }
                // order is very important with these emitters!
                if (isFinish) {
                    // mark page as complete
                    if (!this.wizardHasAltNext) {
                        this.pageCollection.commitPage(currentPage);
                    }
                    this._wizardFinished.next();
                }
                if (this.wizardHasAltNext) {
                    this.pageCollection.commitPage(currentPage);
                    if (isNext || isDangerNext) {
                        this._movedToNextPage.next(true);
                    }
                    // jump out here, no matter what type we're looking at
                    return;
                }
                if (isNext || isDangerNext) {
                    this.forceNext();
                }
                if (!this.wizardHasAltNext && !this.wizardStopNavigation) {
                    this._movedToNextPage.next(true);
                }
            };
        /**
         * This is a public function that can be used to programmatically conclude
         * the wizard.
         *
         * When invoked, this method will  initiate the work involved with finalizing
         * and finishing the wizard workflow. Note that this method goes through all
         * checks and event emissions as if Wizard.finish(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.finish(false).
         *
         * @memberof WizardNavigationService
         */
        /**
         * This is a public function that can be used to programmatically conclude
         * the wizard.
         *
         * When invoked, this method will  initiate the work involved with finalizing
         * and finishing the wizard workflow. Note that this method goes through all
         * checks and event emissions as if Wizard.finish(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.finish(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.finish = /**
         * This is a public function that can be used to programmatically conclude
         * the wizard.
         *
         * When invoked, this method will  initiate the work involved with finalizing
         * and finishing the wizard workflow. Note that this method goes through all
         * checks and event emissions as if Wizard.finish(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.finish(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this.checkAndCommitCurrentPage('finish');
            };
        Object.defineProperty(WizardNavigationService.prototype, "movedToPreviousPage", {
            /**
             * Notifies the wizard when backwards navigation has occurred via the
             * previous button.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Notifies the wizard when backwards navigation has occurred via the
             * previous button.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._movedToPreviousPage.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Programmatically moves the wizard to the page before the current page.
         *
         * In most instances, it makes more sense to call Wizard.previous()
         * which does the same thing.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Programmatically moves the wizard to the page before the current page.
         *
         * In most instances, it makes more sense to call Wizard.previous()
         * which does the same thing.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.previous = /**
         * Programmatically moves the wizard to the page before the current page.
         *
         * In most instances, it makes more sense to call Wizard.previous()
         * which does the same thing.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var previousPage;
                if (this.currentPageIsFirst || this.wizardStopNavigation) {
                    return;
                }
                previousPage = this.pageCollection.getPreviousPage(this.currentPage);
                if (!previousPage) {
                    return;
                }
                this._movedToPreviousPage.next(true);
                if (this.forceForwardNavigation) {
                    this.currentPage.completed = false;
                }
                this.currentPage = previousPage;
            };
        Object.defineProperty(WizardNavigationService.prototype, "notifyWizardCancel", {
            /**
             * Notifies the wizard that a user is trying to cancel it.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Notifies the wizard that a user is trying to cancel it.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._cancelWizard.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
         * this route goes through all checks and event emissions as if a cancel button had
         * been clicked.
         *
         * In most cases, users looking for a hook into the cancel routine are actually looking
         * for a way to close the wizard from their host component because they have prevented
         * the default cancel action.
         *
         * In this instance, it is recommended that you use Wizard.close() to avoid any event
         * emission loop resulting from an event handler calling back into routine that will
         * again evoke the events it handles.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
         * this route goes through all checks and event emissions as if a cancel button had
         * been clicked.
         *
         * In most cases, users looking for a hook into the cancel routine are actually looking
         * for a way to close the wizard from their host component because they have prevented
         * the default cancel action.
         *
         * In this instance, it is recommended that you use Wizard.close() to avoid any event
         * emission loop resulting from an event handler calling back into routine that will
         * again evoke the events it handles.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.cancel = /**
         * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
         * this route goes through all checks and event emissions as if a cancel button had
         * been clicked.
         *
         * In most cases, users looking for a hook into the cancel routine are actually looking
         * for a way to close the wizard from their host component because they have prevented
         * the default cancel action.
         *
         * In this instance, it is recommended that you use Wizard.close() to avoid any event
         * emission loop resulting from an event handler calling back into routine that will
         * again evoke the events it handles.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this._cancelWizard.next();
            };
        /**
         * Performs all required checks to determine if a user can navigate to a page. Checking at each
         * point if a page is navigable -- completed where the page immediately after the last completed
         * page.
         *
         * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
         * ClrWizardPage object that you want to make the current page.
         *
         * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
         * is the Wizard will mark all pages between the current page and the page you want to navigate
         * to as completed. This is useful for informational wizards that do not require user action,
         * allowing an easy means for users to jump ahead.
         *
         * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Performs all required checks to determine if a user can navigate to a page. Checking at each
         * point if a page is navigable -- completed where the page immediately after the last completed
         * page.
         *
         * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
         * ClrWizardPage object that you want to make the current page.
         *
         * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
         * is the Wizard will mark all pages between the current page and the page you want to navigate
         * to as completed. This is useful for informational wizards that do not require user action,
         * allowing an easy means for users to jump ahead.
         *
         * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
         *
         * \@memberof WizardNavigationService
         * @param {?} pageToGoToOrId
         * @param {?=} lazyComplete
         * @return {?}
         */
        WizardNavigationService.prototype.goTo = /**
         * Performs all required checks to determine if a user can navigate to a page. Checking at each
         * point if a page is navigable -- completed where the page immediately after the last completed
         * page.
         *
         * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
         * ClrWizardPage object that you want to make the current page.
         *
         * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
         * is the Wizard will mark all pages between the current page and the page you want to navigate
         * to as completed. This is useful for informational wizards that do not require user action,
         * allowing an easy means for users to jump ahead.
         *
         * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
         *
         * \@memberof WizardNavigationService
         * @param {?} pageToGoToOrId
         * @param {?=} lazyComplete
         * @return {?}
         */
            function (pageToGoToOrId, lazyComplete) {
                if (lazyComplete === void 0) {
                    lazyComplete = false;
                }
                /** @type {?} */
                var pageToGoTo;
                /** @type {?} */
                var currentPage;
                /** @type {?} */
                var myPages;
                /** @type {?} */
                var pagesToCheck;
                /** @type {?} */
                var okayToMove;
                /** @type {?} */
                var goingForward;
                /** @type {?} */
                var currentPageIndex;
                /** @type {?} */
                var goToPageIndex;
                myPages = this.pageCollection;
                pageToGoTo = typeof pageToGoToOrId === 'string' ? myPages.getPageById(pageToGoToOrId) : pageToGoToOrId;
                currentPage = this.currentPage;
                // no point in going to the current page. you're there already!
                // also hard block on any navigation when stopNavigation is true
                if (pageToGoTo === currentPage || this.wizardStopNavigation) {
                    return;
                }
                currentPageIndex = myPages.getPageIndex(currentPage);
                goToPageIndex = myPages.getPageIndex(pageToGoTo);
                goingForward = goToPageIndex > currentPageIndex;
                pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
                okayToMove = lazyComplete || this.canGoTo(pagesToCheck);
                if (!okayToMove) {
                    return;
                }
                if (goingForward && lazyComplete) {
                    pagesToCheck.forEach(function (page) {
                        if (page !== pageToGoTo) {
                            page.completed = true;
                        }
                    });
                }
                else if (!goingForward && this.forceForwardNavigation) {
                    pagesToCheck.forEach(function (page) {
                        page.completed = false;
                    });
                }
                this.currentPage = pageToGoTo;
            };
        /**
         * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
         * those objects to determine if navigation can be accomplished.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
         * those objects to determine if navigation can be accomplished.
         *
         * \@memberof WizardNavigationService
         * @param {?} pagesToCheck
         * @return {?}
         */
        WizardNavigationService.prototype.canGoTo = /**
         * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
         * those objects to determine if navigation can be accomplished.
         *
         * \@memberof WizardNavigationService
         * @param {?} pagesToCheck
         * @return {?}
         */
            function (pagesToCheck) {
                /** @type {?} */
                var okayToMove = true;
                /** @type {?} */
                var myPages = this.pageCollection;
                // previous page can be important when moving because if it's completed it
                // allows us to move to the page even if it's incomplete...
                /** @type {?} */
                var previousPagePasses;
                if (!pagesToCheck || pagesToCheck.length < 1) {
                    return false;
                }
                pagesToCheck.forEach(function (page) {
                    /** @type {?} */
                    var previousPage;
                    if (!okayToMove) {
                        return;
                    }
                    if (page.completed) {
                        // default is true. just jump out instead of complicating it.
                        return;
                    }
                    // so we know our page is not completed...
                    previousPage = myPages.getPageIndex(page) > 0 ? myPages.getPreviousPage(page) : null;
                    previousPagePasses = previousPage === null || previousPage.completed === true;
                    // we are false if not the current page AND previous page is not completed
                    // (but must have a previous page)
                    if (!page.current && !previousPagePasses) {
                        okayToMove = false;
                    }
                    // falls through to true as default
                });
                return okayToMove;
            };
        /**
         * Looks through the collection of pages to find the first one that is incomplete
         * and makes that page the current/active page.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Looks through the collection of pages to find the first one that is incomplete
         * and makes that page the current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.setLastEnabledPageCurrent = /**
         * Looks through the collection of pages to find the first one that is incomplete
         * and makes that page the current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var allPages = this.pageCollection.pagesAsArray;
                /** @type {?} */
                var lastCompletedPageIndex = null;
                allPages.forEach(function (page, index) {
                    if (page.completed) {
                        lastCompletedPageIndex = index;
                    }
                });
                if (lastCompletedPageIndex === null) {
                    // always is at least the first item...
                    lastCompletedPageIndex = 0;
                }
                else if (lastCompletedPageIndex + 1 < allPages.length) {
                    lastCompletedPageIndex = lastCompletedPageIndex + 1;
                }
                this.currentPage = allPages[lastCompletedPageIndex];
            };
        /**
         * Finds the first page in the collection of pages and makes that page the
         * current/active page.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Finds the first page in the collection of pages and makes that page the
         * current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.setFirstPageCurrent = /**
         * Finds the first page in the collection of pages and makes that page the
         * current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this.currentPage = this.pageCollection.pagesAsArray[0];
            };
        /**
         * Updates the stepnav on the left side of the wizard when pages are dynamically
         * added or removed from the collection of pages.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Updates the stepnav on the left side of the wizard when pages are dynamically
         * added or removed from the collection of pages.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.updateNavigation = /**
         * Updates the stepnav on the left side of the wizard when pages are dynamically
         * added or removed from the collection of pages.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var toSetCurrent;
                /** @type {?} */
                var currentPageRemoved;
                this.pageCollection.updateCompletedStates();
                currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
                if (currentPageRemoved) {
                    toSetCurrent = this.pageCollection.findFirstIncompletePage();
                    this.currentPage = toSetCurrent;
                }
            };
        WizardNavigationService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        WizardNavigationService.ctorParameters = function () {
            return [
                { type: PageCollectionService },
                { type: ButtonHubService }
            ];
        };
        return WizardNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var HeaderActionService = /** @class */ (function () {
        // this service communicates information about the presence/display of header actions
        // across the wizard
        function HeaderActionService(navService) {
            this.navService = navService;
        }
        Object.defineProperty(HeaderActionService.prototype, "wizardHasHeaderActions", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var wizardHdrActions = this.wizardHeaderActions;
                if (!wizardHdrActions) {
                    return false;
                }
                return wizardHdrActions.toArray().length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "currentPageHasHeaderActions", {
            get: /**
             * @return {?}
             */ function () {
                return this.navService.currentPage ? this.navService.currentPage.hasHeaderActions : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "showWizardHeaderActions", {
            get: /**
             * @return {?}
             */ function () {
                return !this.currentPageHasHeaderActions && this.wizardHasHeaderActions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "displayHeaderActionsWrapper", {
            get: /**
             * @return {?}
             */ function () {
                return this.currentPageHasHeaderActions || this.wizardHasHeaderActions;
            },
            enumerable: true,
            configurable: true
        });
        HeaderActionService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        HeaderActionService.ctorParameters = function () {
            return [
                { type: WizardNavigationService }
            ];
        };
        return HeaderActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var wizardHeaderActionIndex = 0;
    var ClrWizardHeaderAction = /** @class */ (function () {
        function ClrWizardHeaderAction() {
            // title is explanatory text added to the header action
            this.title = '';
            // If our host has an ID attribute, we use this instead of our index.
            this._id = (wizardHeaderActionIndex++).toString();
            this.disabled = false;
            this.headerActionClicked = new i0.EventEmitter(false);
        }
        Object.defineProperty(ClrWizardHeaderAction.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "clr-wizard-header-action-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizardHeaderAction.prototype.click = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                // passing the header action id allows users to have one method that
                // routes to many different actions based on the type of header action
                // clicked. this is further aided by users being able to specify ids
                // for their header actions.
                this.headerActionClicked.emit(this._id);
            };
        ClrWizardHeaderAction.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-header-action',
                        template: "\n        <button \n            type=\"button\"\n            class=\"btn clr-wizard-header-action btn-link\"\n            [id]=\"id\"\n            [class.disabled]=\"disabled\"\n            (click)=\"click()\"\n            [title]=\"title\">\n            <ng-content></ng-content>\n        </button>\n    ",
                        host: { class: 'clr-wizard-header-action-wrapper' }
                    }] }
        ];
        ClrWizardHeaderAction.propDecorators = {
            title: [{ type: i0.Input, args: ['title',] }],
            _id: [{ type: i0.Input, args: ['id',] }],
            disabled: [{ type: i0.Input, args: ['clrWizardHeaderActionDisabled',] }],
            headerActionClicked: [{ type: i0.Output, args: ['actionClicked',] }]
        };
        return ClrWizardHeaderAction;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageButtons = /** @class */ (function () {
        function ClrWizardPageButtons(pageButtonsTemplateRef) {
            this.pageButtonsTemplateRef = pageButtonsTemplateRef;
        }
        ClrWizardPageButtons.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageButtons]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageButtons.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageButtons;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageHeaderActions = /** @class */ (function () {
        function ClrWizardPageHeaderActions(pageHeaderActionsTemplateRef) {
            this.pageHeaderActionsTemplateRef = pageHeaderActionsTemplateRef;
        }
        ClrWizardPageHeaderActions.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageHeaderActions]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageHeaderActions.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageHeaderActions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageNavTitle = /** @class */ (function () {
        function ClrWizardPageNavTitle(pageNavTitleTemplateRef) {
            this.pageNavTitleTemplateRef = pageNavTitleTemplateRef;
        }
        ClrWizardPageNavTitle.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageNavTitle]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageNavTitle.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageNavTitle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageTitle = /** @class */ (function () {
        function ClrWizardPageTitle(pageTitleTemplateRef) {
            this.pageTitleTemplateRef = pageTitleTemplateRef;
        }
        ClrWizardPageTitle.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageTitle]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageTitle.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageTitle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var wizardPageIndex = 0;
    /**
     * The ClrWizardPage component is responsible for displaying the content of each step
     * in the wizard workflow.
     *
     * ClrWizardPage component has hooks into the navigation service (ClrWizardPage.navService),
     * page collection (ClrWizardPage.pageCollection), and button service
     * (ClrWizardPage.buttonService). These three providers are shared across the components
     * within each instance of a Wizard.
     *
     */
    var ClrWizardPage = /** @class */ (function () {
        /**
         * Creates an instance of ClrWizardPage.
         *
         * @memberof WizardPage
         */
        function ClrWizardPage(navService, pageCollection, buttonService) {
            this.navService = navService;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._nextStepDisabled = false;
            /**
             * Emits when the value of ClrWizardPage.nextStepDisabled changes.
             * Should emit the new value of nextStepDisabled.
             *
             * \@memberof WizardPage
             *
             */
            this.nextStepDisabledChange = new i0.EventEmitter();
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._previousStepDisabled = false;
            /**
             * Emits when the value of ClrWizardPage.previousStepDisabled changes.
             * Should emit the new value of previousStepDisabled.
             *
             * \@memberof WizardPage
             *
             */
            this.previousStepDisabledChange = new i0.EventEmitter();
            /**
             * Overrides all actions from the page level, so you can use an alternate function for
             * validation or data-munging with a ClrWizardPage.onCommit (clrWizardPageOnCommit output),
             * ClrWizardPage.onCancel (clrWizardPageOnCancel output), or one
             * of the granular page-level button click event emitters.
             *
             * \@memberof WizardPage
             *
             */
            this.preventDefault = false;
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._stopCancel = false;
            /**
             *
             * \@memberof WizardPage
             *
             */
            this.stopCancelChange = new i0.EventEmitter();
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._stopNext = false;
            /**
             * An event emitter carried over from a legacy version of ClrWizardPage.
             * Fires an event on ClrWizardPage whenever the next or finish buttons
             * are clicked and the page is the current page of the Wizard.
             *
             * Note that this does not automatically emit an event when a custom
             * button is used in place of a next or finish button.
             *
             * \@memberof WizardPage
             *
             */
            this.onCommit = new i0.EventEmitter(false);
            /**
             * Emits an event when ClrWizardPage becomes the current page of the
             * Wizard.
             *
             * \@memberof WizardPage
             *
             */
            this.onLoad = new i0.EventEmitter();
            /**
             * Emits an event when the ClrWizardPage invokes the cancel routine for the wizard.
             *
             * Can be used in conjunction with the ClrWizardPage.stopCancel
             * (clrWizardPagePreventDefaultCancel) or ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) inputs to implement custom cancel
             * functionality at the page level. This is useful if you would like to do
             * validation, save data, or warn users before cancelling the wizard.
             *
             * Note that this requires you to call Wizard.close() from the host component.
             * This constitues a full replacement of the cancel functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.pageOnCancel = new i0.EventEmitter();
            /**
             * Emits an event when the finish button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom finish
             * functionality at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to complete
             * the wizard.
             *
             * Note that this requires you to call Wizard.finish() or Wizard.forceFinish()
             * from the host component. This combination creates a full replacement of
             * the finish functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.finishButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when the previous button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom backwards
             * navigation at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to go
             * backwards in the wizard.
             *
             * Note that this requires you to call Wizard.previous()
             * from the host component. This combination creates a full replacement of
             * the backwards navigation functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.previousButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when the next button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * navigation at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to go
             * to the next page in the wizard.
             *
             * Note that this requires you to call Wizard.forceNext() or Wizard.next()
             * from the host component. This combination creates a full replacement of
             * the forward navigation functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.nextButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when a danger button is clicked and the ClrWizardPage is
             * the wizard's current page. By default, a danger button will act as
             * either a "next" or "finish" button depending on if the ClrWizardPage is the
             * last page or not.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * or finish navigation at the page level when the danger button is clicked.
             * This is useful if you would like to do validation, save data, or warn
             * users before allowing them to go to the next page in the wizard or
             * finish the wizard.
             *
             * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
             * Wizard.forceNext() or Wizard.next() from the host component. This
             * combination creates a full replacement of the forward navigation and
             * finish functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.dangerButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when a next, finish, or danger button is clicked and the
             * ClrWizardPage is the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * or finish navigation at the page level, regardless of the type of
             * primary button.
             *
             * This is useful if you would like to do validation, save data, or warn
             * users before allowing them to go to the next page in the wizard or
             * finish the wizard.
             *
             * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
             * Wizard.forceNext() or Wizard.next() from the host component. This
             * combination creates a full replacement of the forward navigation and
             * finish functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.primaryButtonClicked = new i0.EventEmitter();
            this.customButtonClicked = new i0.EventEmitter();
            /**
             * An input value that is used internally to generate the ClrWizardPage ID as
             * well as the step nav item ID.
             *
             * Typed as any because it should be able to accept numbers as well as
             * strings. Passing an index for wizard whose pages are created with an
             * ngFor loop is a common use case.
             *
             * \@memberof WizardPage
             *
             */
            this._id = (wizardPageIndex++).toString();
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._complete = false;
        }
        Object.defineProperty(ClrWizardPage.prototype, "nextStepDisabled", {
            /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the next page.
             *
             * Useful for in-page validation because it prevents forward navigation
             * and visibly disables the next button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the next page.
             *
             * Useful for in-page validation because it prevents forward navigation
             * and visibly disables the next button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._nextStepDisabled;
            },
            /**
             * Sets whether the page should allow forward navigation.
             *
             * @memberof WizardPage
             *
             */
            set: /**
             * Sets whether the page should allow forward navigation.
             *
             * \@memberof WizardPage
             *
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._nextStepDisabled) {
                    this._nextStepDisabled = valBool;
                    this.nextStepDisabledChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "previousStepDisabled", {
            /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the previous page.
             *
             * Useful for in-page validation because it prevents backward navigation
             * and visibly disables the previous button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the previous page.
             *
             * Useful for in-page validation because it prevents backward navigation
             * and visibly disables the previous button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._previousStepDisabled;
            },
            /**
             * Sets whether the page should allow backward navigation.
             *
             * @memberof WizardPage
             *
             */
            set: /**
             * Sets whether the page should allow backward navigation.
             *
             * \@memberof WizardPage
             *
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._previousStepDisabled) {
                    this._previousStepDisabled = valBool;
                    this.previousStepDisabledChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "stopCancel", {
            /**
             * A getter that retrieves whether the page is preventing the cancel action.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that retrieves whether the page is preventing the cancel action.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._stopCancel;
            },
            /**
             * Overrides the cancel action from the page level. Allows you to use an
             * alternate function for validation or data-munging before cancelling the
             * wizard when combined with the ClrWizardPage.onCancel
             * (the clrWizardPageOnCancel output).
             *
             * Requires that you manually close the wizard from your host component,
             * usually with a call to Wizard.forceNext() or wizard.next();
             *
             * @memberof ClrWizardPage
             */
            set: /**
             * Overrides the cancel action from the page level. Allows you to use an
             * alternate function for validation or data-munging before cancelling the
             * wizard when combined with the ClrWizardPage.onCancel
             * (the clrWizardPageOnCancel output).
             *
             * Requires that you manually close the wizard from your host component,
             * usually with a call to Wizard.forceNext() or wizard.next();
             *
             * \@memberof ClrWizardPage
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._stopCancel) {
                    this._stopCancel = valBool;
                    this.stopCancelChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "stopNext", {
            /**
             * A getter that tells you whether the page is preventing the next action.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that tells you whether the page is preventing the next action.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._stopNext;
            },
            /**
             * Overrides forward navigation from the page level. Allows you to use an
             * alternate function for validation or data-munging before moving the
             * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
             * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
             * (clrWizardPageNext) outputs.
             *
             * Requires that you manually tell the wizard to navigate forward from
             * the hostComponent, usually with a call to Wizard.forceNext() or
             * wizard.next();
             *
             * @memberof ClrWizardPage
             */
            set: /**
             * Overrides forward navigation from the page level. Allows you to use an
             * alternate function for validation or data-munging before moving the
             * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
             * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
             * (clrWizardPageNext) outputs.
             *
             * Requires that you manually tell the wizard to navigate forward from
             * the hostComponent, usually with a call to Wizard.forceNext() or
             * wizard.next();
             *
             * \@memberof ClrWizardPage
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._stopNext) {
                    this._stopNext = valBool;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "id", {
            /**
             * A read-only getter that generates an ID string for the wizard page from
             * either the value passed to the ClrWizardPage "id" input or a wizard page
             * counter shared across all wizard pages in the application.
             *
             * Note that the value passed into the ID input Will be prefixed with
             * "clr-wizard-page-".
             *
             * @readonly
             *
             * @memberof ClrWizardPage
             */
            get: /**
             * A read-only getter that generates an ID string for the wizard page from
             * either the value passed to the ClrWizardPage "id" input or a wizard page
             * counter shared across all wizard pages in the application.
             *
             * Note that the value passed into the ID input Will be prefixed with
             * "clr-wizard-page-".
             *
             * \@readonly
             *
             * \@memberof ClrWizardPage
             * @return {?}
             */ function () {
                // covers things like null, undefined, false, and empty string
                // while allowing zero to pass
                /** @type {?} */
                var idIsNonZeroFalsy = !this._id && this._id !== 0;
                // in addition to non-zero falsy we also want to make sure _id is not a negative
                // number.
                if (idIsNonZeroFalsy || this._id < 0) {
                    // guard here in the event that input becomes undefined or null by accident
                    this._id = (wizardPageIndex++).toString();
                }
                return "clr-wizard-page-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "readyToComplete", {
            /**
             * A read-only getter that serves as a convenience for those who would rather
             * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
             * ClrWizardPage.readyToComplete is more logical and declarative.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that serves as a convenience for those who would rather
             * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
             * ClrWizardPage.readyToComplete is more logical and declarative.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return !this.nextStepDisabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "completed", {
            /**
             * A page is marked as completed if it is both readyToComplete and completed,
             * as in the next or finish action has been executed while this page was current.
             *
             * Note there is and open question about how to handle pages that are marked
             * complete but who are no longer readyToComplete. This might indicate an error
             * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
             * and only returns that the page is incomplete.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A page is marked as completed if it is both readyToComplete and completed,
             * as in the next or finish action has been executed while this page was current.
             *
             * Note there is and open question about how to handle pages that are marked
             * complete but who are no longer readyToComplete. This might indicate an error
             * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
             * and only returns that the page is incomplete.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._complete && this.readyToComplete;
                // FOR V2: UNWIND COMPLETED, READYTOCOMPLETE, AND ERRORS
                // SUCH THAT ERRORS IS ITS OWN INPUT. IF A STEP IS
                // INCOMPLETE AND ERRORED, ERRORED WILL NOT SHOW.
                // FIRST QUESTION: AM I GREY OR COLORED?
                // SECOND QUESTION: AM I GREEN OR RED?
            },
            /**
             * A ClrWizardPage can be manually set to completed using this boolean setter.
             * It is recommended that users rely on the convenience functions in the wizard
             * and navigation service instead of manually setting pages’ completion state.
             *
             * @memberof ClrWizardPage
             */
            set: /**
             * A ClrWizardPage can be manually set to completed using this boolean setter.
             * It is recommended that users rely on the convenience functions in the wizard
             * and navigation service instead of manually setting pages’ completion state.
             *
             * \@memberof ClrWizardPage
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._complete = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "current", {
            /**
             * Checks with the navigation service to see if it is the current page.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * Checks with the navigation service to see if it is the current page.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.navService.currentPage === this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return !this.enabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "enabled", {
            /**
             * A read-only getter that returns whether or not the page is navigable
             * in the wizard. A wizard page can be navigated to if it is completed
             * or the page before it is completed.
             *
             * This getter handles the logic for enabling or disabling the links in
             * the step nav on the left Side of the wizard.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns whether or not the page is navigable
             * in the wizard. A wizard page can be navigated to if it is completed
             * or the page before it is completed.
             *
             * This getter handles the logic for enabling or disabling the links in
             * the step nav on the left Side of the wizard.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.current || this.completed || this.previousCompleted;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "previousCompleted", {
            /**
             * A read-only getter that returns whether or not the page before this
             * ClrWizardPage is completed. This is useful for determining whether or not
             * a page is navigable if it is not current or already completed.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns whether or not the page before this
             * ClrWizardPage is completed. This is useful for determining whether or not
             * a page is navigable if it is not current or already completed.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                /** @type {?} */
                var previousPage = this.pageCollection.getPreviousPage(this);
                if (!previousPage) {
                    return true;
                }
                return previousPage.completed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "title", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.pageTitle.pageTitleTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "navTitle", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                if (this.pageNavTitle) {
                    return this.pageNavTitle.pageNavTitleTemplateRef;
                }
                return this.pageTitle.pageTitleTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "headerActions", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                if (!this._headerActions) {
                    return;
                }
                return this._headerActions.pageHeaderActionsTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "hasHeaderActions", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return !!this._headerActions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "buttons", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                if (!this._buttons) {
                    return;
                }
                return this._buttons.pageButtonsTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "hasButtons", {
            /**
             * A read-only getter that returns a boolean that says whether or
             * not the ClrWizardPage includes buttons. Used to determine if the
             * Wizard should override the default button set defined as
             * its direct children.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns a boolean that says whether or
             * not the ClrWizardPage includes buttons. Used to determine if the
             * Wizard should override the default button set defined as
             * its direct children.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return !!this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Uses the nav service to make the ClrWizardPage the current page in the
         * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output.
         *
         * In most cases, it is better to use the default navigation functions
         * in Wizard.
         *
         * @memberof WizardPage
         *
         */
        /**
         * Uses the nav service to make the ClrWizardPage the current page in the
         * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output.
         *
         * In most cases, it is better to use the default navigation functions
         * in Wizard.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        ClrWizardPage.prototype.makeCurrent = /**
         * Uses the nav service to make the ClrWizardPage the current page in the
         * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output.
         *
         * In most cases, it is better to use the default navigation functions
         * in Wizard.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
            function () {
                this.navService.currentPage = this;
            };
        /**
         * Links the nav service and establishes the current page if one is not defined.
         *
         * @memberof WizardPage
         *
         */
        /**
         * Links the nav service and establishes the current page if one is not defined.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        ClrWizardPage.prototype.ngOnInit = /**
         * Links the nav service and establishes the current page if one is not defined.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var navService = this.navService;
                if (!navService.currentPage && !navService.navServiceLoaded) {
                    this.makeCurrent();
                    this.navService.navServiceLoaded = true;
                }
            };
        Object.defineProperty(ClrWizardPage.prototype, "stepItemId", {
            /**
             * A read-only getter that returns the id used by the step nav item associated with the page.
             *
             * ClrWizardPage needs this ID string for aria information.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns the id used by the step nav item associated with the page.
             *
             * ClrWizardPage needs this ID string for aria information.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.pageCollection.getStepItemIdForPage(this);
            },
            enumerable: true,
            configurable: true
        });
        ClrWizardPage.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-page',
                        template: '<ng-content></ng-content>',
                        host: {
                            '[id]': 'id',
                            '[attr.aria-hidden]': '!current',
                            '[attr.aria-labelledby]': 'stepItemId',
                            '[class.active]': 'current',
                            '[class.clr-wizard-page]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrWizardPage.ctorParameters = function () {
            return [
                { type: WizardNavigationService },
                { type: PageCollectionService },
                { type: ButtonHubService }
            ];
        };
        ClrWizardPage.propDecorators = {
            pageTitle: [{ type: i0.ContentChild, args: [ClrWizardPageTitle,] }],
            pageNavTitle: [{ type: i0.ContentChild, args: [ClrWizardPageNavTitle,] }],
            _buttons: [{ type: i0.ContentChild, args: [ClrWizardPageButtons,] }],
            _headerActions: [{ type: i0.ContentChild, args: [ClrWizardPageHeaderActions,] }],
            nextStepDisabled: [{ type: i0.Input, args: ['clrWizardPageNextDisabled',] }],
            nextStepDisabledChange: [{ type: i0.Output, args: ['clrWizardPageNextDisabledChange',] }],
            previousStepDisabled: [{ type: i0.Input, args: ['clrWizardPagePreviousDisabled',] }],
            previousStepDisabledChange: [{ type: i0.Output, args: ['clrWizardPagePreviousDisabledChange',] }],
            preventDefault: [{ type: i0.Input, args: ['clrWizardPagePreventDefault',] }],
            stopCancel: [{ type: i0.Input, args: ['clrWizardPagePreventDefaultCancel',] }],
            stopCancelChange: [{ type: i0.Output, args: ['clrWizardPagePreventDefaultCancelChange',] }],
            stopNext: [{ type: i0.Input, args: ['clrWizardPagePreventDefaultNext',] }],
            onCommit: [{ type: i0.Output, args: ['clrWizardPageOnCommit',] }],
            onLoad: [{ type: i0.Output, args: ['clrWizardPageOnLoad',] }],
            pageOnCancel: [{ type: i0.Output, args: ['clrWizardPageOnCancel',] }],
            finishButtonClicked: [{ type: i0.Output, args: ['clrWizardPageFinish',] }],
            previousButtonClicked: [{ type: i0.Output, args: ['clrWizardPagePrevious',] }],
            nextButtonClicked: [{ type: i0.Output, args: ['clrWizardPageNext',] }],
            dangerButtonClicked: [{ type: i0.Output, args: ['clrWizardPageDanger',] }],
            primaryButtonClicked: [{ type: i0.Output, args: ['clrWizardPagePrimary',] }],
            customButtonClicked: [{ type: i0.Output, args: ['clrWizardPageCustomButton',] }],
            _id: [{ type: i0.Input, args: ['id',] }]
        };
        return ClrWizardPage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizard = /** @class */ (function () {
        function ClrWizard(platformId, navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
            this.platformId = platformId;
            this.navService = navService;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            this.headerActionService = headerActionService;
            this.elementRef = elementRef;
            /**
             * Set the modal size of the wizard. Set using `[clrWizardSize]` input.
             */
            this.size = 'xl';
            /**
             * Tells the modal part of the wizard whether it should have a close "X"
             * in the top right corner. Set using `[clrWizardClosable]` input.
             */
            this.closable = true;
            this._forceForward = false;
            this._open = false;
            this._stopNext = false;
            this._stopCancel = false;
            this._stopNavigation = false;
            this._disableStepnav = false;
            /**
             * Used to communicate to the underlying modal that animations are not
             * wanted. Primary use is for the display of static/inline wizards.
             * Set using `[clrWizardPreventModalAnimation]` input.
             */
            this._stopModalAnimations = false;
            /**
             * Emits when the wizard is opened or closed.
             * Listen via `(clrWizardOpenChange)` event.
             */
            this._openChanged = new i0.EventEmitter(false);
            /**
             * Emits when the wizard is canceled. Listen via `(clrWizardOnCancel)` event.
             * Can be combined with the `[clrWizardPreventDefaultCancel]` input to create
             * wizard-level custom cancel routines.
             */
            this.onCancel = new i0.EventEmitter(false);
            /**
             * Emits when the wizard is completed. Listen via `(clrWizardOnFinish)` event.
             * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
             * wizard-level custom completion routines.
             */
            this.wizardFinished = new i0.EventEmitter(false);
            /**
             * Emits when the wizard is reset. Listen via `(clrWizardOnReset)` event.
             */
            this.onReset = new i0.EventEmitter(false);
            /**
             * Emits when the current page has changed. Listen via `(clrWizardCurrentPageChanged)` event.
             * output. Useful for non-blocking validation.
             */
            this.currentPageChanged = new i0.EventEmitter(false);
            /**
             * Emits when the wizard moves to the next page. Listen via `(clrWizardOnNext)` event.
             * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
             * wizard-level custom navigation routines, which are useful for validation.
             */
            this.onMoveNext = new i0.EventEmitter(false);
            /**
             * Emits when the wizard moves to the previous page. Can be useful for validation.
             * Listen via `(clrWizardOnPrevious)` event.
             */
            this.onMovePrevious = new i0.EventEmitter(false);
            // for marking when the collection of wizard pages has been added to or deleted from
            this.subscriptions = [];
            this.subscriptions.push(this.listenForNextPageChanges(), this.listenForPreviousPageChanges(), this.listenForCancelChanges(), this.listenForFinishedChanges(), this.listenForPageChanges());
            this.differ = differs.find([]).create(null);
        }
        Object.defineProperty(ClrWizard.prototype, "forceForward", {
            get: /**
             * @return {?}
             */ function () {
                return this._forceForward;
            },
            /**
             * Resets page completed states when navigating backwards.
             * Set using `[clrWizardForceForwardNavigation]` input.
             */
            set: /**
             * Resets page completed states when navigating backwards.
             * Set using `[clrWizardForceForwardNavigation]` input.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._forceForward = !!value;
                this.navService.forceForwardNavigation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "clrWizardOpen", {
            /**
             * Toggles open/close of the wizard component.
             * Set using the `[clrWizardOpen]` input.
             */
            set: /**
             * Toggles open/close of the wizard component.
             * Set using the `[clrWizardOpen]` input.
             * @param {?} open
             * @return {?}
             */ function (open) {
                if (open) {
                    this.buttonService.buttonsReady = true;
                }
                this._open = open;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopNext", {
            get: /**
             * @return {?}
             */ function () {
                return this._stopNext;
            },
            /**
             * Prevents ClrWizard from moving to the next page or closing itself on finishing.
             * Set using the `[clrWizardPreventDefaultNext]` input. Note that using stopNext
             * will require you to create your own calls to .next() and .finish() in your
             * host component to make the ClrWizard work as expected.
             */
            set: /**
             * Prevents ClrWizard from moving to the next page or closing itself on finishing.
             * Set using the `[clrWizardPreventDefaultNext]` input. Note that using stopNext
             * will require you to create your own calls to .next() and .finish() in your
             * host component to make the ClrWizard work as expected.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._stopNext = !!value;
                this.navService.wizardHasAltNext = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopCancel", {
            get: /**
             * @return {?}
             */ function () {
                return this._stopCancel;
            },
            /**
             * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
             * Set using the `[clrWizardPreventDefaultCancel]` input.
             *
             * Note that using stopCancel will require you to create your own calls to `close()` in your host compone`nt
             * to make the ClrWizard work as expected. Useful for doing checks or prompts
             * before closing a ClrWizard.
             */
            set: /**
             * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
             * Set using the `[clrWizardPreventDefaultCancel]` input.
             *
             * Note that using stopCancel will require you to create your own calls to `close()` in your host compone`nt
             * to make the ClrWizard work as expected. Useful for doing checks or prompts
             * before closing a ClrWizard.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._stopCancel = !!value;
                this.navService.wizardHasAltCancel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopNavigation", {
            get: /**
             * @return {?}
             */ function () {
                return this._stopNavigation;
            },
            /**
             * Prevents ClrWizard from performing any form of navigation away from the current
             * page. Set using the `[clrWizardPreventNavigation]` input.
             * Note that stopNavigation is meant to freeze the wizard in place, typically
             * during a long validation or background action where you want the wizard to
             * display loading content but not allow the user to execute navigation in
             * the stepnav, close X, or the  back, finish, or next buttons.
             */
            set: /**
             * Prevents ClrWizard from performing any form of navigation away from the current
             * page. Set using the `[clrWizardPreventNavigation]` input.
             * Note that stopNavigation is meant to freeze the wizard in place, typically
             * during a long validation or background action where you want the wizard to
             * display loading content but not allow the user to execute navigation in
             * the stepnav, close X, or the  back, finish, or next buttons.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._stopNavigation = !!value;
                this.navService.wizardStopNavigation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "disableStepnav", {
            get: /**
             * @return {?}
             */ function () {
                return this._disableStepnav;
            },
            /**
             * Prevents clicks on the links in the stepnav from working.
             * Set using `[clrWizardDisableStepnav]` input.
             * A more granular bypassing of navigation which can be useful when your
             * ClrWizard is in a state of completion and you don't want users to be
             * able to jump backwards and change things.
             */
            set: /**
             * Prevents clicks on the links in the stepnav from working.
             * Set using `[clrWizardDisableStepnav]` input.
             * A more granular bypassing of navigation which can be useful when your
             * ClrWizard is in a state of completion and you don't want users to be
             * able to jump backwards and change things.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disableStepnav = !!value;
                this.navService.wizardDisableStepnav = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopModalAnimations", {
            get: /**
             * @return {?}
             */ function () {
                return this._stopModalAnimations ? 'true' : 'false';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "currentPage", {
            get: /**
             * @return {?}
             */ function () {
                return this.navService.currentPage;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                this.navService.goTo(page, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isLast", {
            get: /**
             * @return {?}
             */ function () {
                return this.navService.currentPageIsLast;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isFirst", {
            get: /**
             * @return {?}
             */ function () {
                return this.navService.currentPageIsFirst;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isStatic", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.elementRef.nativeElement))).classList.contains('clr-wizard--inline');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizard.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.pageCollection.pages = this.pages;
                this.headerActionService.wizardHeaderActions = this.headerActions;
                this.initializeButtons();
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                this.updateNavOnPageChanges();
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Marks Wizard as finished. By default it does not execute event
         * emissions or checks before completing and closing. This method is commonly
         * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
         *
         * If `skipChecksAndEmits` is true, the wizard will complete and close
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         */
        /**
         * Marks Wizard as finished. By default it does not execute event
         * emissions or checks before completing and closing. This method is commonly
         * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
         *
         * If `skipChecksAndEmits` is true, the wizard will complete and close
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
        ClrWizard.prototype.finish = /**
         * Marks Wizard as finished. By default it does not execute event
         * emissions or checks before completing and closing. This method is commonly
         * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
         *
         * If `skipChecksAndEmits` is true, the wizard will complete and close
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
            function (skipChecksAndEmits) {
                if (skipChecksAndEmits === void 0) {
                    skipChecksAndEmits = true;
                }
                if (skipChecksAndEmits) {
                    this.forceFinish();
                }
                else {
                    this.navService.finish();
                }
            };
        /**
         * Marks the wizard as finished but does run checks and emissions.
         * Good for a last step in an alternate workflow. Does the same thing as
         * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
         */
        /**
         * Marks the wizard as finished but does run checks and emissions.
         * Good for a last step in an alternate workflow. Does the same thing as
         * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
         * @return {?}
         */
        ClrWizard.prototype.forceFinish = /**
         * Marks the wizard as finished but does run checks and emissions.
         * Good for a last step in an alternate workflow. Does the same thing as
         * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
         * @return {?}
         */
            function () {
                if (this.stopNavigation) {
                    return;
                }
                this.close();
            };
        /**
         * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
         */
        /**
         * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
         * @return {?}
         */
        ClrWizard.prototype.open = /**
         * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
         * @return {?}
         */
            function () {
                this._open = true;
                if (!this.currentPage) {
                    this.navService.setFirstPageCurrent();
                }
                // Only render buttons when wizard is opened, to avoid chocolate errors
                this.buttonService.buttonsReady = true;
                this._openChanged.emit(true);
            };
        /**
         * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
         */
        /**
         * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
         * @return {?}
         */
        ClrWizard.prototype.close = /**
         * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
         * @return {?}
         */
            function () {
                if (this.stopNavigation) {
                    return;
                }
                this._open = false;
                this._openChanged.emit(false);
            };
        /**
         * Used to open and close the wizard. By default the wizard will
         * close if invoked with no parameter. If parameter is true wizard will open
         * else if false will close.
         */
        /**
         * Used to open and close the wizard. By default the wizard will
         * close if invoked with no parameter. If parameter is true wizard will open
         * else if false will close.
         * @param {?} open
         * @return {?}
         */
        ClrWizard.prototype.toggle = /**
         * Used to open and close the wizard. By default the wizard will
         * close if invoked with no parameter. If parameter is true wizard will open
         * else if false will close.
         * @param {?} open
         * @return {?}
         */
            function (open) {
                if (open) {
                    this.open();
                }
                else {
                    this.close();
                }
            };
        /**
         * Moves the wizard to the previous page.
         */
        /**
         * Moves the wizard to the previous page.
         * @return {?}
         */
        ClrWizard.prototype.previous = /**
         * Moves the wizard to the previous page.
         * @return {?}
         */
            function () {
                this.navService.previous();
            };
        /**
         * By default, `next()` does not execute event emissions.
         * This method is commonly called as part of an alternative navigation
         * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         *
         * If `skipChecksAndEmits` is false, the wizard will execute default checks
         * and emit events as normal. This is useful for custom buttons or programmatic
         * workflows that are not executing the wizards default checks and emissions.
         * It is another way to navigate without having to rewrite the wizard’s default
         * functionality from scratch.
         */
        /**
         * By default, `next()` does not execute event emissions.
         * This method is commonly called as part of an alternative navigation
         * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         *
         * If `skipChecksAndEmits` is false, the wizard will execute default checks
         * and emit events as normal. This is useful for custom buttons or programmatic
         * workflows that are not executing the wizards default checks and emissions.
         * It is another way to navigate without having to rewrite the wizard’s default
         * functionality from scratch.
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
        ClrWizard.prototype.next = /**
         * By default, `next()` does not execute event emissions.
         * This method is commonly called as part of an alternative navigation
         * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         *
         * If `skipChecksAndEmits` is false, the wizard will execute default checks
         * and emit events as normal. This is useful for custom buttons or programmatic
         * workflows that are not executing the wizards default checks and emissions.
         * It is another way to navigate without having to rewrite the wizard’s default
         * functionality from scratch.
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
            function (skipChecksAndEmits) {
                if (skipChecksAndEmits === void 0) {
                    skipChecksAndEmits = true;
                }
                if (skipChecksAndEmits) {
                    this.forceNext();
                }
                else {
                    this.navService.next();
                }
            };
        /**
         * Moves the wizard to the next page without the checks and emissions.
         * Good for a last step in an alternate workflow.
         * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
         */
        /**
         * Moves the wizard to the next page without the checks and emissions.
         * Good for a last step in an alternate workflow.
         * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
         * @return {?}
         */
        ClrWizard.prototype.forceNext = /**
         * Moves the wizard to the next page without the checks and emissions.
         * Good for a last step in an alternate workflow.
         * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
         * @return {?}
         */
            function () {
                this.navService.forceNext();
            };
        /**
         * Cancels and closes the wizard. Do not use this for an override of the cancel
         * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
         * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
         * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
         */
        /**
         * Cancels and closes the wizard. Do not use this for an override of the cancel
         * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
         * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
         * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
         * @return {?}
         */
        ClrWizard.prototype.cancel = /**
         * Cancels and closes the wizard. Do not use this for an override of the cancel
         * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
         * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
         * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
         * @return {?}
         */
            function () {
                this.navService.cancel();
            };
        /**
         * Overrides behavior of the underlying modal to avoid collisions with
         * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
         */
        /**
         * Overrides behavior of the underlying modal to avoid collisions with
         * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
         * @return {?}
         */
        ClrWizard.prototype.modalCancel = /**
         * Overrides behavior of the underlying modal to avoid collisions with
         * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
         * @return {?}
         */
            function () {
                if (this.closable) {
                    this.checkAndCancel();
                }
            };
        /**
         * Checks for alternative cancel flows defined at the current page or
         * wizard level. Performs a canceled if not. Emits events that initiate
         * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
         */
        /**
         * Checks for alternative cancel flows defined at the current page or
         * wizard level. Performs a canceled if not. Emits events that initiate
         * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
         * @return {?}
         */
        ClrWizard.prototype.checkAndCancel = /**
         * Checks for alternative cancel flows defined at the current page or
         * wizard level. Performs a canceled if not. Emits events that initiate
         * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var currentPage = this.currentPage;
                /** @type {?} */
                var currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
                if (this.stopNavigation) {
                    return;
                }
                currentPage.pageOnCancel.emit();
                if (!currentPageHasOverrides) {
                    this.onCancel.emit();
                }
                if (!this.stopCancel && !currentPageHasOverrides) {
                    this.close();
                }
            };
        /**
         * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
         * checks and event emissions.
         *
         * The format of the expected ID parameter can be found in the return of the
         * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
         * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
         */
        /**
         * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
         * checks and event emissions.
         *
         * The format of the expected ID parameter can be found in the return of the
         * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
         * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
         * @param {?} pageId
         * @return {?}
         */
        ClrWizard.prototype.goTo = /**
         * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
         * checks and event emissions.
         *
         * The format of the expected ID parameter can be found in the return of the
         * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
         * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
         * @param {?} pageId
         * @return {?}
         */
            function (pageId) {
                if (!pageId) {
                    return;
                }
                this.navService.goTo(pageId);
            };
        /**
         * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
         * be the current page, resetting the wizard navigation.
         * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
         */
        /**
         * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
         * be the current page, resetting the wizard navigation.
         * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
         * @return {?}
         */
        ClrWizard.prototype.reset = /**
         * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
         * be the current page, resetting the wizard navigation.
         * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
         * @return {?}
         */
            function () {
                this.pageCollection.reset();
                this.onReset.next();
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.listenForNextPageChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.navService.movedToNextPage.pipe(operators.filter(function () { return common.isPlatformBrowser(_this.platformId); })).subscribe(function () {
                    _this.onMoveNext.emit();
                    _this.wizardTitle.nativeElement.focus();
                });
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.listenForPreviousPageChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.navService.movedToPreviousPage.pipe(operators.filter(function () { return common.isPlatformBrowser(_this.platformId); })).subscribe(function () {
                    _this.onMovePrevious.emit();
                    _this.wizardTitle.nativeElement.focus();
                });
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.listenForCancelChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.navService.notifyWizardCancel.subscribe(function () { return _this.checkAndCancel(); });
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.listenForFinishedChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.navService.wizardFinished.subscribe(function () { return _this.emitWizardFinished(); });
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.listenForPageChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.navService.currentPageChanged.subscribe(function () { return _this.currentPageChanged.emit(); });
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.updateNavOnPageChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var changes = this.differ.diff(this.pages);
                if (changes) {
                    changes.forEachAddedItem(function () { return _this.navService.updateNavigation(); });
                    changes.forEachRemovedItem(function () { return _this.navService.updateNavigation(); });
                }
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.initializeButtons = /**
         * @return {?}
         */
            function () {
                // Only trigger buttons ready if default is open (inlined)
                if (this._open) {
                    this.buttonService.buttonsReady = true;
                }
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.emitWizardFinished = /**
         * @return {?}
         */
            function () {
                if (!this.stopNext) {
                    this.forceFinish();
                }
                this.wizardFinished.emit();
            };
        ClrWizard.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard',
                        providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-modal\n    [clrModalOpen]=\"_open\"\n    [clrModalSize]=\"size\"\n    [clrModalClosable]=\"closable\"\n    [clrModalStaticBackdrop]=\"true\"\n    [clrModalSkipAnimation]=\"stopModalAnimations\"\n    [clrModalOverrideScrollService]=\"isStatic\"\n    [clrModalPreventClose]=\"true\"\n    (clrModalAlternateClose)=\"modalCancel()\">\n\n    <nav class=\"modal-nav clr-wizard-stepnav-wrapper\">\n        <h3 class=\"clr-wizard-title\"><ng-content select=\"clr-wizard-title\"></ng-content></h3>\n        <clr-wizard-stepnav></clr-wizard-stepnav>\n    </nav>\n\n    <h3 class=\"modal-title\">\n        <span tabindex=\"0\" #wizardTitle class=\"modal-title-text\">\n            <ng-template [ngTemplateOutlet]=\"navService.currentPageTitle\"></ng-template>\n        </span>\n\n        <div class=\"modal-header-actions-wrapper\" *ngIf=\"headerActionService.displayHeaderActionsWrapper\">\n            <div *ngIf=\"headerActionService.showWizardHeaderActions\">\n                <ng-content select=\"clr-wizard-header-action\"></ng-content>\n            </div>\n            <div *ngIf=\"headerActionService.currentPageHasHeaderActions\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.headerActions\"></ng-template>\n            </div>\n        </div>\n    </h3>\n\n    <div class=\"modal-body\">\n        <main clr-wizard-pages-wrapper class=\"clr-wizard-content\">\n            <ng-content></ng-content>\n        </main>\n    </div>\n    <div class=\"modal-footer clr-wizard-footer\">\n        <div class=\"clr-wizard-footer-buttons\">\n            <div *ngIf=\"navService.currentPage && !navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-content select=\"clr-wizard-button\"></ng-content>\n            </div>\n            <div *ngIf=\"navService.currentPage && navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.buttons\"></ng-template>\n            </div>\n        </div>\n    </div>\n</clr-modal>\n",
                        host: {
                            '[class.clr-wizard]': 'true',
                            '[class.wizard-md]': "size == 'md'",
                            '[class.wizard-lg]': "size == 'lg'",
                            '[class.wizard-xl]': "size == 'xl'",
                            '[class.lastPage]': 'navService.currentPageIsLast',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrWizard.ctorParameters = function () {
            return [
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: WizardNavigationService },
                { type: PageCollectionService },
                { type: ButtonHubService },
                { type: HeaderActionService },
                { type: i0.ElementRef },
                { type: i0.IterableDiffers }
            ];
        };
        ClrWizard.propDecorators = {
            size: [{ type: i0.Input, args: ['clrWizardSize',] }],
            closable: [{ type: i0.Input, args: ['clrWizardClosable',] }],
            forceForward: [{ type: i0.Input, args: ['clrWizardForceForwardNavigation',] }],
            clrWizardOpen: [{ type: i0.Input, args: ['clrWizardOpen',] }],
            stopNext: [{ type: i0.Input, args: ['clrWizardPreventDefaultNext',] }],
            stopCancel: [{ type: i0.Input, args: ['clrWizardPreventDefaultCancel',] }],
            stopNavigation: [{ type: i0.Input, args: ['clrWizardPreventNavigation',] }],
            disableStepnav: [{ type: i0.Input, args: ['clrWizardDisableStepnav',] }],
            _stopModalAnimations: [{ type: i0.Input, args: ['clrWizardPreventModalAnimation',] }],
            _openChanged: [{ type: i0.Output, args: ['clrWizardOpenChange',] }],
            onCancel: [{ type: i0.Output, args: ['clrWizardOnCancel',] }],
            wizardFinished: [{ type: i0.Output, args: ['clrWizardOnFinish',] }],
            onReset: [{ type: i0.Output, args: ['clrWizardOnReset',] }],
            currentPageChanged: [{ type: i0.Output, args: ['clrWizardCurrentPageChanged',] }],
            onMoveNext: [{ type: i0.Output, args: ['clrWizardOnNext',] }],
            onMovePrevious: [{ type: i0.Output, args: ['clrWizardOnPrevious',] }],
            pages: [{ type: i0.ContentChildren, args: [ClrWizardPage,] }],
            headerActions: [{ type: i0.ContentChildren, args: [ClrWizardHeaderAction,] }],
            wizardTitle: [{ type: i0.ViewChild, args: ['wizardTitle',] }]
        };
        return ClrWizard;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_BUTTON_TYPES = {
        cancel: 'cancel',
        previous: 'previous',
        next: 'next',
        finish: 'finish',
        danger: 'danger',
    };
    /** @type {?} */
    var CUSTOM_BUTTON_TYPES = {
        cancel: 'custom-cancel',
        previous: 'custom-previous',
        next: 'custom-next',
        finish: 'custom-finish',
        danger: 'custom-danger',
    };
    var ClrWizardButton = /** @class */ (function () {
        function ClrWizardButton(navService, buttonService) {
            this.navService = navService;
            this.buttonService = buttonService;
            this.type = '';
            this.disabled = false;
            this.hidden = false;
            // EventEmitter which is emitted when a button is clicked.
            this.wasClicked = new i0.EventEmitter(false);
        }
        /**
         * @param {?=} valueToCheck
         * @param {?=} typeToLookUp
         * @return {?}
         */
        ClrWizardButton.prototype.checkDefaultAndCustomType = /**
         * @param {?=} valueToCheck
         * @param {?=} typeToLookUp
         * @return {?}
         */
            function (valueToCheck, typeToLookUp) {
                if (valueToCheck === void 0) {
                    valueToCheck = '';
                }
                if (DEFAULT_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
                    return true;
                }
                if (CUSTOM_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
                    return true;
                }
                return false;
            };
        Object.defineProperty(ClrWizardButton.prototype, "isCancel", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'cancel');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isNext", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'next');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isPrevious", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'previous');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isFinish", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'finish');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isDanger", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'danger');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isPrimaryAction", {
            get: /**
             * @return {?}
             */ function () {
                return this.isNext || this.isDanger || this.isFinish;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "_disabledAttribute", {
            get: /**
             * @return {?}
             */ function () {
                if (this.isDisabled) {
                    return '';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isDisabled", {
            get: /**
             * @return {?}
             */ function () {
                // dealing with negatives here. cognitively easier to think of it like this...
                /** @type {?} */
                var disabled = true;
                /** @type {?} */
                var nav = this.navService;
                /** @type {?} */
                var page = this.navService.currentPage;
                // Ensure we don't change the response until buttons are ready to avoid chocolate
                if (!this.buttonService.buttonsReady) {
                    return !disabled;
                }
                if (this.disabled || nav.wizardStopNavigation || !page) {
                    return true;
                }
                if (this.isCancel) {
                    return !disabled;
                }
                if (this.isPrevious && (nav.currentPageIsFirst || page.previousStepDisabled)) {
                    return disabled;
                }
                if (this.isDanger && !page.readyToComplete) {
                    return disabled;
                }
                if (this.isNext && (nav.currentPageIsLast || !page.readyToComplete)) {
                    return disabled;
                }
                if (this.isFinish && (!nav.currentPageIsLast || !page.readyToComplete)) {
                    return disabled;
                }
                return !disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isHidden", {
            get: /**
             * @return {?}
             */ function () {
                // dealing with negatives here. cognitively easier to think of it like this...
                /** @type {?} */
                var hidden = true;
                /** @type {?} */
                var nav = this.navService;
                // Ensure we don't change the response until buttons are ready to avoid chocolate
                if (!this.buttonService.buttonsReady) {
                    return !hidden;
                }
                if (this.hidden) {
                    return true;
                }
                if (this.isCancel) {
                    return !hidden;
                }
                if (this.isPrevious && nav.currentPageIsFirst) {
                    return hidden;
                }
                if (this.isNext && nav.currentPageIsLast) {
                    return hidden;
                }
                if (this.isFinish && !nav.currentPageIsLast) {
                    return hidden;
                }
                return !hidden;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizardButton.prototype.click = /**
         * @return {?}
         */
            function () {
                if (this.isDisabled) {
                    return;
                }
                this.wasClicked.emit(this.type);
                this.buttonService.buttonClicked(this.type);
            };
        ClrWizardButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-button',
                        template: "\n        <button\n            type=\"button\"\n            class=\"btn clr-wizard-btn\"\n            [class.btn-link]=\"isCancel\"\n            [class.clr-wizard-btn--tertiary]=\"isCancel\"\n            [class.btn-outline]=\"isPrevious\"\n            [class.clr-wizard-btn--secondary]=\"isPrevious\"\n            [class.btn-primary]=\"isPrimaryAction\"\n            [class.clr-wizard-btn--primary]=\"isPrimaryAction\"\n            [class.btn-success]=\"isFinish\"\n            [class.btn-danger]=\"isDanger\"\n            [class.disabled]=\"isDisabled\"\n            [attr.disabled]=\"_disabledAttribute\"\n            (click)=\"click()\">\n            <ng-content></ng-content>\n        </button>\n    ",
                        host: { class: 'clr-wizard-btn-wrapper', '[attr.aria-hidden]': 'isHidden' },
                        styles: ['[aria-hidden="true"] { display: none; }']
                    }] }
        ];
        /** @nocollapse */
        ClrWizardButton.ctorParameters = function () {
            return [
                { type: WizardNavigationService },
                { type: ButtonHubService }
            ];
        };
        ClrWizardButton.propDecorators = {
            type: [{ type: i0.Input, args: ['type',] }],
            disabled: [{ type: i0.Input, args: ['clrWizardButtonDisabled',] }],
            hidden: [{ type: i0.Input, args: ['clrWizardButtonHidden',] }],
            wasClicked: [{ type: i0.Output, args: ['clrWizardButtonClicked',] }]
        };
        return ClrWizardButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardCustomTags = /** @class */ (function () {
        function ClrWizardCustomTags() {
        }
        ClrWizardCustomTags.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-wizard-title, clr-wizard-pagetitle' },] }
        ];
        return ClrWizardCustomTags;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardStepnav = /** @class */ (function () {
        function ClrWizardStepnav(pageService) {
            this.pageService = pageService;
        }
        ClrWizardStepnav.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-stepnav',
                        template: "\n    <div class=\"clr-wizard-stepnav-list\">\n      <div *ngFor=\"let page of pageService.pages\" clr-wizard-stepnav-item [page]=\"page\" class=\"clr-wizard-stepnav-item\"></div>\n    </div>\n  ",
                        host: { class: 'clr-wizard-stepnav' }
                    }] }
        ];
        /** @nocollapse */
        ClrWizardStepnav.ctorParameters = function () {
            return [
                { type: PageCollectionService }
            ];
        };
        return ClrWizardStepnav;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardStepnavItem = /** @class */ (function () {
        function ClrWizardStepnavItem(navService, pageCollection) {
            this.navService = navService;
            this.pageCollection = pageCollection;
        }
        /**
         * @return {?}
         */
        ClrWizardStepnavItem.prototype.pageGuard = /**
         * @return {?}
         */
            function () {
                if (!this.page) {
                    throw new Error('Wizard stepnav item is not associated with a wizard page.');
                }
            };
        Object.defineProperty(ClrWizardStepnavItem.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.pageCollection.getStepItemIdForPage(this.page);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isDisabled", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.page.disabled || this.navService.wizardStopNavigation || this.navService.wizardDisableStepnav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isCurrent", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.page.current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isComplete", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.page.completed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "canNavigate", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.pageCollection.previousPageIsCompleted(this.page);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizardStepnavItem.prototype.click = /**
         * @return {?}
         */
            function () {
                this.pageGuard();
                // if we click on our own stepnav or a disabled stepnav, we don't want to do anything
                if (this.isDisabled || this.isCurrent) {
                    return;
                }
                this.navService.goTo(this.page);
            };
        ClrWizardStepnavItem.decorators = [
            { type: i0.Component, args: [{
                        selector: '[clr-wizard-stepnav-item]',
                        template: "\n        <button type=\"button\" class=\"btn btn-link clr-wizard-stepnav-link\" (click)=\"click()\" [attr.disabled]=\"isDisabled ? '' : null\">\n            <ng-template [ngTemplateOutlet]=\"page.navTitle\"></ng-template>\n        </button>\n    ",
                        host: {
                            '[id]': 'id',
                            '[attr.aria-selected]': 'isCurrent',
                            '[attr.aria-controls]': 'id',
                            '[class.clr-nav-link]': 'true',
                            '[class.nav-item]': 'true',
                            '[class.active]': 'isCurrent',
                            '[class.disabled]': 'isDisabled',
                            '[class.no-click]': '!canNavigate',
                            '[class.complete]': 'isComplete',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrWizardStepnavItem.ctorParameters = function () {
            return [
                { type: WizardNavigationService },
                { type: PageCollectionService }
            ];
        };
        ClrWizardStepnavItem.propDecorators = {
            page: [{ type: i0.Input, args: ['page',] }]
        };
        return ClrWizardStepnavItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_WIZARD_DIRECTIVES = [
        ClrWizard,
        ClrWizardPage,
        ClrWizardStepnav,
        ClrWizardStepnavItem,
        ClrWizardButton,
        ClrWizardHeaderAction,
        ClrWizardCustomTags,
        ClrWizardPageTitle,
        ClrWizardPageNavTitle,
        ClrWizardPageButtons,
        ClrWizardPageHeaderActions,
    ];
    var ClrWizardModule = /** @class */ (function () {
        function ClrWizardModule() {
        }
        ClrWizardModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrModalModule, ClrAlertModule],
                        declarations: [CLR_WIZARD_DIRECTIVES],
                        exports: [CLR_WIZARD_DIRECTIVES],
                    },] }
        ];
        return ClrWizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrProgressBar = /** @class */ (function () {
        function ClrProgressBar() {
            this.externalId = '';
            // Progress
            this.max = 100;
            this.value = 0;
        }
        Object.defineProperty(ClrProgressBar.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._ID;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._ID = value;
                this.externalId = null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "progressClass", {
            // Styles
            get: 
            // Styles
            /**
             * @return {?}
             */
            function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "labeledClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._labeled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrLabeled", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._labeled = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "fadeClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._fade;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrFade", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._fade = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "loopClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._loop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrLoop", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._loop = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "successClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._success;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrSuccess", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._success = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "dangerClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._danger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrDanger", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._danger = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "flashClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._flash;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrFlash", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._flash = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "flashDangerClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._flashDanger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrFlashDanger", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._flashDanger = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "displayValue", {
            /**
             * Make sure that we always will have something that is readable
             * for the screen reader
             */
            get: /**
             * Make sure that we always will have something that is readable
             * for the screen reader
             * @return {?}
             */ function () {
                if (this.displayval) {
                    return this.displayval;
                }
                return this.value + "%";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Display aria-live only when there is value and it's not 0 or equal to the max value
         */
        /**
         * Display aria-live only when there is value and it's not 0 or equal to the max value
         * @return {?}
         */
        ClrProgressBar.prototype.displayAriaLive = /**
         * Display aria-live only when there is value and it's not 0 or equal to the max value
         * @return {?}
         */
            function () {
                return (this.value !== undefined || this.value !== 0) && this.value !== this.max;
            };
        Object.defineProperty(ClrProgressBar.prototype, "ariaLive", {
            get: /**
             * @return {?}
             */ function () {
                if (isBooleanAttributeSet(this.assertive)) {
                    return 'assertive';
                }
                if (isBooleanAttributeSet(this.off)) {
                    return 'off';
                }
                return 'polite';
            },
            enumerable: true,
            configurable: true
        });
        ClrProgressBar.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-progress-bar',
                        template: "\n    <progress [id]=\"id\" [attr.max]=\"max\" [attr.value]=\"value\" [attr.data-displayval]=\"displayValue\"></progress>\n    <span *ngIf=\"displayAriaLive()\" [attr.aria-live]=\"ariaLive\">{{ displayValue }}</span>\n  "
                    }] }
        ];
        ClrProgressBar.propDecorators = {
            externalId: [{ type: i0.HostBinding, args: ['attr.id',] }],
            id: [{ type: i0.Input }],
            max: [{ type: i0.Input, args: ['clrMax',] }],
            value: [{ type: i0.Input, args: ['clrValue',] }],
            displayval: [{ type: i0.Input, args: ['clrDisplayval',] }],
            progressClass: [{ type: i0.HostBinding, args: ['class.progress',] }],
            labeledClass: [{ type: i0.HostBinding, args: ['class.labeled',] }],
            clrLabeled: [{ type: i0.Input, args: ['clrLabeled',] }],
            fadeClass: [{ type: i0.HostBinding, args: ['class.progress-fade',] }],
            clrFade: [{ type: i0.Input, args: ['clrFade',] }],
            loopClass: [{ type: i0.HostBinding, args: ['class.loop',] }],
            clrLoop: [{ type: i0.Input, args: ['clrLoop',] }],
            successClass: [{ type: i0.HostBinding, args: ['class.success',] }],
            clrSuccess: [{ type: i0.Input, args: ['clrSuccess',] }],
            dangerClass: [{ type: i0.HostBinding, args: ['class.danger',] }],
            clrDanger: [{ type: i0.Input, args: ['clrDanger',] }],
            flashClass: [{ type: i0.HostBinding, args: ['class.flash',] }],
            clrFlash: [{ type: i0.Input, args: ['clrFlash',] }],
            flashDangerClass: [{ type: i0.HostBinding, args: ['class.flash-danger',] }],
            clrFlashDanger: [{ type: i0.Input, args: ['clrFlashDanger',] }],
            assertive: [{ type: i0.Input, args: ['clrAssertive',] }],
            off: [{ type: i0.Input, args: ['clrOff',] }]
        };
        return ClrProgressBar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_PROGRESS_BAR_DIRECTIVES = [ClrProgressBar];
    var ClrProgressBarModule = /** @class */ (function () {
        function ClrProgressBarModule() {
        }
        ClrProgressBarModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [CLR_PROGRESS_BAR_DIRECTIVES],
                        exports: [CLR_PROGRESS_BAR_DIRECTIVES],
                    },] }
        ];
        return ClrProgressBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClarityModule = /** @class */ (function () {
        function ClarityModule() {
        }
        ClarityModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [
                            ClrEmphasisModule,
                            ClrDataModule,
                            ClrIconModule,
                            ClrModalModule,
                            ClrLoadingModule,
                            ClrIfExpandModule,
                            ClrConditionalModule,
                            ClrFocusTrapModule,
                            ClrButtonModule,
                            ClrFormsModule,
                            ClrLayoutModule,
                            ClrPopoverModule,
                            ClrWizardModule,
                            ClrDragAndDropModule,
                            ClrSpinnerModule,
                            ClrProgressBarModule,
                        ],
                    },] }
        ];
        return ClarityModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Private counter to generate unique IDs for the checkboxes, to bind the labels to them.
     * @type {?}
     */
    var latestId = 0;
    /**
     * @deprecated ClrCheckbox will be renamed to ClrCheckboxDeprecated in 0.12, and will be replaced with a new
     * implementation in 0.13, so if you import it you will need to update your references.
     */
    var ClrCheckboxDeprecated = /** @class */ (function () {
        function ClrCheckboxDeprecated() {
            // If our host has an ID attribute, we use this instead of our index.
            this._id = (latestId++).toString();
            // If host provides an clrAriaLabeledBy input, we apply it to the checkbox
            this.clrAriaLabeledBy = null;
            // If our host has a name attribute, we apply it to the checkbox.
            this.name = null;
            // If the host is disabled we apply it to the checkbox
            this.disabled = false;
            // Support for inline checkboxes, adds the necessary class to the host
            this.inline = false;
            this._checked = false;
            this._indeterminate = false;
            this.indeterminateChange = new i0.EventEmitter(false);
            this.change = new i0.EventEmitter(false);
            /*
                 * These callbacks will be given to us through the ControlValueAccessor interface,
                 * and we need to call them when the user interacts with the checkbox.
                 */
            this.onChangeCallback = function (_) { };
            this.onTouchedCallback = function () { };
        }
        Object.defineProperty(ClrCheckboxDeprecated.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "clr-checkbox-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCheckboxDeprecated.prototype, "checked", {
            get: /**
             * @return {?}
             */ function () {
                return this._checked;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._checked) {
                    if (this._indeterminate) {
                        this.setIndeterminate(false);
                    }
                    this.setChecked(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCheckboxDeprecated.prototype, "indeterminate", {
            get: /**
             * @return {?}
             */ function () {
                return this._indeterminate;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._indeterminate !== value) {
                    if (this._checked) {
                        this.setChecked(false);
                    }
                    this.setIndeterminate(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.setIndeterminate = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._indeterminate = value;
                this.indeterminateChange.emit(this._indeterminate);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.setChecked = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._checked = value;
                this.change.emit(this._checked);
            };
        /**
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value === null) {
                    value = false;
                }
                if (value !== this.checked) {
                    this.checked = value;
                }
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this.onChangeCallback = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this.onTouchedCallback = onTouched;
            };
        /**
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.touch = /**
         * @return {?}
         */
            function () {
                this.onTouchedCallback();
            };
        /**
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.checkIndeterminateState = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.toggle();
                }
            };
        ClrCheckboxDeprecated.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-checkbox',
                        template: "\n        <!--\n            FIXME: We are not subscribed to the change event but the click event here.\n            The reason for that is because checkboxes behave differently on IE & Edge.\n            https://stackoverflow.com/a/19447939\n            \n            To fix that, we listen to every click event and then toggle the checkbox manually\n            to make it behave the same way across the browsers we support.\n            \n            This works for cases when users toggle the checkbox using the keyboard too:\n            https://stackoverflow.com/questions/27878940/spacebar-triggering-click-event-on-checkbox\n        -->\n        <input type=\"checkbox\" [attr.aria-labelledby]=\"clrAriaLabeledBy\"\n               [id]=\"id\" [name]=\"name\" [checked]=\"checked\"\n               [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n               (blur)=\"touch()\" (click)=\"checkIndeterminateState()\">\n        <label [attr.for]=\"id\">\n            <ng-content></ng-content>\n        </label>\n    ",
                        host: { '[class.checkbox]': '!inline', '[class.checkbox-inline]': 'inline', '[class.disabled]': 'disabled' },
                        /*
                             * This provider lets us declare our checkbox as a ControlValueAccessor,
                             * which allows us to use [(ngModel)] directly on our component,
                             * with all the automatic features wiring that come with it.
                             */
                        providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return ClrCheckboxDeprecated; }), multi: true }]
                    }] }
        ];
        ClrCheckboxDeprecated.propDecorators = {
            _id: [{ type: i0.Input, args: ['id',] }],
            clrAriaLabeledBy: [{ type: i0.Input, args: ['clrAriaLabeledBy',] }],
            name: [{ type: i0.Input, args: ['name',] }],
            disabled: [{ type: i0.Input, args: ['clrDisabled',] }],
            inline: [{ type: i0.Input, args: ['clrInline',] }],
            checked: [{ type: i0.Input, args: ['clrChecked',] }],
            indeterminate: [{ type: i0.Input, args: ['clrIndeterminate',] }],
            indeterminateChange: [{ type: i0.Output, args: ['clrIndeterminateChange',] }],
            change: [{ type: i0.Output, args: ['clrCheckedChange',] }]
        };
        return ClrCheckboxDeprecated;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_CHECKBOX_DIRECTIVES = [ClrCheckboxDeprecated];
    var ClrCheckboxDeprecatedModule = /** @class */ (function () {
        function ClrCheckboxDeprecatedModule() {
        }
        ClrCheckboxDeprecatedModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CLR_CHECKBOX_DIRECTIVES], exports: [CLR_CHECKBOX_DIRECTIVES] },] }
        ];
        return ClrCheckboxDeprecatedModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrFormsDeprecatedModule = /** @class */ (function () {
        function ClrFormsDeprecatedModule() {
        }
        ClrFormsDeprecatedModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [ClrCheckboxDeprecatedModule, ClrDatepickerModule],
                    },] }
        ];
        return ClrFormsDeprecatedModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function collapse() {
        return [
            animations.state('true', animations.style({ height: 0, 'overflow-y': 'hidden' })),
            animations.transition('true => false', [animations.animate('0.2s ease-in-out', animations.style({ height: '*', 'overflow-y': 'hidden' }))]),
            animations.transition('false => true', [animations.style({ height: '*', 'overflow-y': 'hidden' }), animations.animate('0.2s ease-in-out')]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?=} opacity
     * @return {?}
     */
    function fade(opacity) {
        if (opacity === void 0) {
            opacity = 1;
        }
        return [
            animations.transition('void => *', [animations.style({ opacity: 0 }), animations.animate('0.2s ease-in-out', animations.style({ opacity: opacity }))]),
            animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0 }))]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} direction
     * @return {?}
     */
    function fadeSlide(direction) {
        /** @type {?} */
        var transform = null;
        if (direction === 'up') {
            transform = 'translate(0, 25%)';
        }
        else if (direction === 'down') {
            transform = 'translate(0, -25%)';
        }
        else if (direction === 'left') {
            transform = 'translate(25%, 0)';
        }
        else if (direction === 'right') {
            transform = 'translate(-25%, 0)';
        }
        else {
            throw new Error('Unknown direction ' + direction + ' for slide animation.');
        }
        return [
            animations.transition('void => *', [animations.style({ opacity: 0, transform: transform }), animations.animate('0.2s ease-in-out')]),
            animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0, transform: transform }))]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} direction
     * @return {?}
     */
    function slide(direction) {
        /** @type {?} */
        var transform = null;
        if (direction === 'up') {
            transform = 'translate(0, 25%)';
        }
        else if (direction === 'down') {
            transform = 'translate(0, -25%)';
        }
        else if (direction === 'left') {
            transform = 'translate(25%, 0)';
        }
        else if (direction === 'right') {
            transform = 'translate(-25%, 0)';
        }
        else {
            throw new Error('Unknown direction ' + direction + ' for slide animation.');
        }
        return [
            animations.transition('void => *', [animations.style({ transform: transform }), animations.animate('0.2s ease-in-out')]),
            animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ transform: transform }))]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.ÇlrFocusTrapTracker = FocusTrapTracker;
    exports.ClarityModule = ClarityModule;
    exports.ClrButtonModule = ClrButtonModule;
    exports.ClrButton = ClrButton;
    exports.ClrButtonGroup = ClrButtonGroup;
    exports.CLR_BUTTON_GROUP_DIRECTIVES = CLR_BUTTON_GROUP_DIRECTIVES;
    exports.ClrButtonGroupModule = ClrButtonGroupModule;
    exports.ClrLoadingButton = ClrLoadingButton;
    exports.CLR_LOADING_BUTTON_DIRECTIVES = CLR_LOADING_BUTTON_DIRECTIVES;
    exports.ClrLoadingButtonModule = ClrLoadingButtonModule;
    exports.ClrDataModule = ClrDataModule;
    exports.ClrDatagrid = ClrDatagrid;
    exports.ClrDatagridActionBar = ClrDatagridActionBar;
    exports.ClrDatagridActionOverflow = ClrDatagridActionOverflow;
    exports.ClrDatagridColumn = ClrDatagridColumn;
    exports.ClrDatagridColumnToggle = ClrDatagridColumnToggle;
    exports.ClrDatagridHideableColumn = ClrDatagridHideableColumn;
    exports.ClrDatagridFilter = ClrDatagridFilter;
    exports.ClrDatagridItems = ClrDatagridItems;
    exports.ClrDatagridRow = ClrDatagridRow;
    exports.ClrDatagridRowDetail = ClrDatagridRowDetail;
    exports.ClrDatagridCell = ClrDatagridCell;
    exports.ClrDatagridFooter = ClrDatagridFooter;
    exports.ClrDatagridPagination = ClrDatagridPagination;
    exports.ClrDatagridPlaceholder = ClrDatagridPlaceholder;
    exports.ClrDatagridSortOrder = ClrDatagridSortOrder;
    exports.DatagridStringFilter = DatagridStringFilter;
    exports.DatagridPropertyStringFilter = DatagridPropertyStringFilter;
    exports.DatagridPropertyComparator = DatagridPropertyComparator;
    exports.CLR_DATAGRID_DIRECTIVES = CLR_DATAGRID_DIRECTIVES;
    exports.ClrDatagridModule = ClrDatagridModule;
    exports.ClrSelectedState = ClrSelectedState;
    exports.ClrTree = ClrTree;
    exports.ClrTreeNode = ClrTreeNode;
    exports.ClrRecursiveForOf = ClrRecursiveForOf;
    exports.CLR_TREE_VIEW_DIRECTIVES = CLR_TREE_VIEW_DIRECTIVES;
    exports.ClrTreeViewModule = ClrTreeViewModule;
    exports.ClrStackView = ClrStackView;
    exports.ClrStackHeader = ClrStackHeader;
    exports.ClrStackBlock = ClrStackBlock;
    exports.ClrStackInput = ClrStackInput;
    exports.ClrStackSelect = ClrStackSelect;
    exports.CLR_STACK_VIEW_DIRECTIVES = CLR_STACK_VIEW_DIRECTIVES;
    exports.ClrStackViewModule = ClrStackViewModule;
    exports.ClrStackViewCustomTags = ClrStackViewCustomTags;
    exports.ClrEmphasisModule = ClrEmphasisModule;
    exports.ClrAlert = ClrAlert;
    exports.ClrAlertItem = ClrAlertItem;
    exports.ClrAlerts = ClrAlerts;
    exports.ClrAlertsPager = ClrAlertsPager;
    exports.CLR_ALERT_DIRECTIVES = CLR_ALERT_DIRECTIVES;
    exports.ClrAlertModule = ClrAlertModule;
    exports.ClrIfError = ClrIfError;
    exports.ClrControlError = ClrControlError;
    exports.ClrForm = ClrForm;
    exports.ClrControlHelper = ClrControlHelper;
    exports.ClrLabel = ClrLabel;
    exports.ClrLayout = ClrLayout;
    exports.ClrCommonFormsModule = ClrCommonFormsModule;
    exports.ClrCheckbox = ClrCheckbox;
    exports.ClrCheckboxContainer = ClrCheckboxContainer;
    exports.isToggleFactory = isToggleFactory;
    exports.IS_TOGGLE = IS_TOGGLE;
    exports.IS_TOGGLE_PROVIDER = IS_TOGGLE_PROVIDER;
    exports.ClrCheckboxWrapper = ClrCheckboxWrapper;
    exports.ClrCheckboxModule = ClrCheckboxModule;
    exports.ClrDateContainer = ClrDateContainer;
    exports.ClrDateInput = ClrDateInput;
    exports.ClrDatepickerViewManager = ClrDatepickerViewManager;
    exports.ClrDaypicker = ClrDaypicker;
    exports.ClrMonthpicker = ClrMonthpicker;
    exports.ClrYearpicker = ClrYearpicker;
    exports.ClrCalendar = ClrCalendar;
    exports.ClrDay = ClrDay;
    exports.CLR_DATEPICKER_DIRECTIVES = CLR_DATEPICKER_DIRECTIVES;
    exports.ClrDatepickerModule = ClrDatepickerModule;
    exports.ClrInput = ClrInput;
    exports.ClrInputContainer = ClrInputContainer;
    exports.ClrInputModule = ClrInputModule;
    exports.ClrPassword = ClrPassword;
    exports.ToggleServiceFactory = ToggleServiceFactory;
    exports.TOGGLE_SERVICE = TOGGLE_SERVICE;
    exports.TOGGLE_SERVICE_PROVIDER = TOGGLE_SERVICE_PROVIDER;
    exports.ClrPasswordContainer = ClrPasswordContainer;
    exports.ClrPasswordModule = ClrPasswordModule;
    exports.ClrRadio = ClrRadio;
    exports.ClrRadioContainer = ClrRadioContainer;
    exports.ClrRadioWrapper = ClrRadioWrapper;
    exports.ClrRadioModule = ClrRadioModule;
    exports.ClrSelect = ClrSelect;
    exports.ClrSelectContainer = ClrSelectContainer;
    exports.ClrSelectModule = ClrSelectModule;
    exports.ClrTextarea = ClrTextarea;
    exports.ClrTextareaContainer = ClrTextareaContainer;
    exports.ClrTextareaModule = ClrTextareaModule;
    exports.ClrFormsModule = ClrFormsModule;
    exports.ClrCheckboxDeprecated = ClrCheckboxDeprecated;
    exports.CLR_CHECKBOX_DIRECTIVES = CLR_CHECKBOX_DIRECTIVES;
    exports.ClrCheckboxDeprecatedModule = ClrCheckboxDeprecatedModule;
    exports.ClrFormsDeprecatedModule = ClrFormsDeprecatedModule;
    exports.ClrIconCustomTag = ClrIconCustomTag;
    exports.CLR_ICON_DIRECTIVES = CLR_ICON_DIRECTIVES;
    exports.ClrIconModule = ClrIconModule;
    exports.ClrLayoutModule = ClrLayoutModule;
    exports.ClrMainContainer = ClrMainContainer;
    exports.CLR_LAYOUT_DIRECTIVES = CLR_LAYOUT_DIRECTIVES;
    exports.ClrMainContainerModule = ClrMainContainerModule;
    exports.MainContainerWillyWonka = MainContainerWillyWonka;
    exports.NavDetectionOompaLoompa = NavDetectionOompaLoompa;
    exports.ClrHeader = ClrHeader;
    exports.ClrNavLevel = ClrNavLevel;
    exports.CLR_NAVIGATION_DIRECTIVES = CLR_NAVIGATION_DIRECTIVES;
    exports.ClrNavigationModule = ClrNavigationModule;
    exports.ClrTabs = ClrTabs;
    exports.ClrTab = ClrTab;
    exports.ClrTabContent = ClrTabContent;
    exports.ClrTabOverflowContent = ClrTabOverflowContent;
    exports.ClrTabLink = ClrTabLink;
    exports.CLR_TABS_DIRECTIVES = CLR_TABS_DIRECTIVES;
    exports.ClrTabsModule = ClrTabsModule;
    exports.ClrVerticalNavGroupChildren = ClrVerticalNavGroupChildren;
    exports.ClrVerticalNavGroup = ClrVerticalNavGroup;
    exports.ClrVerticalNav = ClrVerticalNav;
    exports.ClrVerticalNavLink = ClrVerticalNavLink;
    exports.ClrVerticalNavIcon = ClrVerticalNavIcon;
    exports.CLR_VERTICAL_NAV_DIRECTIVES = CLR_VERTICAL_NAV_DIRECTIVES;
    exports.ClrVerticalNavModule = ClrVerticalNavModule;
    exports.ClrModal = ClrModal;
    exports.CLR_MODAL_DIRECTIVES = CLR_MODAL_DIRECTIVES;
    exports.ClrModalModule = ClrModalModule;
    exports.ClrDropdown = ClrDropdown;
    exports.ClrDropdownMenu = ClrDropdownMenu;
    exports.ClrDropdownTrigger = ClrDropdownTrigger;
    exports.ClrDropdownItem = ClrDropdownItem;
    exports.CLR_MENU_POSITIONS = CLR_MENU_POSITIONS;
    exports.CLR_DROPDOWN_DIRECTIVES = CLR_DROPDOWN_DIRECTIVES;
    exports.ClrDropdownModule = ClrDropdownModule;
    exports.ClrPopoverModule = ClrPopoverModule;
    exports.ClrSignpost = ClrSignpost;
    exports.ClrSignpostContent = ClrSignpostContent;
    exports.ClrSignpostTrigger = ClrSignpostTrigger;
    exports.CLR_SIGNPOST_DIRECTIVES = CLR_SIGNPOST_DIRECTIVES;
    exports.ClrSignpostModule = ClrSignpostModule;
    exports.ClrTooltip = ClrTooltip;
    exports.ClrTooltipTrigger = ClrTooltipTrigger;
    exports.ClrTooltipContent = ClrTooltipContent;
    exports.CLR_TOOLTIP_DIRECTIVES = CLR_TOOLTIP_DIRECTIVES;
    exports.ClrTooltipModule = ClrTooltipModule;
    exports.collapse = collapse;
    exports.fade = fade;
    exports.fadeSlide = fadeSlide;
    exports.slide = slide;
    exports.ClrLoadingState = ClrLoadingState;
    exports.ClrLoading = ClrLoading;
    exports.LoadingListener = LoadingListener;
    exports.CLR_LOADING_DIRECTIVES = CLR_LOADING_DIRECTIVES;
    exports.ClrLoadingModule = ClrLoadingModule;
    exports.CONDITIONAL_DIRECTIVES = CONDITIONAL_DIRECTIVES;
    exports.ClrIfActive = ClrIfActive;
    exports.ClrIfOpen = ClrIfOpen;
    exports.EXPAND_DIRECTIVES = EXPAND_DIRECTIVES;
    exports.ClrIfExpanded = ClrIfExpanded;
    exports.ClrCommonStringsService = ClrCommonStringsService;
    exports.ClrDraggable = ClrDraggable;
    exports.ClrDroppable = ClrDroppable;
    exports.ClrIfDragged = ClrIfDragged;
    exports.ClrDragHandle = ClrDragHandle;
    exports.ClrDraggableGhost = ClrDraggableGhost;
    exports.ClrDragEvent = ClrDragEvent;
    exports.CLR_DRAG_AND_DROP_DIRECTIVES = CLR_DRAG_AND_DROP_DIRECTIVES;
    exports.ClrDragAndDropModule = ClrDragAndDropModule;
    exports.ClrWizard = ClrWizard;
    exports.ClrWizardPage = ClrWizardPage;
    exports.ClrWizardStepnav = ClrWizardStepnav;
    exports.ClrWizardStepnavItem = ClrWizardStepnavItem;
    exports.DEFAULT_BUTTON_TYPES = DEFAULT_BUTTON_TYPES;
    exports.CUSTOM_BUTTON_TYPES = CUSTOM_BUTTON_TYPES;
    exports.ClrWizardButton = ClrWizardButton;
    exports.ClrWizardHeaderAction = ClrWizardHeaderAction;
    exports.ClrWizardCustomTags = ClrWizardCustomTags;
    exports.ClrWizardPageTitle = ClrWizardPageTitle;
    exports.ClrWizardPageNavTitle = ClrWizardPageNavTitle;
    exports.ClrWizardPageButtons = ClrWizardPageButtons;
    exports.ClrWizardPageHeaderActions = ClrWizardPageHeaderActions;
    exports.CLR_WIZARD_DIRECTIVES = CLR_WIZARD_DIRECTIVES;
    exports.ClrWizardModule = ClrWizardModule;
    exports.CLR_SPINNER_DIRECTIVES = CLR_SPINNER_DIRECTIVES;
    exports.ClrSpinnerModule = ClrSpinnerModule;
    exports.ClrSpinner = ClrSpinner;
    exports.CLR_PROGRESS_BAR_DIRECTIVES = CLR_PROGRESS_BAR_DIRECTIVES;
    exports.ClrProgressBarModule = ClrProgressBarModule;
    exports.ClrProgressBar = ClrProgressBar;
    exports.ɵed = ButtonInGroupService;
    exports.ɵdt = DatagridRowExpandAnimation;
    exports.ɵdq = ActionableOompaLoompa;
    exports.ɵdo = DatagridWillyWonka;
    exports.ɵds = ExpandableOompaLoompa;
    exports.ɵcz = ClrDatagridColumnSeparator;
    exports.ɵdc = ClrDatagridColumnToggleButton;
    exports.ɵdb = ClrDatagridColumnToggleTitle;
    exports.ɵde = DatagridDetailRegisterer;
    exports.ɵdd = ClrDatagridItemsTrackBy;
    exports.ɵdf = ClrDatagridPageSize;
    exports.ɵda = ColumnResizerService;
    exports.ɵcs = ColumnToggleButtonsService;
    exports.ɵcw = CustomFilter;
    exports.ɵcu = DisplayModeService;
    exports.ɵcj = FiltersProvider;
    exports.ɵcp = ExpandableRowsCount;
    exports.ɵcq = HideableColumnService;
    exports.ɵci = Items;
    exports.ɵck = Page;
    exports.ɵco = RowActionService;
    exports.ɵch = Selection;
    exports.ɵcm = Sort;
    exports.ɵcl = StateDebouncer;
    exports.ɵcr = StateProvider;
    exports.ɵct = TableSizeService;
    exports.ɵdn = DatagridCellRenderer;
    exports.ɵdl = DatagridHeaderRenderer;
    exports.ɵdk = DatagridMainRenderer;
    exports.ɵdj = domAdapterFactory;
    exports.ɵcn = DatagridRenderOrganizer;
    exports.ɵdm = DatagridRowRenderer;
    exports.ɵcv = DatagridFilterRegistrar;
    exports.ɵdg = WrappedCell;
    exports.ɵdh = WrappedColumn;
    exports.ɵdi = WrappedRow;
    exports.ɵdv = ClrStackContentInput;
    exports.ɵdw = StackControl;
    exports.ɵea = RecursiveChildren;
    exports.ɵdz = TREE_FEATURES_PROVIDER;
    exports.ɵdx = TreeFeaturesService;
    exports.ɵdy = treeFeaturesFactory;
    exports.ɵba = AlertIconAndTypesService;
    exports.ɵbb = MultiAlertService;
    exports.ɵbf = IfErrorService;
    exports.ɵbm = ControlClassService;
    exports.ɵbc = ControlIdService;
    exports.ɵbt = FocusService;
    exports.ɵbd = LayoutService;
    exports.ɵbg = MarkControlService;
    exports.ɵbh = IS_NEW_FORMS_LAYOUT;
    exports.ɵbi = IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER;
    exports.ɵbe = NgControlService;
    exports.ɵbl = WrappedFormControl;
    exports.ɵbr = DateFormControlService;
    exports.ɵbu = DateIOService;
    exports.ɵbq = DateNavigationService;
    exports.ɵbv = DatepickerEnabledService;
    exports.ɵbw = DatepickerFocusService;
    exports.ɵbs = LocaleHelperService;
    exports.ɵbx = ViewManagerService;
    exports.ɵee = ResponsiveNavigationService;
    exports.ɵeo = ActiveOompaLoompa;
    exports.ɵen = TabsWillyWonka;
    exports.ɵei = AriaService;
    exports.ɵej = TabsService;
    exports.ɵek = TABS_ID;
    exports.ɵem = TABS_ID_PROVIDER;
    exports.ɵel = tokenFactory$1;
    exports.ɵer = VerticalNavGroupRegistrationService;
    exports.ɵes = VerticalNavGroupService;
    exports.ɵeq = VerticalNavIconService;
    exports.ɵep = VerticalNavService;
    exports.ɵec = ClrModalBody;
    exports.ɵs = AbstractPopover;
    exports.ɵb = POPOVER_DIRECTIVES;
    exports.ɵh = POPOVER_HOST_ANCHOR;
    exports.ɵc = PopoverDirectiveOld;
    exports.ɵa = ClrCommonPopoverModule;
    exports.ɵm = DROPDOWN_FOCUS_HANDLER_PROVIDER;
    exports.ɵl = DropdownFocusHandler;
    exports.ɵg = ROOT_DROPDOWN_PROVIDER;
    exports.ɵe = RootDropdownService;
    exports.ɵf = clrRootDropdownFactory;
    exports.ɵcy = SignpostIdService;
    exports.ɵet = TooltipIdService;
    exports.ɵdr = OompaLoompa;
    exports.ɵdp = WillyWonka;
    exports.ɵv = ClrConditionalModule;
    exports.ɵw = IF_ACTIVE_ID;
    exports.ɵy = IF_ACTIVE_ID_PROVIDER;
    exports.ɵz = IfActiveService;
    exports.ɵx = tokenFactory;
    exports.ɵd = IfOpenService;
    exports.ɵcf = DomAdapter;
    exports.ɵcc = DragAndDropEventBusService;
    exports.ɵcb = DragEventListenerService;
    exports.ɵcd = DragHandleRegistrarService;
    exports.ɵce = DraggableSnapshotService;
    exports.ɵcg = GlobalDragModeService;
    exports.ɵdu = ClrIfExpandModule;
    exports.ɵcx = Expand;
    exports.ɵbp = FocusTrapDirective;
    exports.ɵbn = ClrFocusTrapModule;
    exports.ɵbo = FOCUS_TRAP_DIRECTIVES;
    exports.ɵk = FOCUS_SERVICE_PROVIDER;
    exports.ɵi = FocusService$1;
    exports.ɵj = clrFocusServiceFactory;
    exports.ɵu = BASIC_FOCUSABLE_ITEM_PROVIDER;
    exports.ɵt = BasicFocusableItem;
    exports.ɵn = customFocusableItemProvider;
    exports.ɵr = FocusableItem;
    exports.ɵbk = EmptyAnchor;
    exports.ɵbj = ClrHostWrappingModule;
    exports.ɵo = UNIQUE_ID;
    exports.ɵq = UNIQUE_ID_PROVIDER;
    exports.ɵp = uniqueIdFactory;
    exports.ɵbz = OUSTIDE_CLICK_DIRECTIVES;
    exports.ɵca = OutsideClick;
    exports.ɵby = ClrOutsideClickModule;
    exports.ɵeb = ScrollingService;
    exports.ɵeg = TEMPLATE_REF_DIRECTIVES;
    exports.ɵeh = TemplateRefContainer;
    exports.ɵef = ClrTemplateRefModule;
    exports.ɵew = ButtonHubService;
    exports.ɵex = HeaderActionService;
    exports.ɵev = PageCollectionService;
    exports.ɵeu = WizardNavigationService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xyLWFuZ3VsYXIudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AY2xyL2FuZ3VsYXIvaWNvbi9pY29uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvaWNvbi9pY29uLm1vZHVsZS50cyIsIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vcG9wb3Zlci1vbGQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2xvYWRpbmcvbG9hZGluZy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9wcm92aWRlcnMvYnV0dG9uLWluLWdyb3VwLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLWdyb3VwL2J1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vbWVudS1wb3NpdGlvbnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmRlZmF1bHQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLWdyb3VwL2J1dHRvbi1ncm91cC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tbG9hZGluZy9sb2FkaW5nLWJ1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tbG9hZGluZy9sb2FkaW5nLWJ1dHRvbi5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZW1wdHktYW5jaG9yLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9lcnJvci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2hlbHBlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3IudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2xhYmVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9uZXctZm9ybXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvbWFyay1jb250cm9sLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vZm9ybS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9sYXlvdXQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vY29tbW9uLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LXdyYXBwZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3dyYXBwZWQtY29udHJvbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY2hlY2tib3gvY2hlY2tib3gtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY2hlY2tib3gvY2hlY2tib3gubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5kaXJlY3RpdmUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jb25kaXRpb25hbC9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC10cmFja2VyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZm9jdXMtdHJhcC9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9rZXktY29kZXMva2V5LWNvZGVzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci91dGlscy9jb25zdGFudHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3V0aWxzL2RhdGUtdXRpbHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL21vZGVsL2RheS12aWV3Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC9jYWxlbmRhci5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvbW9kZWwvZGF5Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC9jYWxlbmRhci12aWV3Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL2NhbGVuZGFyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL2RhdGUtaW8uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZXBpY2tlci1lbmFibGVkLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL2RhdGUtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlLWlucHV0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vYWJzdHJhY3QtcG9wb3Zlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL3ZpZXctbWFuYWdlci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLXZpZXctbWFuYWdlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvZGF5LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXlwaWNrZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL21vbnRocGlja2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC95ZWFyLXJhbmdlLm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci95ZWFycGlja2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2lucHV0L2lucHV0LWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2lucHV0L2lucHV0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvaW5wdXQvaW5wdXQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcGFzc3dvcmQvcGFzc3dvcmQtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcGFzc3dvcmQvcGFzc3dvcmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9wYXNzd29yZC9wYXNzd29yZC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby13cmFwcGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcmFkaW8vcmFkaW8udHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9zZWxlY3Qvc2VsZWN0LWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3NlbGVjdC9zZWxlY3QudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9zZWxlY3Qvc2VsZWN0Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3RleHRhcmVhL3RleHRhcmVhLWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3RleHRhcmVhL3RleHRhcmVhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvdGV4dGFyZWEvdGV4dGFyZWEubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZm9ybXMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaWYtZXhwYW5kZWQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9vdXRzaWRlLWNsaWNrL291dHNpZGUtY2xpY2sudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9vdXRzaWRlLWNsaWNrL2luZGV4LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvb3V0c2lkZS1jbGljay9vdXRzaWRlLWNsaWNrLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnLWV2ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9wcm92aWRlcnMvZHJhZy1hbmQtZHJvcC1ldmVudC1idXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2RyYWctZXZlbnQtbGlzdGVuZXIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2RyYWdnYWJsZS1zbmFwc2hvdC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnZ2FibGUtZ2hvc3QudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2lmLWRyYWdnZWQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL3Byb3ZpZGVycy9kcmFnLWhhbmRsZS1yZWdpc3RyYXIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2dsb2JhbC1kcmFnLW1vZGUuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZ2dhYmxlL2RyYWdnYWJsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJvcHBhYmxlL2Ryb3BwYWJsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1oYW5kbGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWctYW5kLWRyb3AubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29tcG9uZW50L2lzLWJvb2xlYW4tYXR0cmlidXRlLXNldC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3Byb2dyZXNzL3NwaW5uZXIvc3Bpbm5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3Byb2dyZXNzL3NwaW5uZXIvc3Bpbm5lci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2FuaW1hdGlvbi1oYWNrL3Jvdy1leHBhbmQtYW5pbWF0aW9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvY3VzdG9tLWZpbHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3N0YXRlLWRlYm91bmNlci5wcm92aWRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3BhZ2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9maWx0ZXJzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC91dGlscy9kYXRhZ3JpZC1maWx0ZXItcmVnaXN0cmFyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1maWx0ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL25lc3RlZC1wcm9wZXJ0eS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1wcm9wZXJ0eS1zdHJpbmctZmlsdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9idWlsdC1pbi9maWx0ZXJzL2RhdGFncmlkLXN0cmluZy1maWx0ZXItaW1wbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY2hvY29sYXRlL29vbXBhLWxvb21wYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2Nob2NvbGF0ZS93aWxseS13b25rYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvY2hvY29sYXRlL2RhdGFncmlkLXdpbGx5LXdvbmthLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9jaG9jb2xhdGUvYWN0aW9uYWJsZS1vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9jaG9jb2xhdGUvZXhwYW5kYWJsZS1vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL2NvbXBhcmF0b3JzL2RhdGFncmlkLXByb3BlcnR5LWNvbXBhcmF0b3IudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2VudW1zL3NvcnQtb3JkZXIuZW51bS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3NvcnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3dyYXBwZWQtY29sdW1uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1jb2x1bW4udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9pdGVtcy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtaXRlbXMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLXBsYWNlaG9sZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvc2lnbnBvc3QvcHJvdmlkZXJzL3NpZ25wb3N0LWlkLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LXRyaWdnZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3dyYXBwZWQtY2VsbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY2VsbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZW51bXMvZGlzcGxheS1tb2RlLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2VudW1zL3JlbmRlci1zdGVwLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9yZW5kZXItb3JnYW5pemVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZGlzcGxheS1tb2RlLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zZWxlY3Rpb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3dyYXBwZWQtcm93LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1yb3cudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3N0YXRlLnByb3ZpZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvdGFibGUtc2l6ZS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtYWN0aW9uLWJhci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtYWN0aW9uLW92ZXJmbG93LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvY29sdW1uLXJlc2l6ZXIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLXNlcGFyYXRvci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS1idXR0b24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtdGl0bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNvbHVtbi10b2dnbGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWRldGFpbC1yZWdpc3RlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1mb290ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1pdGVtcy10cmFja2J5LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1wYWdlLXNpemUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLXBhZ2luYXRpb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLXJvdy1kZXRhaWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9jb25zdGFudHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9jZWxsLXJlbmRlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvaGVhZGVyLXJlbmRlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvbm9vcC1kb20tYWRhcHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL21haW4tcmVuZGVyZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9yb3ctcmVuZGVyZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1ibG9jay50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay12aWV3LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLWhlYWRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1jb250cm9sLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLWlucHV0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLXNlbGVjdC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay12aWV3LWN1c3RvbS10YWdzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLWNvbnRlbnQtaW5wdXQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stdmlldy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy9tb2RlbHMvc2VsZWN0ZWQtc3RhdGUuZW51bS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L21vZGVscy90cmVlLW5vZGUubW9kZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy9tb2RlbHMvZGVjbGFyYXRpdmUtdHJlZS1ub2RlLm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvdHJlZS1mZWF0dXJlcy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvdHJlZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L21vZGVscy9hc3luYy1hcnJheS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L21vZGVscy9yZWN1cnNpdmUtdHJlZS1ub2RlLm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvcmVjdXJzaXZlLWZvci1vZi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L3JlY3Vyc2l2ZS1jaGlsZHJlbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L3RyZWUtdmlldy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGEubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZm9jdXMvZm9jdXNhYmxlLWl0ZW0vZm9jdXNhYmxlLWl0ZW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy9mb2N1c2FibGUtaXRlbS9jdXN0b20tZm9jdXNhYmxlLWl0ZW0tcHJvdmlkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy9hcnJvdy1rZXktZGlyZWN0aW9uLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy9mb2N1cy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZm9jdXMvZm9jdXNhYmxlLWl0ZW0vbGlua2Vycy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzL3dyYXAtb2JzZXJ2YWJsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vcHJvdmlkZXJzL2Ryb3Bkb3duLWZvY3VzLWhhbmRsZXIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vcHJvdmlkZXJzL2Ryb3Bkb3duLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2Ryb3Bkb3duL2Ryb3Bkb3duLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZm9jdXMvZm9jdXNhYmxlLWl0ZW0vYmFzaWMtZm9jdXNhYmxlLWl0ZW0uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24taXRlbS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24tbWVudS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24tdHJpZ2dlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvdXRpbHMvYWxlcnQtdHlwZXMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9wcm92aWRlcnMvaWNvbi1hbmQtdHlwZXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2VtcGhhc2lzL2FsZXJ0L3Byb3ZpZGVycy9tdWx0aS1hbGVydC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9hbGVydC1pdGVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnRzLXBhZ2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvZW1waGFzaXMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9yZXNwb25zaXZlLW5hdi1jb2Rlcy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvcmVzcG9uc2l2ZS1uYXYtY29udHJvbC1tZXNzYWdlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9wcm92aWRlcnMvcmVzcG9uc2l2ZS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbWFpbi1jb250YWluZXIvbWFpbi1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbWFpbi1jb250YWluZXIvbWFpbi1jb250YWluZXIubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9jaG9jb2xhdGUvbWFpbi1jb250YWluZXItd2lsbHktd29ua2EudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L2Nob2NvbGF0ZS9uYXYtZGV0ZWN0aW9uLW9vbXBhLWxvb21wYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvaGVhZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9uYXYtbGV2ZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L25hdmlnYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy90ZW1wbGF0ZS1yZWYvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy90ZW1wbGF0ZS1yZWYvdGVtcGxhdGUtcmVmLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL2Nob2NvbGF0ZS90YWJzLXdpbGx5LXdvbmthLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvY2hvY29sYXRlL2FjdGl2ZS1vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy9wcm92aWRlcnMvYXJpYS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvcHJvdmlkZXJzL3RhYnMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi1jb250ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFicy1pZC5wcm92aWRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi1saW5rLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi1vdmVyZmxvdy1jb250ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFicy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYnMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLXJlZ2lzdHJhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWljb24uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtZ3JvdXAuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2LWdyb3VwLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYtZ3JvdXAtY2hpbGRyZW4udHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi1pY29uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYtbGluay50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9sYXlvdXQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvc2Nyb2xsaW5nL3Njcm9sbGluZy1zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbW9kYWwvbW9kYWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9tb2RhbC9tb2RhbC1ib2R5LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbW9kYWwvbW9kYWwubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9zaWducG9zdC9zaWducG9zdC1wb3NpdGlvbnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LWNvbnRlbnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvdG9vbHRpcC9wcm92aWRlcnMvdG9vbHRpcC1pZC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci90b29sdGlwL3Rvb2x0aXAudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3Rvb2x0aXAvdG9vbHRpcC1jb250ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci90b29sdGlwL3Rvb2x0aXAtdHJpZ2dlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvdG9vbHRpcC90b29sdGlwLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvcG9wb3Zlci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvcHJvdmlkZXJzL2J1dHRvbi1odWIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC9wcm92aWRlcnMvcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvcHJvdmlkZXJzL2hlYWRlci1hY3Rpb25zLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLWhlYWRlci1hY3Rpb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXBhZ2UtYnV0dG9ucy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS1oZWFkZXItYWN0aW9ucy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS1uYXZ0aXRsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS10aXRsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLWJ1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtY3VzdG9tLXRhZ3MudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXN0ZXBuYXYudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXN0ZXBuYXYtaXRlbS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcHJvZ3Jlc3MvcHJvZ3Jlc3MtYmFycy9wcm9ncmVzcy1iYXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wcm9ncmVzcy9wcm9ncmVzcy1iYXJzL3Byb2dyZXNzLWJhci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9jbHItYW5ndWxhci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy1kZXByZWNhdGVkL2NoZWNrYm94L2NoZWNrYm94LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMtZGVwcmVjYXRlZC9jaGVja2JveC9jaGVja2JveC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy1kZXByZWNhdGVkL2Zvcm1zLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2FuaW1hdGlvbnMvY29sbGFwc2UvY29sbGFwc2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9hbmltYXRpb25zL2ZhZGUvZmFkZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2FuaW1hdGlvbnMvZmFkZS1zbGlkZS9mYWRlLXNsaWRlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvYW5pbWF0aW9ucy9zbGlkZS9zbGlkZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWljb24nIH0pXG5leHBvcnQgY2xhc3MgQ2xySWNvbkN1c3RvbVRhZyB7XG4gIC8vIE5vIGJlaGF2aW9yXG4gIC8vIFRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gXCJkZWNsYXJlXCIgdGhlIHRhZyBpbiBBbmd1bGFyXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWNvbkN1c3RvbVRhZyB9IGZyb20gJy4vaWNvbic7XG5cbmV4cG9ydCBjb25zdCBDTFJfSUNPTl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJJY29uQ3VzdG9tVGFnXTtcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0NMUl9JQ09OX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbQ0xSX0lDT05fRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJJY29uTW9kdWxlIHt9XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vKlxuICogRG8gTk9UIEFuZ3VsYXIgdGhpcyB1cC4gSXQgYXNzdW1lcyB3ZSdyZSBpbiB0aGUgRE9NLCBwbGF5cyB3aXRoIG5hdGl2ZSBlbGVtZW50cywgLi4uXG4gKiBJdCBjb3VsZCBwb3RlbnRpYWxseSBiZSB1c2VkIGFzIHBhcnQgb2YgQGNsci91aSBhcyBhIHZhbmlsbGEgSmF2YXNjcmlwdCBoZWxwZXIuXG4gKi9cblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUG9wb3Zlck9wdGlvbnMgfSBmcm9tICcuL3BvcG92ZXItb3B0aW9ucy5pbnRlcmZhY2UnO1xuZXhwb3J0IGVudW0gUG9pbnQge1xuICBSSUdIVF9DRU5URVIsXG4gIFJJR0hUX1RPUCxcbiAgUklHSFRfQk9UVE9NLFxuICBUT1BfQ0VOVEVSLFxuICBUT1BfUklHSFQsXG4gIFRPUF9MRUZULFxuICBCT1RUT01fQ0VOVEVSLFxuICBCT1RUT01fUklHSFQsXG4gIEJPVFRPTV9MRUZULFxuICBMRUZUX0NFTlRFUixcbiAgTEVGVF9UT1AsXG4gIExFRlRfQk9UVE9NLFxufVxuXG5jb25zdCBQT1NJVElPTl9SRUxBVElWRSA9ICdyZWxhdGl2ZSc7XG5jb25zdCBQT1NJVElPTl9BQlNPTFVURSA9ICdhYnNvbHV0ZSc7XG5jb25zdCBQT1NJVElPTl9GSVhFRCA9ICdmaXhlZCc7XG5cbmNvbnN0IE9WRVJGTE9XX1NDUk9MTCA9ICdzY3JvbGwnO1xuY29uc3QgT1ZFUkZMT1dfQVVUTyA9ICdhdXRvJztcblxuZXhwb3J0IGNsYXNzIFBvcG92ZXIge1xuICBwcml2YXRlIF9zY3JvbGw6IFN1YmplY3Q8dm9pZD47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBhbnkpIHtcbiAgICAvLyBCcm93c2VycyBkb24ndCBhZ3JlZSB3aXRoIHdoYXQgdG8gZG8gaWYgc29tZSBvZiB0aGVzZSBhcmUgbm90IHNwZWNpZmllZCwgc28gd2Ugc2V0IHRoZW0gYWxsIHRvIGJlIHNhZmUuXG4gICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFBPU0lUSU9OX0FCU09MVVRFO1xuICAgIGVsZW1lbnQuc3R5bGUudG9wID0gMDtcbiAgICBlbGVtZW50LnN0eWxlLmJvdHRvbSA9ICdhdXRvJztcbiAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSAwO1xuICAgIGVsZW1lbnQuc3R5bGUucmlnaHQgPSAnYXV0byc7XG4gIH1cblxuICAvLyBUT0RPOiBuZWVkIGEgd2F5IHRvIGFjY291bnQgZm9yIHBhcmFtZXRlcnMgdGhhdCBjaGFuZ2UgZHluYW1pY2FsbHkgKHBvc2l0aW9uaW5nKS5cbiAgcHVibGljIGFuY2hvcihcbiAgICBhbmNob3I6IGFueSxcbiAgICBhbmNob3JBbGlnbjogUG9pbnQsXG4gICAgcG9wb3ZlckFsaWduOiBQb2ludCxcbiAgICB7IG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCwgdXNlQW5jaG9yUGFyZW50ID0gZmFsc2UgfTogUG9wb3Zlck9wdGlvbnMgPSB7fVxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIC8vIFRPRE86IHdlIGFyZSBhc3N1bWluZyBoZXJlIHRoYXQgdGhlIHBvcG92ZXIgaXMgaW5zaWRlIG9yIG5leHQgdG8gdGhlIGFuY2hvci5cbiAgICAvLyBXZSdkIG5lZWQgdG8gZ28gdXAgdGhlIHBvcG92ZXIgdHJlZSB0b28gb3RoZXJ3aXNlXG5cbiAgICB0aGlzLmFkZFNjcm9sbEV2ZW50TGlzdGVuZXJzKGFuY2hvcik7XG4gICAgaWYgKHVzZUFuY2hvclBhcmVudCkge1xuICAgICAgYW5jaG9yID0gYW5jaG9yLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIC8vIGV4cGxpY2l0bHkgb3ZlcnJpZGUgYW5jaG9yJ3Mgc3R5bGUgdG8gc3RhdGljXG4gICAgYW5jaG9yLnN0eWxlLnBvc2l0aW9uID0gJ3N0YXRpYyc7XG5cbiAgICBjb25zdCBhbmNob3JSZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBvcG92ZXJSZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgLy8gcG9zaXRpb24gb2YgbGVmdCB0b3AgY29ybmVyIG9mIGFuY2hvciArIHRoZSBvZmZzZXRcbiAgICBsZXQgbGVmdERpZmY6IG51bWJlciA9IGFuY2hvclJlY3QubGVmdCAtIHBvcG92ZXJSZWN0LmxlZnQgKyBvZmZzZXRYO1xuICAgIGxldCB0b3BEaWZmOiBudW1iZXIgPSBhbmNob3JSZWN0LnRvcCAtIHBvcG92ZXJSZWN0LnRvcCArIG9mZnNldFk7XG5cbiAgICAvLyBmaXJzdCwgYWRqdXN0IHBvc2l0aW9uaW5nIGJhc2VkIG9uIGFuY2hvcidzIGFsaWduIHBvaW50XG4gICAgc3dpdGNoIChhbmNob3JBbGlnbikge1xuICAgICAgY2FzZSBQb2ludC5MRUZUX1RPUDpcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0xFRlQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5UT1BfQ0VOVEVSOlxuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlRPUF9SSUdIVDpcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX1RPUDpcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfQk9UVE9NOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0xFRlQ6XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0O1xuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9SSUdIVDpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX0JPVFRPTTpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICAvLyBzZWNvbmQsIGFkanVzdCBwb3NpdGlvbmluZyBiYXNlZCBvbiBwb3BvdmVyJ3MgYWxpZ24gcG9pbnRcbiAgICBzd2l0Y2ggKHBvcG92ZXJBbGlnbikge1xuICAgICAgY2FzZSBQb2ludC5MRUZUX1RPUDpcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0xFRlQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5UT1BfQ0VOVEVSOlxuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5UT1BfUklHSFQ6XG4gICAgICAgIGxlZnREaWZmIC09IHBvcG92ZXJSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfVE9QOlxuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfQk9UVE9NOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9MRUZUOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0O1xuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fUklHSFQ6XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0O1xuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX0JPVFRPTTpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmIC09IHBvcG92ZXJSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cblxuICAgIC8vIFRoaXJkLCBhZGp1c3Qgd2l0aCBwb3BvdmVyJ3MgbWFyZ2lucyBiYXNlZCBvbiB0aGUgdHdvIGFsaWduIHBvaW50cy5cbiAgICAvLyBIZXJlLCB3ZSBtYWtlIGFuIGFzc3VtcHRpb24gdGhhdCBwb3BvdmVyIGlzIHByaW1hcmlseSBwb3NpdGlvbmVkIG91dHNpZGUgdGhlXG4gICAgLy8gYW5jaG9yIHdpdGggbWlub3Igb2Zmc2V0LiBXaXRob3V0IHRoaXMgYXNzdW1wdGlvbiwgaXQncyBpbXBvc3NpYmxlIHRvIGFwcGx5XG4gICAgLy8gdGhlIHBvcG92ZXIncyBtYXJnaW5zIGluIGEgcHJlZGljdGFibGUgd2F5LiBGb3IgZXhhbXBsZSwgYXNzdW1lIHRoYXQgYSBwb3BvdmVyXG4gICAgLy8gYW5kIGl0cyBhbmNob3IgYXJlIGV4YWN0bHkgdGhlIHNhbWUgc2l6ZS4gaWYgYSBwb3BvdmVyIGlzIHBvc2l0aW9uZWQgaW5zaWRlIHRoZVxuICAgIC8vIGFuY2hvciAod2hpY2ggaXMgdGVjaG5pY2FsbHkgcG9zc2libGUpLCB0aGVuIGl0IGJlY29tZXMgaW1wb3NzaWJsZSB0byBrbm93IHdoYXQgdG8gZG9cbiAgICAvLyBpZiB0aGUgcG9wb3ZlciBoYXMgYSBub24temVybyBtYXJnaW4gdmFsdWUgYWxsIGFyb3VuZCAoYmVjYXVzZSBhcHBseWluZyB0aGUgbWFyZ2luIGluXG4gICAgLy8gYWxsIGZvdXIgZGlyZWN0aW9ucyB3aWxsIHJlc3VsdCBpbiBubyBtYXJnaW4gdmlzdWFsbHksIHdoaWNoIGlzbid0IHdoYXQgd2Ugd2FudCkuXG4gICAgLy8gVGhlcmVmb3JlLCBvdXIgbG9naWMgbWFrZXMgYXNzdW1wdGlvbnMgYWJvdXQgbWFyZ2lucyBvZiBpbnRlcmVzdCBnaXZlbiB0aGUgcG9pbnRzLFxuICAgIC8vIGFuZCBvbmx5IGNvdmVycyB0aGUgY2FzZXMgd2hlcmUgcG9wb3ZlciBpcyBvdXRzaWRlIHRoZSBhbmNob3IuXG5cbiAgICBjb25zdCBwb3BvdmVyQ29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KTtcbiAgICBjb25zdCBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQocG9wb3ZlckNvbXB1dGVkU3R5bGUubWFyZ2luTGVmdCwgMTApO1xuICAgIGNvbnN0IG1hcmdpblJpZ2h0ID0gcGFyc2VJbnQocG9wb3ZlckNvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsIDEwKTtcbiAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUludChwb3BvdmVyQ29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsIDEwKTtcbiAgICBjb25zdCBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChwb3BvdmVyQ29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sIDEwKTtcblxuICAgIHN3aXRjaCAoYW5jaG9yQWxpZ24pIHtcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9UT1A6XG4gICAgICBjYXNlIFBvaW50LlRPUF9MRUZUOlxuICAgICAgY2FzZSBQb2ludC5UT1BfUklHSFQ6XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX1RPUDpcbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuQk9UVE9NX1JJR0hUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuUklHSFRfQk9UVE9NKSB7XG4gICAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuQk9UVE9NX0xFRlQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5MRUZUX0JPVFRPTSkge1xuICAgICAgICAgIHRvcERpZmYgLT0gbWFyZ2luVG9wO1xuICAgICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuVE9QX0xFRlQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5MRUZUX1RPUCkge1xuICAgICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuVE9QX1JJR0hUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuUklHSFRfVE9QKSB7XG4gICAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfQk9UVE9NOlxuICAgICAgY2FzZSBQb2ludC5CT1RUT01fTEVGVDpcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX1JJR0hUOlxuICAgICAgY2FzZSBQb2ludC5SSUdIVF9CT1RUT006XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LkJPVFRPTV9MRUZUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuTEVGVF9CT1RUT00pIHtcbiAgICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LkJPVFRPTV9SSUdIVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LlJJR0hUX0JPVFRPTSkge1xuICAgICAgICAgIHRvcERpZmYgLT0gbWFyZ2luQm90dG9tO1xuICAgICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LlRPUF9MRUZUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuTEVGVF9UT1ApIHtcbiAgICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LlRPUF9SSUdIVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LlJJR0hUX1RPUCkge1xuICAgICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5UT1BfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgIHRvcERpZmYgLT0gbWFyZ2luQm90dG9tO1xuICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgIHRvcERpZmYgLT0gbWFyZ2luQm90dG9tO1xuICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7TWF0aC5yb3VuZChsZWZ0RGlmZil9cHgpIHRyYW5zbGF0ZVkoJHtNYXRoLnJvdW5kKHRvcERpZmYpfXB4KWA7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHB1YmxpYyByZWxlYXNlKCkge1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICB0aGlzLnJlbW92ZVNjcm9sbEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIGlzUG9zaXRpb25lZChjb250YWluZXI6IGFueSkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gUE9TSVRJT05fUkVMQVRJVkUgfHwgcG9zaXRpb24gPT09IFBPU0lUSU9OX0FCU09MVVRFIHx8IHBvc2l0aW9uID09PSBQT1NJVElPTl9GSVhFRDtcbiAgfVxuXG4gIC8qXG4gICAgICogQ29udGFpbmVycyB1cCB0byB0aGUgZmlyc3QgcG9zaXRpb25lZCBvbmUgd2lsbCBoYXZlIGFuIGV2ZW50IG9uIHNjcm9sbFxuICAgICAqL1xuXG4gIHByaXZhdGUgc2Nyb2xsYWJsZUVsZW1lbnRzOiBIVE1MRWxlbWVudFtdID0gW107XG5cbiAgcHJpdmF0ZSBlbWl0U2Nyb2xsRXZlbnQoKSB7XG4gICAgdGhpcy5fc2Nyb2xsLm5leHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgYm91bmRPblNjcm9sbExpc3RlbmVyOiBhbnkgPSB0aGlzLmVtaXRTY3JvbGxFdmVudC5iaW5kKHRoaXMpO1xuXG4gIHByaXZhdGUgYWRkU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoZTogYW55KSB7XG4gICAgdGhpcy5fc2Nyb2xsID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBjb25zdCBhbmNob3I6IGFueSA9IGU7XG4gICAgbGV0IGN1cnJlbnQ6IGFueSA9IGU7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbHMoY3VycmVudCkpIHtcbiAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmJvdW5kT25TY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnRzLnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCAhPT0gYW5jaG9yICYmIHRoaXMuaXNQb3NpdGlvbmVkKGN1cnJlbnQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVNjcm9sbEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiB0aGlzLnNjcm9sbGFibGVFbGVtZW50cykge1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmJvdW5kT25TY3JvbGxMaXN0ZW5lcik7XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX3Njcm9sbCkge1xuICAgICAgdGhpcy5fc2Nyb2xsLmNvbXBsZXRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5fc2Nyb2xsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2Nyb2xscyhjb250YWluZXI6IGFueSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgIHJldHVybiAoXG4gICAgICBjb21wdXRlZFN0eWxlcy5vdmVyZmxvd1ggPT09IE9WRVJGTE9XX1NDUk9MTCB8fFxuICAgICAgY29tcHV0ZWRTdHlsZXMub3ZlcmZsb3dYID09PSBPVkVSRkxPV19BVVRPIHx8XG4gICAgICBjb21wdXRlZFN0eWxlcy5vdmVyZmxvd1kgPT09IE9WRVJGTE9XX1NDUk9MTCB8fFxuICAgICAgY29tcHV0ZWRTdHlsZXMub3ZlcmZsb3dZID09PSBPVkVSRkxPV19BVVRPXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbWJlZGRlZFZpZXdSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBQb2ludCwgUG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlcic7XG5pbXBvcnQgeyBQb3BvdmVyT3B0aW9ucyB9IGZyb20gJy4vcG9wb3Zlci1vcHRpb25zLmludGVyZmFjZSc7XG5cbmxldCBvcGVuQ291bnQ6IG51bWJlciA9IDA7XG5jb25zdCB3YWl0aW5nOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdOyAvLyBwZW5kaW5nIGNyZWF0ZSBmdW5jdGlvbnNcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBvcG92ZXJPbGRdJyB9KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJEaXJlY3RpdmVPbGQge1xuICBwcml2YXRlIF9wb3BvdmVySW5zdGFuY2U6IFBvcG92ZXI7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIEBJbnB1dCgnY2xyUG9wb3Zlck9sZEFuY2hvcicpIGFuY2hvckVsZW06IGFueTtcbiAgQElucHV0KCdjbHJQb3BvdmVyT2xkQW5jaG9yUG9pbnQnKSBhbmNob3JQb2ludDogUG9pbnQ7XG4gIEBJbnB1dCgnY2xyUG9wb3Zlck9sZFBvcG92ZXJQb2ludCcpIHBvcG92ZXJQb2ludDogUG9pbnQ7XG4gIEBJbnB1dCgnY2xyUG9wb3Zlck9sZE9wdGlvbnMnKSBwb3BvdmVyT3B0aW9uczogUG9wb3Zlck9wdGlvbnMgPSB7fTtcbiAgQE91dHB1dCgnY2xyUG9wb3Zlck9sZENoYW5nZScpIGNsclBvcG92ZXJPbGRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LCBwcml2YXRlIHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYpIHt9XG5cbiAgQElucHV0KClcbiAgc2V0IGNsclBvcG92ZXJPbGQob3BlbjogYm9vbGVhbikge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBpZiAodGhpcy5wb3BvdmVyT3B0aW9ucy5hbGxvd011bHRpcGxlT3Blbikge1xuICAgICAgICB0aGlzLmNyZWF0ZVBvcG92ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcGVuQ291bnQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZVBvcG92ZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YWl0aW5nLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB0aGlzLmRlc3Ryb3lQb3BvdmVyKCk7XG5cbiAgICAgIGlmICghdGhpcy5wb3BvdmVyT3B0aW9ucy5hbGxvd011bHRpcGxlT3Blbikge1xuICAgICAgICBpZiAod2FpdGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgY3JlYXRlUG9wb3ZlckZuID0gd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICAgIGNyZWF0ZVBvcG92ZXJGbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlUG9wb3ZlcigpIHtcbiAgICBjb25zdCBlbWJlZGRlZFZpZXdSZWY6IEVtYmVkZGVkVmlld1JlZjxhbnk+ID0gPEVtYmVkZGVkVmlld1JlZjxhbnk+PnRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcoXG4gICAgICB0aGlzLnRlbXBsYXRlUmVmXG4gICAgKTtcblxuICAgIC8vIFRPRE86IE5vdCBzdXJlIG9mIHRoZSByaXNrcyBhc3NvY2lhdGVkIHdpdGggdXNpbmcgdGhpcy4gRmluZCBhbiBhbHRlcm5hdGl2ZS5cbiAgICAvLyBOZWVkZWQgZm9yIGZpbmQgdGhlIGNvcnJlY3QgaGVpZ2h0IGFuZCB3aWR0aCBvZiBkeW5hbWljYWxseSBjcmVhdGVkIHZpZXdzXG4gICAgLy8gaW5zaWRlIG9mIHRoZSBwb3BvdmVyLiBGb3IgRWc6IEJ1dHRvbiBHcm91cHNcbiAgICBlbWJlZGRlZFZpZXdSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgLy8gZmlsdGVyIG91dCBvdGhlciBub2RlcyBpbiB0aGUgdmlldyByZWYgc28gd2UgYXJlIG9ubHkgbGVmdCB3aXRoIGVsZW1lbnQgbm9kZXNcbiAgICBjb25zdCBlbGVtZW50Tm9kZXM6IEhUTUxFbGVtZW50W10gPSBlbWJlZGRlZFZpZXdSZWYucm9vdE5vZGVzLmZpbHRlcigobm9kZTogYW55KSA9PiB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMTtcbiAgICB9KTtcblxuICAgIC8vIHdlIHRha2UgdGhlIGZpcnN0IGVsZW1lbnQgbm9kZSBpbiB0aGUgZW1iZWRkZWQgdmlldzsgdXN1YWxseSB0aGVyZSBzaG91bGQgb25seSBiZSBvbmUgYW55d2F5c1xuICAgIHRoaXMuX3BvcG92ZXJJbnN0YW5jZSA9IG5ldyBQb3BvdmVyKGVsZW1lbnROb2Rlc1swXSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fcG9wb3Zlckluc3RhbmNlXG4gICAgICAuYW5jaG9yKHRoaXMuYW5jaG9yRWxlbSwgdGhpcy5hbmNob3JQb2ludCwgdGhpcy5wb3BvdmVyUG9pbnQsIHRoaXMucG9wb3Zlck9wdGlvbnMpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbHJQb3BvdmVyT2xkQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgb3BlbkNvdW50Kys7XG4gIH1cblxuICBkZXN0cm95UG9wb3ZlcigpIHtcbiAgICBpZiAodGhpcy5fcG9wb3Zlckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuX3BvcG92ZXJJbnN0YW5jZS5yZWxlYXNlKCk7XG4gICAgICBkZWxldGUgdGhpcy5fcG9wb3Zlckluc3RhbmNlO1xuICAgICAgb3BlbkNvdW50LS07XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95UG9wb3ZlcigpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQb3BvdmVyRGlyZWN0aXZlT2xkIH0gZnJvbSAnLi9wb3BvdmVyLW9sZC5kaXJlY3RpdmUnO1xuXG5leHBvcnQgKiBmcm9tICcuL3BvcG92ZXItb3B0aW9ucy5pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9wb3BvdmVyLW9sZC5kaXJlY3RpdmUnO1xuXG5leHBvcnQgY29uc3QgUE9QT1ZFUl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtQb3BvdmVyRGlyZWN0aXZlT2xkXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBPUE9WRVJfRElSRUNUSVZFUyB9IGZyb20gJy4vaW5kZXgnO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbUE9QT1ZFUl9ESVJFQ1RJVkVTXSwgZXhwb3J0czogW1BPUE9WRVJfRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENsckxvYWRpbmdTdGF0ZSB9IGZyb20gJy4vbG9hZGluZyc7XG5cbi8qKlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcyBiZWNhdXNlIHdlIG5lZWQgaXQgdG8gc3RpbGwgYmUgYSB2YWxpZCB0b2tlbiBmb3IgZGVwZW5kZW5jeSBpbmplY3Rpb24gYWZ0ZXIgdHJhbnNwaWxpbmcuXG4gKiBUaGlzIGRvZXMgbm90IG1lYW4geW91IHNob3VsZCBleHRlbmQgaXQsIHNpbXBseSBpbXBsZW1lbnRpbmcgaXQgaXMgZmluZS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExvYWRpbmdMaXN0ZW5lciB7XG4gIGFic3RyYWN0IGxvYWRpbmdTdGF0ZUNoYW5nZShzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlKTogdm9pZDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi9sb2FkaW5nLWxpc3RlbmVyJztcblxuZXhwb3J0IGVudW0gQ2xyTG9hZGluZ1N0YXRlIHtcbiAgREVGQVVMVCxcbiAgTE9BRElORyxcbiAgU1VDQ0VTUyxcbiAgRVJST1IsXG59XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJMb2FkaW5nXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJMb2FkaW5nIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLy8gV2UgZmluZCB0aGUgZmlyc3QgcGFyZW50IHRoYXQgaGFuZGxlcyBzb21ldGhpbmcgbG9hZGluZ1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIGxpc3RlbmVyOiBMb2FkaW5nTGlzdGVuZXIpIHt9XG5cbiAgcHJpdmF0ZSBfbG9hZGluZ1N0YXRlOiBDbHJMb2FkaW5nU3RhdGUgPSBDbHJMb2FkaW5nU3RhdGUuREVGQVVMVDtcblxuICBwdWJsaWMgZ2V0IGxvYWRpbmdTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZGluZ1N0YXRlO1xuICB9XG5cbiAgQElucHV0KCdjbHJMb2FkaW5nJylcbiAgcHVibGljIHNldCBsb2FkaW5nU3RhdGUodmFsdWU6IGJvb2xlYW4gfCBDbHJMb2FkaW5nU3RhdGUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHZhbHVlID0gQ2xyTG9hZGluZ1N0YXRlLkxPQURJTkc7XG4gICAgfSBlbHNlIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gQ2xyTG9hZGluZ1N0YXRlLkRFRkFVTFQ7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSB0aGlzLl9sb2FkaW5nU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2FkaW5nU3RhdGUgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5saXN0ZW5lcikge1xuICAgICAgdGhpcy5saXN0ZW5lci5sb2FkaW5nU3RhdGVDaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGluZ1N0YXRlID0gQ2xyTG9hZGluZ1N0YXRlLkRFRkFVTFQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJCdXR0b24gfSBmcm9tICcuLi9idXR0b24tZ3JvdXAvYnV0dG9uJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEJ1dHRvbkluR3JvdXBTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfY2hhbmdlczogU3ViamVjdDxDbHJCdXR0b24+ID0gbmV3IFN1YmplY3Q8Q2xyQnV0dG9uPigpO1xuXG4gIGdldCBjaGFuZ2VzKCk6IE9ic2VydmFibGU8Q2xyQnV0dG9uPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICB1cGRhdGVCdXR0b25Hcm91cChidXR0b246IENsckJ1dHRvbik6IHZvaWQge1xuICAgIHRoaXMuX2NoYW5nZXMubmV4dChidXR0b24pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3B0aW9uYWwsIE91dHB1dCwgU2tpcFNlbGYsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyTG9hZGluZ1N0YXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nJztcbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBCdXR0b25Jbkdyb3VwU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9idXR0b24taW4tZ3JvdXAuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1idXR0b24nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctdGVtcGxhdGUgI2J1dHRvblByb2plY3RlZFJlZj5cbiAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgW2NsYXNzXT1cImNsYXNzTmFtZXNcIiBcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiZW1pdENsaWNrKClcIlxuICAgICAgICAgICAgICAgIFthdHRyLnR5cGVdPVwidHlwZVwiXG4gICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgW2lkXT1cImlkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzcGlubmVyIHNwaW5uZXItaW5saW5lXCIgKm5nSWY9XCJsb2FkaW5nXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTG9hZGluZ0xpc3RlbmVyLCB1c2VFeGlzdGluZzogQ2xyQnV0dG9uIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJCdXR0b24gaW1wbGVtZW50cyBMb2FkaW5nTGlzdGVuZXIge1xuICBwcml2YXRlIF9lbmFibGVTZXJ2aWNlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQFZpZXdDaGlsZCgnYnV0dG9uUHJvamVjdGVkUmVmJykgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPENsckJ1dHRvbj47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQFNraXBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHB1YmxpYyBidXR0b25Jbkdyb3VwU2VydmljZTogQnV0dG9uSW5Hcm91cFNlcnZpY2VcbiAgKSB7fVxuXG4gIHByaXZhdGUgX2luTWVudTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBpbk1lbnUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2luTWVudTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xySW5NZW51JylcbiAgc2V0IGluTWVudSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5faW5NZW51ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5faW5NZW51ID0gdmFsdWU7XG4gICAgICAvLyBXZSBjaGVjayBpZiB0aGUgc2VydmljZSBmbGFnIGlzIGVuYWJsZWRcbiAgICAgIC8vIGFuZCBpZiB0aGUgc2VydmljZSBleGlzdHMgYmVjYXVzZSB0aGUgc2VydmljZSBpcyBvcHRpb25hbFxuICAgICAgaWYgKHRoaXMuX2VuYWJsZVNlcnZpY2UgJiYgdGhpcy5idXR0b25Jbkdyb3VwU2VydmljZSkge1xuICAgICAgICB0aGlzLmJ1dHRvbkluR3JvdXBTZXJ2aWNlLnVwZGF0ZUJ1dHRvbkdyb3VwKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NsYXNzTmFtZXM6IHN0cmluZyA9ICdidG4nO1xuXG4gIGdldCBjbGFzc05hbWVzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NsYXNzTmFtZXM7XG4gIH1cblxuICBASW5wdXQoJ2NsYXNzJylcbiAgc2V0IGNsYXNzTmFtZXModmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzOiBzdHJpbmdbXSA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICBpZiAoY2xhc3NOYW1lcy5pbmRleE9mKCdidG4nKSA9PT0gLTEpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdidG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsYXNzTmFtZXMgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9uYW1lOiBzdHJpbmcgPSBudWxsO1xuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cblxuICBASW5wdXQoJ25hbWUnKVxuICBzZXQgbmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF90eXBlOiBzdHJpbmcgPSBudWxsO1xuXG4gIGdldCB0eXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gIH1cblxuICBASW5wdXQoJ3R5cGUnKVxuICBzZXQgdHlwZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pZDogc3RyaW5nID0gbnVsbDtcblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICBASW5wdXQoJ2lkJylcbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5faWQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9kaXNhYmxlZDogYW55ID0gbnVsbDtcblxuICBnZXQgZGlzYWJsZWQoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICBASW5wdXQoJ2Rpc2FibGVkJylcbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGxvYWRpbmc6IGJvb2xlYW47XG5cbiAgbG9hZGluZ1N0YXRlQ2hhbmdlKHN0YXRlOiBDbHJMb2FkaW5nU3RhdGUpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWRpbmcgPSBzdGF0ZSA9PT0gQ2xyTG9hZGluZ1N0YXRlLkxPQURJTkc7XG4gIH1cblxuICBAT3V0cHV0KCdjbGljaycpIF9jbGljazogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgZW1pdENsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuX2NsaWNrLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZW5hYmxlU2VydmljZSA9IHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBDTFJfTUVOVV9QT1NJVElPTlM6IHN0cmluZ1tdID0gW1xuICAnYm90dG9tLWxlZnQnLFxuICAnYm90dG9tLXJpZ2h0JyxcbiAgJ3RvcC1sZWZ0JyxcbiAgJ3RvcC1yaWdodCcsXG4gICdsZWZ0LWJvdHRvbScsXG4gICdsZWZ0LXRvcCcsXG4gICdyaWdodC1ib3R0b20nLFxuICAncmlnaHQtdG9wJyxcbl07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbmV4cG9ydCBjb25zdCBjb21tb25TdHJpbmdzRGVmYXVsdDogQ2xyQ29tbW9uU3RyaW5ncyA9IHtcbiAgb3BlbjogJ09wZW4nLFxuICBjbG9zZTogJ0Nsb3NlJyxcbiAgc2hvdzogJ1Nob3cnLFxuICBoaWRlOiAnSGlkZScsXG4gIGV4cGFuZDogJ0V4cGFuZCcsXG4gIGNvbGxhcHNlOiAnQ29sbGFwc2UnLFxuICBtb3JlOiAnTW9yZScsXG4gIHNlbGVjdDogJ1NlbGVjdCcsXG4gIHNlbGVjdEFsbDogJ1NlbGVjdCBBbGwnLFxuICBwcmV2aW91czogJ1ByZXZpb3VzJyxcbiAgbmV4dDogJ05leHQnLFxuICBjdXJyZW50OiAnSnVtcCB0byBjdXJyZW50JyxcbiAgaW5mbzogJ0luZm8nLFxuICBzdWNjZXNzOiAnU3VjY2VzcycsXG4gIHdhcm5pbmc6ICdXYXJuaW5nJyxcbiAgZGFuZ2VyOiAnRXJyb3InLFxuICByb3dBY3Rpb25zOiAnQXZhaWxhYmxlIGFjdGlvbnMnLFxuICBwaWNrQ29sdW1uczogJ1Nob3cgb3IgaGlkZSBjb2x1bW5zJyxcbiAgc2hvd0NvbHVtbnM6ICdTaG93IENvbHVtbnMnLFxuICBzb3J0Q29sdW1uOiAnU29ydCBDb2x1bW4nLFxuICBmaXJzdFBhZ2U6ICdGaXJzdCBQYWdlJyxcbiAgbGFzdFBhZ2U6ICdMYXN0IFBhZ2UnLFxuICBuZXh0UGFnZTogJ05leHQgUGFnZScsXG4gIHByZXZpb3VzUGFnZTogJ1ByZXZpb3VzIFBhZ2UnLFxuICBjdXJyZW50UGFnZTogJ0N1cnJlbnQgUGFnZScsXG4gIHRvdGFsUGFnZXM6ICdUb3RhbCBQYWdlcycsXG4gIG1pblZhbHVlOiAnTWluIHZhbHVlJyxcbiAgbWF4VmFsdWU6ICdNYXggdmFsdWUnLFxuICBtb2RhbENvbnRlbnRTdGFydDogJ0JlZ2lubmluZyBvZiBNb2RhbCBDb250ZW50JyxcbiAgbW9kYWxDb250ZW50RW5kOiAnRW5kIG9mIE1vZGFsIENvbnRlbnQnLFxuICBzaG93Q29sdW1uc01lbnVEZXNjcmlwdGlvbjogJ1Nob3cgb3IgaGlkZSBjb2x1bW5zIG1lbnUnLFxuICBhbGxDb2x1bW5zU2VsZWN0ZWQ6ICdBbGwgY29sdW1ucyBzZWxlY3RlZCcsXG4gIHNpZ25wb3N0VG9nZ2xlOiAnU2lnbnBvc3QgVG9nZ2xlJyxcbiAgc2lnbnBvc3RDbG9zZTogJ1NpZ25wb3N0IENsb3NlJyxcbiAgbG9hZGluZzogJ0xvYWRpbmcnLFxuICBzaW5nbGVTZWxlY3Rpb25BcmlhTGFiZWw6ICdTaW5nbGUgc2VsZWN0aW9uIGhlYWRlcicsXG4gIHNpbmdsZUFjdGlvbmFibGVBcmlhTGFiZWw6ICdTaW5nbGUgYWN0aW9uYWJsZSBoZWFkZXInLFxuICBkZXRhaWxFeHBhbmRhYmxlQXJpYUxhYmVsOiAnVG9nZ2xlIG1vcmUgcm93IGNvbnRlbnQnLFxuICAvLyBBbGVydFxuICBhbGVydENsb3NlQnV0dG9uQXJpYUxhYmVsOiAnQ2xvc2UgYWxlcnQnLFxuICAvLyBEYXRlIFBpY2tlclxuICBkYXRlcGlja2VyVG9nZ2xlOiAnVG9nZ2xlIGRhdGVwaWNrZXInLFxuICBkYXRlcGlja2VyUHJldmlvdXNNb250aDogJ1ByZXZpb3VzIG1vbnRoJyxcbiAgZGF0ZXBpY2tlckN1cnJlbnRNb250aDogJ0N1cnJlbnQgbW9udGgnLFxuICBkYXRlcGlja2VyTmV4dE1vbnRoOiAnTmV4dCBtb250aCcsXG4gIGRhdGVwaWNrZXJQcmV2aW91c0RlY2FkZTogJ1ByZXZpb3VzIGRlY2FkZScsXG4gIGRhdGVwaWNrZXJOZXh0RGVjYWRlOiAnTmV4dCBkZWNhZGUnLFxuICBkYXRlcGlja2VyQ3VycmVudERlY2FkZTogJ0N1cnJlbnQgZGVjYWRlJyxcbiAgZGF0ZXBpY2tlclNlbGVjdE1vbnRoVGV4dDogJ1NlbGVjdCBtb250aCwgdGhlIGN1cnJlbnQgbW9udGggaXMge0NBTEVOREFSX01PTlRIfScsXG4gIGRhdGVwaWNrZXJTZWxlY3RZZWFyVGV4dDogJ1NlbGVjdCB5ZWFyLCB0aGUgY3VycmVudCB5ZWFyIGlzIHtDQUxFTkRBUl9ZRUFSfScsXG4gIGRheXBpY2tlclNSQ3VycmVudE1vbnRoUGhyYXNlOiAnVGhlIGN1cnJlbnQgbW9udGggaXMge0NVUlJFTlRfTU9OVEh9JyxcbiAgZGF5cGlja2VyU1JDdXJyZW50WWVhclBocmFzZTogJ1RoZSBjdXJyZW50IHllYXIgaXMge0NVUlJFTlRfWUVBUn0nLFxuICBkYXlwaWNrZXJTUkN1cnJlbnREZWNhZGVQaHJhc2U6ICdUaGUgY3VycmVudCBkZWNhZGUgaXMge0RFQ0FERV9SQU5HRX0nLFxuICAvLyBTdGFjayBWaWV3XG4gIHN0YWNrVmlld0NoYW5nZWQ6ICdWYWx1ZSBjaGFuZ2VkLicsXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgY29tbW9uU3RyaW5nc0RlZmF1bHQgfSBmcm9tICcuL2NvbW1vbi1zdHJpbmdzLmRlZmF1bHQnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2Uge1xuICBwcml2YXRlIF9zdHJpbmdzID0gY29tbW9uU3RyaW5nc0RlZmF1bHQ7XG5cbiAgLyoqXG4gICAqIEFsbG93cyB5b3UgdG8gcGFzcyBpbiBuZXcgb3ZlcnJpZGVzIGZvciBsb2NhbGl6YXRpb25cbiAgICovXG4gIGxvY2FsaXplKG92ZXJyaWRlczogQ2xyQ29tbW9uU3RyaW5ncykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSB7IC4uLnRoaXMuX3N0cmluZ3MsIC4uLm92ZXJyaWRlcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0byBhbGwgb2YgdGhlIGtleXMgYXMgc3RyaW5nc1xuICAgKi9cbiAgZ2V0IGtleXMoKTogUmVhZG9ubHk8Q2xyQ29tbW9uU3RyaW5ncz4ge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc3RyaW5nIHdpdGggYSBzZXQgb2YgdG9rZW5zIHRvIHJlcGxhY2VcbiAgICovXG4gIHBhcnNlKHNvdXJjZTogc3RyaW5nLCB0b2tlbnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSkge1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXModG9rZW5zKTtcbiAgICBsZXQgb3V0cHV0ID0gc291cmNlO1xuICAgIGlmIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgIG5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKGB7JHtuYW1lfX1gLCB0b2tlbnNbbmFtZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuaW1wb3J0IHsgQ0xSX01FTlVfUE9TSVRJT05TIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9kcm9wZG93bi9tZW51LXBvc2l0aW9ucyc7XG5pbXBvcnQgeyBCdXR0b25Jbkdyb3VwU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9idXR0b24taW4tZ3JvdXAuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5cbmltcG9ydCB7IENsckJ1dHRvbiB9IGZyb20gJy4vYnV0dG9uJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWJ1dHRvbi1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAnYnV0dG9uLWdyb3VwLmh0bWwnLFxuICBwcm92aWRlcnM6IFtCdXR0b25Jbkdyb3VwU2VydmljZV0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5idG4tZ3JvdXBdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckJ1dHRvbkdyb3VwIHtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJCdXR0b24pIGJ1dHRvbnM6IFF1ZXJ5TGlzdDxDbHJCdXR0b24+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBidXR0b25Hcm91cE5ld1NlcnZpY2U6IEJ1dHRvbkluR3JvdXBTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2VcbiAgKSB7fVxuXG4gIGlubGluZUJ1dHRvbnM6IENsckJ1dHRvbltdID0gW107XG4gIG1lbnVCdXR0b25zOiBDbHJCdXR0b25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiAxLiBJbml0aWFsaXplcyB0aGUgaW5pdGlhbCBCdXR0b24gR3JvdXAgVmlld1xuICAgKiAyLiBTdWJzY3JpYmVzIHRvIGNoYW5nZXMgb24gdGhlIENvbnRlbnRDaGlsZHJlblxuICAgKiAgICBpbiBjYXNlIHRoZSB1c2VyIGNvbnRlbnQgcHJvamVjdGlvbiBjaGFuZ2VzXG4gICAqL1xuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplQnV0dG9ucygpO1xuICAgIHRoaXMuYnV0dG9uR3JvdXBOZXdTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKGJ1dHRvbiA9PiB0aGlzLnJlYXJyYW5nZUJ1dHRvbihidXR0b24pKTtcbiAgICB0aGlzLmJ1dHRvbnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplQnV0dG9ucygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBidXR0b24gaW50byB0aGUgb3RoZXIgVmlld0NvbnRhaW5lclxuICAgKiB3aGVuIGFuIHVwZGF0ZSBpcyByZWNlaXZlZC5cbiAgICpcbiAgICogQHBhcmFtIGJ1dHRvblxuICAgKi9cbiAgcmVhcnJhbmdlQnV0dG9uKGJ1dHRvbjogQ2xyQnV0dG9uKTogdm9pZCB7XG4gICAgbGV0IGZyb21WaWV3OiBDbHJCdXR0b25bXTtcbiAgICBsZXQgdG9WaWV3OiBDbHJCdXR0b25bXTtcbiAgICBpZiAoYnV0dG9uLmluTWVudSkge1xuICAgICAgZnJvbVZpZXcgPSB0aGlzLmlubGluZUJ1dHRvbnM7XG4gICAgICB0b1ZpZXcgPSB0aGlzLm1lbnVCdXR0b25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tVmlldyA9IHRoaXMubWVudUJ1dHRvbnM7XG4gICAgICB0b1ZpZXcgPSB0aGlzLmlubGluZUJ1dHRvbnM7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBmcm9tVmlldy5pbmRleE9mKGJ1dHRvbik7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIGZyb21WaWV3LnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjb25zdCBtb3ZlSW5kZXggPSB0aGlzLmdldE1vdmVJbmRleChidXR0b24pO1xuICAgICAgaWYgKG1vdmVJbmRleCA8PSB0b1ZpZXcubGVuZ3RoKSB7XG4gICAgICAgIHRvVmlldy5zcGxpY2UobW92ZUluZGV4LCAwLCBidXR0b24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdXRob3I6IEV1ZGVzXG4gICAqXG4gICAqIEZpbmRzIHRoZSBvcmRlciBvZiBhIGJ1dHRvbiB3LnIudCBvdGhlciBidXR0b25zXG4gICAqXG4gICAqIEBwYXJhbSBidXR0b25Ub01vdmVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldE1vdmVJbmRleChidXR0b25Ub01vdmU6IENsckJ1dHRvbik6IG51bWJlciB7XG4gICAgY29uc3QgdGVtcEFycjogQ2xyQnV0dG9uW10gPSB0aGlzLmJ1dHRvbnMuZmlsdGVyKGJ1dHRvbiA9PiBidXR0b24uaW5NZW51ID09PSBidXR0b25Ub01vdmUuaW5NZW51KTtcbiAgICByZXR1cm4gdGVtcEFyci5pbmRleE9mKGJ1dHRvblRvTW92ZSk7XG4gIH1cblxuICBpbml0aWFsaXplQnV0dG9ucygpOiB2b2lkIHtcbiAgICBjb25zdCB0ZW1wSW5saW5lQnV0dG9uczogQ2xyQnV0dG9uW10gPSBbXTtcbiAgICBjb25zdCB0ZW1wSW5NZW51QnV0dG9uczogQ2xyQnV0dG9uW10gPSBbXTtcbiAgICB0aGlzLmJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgaWYgKGJ1dHRvbi5pbk1lbnUpIHtcbiAgICAgICAgdGVtcEluTWVudUJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcElubGluZUJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaW5saW5lQnV0dG9ucyA9IHRlbXBJbmxpbmVCdXR0b25zO1xuICAgIHRoaXMubWVudUJ1dHRvbnMgPSB0ZW1wSW5NZW51QnV0dG9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyZmxvdyBNZW51XG4gICAqXG4gICAqL1xuXG4gIC8vIEluZGljYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJmbG93IG1lbnVcbiAgcHJpdmF0ZSBfbWVudVBvc2l0aW9uOiBzdHJpbmc7XG5cbiAgZ2V0IG1lbnVQb3NpdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9tZW51UG9zaXRpb247XG4gIH1cblxuICBASW5wdXQoJ2Nsck1lbnVQb3NpdGlvbicpXG4gIHNldCBtZW51UG9zaXRpb24ocG9zOiBzdHJpbmcpIHtcbiAgICBpZiAocG9zICYmIENMUl9NRU5VX1BPU0lUSU9OUy5pbmRleE9mKHBvcykgPiAtMSkge1xuICAgICAgdGhpcy5fbWVudVBvc2l0aW9uID0gcG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tZW51UG9zaXRpb24gPSAnYm90dG9tLWxlZnQnO1xuICAgIH1cbiAgICAvLyBzZXQgdGhlIHBvcG92ZXIgdmFsdWVzIGJhc2VkIG9uIG1lbnUgcG9zaXRpb25cbiAgICBzd2l0Y2ggKHRoaXMuX21lbnVQb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9SSUdIVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuVE9QX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9SSUdIVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQtdG9wJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodC1ib3R0b20nOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQtdG9wJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0LWJvdHRvbSc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9vcGVuTWVudTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBvcGVuTWVudSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fb3Blbk1lbnU7XG4gIH1cblxuICBzZXQgb3Blbk1lbnUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9vcGVuTWVudSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGFuY2hvclBvaW50OiBQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUOyAvLyBkZWZhdWx0IGlmIG1lbnVQb3NpdGlvbiBpc24ndCBzZXRcbiAgcHVibGljIHBvcG92ZXJQb2ludDogUG9pbnQgPSBQb2ludC5MRUZUX1RPUDsgLy8gZGVmYXVsdCBpZiBtZW51UG9zaXRpb24gaXNuJ3Qgc2V0XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgQ2xyRHJvcGRvd24gTWVudSB3aGVuIHRoZSBDbHJEcm9wZG93biBUb2dnbGUgaXNcbiAgICogY2xpY2tlZC4gQWxzbyBzZXQgYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHRvZ2dsZVxuICAgKiB3YXMgY2xpY2tlZCBzbyB0aGF0IHdlIGRvbid0IHRyYXZlcnNlIHRoZSBET00gdG8gZmluZCB0aGVcbiAgICogbG9jYXRpb24gb2YgdGhlIGNsaWNrLlxuICAgKi9cbiAgdG9nZ2xlTWVudSgpOiB2b2lkIHtcbiAgICB0aGlzLm9wZW5NZW51ID0gIXRoaXMub3Blbk1lbnU7XG4gICAgdGhpcy5fb3ZlcmZsb3dNZW51VG9nZ2xlQ2xpY2tlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyB3aXRoIGluZGljYXRlcyBpZiB0aGUgb3ZlcmZsb3cgbWVudSB0b2dnbGUgd2FzIGNsaWNrZWQuXG4gICAqIElmIHRydWUsIHRoaXMgY2FuIHNhdmUgdXMgdHJhdmVyc2luZyB0aGUgRE9NIHRvIGZpbmRcbiAgICogd2hldGhlciB0aGUgY2xpY2sgd2FzIHdpdGhpbmcgdGhlIGJ1dHRvbiBncm91cCB0b2dnbGVcbiAgICogb3IgbWVudSBpbiB0aGUgb25Nb3VzZUNsaWNrIG1ldGhvZFxuICAgKi9cbiAgcHJpdmF0ZSBfb3ZlcmZsb3dNZW51VG9nZ2xlQ2xpY2tlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIFRPRE86IEdlbmVyaWMgRGlyZWN0aXZlIHRvIGhhbmRsZSB0aGlzXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gbW91c2UgY2xpY2tzIGFueXdoZXJlIGluIHRoZSBET00uXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG1vdXNlY2xpY2sgaGFwcGVuZWQgb24gdGhlIGhvc3Qgb3Igb3V0c2lkZVxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcbiAgb25Nb3VzZUNsaWNrKHRhcmdldDogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3Blbk1lbnUgJiYgIXRoaXMuX292ZXJmbG93TWVudVRvZ2dsZUNsaWNrZWQpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBvdmVyZmxvdyBtZW51IHRvZ2dsZSBjbGlja2VkIGZsYWdcbiAgICAgIHRoaXMuX292ZXJmbG93TWVudVRvZ2dsZUNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGxldCBjdXJyZW50OiBhbnkgPSB0YXJnZXQ7IC8vIEdldCB0aGUgZWxlbWVudCBpbiB0aGUgRE9NIG9uIHdoaWNoIHRoZSBtb3VzZSB3YXMgY2xpY2tlZFxuICAgICAgY29uc3QgaG9zdDogYW55ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7IC8vIEN1cnJlbnQgQnV0dG9uIEdyb3VwXG5cbiAgICAgIGlmIChjdXJyZW50LmNsYXNzTGlzdC5jb250YWlucygnZHJvcGRvd24tbWVudScpKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5NZW51ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgY2xpY2tlZCBvbiBkcm9wZG93biBtZW51IGFuZCBtZW51IGlzIGluIGhvc3RcbiAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vcGVuTWVudSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9vdmVyZmxvd01lbnVUb2dnbGVDbGlja2VkID0gZmFsc2U7IC8vIFJlc2V0IHRoZSBvdmVyZmxvdyBtZW51IHRvZ2dsZSBjbGlja2VkIGZsYWdcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXIubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyQnV0dG9uIH0gZnJvbSAnLi9idXR0b24nO1xuaW1wb3J0IHsgQ2xyQnV0dG9uR3JvdXAgfSBmcm9tICcuL2J1dHRvbi1ncm91cCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfQlVUVE9OX0dST1VQX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsckJ1dHRvbiwgQ2xyQnV0dG9uR3JvdXBdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0JVVFRPTl9HUk9VUF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9CVVRUT05fR1JPVVBfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsckJ1dHRvbkdyb3VwTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IGFuaW1hdGUsIGtleWZyYW1lcywgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckxvYWRpbmdTdGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZyc7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdidXR0b25bY2xyTG9hZGluZ10nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJzdGF0ZVwiPlxuICAgICAgICAgICAgPHNwYW4gKm5nU3dpdGNoQ2FzZT1cImJ1dHRvblN0YXRlLkxPQURJTkdcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBAc3Bpbm5lciBjbGFzcz1cInNwaW5uZXIgc3Bpbm5lci1pbmxpbmVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiAqbmdTd2l0Y2hDYXNlPVwiYnV0dG9uU3RhdGUuU1VDQ0VTU1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIEB2YWxpZGF0ZWQgKEB2YWxpZGF0ZWQuZG9uZSk9XCJ0aGlzLmxvYWRpbmdTdGF0ZUNoYW5nZSh0aGlzLmJ1dHRvblN0YXRlLkRFRkFVTFQpXCIgY2xhc3M9XCJzcGlubmVyIHNwaW5uZXItaW5saW5lIHNwaW5uZXItY2hlY2tcIj48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiAqbmdTd2l0Y2hDYXNlPVwiYnV0dG9uU3RhdGUuREVGQVVMVFwiIEBkZWZhdWx0QnV0dG9uPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgYCxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBDbHJMb2FkaW5nQnV0dG9uIH1dLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignZGVmYXVsdEJ1dHRvbicsIFtcbiAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSksIGFuaW1hdGUoJzIwMG1zIDEwMG1zIGVhc2UtaW4nLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXSksXG4gICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIGdldCBsZWF2ZSBhbmltYXRpb24gdG8gd29yayBiZWZvcmUgc3Bpbm5lcidzIGVudGVyIGFuaW1hdGlvblxuICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW3N0eWxlKHsgb3BhY2l0eTogMCB9KV0pLFxuICAgIF0pLFxuICAgIHRyaWdnZXIoJ3NwaW5uZXInLCBbXG4gICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbc3R5bGUoeyBvcGFjaXR5OiAwIH0pLCBhbmltYXRlKCcyMDBtcyAxMDBtcyBlYXNlLWluJywgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKV0pLFxuICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW3N0eWxlKHsgb3BhY2l0eTogMSB9KSwgYW5pbWF0ZSgnMTAwbXMgZWFzZS1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXSksXG4gICAgXSksXG4gICAgdHJpZ2dlcigndmFsaWRhdGVkJywgW1xuICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xuICAgICAgICBhbmltYXRlKFxuICAgICAgICAgICc2MDBtcycsXG4gICAgICAgICAga2V5ZnJhbWVzKFtcbiAgICAgICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMCwwKScsIG9mZnNldDogMCB9KSxcbiAgICAgICAgICAgIHN0eWxlKHsgb3BhY2l0eTogMSwgb2Zmc2V0OiAwLjIgfSksXG4gICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDEuMiwxLjIpJywgb2Zmc2V0OiAwLjQgfSksXG4gICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKC45LC45KScsIG9mZnNldDogMC42IH0pLFxuICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgxLDEpJywgb2Zmc2V0OiAxIH0pLFxuICAgICAgICAgIF0pXG4gICAgICAgICksXG4gICAgICBdKSxcbiAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtzdHlsZSh7IG9wYWNpdHk6IDEgfSksIGFuaW1hdGUoJzEwMG1zIGVhc2Utb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKV0pLFxuICAgIF0pLFxuICBdLFxuICBob3N0OiB7ICdbYXR0ci5kaXNhYmxlZF0nOiBcImRpc2FibGVkPyAnJyA6IG51bGxcIiB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJMb2FkaW5nQnV0dG9uIGltcGxlbWVudHMgTG9hZGluZ0xpc3RlbmVyIHtcbiAgcHVibGljIGJ1dHRvblN0YXRlID0gQ2xyTG9hZGluZ1N0YXRlO1xuICBwdWJsaWMgc3RhdGU6IENsckxvYWRpbmdTdGF0ZSA9IENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUO1xuXG4gIEBJbnB1dCgnZGlzYWJsZWQnKSBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW47XG5cbiAgQE91dHB1dCgnY2xyTG9hZGluZ0NoYW5nZScpXG4gIHB1YmxpYyBjbHJMb2FkaW5nQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Q2xyTG9hZGluZ1N0YXRlPiA9IG5ldyBFdmVudEVtaXR0ZXI8Q2xyTG9hZGluZ1N0YXRlPihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cbiAgbG9hZGluZ1N0YXRlQ2hhbmdlKHN0YXRlOiBDbHJMb2FkaW5nU3RhdGUpOiB2b2lkIHtcbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuREVGQVVMVDpcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3RyYW5zZm9ybScpOyAvLyBmb3IgY2hyb21pdW0gcmVuZGVyIGJ1ZyBzZWUgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS9jbGFyaXR5L2lzc3Vlcy8yNzAwXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsckxvYWRpbmdTdGF0ZS5MT0FESU5HOlxuICAgICAgICB0aGlzLnNldEV4cGxpY2l0QnV0dG9uV2lkdGgoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRleigwKScpOyAvLyBmb3IgY2hyb21pdW0gcmVuZGVyIGJ1ZyBzZWUgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS9jbGFyaXR5L2lzc3Vlcy8yNzAwXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgJycpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyTG9hZGluZ1N0YXRlLlNVQ0NFU1M6XG4gICAgICAgIHRoaXMuc2V0RXhwbGljaXRCdXR0b25XaWR0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyTG9hZGluZ1N0YXRlLkVSUk9SOlxuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0ZUNoYW5nZShDbHJMb2FkaW5nU3RhdGUuREVGQVVMVCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuY2xyTG9hZGluZ0NoYW5nZS5lbWl0KHN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0RXhwbGljaXRCdXR0b25XaWR0aCgpIHtcbiAgICBpZiAodGhpcy5lbC5uYXRpdmVFbGVtZW50ICYmIHRoaXMuZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgIGNvbnN0IGJvdW5kaW5nQ2xpZW50UmVjdCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCBgJHtib3VuZGluZ0NsaWVudFJlY3Qud2lkdGh9cHhgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckxvYWRpbmdCdXR0b24gfSBmcm9tICcuL2xvYWRpbmctYnV0dG9uJztcblxuZXhwb3J0IGNvbnN0IENMUl9MT0FESU5HX0JVVFRPTl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJMb2FkaW5nQnV0dG9uXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9MT0FESU5HX0JVVFRPTl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9MT0FESU5HX0JVVFRPTl9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTG9hZGluZ0J1dHRvbk1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJCdXR0b25Hcm91cE1vZHVsZSB9IGZyb20gJy4vYnV0dG9uLWdyb3VwL2J1dHRvbi1ncm91cC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ0J1dHRvbk1vZHVsZSB9IGZyb20gJy4vYnV0dG9uLWxvYWRpbmcvbG9hZGluZy1idXR0b24ubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgZXhwb3J0czogW0NsckxvYWRpbmdCdXR0b25Nb2R1bGUsIENsckJ1dHRvbkdyb3VwTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQnV0dG9uTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiAnJyxcbn0pXG5leHBvcnQgY2xhc3MgRW1wdHlBbmNob3Ige31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEVtcHR5QW5jaG9yIH0gZnJvbSAnLi9lbXB0eS1hbmNob3InO1xuXG4vKipcbiAqIEludGVybmFsIG1vZHVsZSwgcGxlYXNlIGRvIG5vdCBleHBvcnQhXG4gKi9cbkBOZ01vZHVsZSh7IGRlY2xhcmF0aW9uczogW0VtcHR5QW5jaG9yXSwgZXhwb3J0czogW0VtcHR5QW5jaG9yXSwgZW50cnlDb21wb25lbnRzOiBbRW1wdHlBbmNob3JdIH0pXG5leHBvcnQgY2xhc3MgQ2xySG9zdFdyYXBwaW5nTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNvbnRyb2wtZXJyb3InLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuY2xyLXN1YnRleHRdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNvbnRyb2xFcnJvciB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmxldCBjb3VudGVyID0gMDtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbnRyb2xJZFNlcnZpY2Uge1xuICBwcml2YXRlIF9pZCA9ICdjbHItZm9ybS1jb250cm9sLScgKyArK2NvdW50ZXI7XG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuICBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgdGhpcy5faWRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9pZENoYW5nZTogQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuX2lkKTtcbiAgcHVibGljIGdldCBpZENoYW5nZSgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9pZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jb250cm9sLWhlbHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1zdWJ0ZXh0XSc6ICd0cnVlJyxcbiAgICAnW2lkXSc6ICdjb250cm9sSWRTZXJ2aWNlPy5pZCArIFwiLWhlbHBlclwiJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ29udHJvbEhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHB1YmxpYyBjb250cm9sSWRTZXJ2aWNlOiBDb250cm9sSWRTZXJ2aWNlKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ0NvbnRyb2xTZXJ2aWNlIHtcbiAgLy8gT2JzZXJ2YWJsZSB0byBzdWJzY3JpYmUgdG8gdGhlIGNvbnRyb2wsIHNpbmNlIGl0cyBub3QgYXZhaWxhYmxlIGltbWVkaWF0ZWx5IGZvciBwcm9qZWN0ZWQgY29udGVudFxuICBwcml2YXRlIF9jb250cm9sQ2hhbmdlczogU3ViamVjdDxOZ0NvbnRyb2w+ID0gbmV3IFN1YmplY3Q8TmdDb250cm9sPigpO1xuICBnZXQgY29udHJvbENoYW5nZXMoKTogT2JzZXJ2YWJsZTxOZ0NvbnRyb2w+IHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbENoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBzZXRDb250cm9sKGNvbnRyb2w6IE5nQ29udHJvbCkge1xuICAgIHRoaXMuX2NvbnRyb2xDaGFuZ2VzLm5leHQoY29udHJvbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSWZFcnJvclNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAvLyBJbXBsZW1lbnQgb3VyIG93biBzdGF0dXMgY2hhbmdlcyBvYnNlcnZhYmxlLCBzaW5jZSBBbmd1bGFyIGNvbnRyb2xzIGRvbid0XG4gIC8vIGZpcmUgb24gZXZlbnRzIGxpa2UgYmx1ciwgYW5kIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSBib29sZWFuIHN0YXRlIGluc3RlYWQgb2YgYSBzdHJpbmdcbiAgcHJpdmF0ZSBfc3RhdHVzQ2hhbmdlczogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0KCk7XG4gIGdldCBzdGF0dXNDaGFuZ2VzKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXNDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgY29udHJvbCB0byBiZSBhdmFpbGFibGVcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgICAgICB0aGlzLmxpc3RlbkZvckNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdGF0dXMgY2hhbmdlIGV2ZW50cywgb25seSBhZnRlciB0b3VjaGVkIGFuZCBlbWl0IHRoZSBjb250cm9sXG4gIHByaXZhdGUgbGlzdGVuRm9yQ2hhbmdlcygpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VuZFZhbGlkaXR5KCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHNlbmRWYWxpZGl0eSgpIHtcbiAgICBpZiAoKHRoaXMuY29udHJvbC50b3VjaGVkIHx8IHRoaXMuY29udHJvbC5kaXJ0eSkgJiYgdGhpcy5jb250cm9sLmludmFsaWQpIHtcbiAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMubmV4dCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5uZXh0KGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvd3MgYSBjb250cm9sIHRvIHB1c2ggYSBzdGF0dXMgY2hlY2sgdXBzdHJlYW0sIHN1Y2ggYXMgb24gYmx1clxuICB0cmlnZ2VyU3RhdHVzQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHRoaXMuc2VuZFZhbGlkaXR5KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgc3Vic2NyaXB0aW9uc1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPcHRpb25hbCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4vaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkVycm9yXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJJZkVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmlmRXJyb3JTZXJ2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NscklmRXJyb3IgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gYSBmb3JtIGNvbnRyb2wgY29udGFpbmVyIGVsZW1lbnQgbGlrZSBjbHItaW5wdXQtY29udGFpbmVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBzcGVjaWZpYyBlcnJvciB0byB0cmFjaywgY2hlY2sgaXQsIG90aGVyd2lzZSBjaGVjayBvdmVyYWxsIHZhbGlkaXR5XG4gICAgICAgIGlmICh0aGlzLmVycm9yICYmIHRoaXMuY29udHJvbCkge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yKHRoaXMuY29udHJvbC5oYXNFcnJvcih0aGlzLmVycm9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoaW52YWxpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xySWZFcnJvcicpIGVycm9yOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIGRpc3BsYXllZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBkaXNwbGF5RXJyb3IoaW52YWxpZDogYm9vbGVhbikge1xuICAgIGlmIChpbnZhbGlkICYmICF0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWludmFsaWQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBlbnVtIExheW91dHMge1xuICBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCcsXG4gIEhPUklaT05UQUwgPSAnaG9yaXpvbnRhbCcsXG4gIENPTVBBQ1QgPSAnY29tcGFjdCcsXG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMYXlvdXRTZXJ2aWNlIHtcbiAgbGF5b3V0OiBMYXlvdXRzID0gTGF5b3V0cy5IT1JJWk9OVEFMO1xuICAvLyBUaGlzIGlzIGJhc2ljYWxseSBhIHJlcGxhY2VtZW50IGZvciBPYmplY3QudmFsdWVzKCksIHdoaWNoIElFMTEgYW5kIE5vZGUgPDkgZG9uJ3Qgc3VwcG9ydCA6KFxuICAvLyBTdHJpbmcgZW51bXMgY2Fubm90IGJlIHJldmVyc2UtbWFwcGVkLCBtZWFuaW5nIExheW91dHNbJ0NPTVBBQ1QnXSBkb2VzIG5vdCByZXR1cm4gJ2NvbXBhY3QnIHNvXG4gIC8vIHRoaXMgZXhpc3RzIHRvIGRlYWwgd2l0aCB0aGlzIGxpdHRsZSBjYXZlYXQgdG8gZ2V0IHRoZSBsaXN0IG9mIHRoZSB2YWx1ZXMgYXMgYW4gYXJyYXkuXG4gIHByaXZhdGUgbGF5b3V0VmFsdWVzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKExheW91dHMpLm1hcChrZXkgPT4gTGF5b3V0c1trZXldKTtcblxuICBpc1ZlcnRpY2FsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxheW91dCA9PT0gTGF5b3V0cy5WRVJUSUNBTDtcbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09IExheW91dHMuSE9SSVpPTlRBTDtcbiAgfVxuXG4gIGlzQ29tcGFjdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09IExheW91dHMuQ09NUEFDVDtcbiAgfVxuXG4gIGdldCBsYXlvdXRDbGFzcygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2xyLWZvcm0tJHt0aGlzLmxheW91dH1gO1xuICB9XG5cbiAgaXNWYWxpZChsYXlvdXQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxheW91dFZhbHVlcy5pbmRleE9mKGxheW91dCkgPiAtMTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPcHRpb25hbCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2xhYmVsJyB9KVxuZXhwb3J0IGNsYXNzIENsckxhYmVsIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGNvbnRyb2xJZFNlcnZpY2U6IENvbnRyb2xJZFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZlxuICApIHt9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmZvcicpXG4gIEBJbnB1dCgnZm9yJylcbiAgZm9yQXR0cjogc3RyaW5nO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBlbmFibGVHcmlkID0gdHJ1ZTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBPbmx5IGFkZCB0aGUgY2xyLWNvbnRyb2wtbGFiZWwgaWYgaXQgaXMgaW5zaWRlIGEgY29udHJvbCBjb250YWluZXJcbiAgICBpZiAodGhpcy5jb250cm9sSWRTZXJ2aWNlIHx8IHRoaXMubmdDb250cm9sU2VydmljZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbHItY29udHJvbC1sYWJlbCcpO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB0aGUgZ3JpZCBjb2x1bW4gY2xhc3NlcyBpZiB3ZSBhcmUgaW4gdGhlIHJpZ2h0IGNvbnRleHQgYW5kIGlmIHRoZXkgYXJlbid0IGFscmVhZHkgc2V0XG4gICAgaWYgKFxuICAgICAgdGhpcy5lbmFibGVHcmlkICYmXG4gICAgICB0aGlzLmxheW91dFNlcnZpY2UgJiZcbiAgICAgICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpICYmXG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQgJiZcbiAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZignY2xyLWNvbCcpIDwgMFxuICAgICkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbHItY29sLTEyJyk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2Nsci1jb2wtbWQtMicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250cm9sSWRTZXJ2aWNlICYmICF0aGlzLmZvckF0dHIpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuY29udHJvbElkU2VydmljZS5pZENoYW5nZS5zdWJzY3JpYmUoaWQgPT4gKHRoaXMuZm9yQXR0ciA9IGlkKSkpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVHcmlkKCkge1xuICAgIHRoaXMuZW5hYmxlR3JpZCA9IGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgSVNfTkVXX0ZPUk1TX0xBWU9VVCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxib29sZWFuPignSVNfTkVXX0ZPUk1TX0xBWU9VVCcpO1xuZXhwb3J0IGNvbnN0IElTX05FV19GT1JNU19MQVlPVVRfVFJVRV9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogSVNfTkVXX0ZPUk1TX0xBWU9VVCxcbiAgdXNlVmFsdWU6IHRydWUsXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNYXJrQ29udHJvbFNlcnZpY2Uge1xuICBwcml2YXRlIF9kaXJ0eTogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgZ2V0IGRpcnR5Q2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIG1hcmtBc0RpcnR5KCkge1xuICAgIHRoaXMuX2RpcnR5Lm5leHQoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgSVNfTkVXX0ZPUk1TX0xBWU9VVF9UUlVFX1BST1ZJREVSIH0gZnJvbSAnLi9wcm92aWRlcnMvbmV3LWZvcm1zLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbWFyay1jb250cm9sLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRm9ybV0nLFxuICBwcm92aWRlcnM6IFtMYXlvdXRTZXJ2aWNlLCBNYXJrQ29udHJvbFNlcnZpY2UsIElTX05FV19GT1JNU19MQVlPVVRfVFJVRV9QUk9WSURFUl0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1mb3JtXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWhvcml6b250YWxdJzogJ2xheW91dFNlcnZpY2UuaXNIb3Jpem9udGFsKCknLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29tcGFjdF0nOiAnbGF5b3V0U2VydmljZS5pc0NvbXBhY3QoKScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckZvcm0ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSwgcHJpdmF0ZSBtYXJrQ29udHJvbFNlcnZpY2U6IE1hcmtDb250cm9sU2VydmljZSkge31cblxuICBtYXJrQXNEaXJ0eSgpIHtcbiAgICB0aGlzLm1hcmtDb250cm9sU2VydmljZS5tYXJrQXNEaXJ0eSgpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExheW91dHMsIExheW91dFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJMYXlvdXRdJyxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTGF5b3V0IGltcGxlbWVudHMgT25Jbml0IHtcbiAgQElucHV0KCdjbHJMYXlvdXQnKSBsYXlvdXQ6IExheW91dHM7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLy8gT25seSBzZXQgdGhlIGxheW91dCBpZiBpdCBpcyBhIHZhbGlkIG9wdGlvblxuICAgIGlmICh0aGlzLmxheW91dCAmJiB0aGlzLmxheW91dFNlcnZpY2UuaXNWYWxpZCh0aGlzLmxheW91dCkpIHtcbiAgICAgIHRoaXMubGF5b3V0U2VydmljZS5sYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJDb250cm9sRXJyb3IgfSBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IENsckNvbnRyb2xIZWxwZXIgfSBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgeyBDbHJJZkVycm9yIH0gZnJvbSAnLi9pZi1lcnJvci9pZi1lcnJvcic7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4vbGFiZWwnO1xuaW1wb3J0IHsgQ2xyRm9ybSB9IGZyb20gJy4vZm9ybSc7XG5pbXBvcnQgeyBDbHJMYXlvdXQgfSBmcm9tICcuL2xheW91dCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDbHJMYWJlbCwgQ2xyQ29udHJvbEVycm9yLCBDbHJDb250cm9sSGVscGVyLCBDbHJJZkVycm9yLCBDbHJGb3JtLCBDbHJMYXlvdXRdLFxuICBleHBvcnRzOiBbQ2xyTGFiZWwsIENsckNvbnRyb2xFcnJvciwgQ2xyQ29udHJvbEhlbHBlciwgQ2xySWZFcnJvciwgQ2xyRm9ybSwgQ2xyTGF5b3V0XSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ29tbW9uRm9ybXNNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBDb250ZW50Q2hpbGQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5leHBvcnQgY29uc3QgSVNfVE9HR0xFID0gbmV3IEluamVjdGlvblRva2VuPEJlaGF2aW9yU3ViamVjdDxib29sZWFuPj4oJ0lTX1RPR0dMRScpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9nZ2xlRmFjdG9yeSgpIHtcbiAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xufVxuZXhwb3J0IGNvbnN0IElTX1RPR0dMRV9QUk9WSURFUiA9IHsgcHJvdmlkZTogSVNfVE9HR0xFLCB1c2VGYWN0b3J5OiBpc1RvZ2dsZUZhY3RvcnkgfTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNoZWNrYm94LXdyYXBwZXIsY2xyLXRvZ2dsZS13cmFwcGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyQ2hlY2tib3hdLFtjbHJUb2dnbGVdXCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbFwiPjwvbGFiZWw+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1jaGVja2JveC13cmFwcGVyXSc6ICchdG9nZ2xlJyxcbiAgICAnW2NsYXNzLmNsci10b2dnbGUtd3JhcHBlcl0nOiAndG9nZ2xlJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbQ29udHJvbElkU2VydmljZSwgSVNfVE9HR0xFX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hXcmFwcGVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLy8gV2UgbmVlZCBib3RoIF9keW5hbWljIGZvciBIb3N0V3JhcHBlciBhbmQgQ29udGVudENoaWxkKENsckxhYmVsKSBpbiBjYXNlcyB3aGVyZVxuICAvLyB0aGUgdXNlciBwdXRzIGEgcmFkaW8gaW5zaWRlIGEgd3JhcHBlciB3aXRob3V0IGEgbGFiZWwsIGhvc3Qgd3JhcHBpbmcgZG9lc24ndCBhcHBseVxuICAvLyBidXQgd2UnZCBzdGlsbCBuZWVkIHRvIGluc2VydCBhIGxhYmVsXG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgdG9nZ2xlID0gZmFsc2U7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KElTX1RPR0dMRSkgdG9nZ2xlU2VydmljZTogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0b2dnbGVTZXJ2aWNlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlID0gc3RhdGU7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbC5kaXNhYmxlR3JpZCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7XG4gIENvbXBvbmVudEZhY3RvcnksXG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEluamVjdG9yLFxuICBUeXBlLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBFbXB0eUFuY2hvciB9IGZyb20gJy4vZW1wdHktYW5jaG9yJztcblxuLyoqXG4gKiBIb3N0V3JhcHBlciBtdXN0IGJlIGNhbGxlZCBpbiBPbkluaXQgdG8gZW5zdXJlIHRoYXQgdGhlIFZpZXdzIGFyZSByZWFkeS4gSWYgaXRzIGNhbGxlZCBpbiBhIGNvbnN0cnVjdG9yIHRoZSB2aWV3IGlzXG4gKiBzdGlsbCB1bmRlZmluZWQuXG4gKiBUT0RPIC0gbWFrZSBzdXJlIHRoZXNlIGNvbW1lbnQgYW5ub3RhdGlvbnMgZG8gbm90IGJyZWFrIG5nLXBhY2tnci5cbiAqL1xuZXhwb3J0IGNsYXNzIEhvc3RXcmFwcGVyPFcgZXh0ZW5kcyBEeW5hbWljV3JhcHBlcj4gaW1wbGVtZW50cyBJbmplY3RvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lclR5cGU6IFR5cGU8Vz4sIHZjcjogVmlld0NvbnRhaW5lclJlZiwgaW5kZXg6IG51bWJlciA9IDApIHtcbiAgICB0aGlzLmluamVjdG9yID0gdmNyLmluamVjdG9yO1xuICAgIC8vIElmIHRoZSBob3N0IGlzIGFscmVhZHkgd3JhcHBlZCwgd2UgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiAoIXRoaXMuaW5qZWN0b3IuZ2V0KGNvbnRhaW5lclR5cGUsIG51bGwpKSB7XG4gICAgICBjb25zdCBjZnIgPSB0aGlzLmluamVjdG9yLmdldChDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgY29uc3QgZWwgPSB0aGlzLmluamVjdG9yLmdldChFbGVtZW50UmVmKTtcblxuICAgICAgLy8gV2UgbmVlZCBhIG5ldyBhbmNob3IsIHNpbmNlIHdlJ3JlIHByb2plY3RpbmcgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgdmNyLmNyZWF0ZUNvbXBvbmVudChjZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRW1wdHlBbmNob3IpKTtcbiAgICAgIGNvbnN0IGZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8Vz4gPSBjZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29udGFpbmVyVHlwZSk7XG4gICAgICAvLyBDcmFmdCB0aGUgZWxlbWVudCBhcnJheSBiYXNlZCBvbiB3aGF0IHNsb3QgdG8gdXNlLiBBbmd1bGFyIG9ubHkgdXNlcyB0aGUgaW5kZXggdG8gZGV0ZXJtaW5lXG4gICAgICAvLyB3aGljaCBuZy1jb250ZW50IHRvIHByb2plY3QgaW50bywgc28gaWYgeW91IGhhdmUgbW9yZSB0aGFuIG9uZSBuZy1jb250ZW50IHlvdSdsbCBuZWVkIHRvIHNldFxuICAgICAgLy8gdGhlIGluZGV4IGluIHRoZSBjb25zdHJ1Y3RvciBhcHByb3ByaWF0ZWx5XG4gICAgICBjb25zdCBlbGVtZW50ID0gW107XG4gICAgICBlbGVtZW50W2luZGV4XSA9IFtlbC5uYXRpdmVFbGVtZW50XTtcbiAgICAgIC8vIFdlJ3JlIGFzc3VtaW5nIG9ubHkgb25lIHByb2plY3Rpb24gc2xvdCwgYnV0IGluIG1vcmUgY29tcGxleCBjYXNlcyB3ZSBtaWdodCB3YW50IHRvIHByb3ZpZGVcbiAgICAgIC8vIGEgZGlmZmVyZW50IGFycmF5IG9mIHByb2plY3RlZCBlbGVtZW50cy5cbiAgICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHZjci5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGVsZW1lbnQpO1xuICAgICAgLy8gV2UgY2FuIG5vdyByZW1vdmUgdGhlIHVzZWxlc3MgYW5jaG9yXG4gICAgICB2Y3IucmVtb3ZlKDApO1xuXG4gICAgICAvLyBXZSBub3RlIHRoYXQgdGhlIGNvbnRhaW5lciB3YXMgZHluYW1pY2FsbHkgY3JlYXRlZFxuICAgICAgY29udGFpbmVyUmVmLmluc3RhbmNlLl9keW5hbWljID0gdHJ1ZTtcblxuICAgICAgLy8gV2Uga2VlcCB0aGUgd3JhcHBlcidzIGluamVjdG9yIHRvIGFjY2VzcyB0aGUgZGVwZW5kZW5jaWVzIHRoYXQgd2VyZW4ndCBhdmFpbGFibGUgYmVmb3JlLlxuICAgICAgdGhpcy5pbmplY3RvciA9IGNvbnRhaW5lclJlZi5pbmplY3RvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcjtcblxuICBnZXQ8VD4odG9rZW46IFR5cGU8VD4gfCBJbmplY3Rpb25Ub2tlbjxUPiwgbm90Rm91bmRWYWx1ZT86IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5nZXQodG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbnRyb2xDbGFzc1NlcnZpY2Uge1xuICBjbGFzc05hbWUgPSAnJztcblxuICBjb250cm9sQ2xhc3MoaW52YWxpZCA9IGZhbHNlLCBncmlkID0gZmFsc2UsIGFkZGl0aW9uYWwgPSAnJykge1xuICAgIGNvbnN0IGNvbnRyb2xDbGFzc2VzID0gW3RoaXMuY2xhc3NOYW1lLCBhZGRpdGlvbmFsXTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgY29udHJvbENsYXNzZXMucHVzaCgnY2xyLWVycm9yJyk7XG4gICAgfVxuICAgIGlmIChncmlkICYmIHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoJ2Nsci1jb2wnKSA9PT0gLTEpIHtcbiAgICAgIGNvbnRyb2xDbGFzc2VzLnB1c2goJ2Nsci1jb2wtbWQtMTAgY2xyLWNvbC0xMicpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbENsYXNzZXMuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8vIFdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBjb2x1bW4gY2xhc3NlcyBmcm9tIHRoZSBpbnB1dCB1cCB0byB0aGUgY29udGFpbmVyXG4gIGluaXRDb250cm9sQ2xhc3MocmVuZGVyZXIsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5jbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWU7XG4gICAgICBjb25zdCBrbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICAgIGtsYXNzZXMuZm9yRWFjaChrbGFzcyA9PiB7XG4gICAgICAgIGlmIChrbGFzcy5zdGFydHNXaXRoKCdjbHItY29sJykpIHtcbiAgICAgICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCBrbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3Rpb25Ub2tlbixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uSW5pdCxcbiAgVHlwZSxcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgUmVuZGVyZXIyLFxuICBFbGVtZW50UmVmLFxuICBPbkRlc3Ryb3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBIb3N0V3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvaG9zdC13cmFwcGVyJztcbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuXG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBNYXJrQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9tYXJrLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuZXhwb3J0IGNsYXNzIFdyYXBwZWRGb3JtQ29udHJvbDxXIGV4dGVuZHMgRHluYW1pY1dyYXBwZXI+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2U7XG4gIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlO1xuICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2U7XG4gIHByaXZhdGUgbWFya0NvbnRyb2xTZXJ2aWNlOiBNYXJrQ29udHJvbFNlcnZpY2U7XG4gIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyO1xuICBwcm90ZWN0ZWQgZWw6IEVsZW1lbnRSZWY8YW55PjtcblxuICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJvdGVjdGVkIGluZGV4ID0gMDtcbiAgcHJvdGVjdGVkIGNvbnRyb2xJZFNlcnZpY2U6IENvbnRyb2xJZFNlcnZpY2U7XG5cbiAgX2lkOiBzdHJpbmc7XG5cbiAgLy8gSSBsb3N0IHdheSB0b28gbXVjaCB0aW1lIHRyeWluZyB0byBtYWtlIHRoaXMgd29yayB3aXRob3V0IGluamVjdGluZyB0aGUgVmlld0NvbnRhaW5lclJlZiBhbmQgdGhlIEluamVjdG9yLFxuICAvLyBJJ20gZ2l2aW5nIHVwLiBTbyB3ZSBoYXZlIHRvIGluamVjdCB0aGVzZSB0d28gbWFudWFsbHkgZm9yIG5vdy5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcm90ZWN0ZWQgd3JhcHBlclR5cGU6IFR5cGU8Vz4sXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgbmdDb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZlxuICApIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UgPSBpbmplY3Rvci5nZXQoTmdDb250cm9sU2VydmljZSk7XG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KElmRXJyb3JTZXJ2aWNlKTtcbiAgICAgIHRoaXMuY29udHJvbENsYXNzU2VydmljZSA9IGluamVjdG9yLmdldChDb250cm9sQ2xhc3NTZXJ2aWNlKTtcbiAgICAgIHRoaXMubWFya0NvbnRyb2xTZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KE1hcmtDb250cm9sU2VydmljZSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICh0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UpIHtcbiAgICAgIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5pbml0Q29udHJvbENsYXNzKHJlbmRlcmVyLCBlbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFya0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5tYXJrQ29udHJvbFNlcnZpY2UuZGlydHlDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm5nQ29udHJvbC5jb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRyb2wuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0QmluZGluZygpXG4gIEBJbnB1dCgpXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmNvbnRyb2xJZFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuY29udHJvbElkU2VydmljZS5pZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICB0cmlnZ2VyVmFsaWRhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pZkVycm9yU2VydmljZSkge1xuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS50cmlnZ2VyU3RhdHVzQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY29udGFpbmVySW5qZWN0b3I6IEluamVjdG9yO1xuXG4gIC8vIEBUT0RPIFRoaXMgbWV0aG9kIGhhcyBhIHRyeS9jYXRjaCBkdWUgdG8gYW4gdW5rbm93biBpc3N1ZSB0aGF0IGNhbWUgd2hlbiBidWlsZGluZyB0aGUgY2xyVG9nZ2xlIGZlYXR1cmVcbiAgLy8gV2UgbmVlZCB0byBmaWd1cmUgb3V0IHdoeSB0aGlzIGZhaWxzIGZvciB0aGUgQ2xyVG9nZ2xlIHNjZW5hcmlvIGJ1dCB3b3JrcyBmb3IgRGF0ZSBwaWNrZXIuLi5cbiAgLy8gVG8gc2VlIHRoZSBlcnJvciwgcmVtb3ZlIHRoZSB0cnkvY2F0Y2ggaGVyZSBhbmQgcnVuIHRoZSBDbHJUb2dnbGUgc3VpdGUgdG8gc2VlIGlzc3VlcyBnZXR0aW5nIHRoZSBjb250YWluZXJcbiAgLy8gaW5qZWN0b3IgaW4gdGltZSwgYW5kIHRoaXMgT05MWSBIQVBQRU5TIGluIHRlc3RzIGFuZCBub3QgaW4gZGV2L3Byb2QgbW9kZS5cbiAgcHJvdGVjdGVkIGdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcjxUPih0b2tlbjogVHlwZTxUPiB8IEluamVjdGlvblRva2VuPFQ+LCBub3RGb3VuZFZhbHVlPzogVCk6IFQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVySW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbm90Rm91bmRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9jb250YWluZXJJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcih0aGlzLndyYXBwZXJUeXBlLCB0aGlzLnZjciwgdGhpcy5pbmRleCk7XG4gICAgdGhpcy5jb250cm9sSWRTZXJ2aWNlID0gdGhpcy5fY29udGFpbmVySW5qZWN0b3IuZ2V0KENvbnRyb2xJZFNlcnZpY2UpO1xuICAgIGlmICh0aGlzLl9pZCkge1xuICAgICAgdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkID0gdGhpcy5faWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lkID0gdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJlciAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWRlc2NyaWJlZGJ5JywgdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkICsgJy1oZWxwZXInKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZ0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2Uuc2V0Q29udHJvbCh0aGlzLm5nQ29udHJvbCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBTZWxmLCBPcHRpb25hbCwgVmlld0NvbnRhaW5lclJlZiwgQXR0cmlidXRlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyQ2hlY2tib3hXcmFwcGVyLCBJU19UT0dHTEUgfSBmcm9tICcuL2NoZWNrYm94LXdyYXBwZXInO1xuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5cbi8qKlxuICogVGhpcyBpbXBsZW1lbnRzIGJvdGggdGhlIGNsckNoZWNrYm94IGFuZCBjbHJUb2dnbGUgZnVuY3Rpb25hbGl0eSwgc2luY2UgdGhleSBhcmUgYm90aCBqdXN0IGNoZWNrYm94ZXMgd2l0aCBkaWZmZXJlbnRcbiAqIHZpc3VhbCBzdHlsaW5nLiBUaGUgY2hhbGxlbmdlIGlzIHRoYXQgdGhlIGNvbnRhaW5lciBuZWVkcyB0byBrbm93IHdoaWNoIHNlbGVjdG9yIHdhcyB1c2VkLCB3aGljaCB0aGUgQEF0dHJpYnV0ZVxuICogZGVjb3JhdG9yIGdldHMgZm9yIHVzIHRvIGRldGVybWluZSBpZiB0aGUgdG9nZ2xlIGlzIHVzZWQsIGFuZCBlbWl0cyBhIHZhbHVlIHRvIHRoZSB3cmFwcGVyIGNvbnRhaW5lciB0byB0ZWxsIGl0XG4gKiB0aGVyZSBpcyBhIHRvZ2dsZSBzd2l0Y2ggaW5zdGVhZC5cbiAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckNoZWNrYm94XSxbY2xyVG9nZ2xlXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJDaGVja2JveCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJDaGVja2JveFdyYXBwZXI+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZixcbiAgICBAQXR0cmlidXRlKCdjbHJUb2dnbGUnKSBwcml2YXRlIHRvZ2dsZTogc3RyaW5nXG4gICkge1xuICAgIHN1cGVyKHZjciwgQ2xyQ2hlY2tib3hXcmFwcGVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICBjb25zdCB0b2dnbGVTZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXI8QmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+PihJU19UT0dHTEUsIG51bGwpO1xuXG4gICAgaWYgKHRvZ2dsZVNlcnZpY2UgJiYgdGhpcy50b2dnbGUgIT09IG51bGwpIHtcbiAgICAgIHRvZ2dsZVNlcnZpY2UubmV4dCh0cnVlKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBJbnB1dCwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcbmltcG9ydCB7IExheW91dFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jaGVja2JveC1jb250YWluZXIsY2xyLXRvZ2dsZS1jb250YWluZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgIDxkaXYgY2xhc3M9XCJjbHItY29udHJvbC1jb250YWluZXJcIiBbY2xhc3MuY2xyLWNvbnRyb2wtaW5saW5lXT1cImNscklubGluZVwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY2hlY2tib3gtd3JhcHBlcixjbHItdG9nZ2xlLXdyYXBwZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2xyLXN1YnRleHQtd3JhcHBlclwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlLCBJZkVycm9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94Q29udGFpbmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgcHJpdmF0ZSBpbmxpbmUgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuICAvLyBwcml2YXRlIGZvcm1Hcm91cDogQWJzdHJhY3RDb250cm9sO1xuXG4gIC8qXG4gICAqIEhlcmUgd2Ugd2FudCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmcgY2FzZXNcbiAgICogY2xySW5saW5lIC0gdHJ1ZSBieSBwcmVzZW5jZVxuICAgKiBjbHJJbmxpbmU9XCJ0cnVlfGZhbHNlXCIgLSB1bmxlc3MgaXQgaXMgZXhwbGljaXRseSBmYWxzZSwgc3RyaW5ncyBhcmUgY29uc2lkZXJlZCB0cnVlXG4gICAqIFtjbHJJbmxpbmVdPVwidHJ1ZXxmYWxzZVwiIC0gZXhwZWN0IGEgYm9vbGVhblxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGNscklubGluZSh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmlubGluZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlubGluZSA9ICEhdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjbHJJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5saW5lO1xuICB9XG5cbiAgLy8gQFRPRE8gU29sdmUgZm9yIGdyb3VwIHZhbGlkYXRpb24sIHdoaWNoIGRvZXNuJ3Qgd29yayBub3cgd2l0aCBuZ01vZGVsR3JvdXBcbiAgLy8gQmxvY2tlZCBieSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMDI2OFxuICAvLyBASW5wdXQoKVxuICAvLyBzZXQgY2xyRm9ybUdyb3VwKHZhbHVlOiBGb3JtR3JvdXApIHtcbiAgLy8gICB0aGlzLmZvcm1Hcm91cCA9IHZhbHVlO1xuICAvLyB9XG5cbiAgLy8gQElucHV0KClcbiAgLy8gc2V0IGNsckZvcm1BcnJheSh2YWx1ZTogRm9ybUFycmF5KSB7XG4gIC8vICAgdGhpcy5mb3JtR3JvdXAgPSB2YWx1ZTtcbiAgLy8gfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8vIEBUT0RPIHB1dCBhIHNvbHV0aW9uIGluIGZvciBmb3JtIGdyb3VwIHZhbGlkYXRpb25cbiAgICAvLyBpZiAoIXRoaXMuZm9ybUdyb3VwKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICAvLyBCZWNhdXNlIG5nTW9kZWwgZG9lcyB0aGlzLCB3ZSBoYXZlIHRvIGRlbGF5IGEgdGljayB0byBnZXQgdGhlIHJlc3VsdFxuICAgIC8vICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgLy8gICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgIC8vICAgICAgIHRoaXMuZm9ybUdyb3VwLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAvLyAgICAgICAgIHRoaXMuaW52YWxpZCA9IHRoaXMuZm9ybUdyb3VwLmludmFsaWQ7XG4gICAgLy8gICAgICAgfSlcbiAgICAvLyAgICAgKTtcbiAgICAvLyAgIH0pO1xuICAgIC8vIH1cbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpLCB0aGlzLmlubGluZSA/ICdjbHItY29udHJvbC1pbmxpbmUnIDogJycpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xySG9zdFdyYXBwaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyQ2hlY2tib3ggfSBmcm9tICcuL2NoZWNrYm94JztcbmltcG9ydCB7IENsckNoZWNrYm94Q29udGFpbmVyIH0gZnJvbSAnLi9jaGVja2JveC1jb250YWluZXInO1xuaW1wb3J0IHsgQ2xyQ2hlY2tib3hXcmFwcGVyIH0gZnJvbSAnLi9jaGVja2JveC13cmFwcGVyJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsckhvc3RXcmFwcGluZ01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsckNoZWNrYm94LCBDbHJDaGVja2JveENvbnRhaW5lciwgQ2xyQ2hlY2tib3hXcmFwcGVyXSxcbiAgZXhwb3J0czogW0NsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJDaGVja2JveCwgQ2xyQ2hlY2tib3hDb250YWluZXIsIENsckNoZWNrYm94V3JhcHBlcl0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsckNoZWNrYm94V3JhcHBlcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5sZXQgYWN0aXZlQ291bnRlciA9IDA7XG5cbmV4cG9ydCBjb25zdCBJRl9BQ1RJVkVfSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW48bnVtYmVyPignSUZfQUNUSVZFX0lEJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbkZhY3RvcnkoKSB7XG4gIHJldHVybiArK2FjdGl2ZUNvdW50ZXI7XG59XG5cbmV4cG9ydCBjb25zdCBJRl9BQ1RJVkVfSURfUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IElGX0FDVElWRV9JRCxcbiAgdXNlRmFjdG9yeTogdG9rZW5GYWN0b3J5LFxufTtcblxuQEluamVjdGFibGUoKVxuXG4vKioqKioqKioqXG4gKiBAY2xhc3MgSWZBY3RpdmVTZXJ2aWNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgdXNlZCBieSBJZkFjdGl2ZSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgYW5kIHRoZSBjb21wb25lbnRzIHRoYXQgaW1wbGVtZW50IElmQWN0aXZlIGluIHRoZWlyXG4gKiB0ZW1wbGF0ZXMuIEl0IGhvbGRzIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgcHJvdmlkZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGJvdGggdGhlIGRpcmVjdGl2ZSBhbmQgdGhlXG4gKiBpbXBsZW1lbnRpbmcgY29tcG9uZW50IGNhbiBzdWJzY3JpYmUgdG8gaW4gb3JkZXIgdG8gdGFrZSBhY3Rpb24gb24gY3VycmVudCB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIElmQWN0aXZlU2VydmljZSB7XG4gIC8qKioqKioqKlxuICAgKiBAcHJvcGVydHkgX2N1cnJlbnRDaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgUlhKUyBTdWJqZWN0IHRoYXQgdXBkYXRlcyBhbmQgcHJvdmlkZXMgc3Vic2NyaXB0aW9ucyB0byBmb3IgdGhlIGN1cnJlbnQgY3VycmVudCBzdGF0ZSBvZiBhIGNvbXBvbmVudCB0ZW1wbGF0ZVxuICAgKiBpbXBsZW10aW5nIHRoZSBJZkFjdGl2ZSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnRDaGFuZ2U6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcblxuICAvKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBfY3VycmVudFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBwcm9wZXJ0eSBob2xkaW5nIHRoZSBjdXJyZW50IHZhbHVlIGZvciBjdXJyZW50L2Nsb3NlZCBzdGF0ZSBvZiBhbiBJZkFjdGl2ZSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnQ6IG51bWJlcjtcblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGFuIG9ic2VydmFibGUgZm9yIHRoZSBfY3VycmVudCBTdWJqZWN0LlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50Q2hhbmdlKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHNldHRlciBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgX2N1cnJlbnQgZm9yIHRoaXMgaW5zdGFuY2Ugb2YgSWZBY3RpdmUgc3RydWN0dXJhbCBkaXJlY3RpdmUuXG4gICAqIEFuZCwgYnJvYWRjYXN0cyB0aGUgbmV3IHZhbHVlIHRvIGFsbCBzdWJzY3JpYmVycy5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgc2V0IGN1cnJlbnQodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fY3VycmVudCA9IHZhbHVlO1xuICAgICAgdGhpcy5fY3VycmVudENoYW5nZS5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBJZkFjdGl2ZSBpbnN0YW5jZS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4vaWYtYWN0aXZlLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xySWZBY3RpdmVdJyB9KVxuXG4vKioqKioqKioqKlxuICpcbiAqIEBjbGFzcyBDbHJJZkFjdGl2ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IHRoZSBhc3NvY2lhdGVkIFRlbXBsYXRlUmVmIGlzIGluc3RhbnRpYXRlZCBvciBub3QuXG4gKiBJdCBtYWtlcyB1c2Ugb2YgYSBDb21wb25lbnQgaW5zdGFuY2UgbGV2ZWwgc2VydmljZTogSWZBY3RpdmVTZXJ2aWNlIHRvIG1haW50YWluIHN0YXRlIGJldHdlZW4gaXRzZWxmIGFuZFxuICogdGhlIGNvbXBvbmVudCB1c2luZyBpdCBpbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENscklmQWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSB3YXNBY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIEBJbmplY3QoSUZfQUNUSVZFX0lEKSBwcml2YXRlIGlkOiBudW1iZXIsXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZlxuICApIHtcbiAgICB0aGlzLmNoZWNrQW5kVXBkYXRlVmlldyhpZkFjdGl2ZVNlcnZpY2UuY3VycmVudCk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnRDaGFuZ2Uuc3Vic2NyaWJlKG5ld0N1cnJlbnRJZCA9PiB7XG4gICAgICB0aGlzLmNoZWNrQW5kVXBkYXRlVmlldyhuZXdDdXJyZW50SWQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0FuZFVwZGF0ZVZpZXcoY3VycmVudElkOiBudW1iZXIpIHtcbiAgICBjb25zdCBpc05vd0FjdGl2ZSA9IGN1cnJlbnRJZCA9PT0gdGhpcy5pZDtcbiAgICAvLyBvbmx5IGVtaXQgaWYgdGhlIG5ldyBhY3RpdmUgc3RhdGUgaXMgY2hhbmdlZCBzaW5jZSBsYXN0IHRpbWUuXG4gICAgaWYgKGlzTm93QWN0aXZlICE9PSB0aGlzLndhc0FjdGl2ZSkge1xuICAgICAgdGhpcy51cGRhdGVWaWV3KGlzTm93QWN0aXZlKTtcbiAgICAgIHRoaXMuYWN0aXZlQ2hhbmdlLmVtaXQoaXNOb3dBY3RpdmUpO1xuICAgICAgdGhpcy53YXNBY3RpdmUgPSBpc05vd0FjdGl2ZTtcbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHNldHRlciB0aGF0IHVwZGF0ZXMgSWZBY3RpdmVTZXJ2aWNlLmFjdGl2ZSB3aXRoIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIEBJbnB1dCgnY2xySWZBY3RpdmUnKVxuICBwdWJsaWMgc2V0IGFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9IHRoaXMuaWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IGFjdGl2ZUNoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQW4gZXZlbnQgZW1pdHRlciB0aGF0IGVtaXRzIHdoZW4gdGhlIGFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQgdG8gYWxsb3cgZm9yIDJ3YXkgYmluZGluZyB3aGVuIHRoZSBkaXJlY3RpdmUgaXNcbiAgICogdXNlZCB3aXRoIGRlLXN0cnVjdHVyZWQgLyBkZS1zdWdhcmVkIHN5bnRheC5cbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscklmQWN0aXZlQ2hhbmdlJykgYWN0aXZlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICAvKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBJZkFjdGl2ZVNlcnZpY2UuYWN0aXZlIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPT09IHRoaXMuaWQ7XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGdW5jdGlvbiB0aGF0IHRha2VzIGEgYW55IHZhbHVlIGFuZCBlaXRoZXIgY3JlYXRlZCBhbiBlbWJlZGRlZCB2aWV3IGZvciB0aGUgYXNzb2NpYXRlZCBWaWV3Q29udGFpbmVyUmVmIG9yLFxuICAgKiBDbGVhcnMgYWxsIHZpZXdzIGZyb20gdGhlIFZpZXdDb250YWluZXJSZWZcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlVmlldyh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuXG4vKioqKioqKioqXG4gKiBAY2xhc3MgSWZPcGVuU2VydmljZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQW4gaW5qZWN0YWJsZSBzZXJ2aWNlIHVzZWQgYnkgSWZPcGVuIHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBhbmQgdGhlIGNvbXBvbmVudHMgdGhhdCBpbXBsZW1udCBJZk9wZW4gaW4gdGhlaXJcbiAqIHRlbXBsYXRlcy4gSXQgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBvcGVuIHN0YXRlIGFuZCBwcm92aWRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgYm90aCB0aGUgZGlyZWN0aXZlIGFuZCB0aGVcbiAqIGltcGxlbWVudGluZyBjb21wb25lbnQgY2FuIHN1YnNjcmliZSB0byBpbiBvcmRlciB0byB0YWtlIGFjdGlvbiBvbiBvcGVuIHZhbHVlIGNoYW5nZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgSWZPcGVuU2VydmljZSB7XG4gIC8qKioqKioqKlxuICAgKiBAcHJvcGVydHkgX29wZW5DaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgUlhKUyBTdWJqZWN0IHRoYXQgdXBkYXRlcyBhbmQgcHJvdmlkZXMgc3Vic2NyaXB0aW9ucyB0byBmb3IgdGhlIGN1cnJlbnQgb3BlbiBzdGF0ZSBvZiBhIGNvbXBvbmVudCB0ZW1wbGF0ZVxuICAgKiBpbXBsZW10aW5nIHRoZSBJZk9wZW4gc3RydWN0dXJhbCBkaXJlY3RpdmUuXG4gICAqL1xuICBwcml2YXRlIF9vcGVuQ2hhbmdlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBfb3BlblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBwcm9wZXJ0eSBob2xkaW5nIHRoZSBjdXJyZW50IHZhbHVlIGZvciBvcGVuL2Nsb3NlZCBzdGF0ZSBvZiBhbiBJZk9wZW4gc3RydWN0dXJhbCBkaXJlY3RpdmUuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9vcGVuOiBib29sZWFuO1xuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBmb3IgdGhlIF9vcGVuZWQgU3ViamVjdC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgb3BlbkNoYW5nZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fb3BlbkNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBfb3BlbiBmb3IgdGhpcyBpbnN0YW5jZSBvZiBJZk9wZW4gc3RydWN0dXJhbCBkaXJlY3RpdmUuIEFuZCxcbiAgICogYnJvYWRjYXN0cyB0aGUgbmV3IHZhbHVlIHRvIGFsbCBzdWJzY3JpYmVycy5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgc2V0IG9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMuX29wZW4gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9vcGVuID0gdmFsdWU7XG4gICAgICB0aGlzLl9vcGVuQ2hhbmdlLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzIElmT3BlbiBpbnN0YW5jZS5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgb3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb21ldGltZXMsIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSB0b2dnbGluZyB0byBhdm9pZCBsb29wcy5cbiAgICogVGhpcyBpcyBmb3IgaW5zdGFuY2UgdGhlIGNhc2Ugb2YgY29tcG9uZW50cyB0aGF0IG9wZW4gb24gYSBjbGljaywgYnV0IGNsb3NlIG9uIGEgY2xpY2sgb3V0c2lkZS5cbiAgICovXG4gIHB1YmxpYyBvcmlnaW5hbEV2ZW50OiBhbnk7XG4gIHB1YmxpYyB0b2dnbGVXaXRoRXZlbnQoZXZlbnQ6IGFueSkge1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW47XG4gICAgZGVsZXRlIHRoaXMub3JpZ2luYWxFdmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiAgUG9wb3ZlcnMgbWlnaHQgbmVlZCB0byBpZ25vcmUgY2xpY2sgZXZlbnRzIG9uIGFuIGVsZW1lbnRcbiAgICogIChlZzogcG9wb3ZlciBvcGVucyBvbiBmb2N1cyBvbiBhbiBpbnB1dCBmaWVsZC4gQ2xpY2tzIHNob3VsZCBiZSBpZ25vcmVkIGluIHRoaXMgY2FzZSlcbiAgICovXG4gIHByaXZhdGUgX2lnbm9yZWRFbGVtZW50Q2hhbmdlOiBTdWJqZWN0PEVsZW1lbnRSZWY+ID0gbmV3IFN1YmplY3Q8RWxlbWVudFJlZj4oKTtcblxuICBnZXQgaWdub3JlZEVsZW1lbnRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxFbGVtZW50UmVmPiB7XG4gICAgcmV0dXJuIHRoaXMuX2lnbm9yZWRFbGVtZW50Q2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcmVnaXN0ZXJJZ25vcmVkRWxlbWVudChlbGVtZW50OiBFbGVtZW50UmVmKSB7XG4gICAgdGhpcy5faWdub3JlZEVsZW1lbnRDaGFuZ2UubmV4dChlbGVtZW50KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi9pZi1vcGVuLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xySWZPcGVuXScgfSlcblxuLyoqKioqKioqKipcbiAqXG4gKiBAY2xhc3MgQ2xySWZPcGVuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRoYXQgY29udHJvbHMgd2hldGhlciBvciBub3QgdGhlIGFzc29jaWF0ZWQgVGVtcGxhdGVSZWYgaXMgaW5zdGFudGlhdGVkIG9yIG5vdC5cbiAqIEl0IG1ha2VzIHVzZSBvZiBhIENvbXBvbmVudCBpbnN0YW5jZSBsZXZlbCBzZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlIHRvIG1haW50YWluIHN0YXRlIGJldHdlZW4gaXRzZWxmIGFuZCB0aGUgY29tcG9uZW50XG4gKiB1c2luZyBpdCBpbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENscklmT3BlbiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBzZXR0ZXIgdGhhdCB1cGRhdGVzIElmT3BlblNlcnZpY2Uub3BlbiB3aXRoIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIEBJbnB1dCgnY2xySWZPcGVuJylcbiAgcHVibGljIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBvcGVuQ2hhbmdlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBldmVudCBlbWl0dGVyIHRoYXQgZW1pdHMgd2hlbiB0aGUgb3BlbiBwcm9wZXJ0eSBpcyBzZXQgdG8gYWxsb3cgZm9yIDJ3YXkgYmluZGluZyB3aGVuIHRoZSBkaXJlY3RpdmUgaXNcbiAgICogdXNlZCB3aXRoIGRlLXN0cnVjdHVyZWQgLyBkZS1zdWdhcmVkIHN5bnRheC5cbiAgICovXG4gIEBPdXRwdXQoJ2NscklmT3BlbkNoYW5nZScpIG9wZW5DaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8qKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IElmT3BlblNlcnZpY2Uub3BlbiB2YWx1ZS5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW47XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZlxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuaWZPcGVuU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgdGhpcy51cGRhdGVWaWV3KGNoYW5nZSk7XG4gICAgICB0aGlzLm9wZW5DaGFuZ2UuZW1pdChjaGFuZ2UpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRnVuY3Rpb24gdGhhdCB0YWtlcyBhIGJvb2xlYW4gdmFsdWUgYW5kIGVpdGhlciBjcmVhdGVkIGFuIGVtYmVkZGVkIHZpZXcgZm9yIHRoZSBhc3NvY2lhdGVkIFZpZXdDb250YWluZXJSZWYgb3IsXG4gICAqIENsZWFycyBhbGwgdmlld3MgZnJvbSB0aGUgVmlld0NvbnRhaW5lclJlZlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVWaWV3KHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWZBY3RpdmUgfSBmcm9tICcuL2lmLWFjdGl2ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2xySWZPcGVuIH0gZnJvbSAnLi9pZi1vcGVuLmRpcmVjdGl2ZSc7XG5cbmV4cG9ydCAqIGZyb20gJy4vaWYtYWN0aXZlLmRpcmVjdGl2ZSc7XG5leHBvcnQgKiBmcm9tICcuL2lmLW9wZW4uZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IENPTkRJVElPTkFMX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NscklmQWN0aXZlLCBDbHJJZk9wZW5dO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENPTkRJVElPTkFMX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0NPTkRJVElPTkFMX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbQ09ORElUSU9OQUxfRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJDb25kaXRpb25hbE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9jdXNUcmFwRGlyZWN0aXZlIH0gZnJvbSAnLi9mb2N1cy10cmFwLmRpcmVjdGl2ZSc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgRm9jdXNUcmFwVHJhY2tlciB7XG4gIHByaXZhdGUgX3ByZXZpb3VzRm9jdXNUcmFwczogRm9jdXNUcmFwRGlyZWN0aXZlW10gPSBbXTtcbiAgcHJpdmF0ZSBfY3VycmVudDogRm9jdXNUcmFwRGlyZWN0aXZlO1xuXG4gIGdldCBjdXJyZW50KCk6IEZvY3VzVHJhcERpcmVjdGl2ZSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gIH1cblxuICBzZXQgY3VycmVudCh2YWx1ZTogRm9jdXNUcmFwRGlyZWN0aXZlKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1c1RyYXBzLnB1c2godGhpcy5fY3VycmVudCk7XG4gICAgdGhpcy5fY3VycmVudCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IG5iRm9jdXNUcmFwcGVycygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0ZvY3VzVHJhcHMubGVuZ3RoO1xuICB9XG5cbiAgYWN0aXZhdGVQcmV2aW91c1RyYXBwZXIoKSB7XG4gICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX3ByZXZpb3VzRm9jdXNUcmFwcy5wb3AoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3QsXG4gIEluamVjdG9yLFxuICBPbkRlc3Ryb3ksXG4gIFBMQVRGT1JNX0lELFxuICBSZW5kZXJlcjIsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGb2N1c1RyYXBUcmFja2VyIH0gZnJvbSAnLi9mb2N1cy10cmFwLXRyYWNrZXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJGb2N1c1RyYXBdJyB9KVxuZXhwb3J0IGNsYXNzIEZvY3VzVHJhcERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgcHJldmlvdXNBY3RpdmVFbGVtZW50OiBhbnk7XG4gIHByaXZhdGUgZG9jdW1lbnQ6IERvY3VtZW50O1xuXG4gIHByaXZhdGUgdG9wUmVib3VuZEVsOiBhbnk7XG4gIHByaXZhdGUgYm90dG9tUmVib3VuZEVsOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBwcml2YXRlIGZvY3VzVHJhcHNUcmFja2VyOiBGb2N1c1RyYXBUcmFja2VyLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdFxuICApIHtcbiAgICB0aGlzLmRvY3VtZW50ID0gdGhpcy5pbmplY3Rvci5nZXQoRE9DVU1FTlQpO1xuICAgIHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIuY3VycmVudCA9IHRoaXM7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcsICcwJyk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpmb2N1c2luJywgWyckZXZlbnQnXSlcbiAgb25Gb2N1c0luKGV2ZW50OiBhbnkpIHtcbiAgICBjb25zdCBuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcblxuICAgIGlmICh0aGlzLmZvY3VzVHJhcHNUcmFja2VyLmN1cnJlbnQgPT09IHRoaXMgJiYgZXZlbnQudGFyZ2V0ICYmICFuYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIG5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUZvY3VzYWJsZU9mZlNjcmVlbkVsKCk6IGFueSB7XG4gICAgLy8gTm90IHVzaW5nIFJlbmRlcmVyMidzIGNyZWF0ZUVsZW1lbnQgbWV0aG9kIGJlY2F1c2UgdGhhdCBsZWFkcyB0byBET00gbGVha2FnZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yNjk1NFxuICAgIGNvbnN0IG9mZlNjcmVlblNwYW4gPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShvZmZTY3JlZW5TcGFuLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3Mob2ZmU2NyZWVuU3BhbiwgJ29mZnNjcmVlbi1mb2N1cy1yZWJvdW5kZXInKTtcblxuICAgIHJldHVybiBvZmZTY3JlZW5TcGFuO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRSZWJvdW5kRWxzKCkge1xuICAgIC8vIFdlIHdpbGwgYWRkIHRoZXNlIGZvY3VzIHJlYm91bmRpbmcgZWxlbWVudHMgb25seSBpbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgLy8gMS4gSXQgc2hvdWxkIGJlIHJ1bm5pbmcgaW5zaWRlIGJyb3dzZXIgcGxhdGZvcm0gYXMgaXQgYWNjZXNzZXMgZG9jdW1lbnQuYm9keSBlbGVtZW50XG4gICAgLy8gMi4gV2Ugc2hvdWxkIE5PVCBhZGQgdGhlbSBtb3JlIHRoYW4gb25jZS4gSGVuY2UsIHdlIGFyZSBjb3VudGluZyBhIG51bWJlciBvZiBmb2N1cyB0cmFwcGVyc1xuICAgIC8vICAgIGFuZCBvbmx5IGFkZCBvbiB0aGUgZmlyc3QgZm9jdXMgdHJhcHBlci5cblxuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIubmJGb2N1c1RyYXBwZXJzID09PSAxKSB7XG4gICAgICB0aGlzLnRvcFJlYm91bmRFbCA9IHRoaXMuY3JlYXRlRm9jdXNhYmxlT2ZmU2NyZWVuRWwoKTtcbiAgICAgIHRoaXMuYm90dG9tUmVib3VuZEVsID0gdGhpcy5jcmVhdGVGb2N1c2FibGVPZmZTY3JlZW5FbCgpO1xuICAgICAgLy8gQWRkIHJlYm91bmRCZWZvcmVUcmFwRWwgdG8gdGhlIGRvY3VtZW50IGJvZHkgYXMgdGhlIGZpcnN0IGNoaWxkXG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydEJlZm9yZSh0aGlzLmRvY3VtZW50LmJvZHksIHRoaXMudG9wUmVib3VuZEVsLCB0aGlzLmRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAvLyBBZGQgcmVib3VuZEFmdGVyVHJhcEVsIHRvIHRoZSBkb2N1bWVudCBib2R5IGFzIHRoZSBsYXN0IGNoaWxkXG4gICAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZG9jdW1lbnQuYm9keSwgdGhpcy5ib3R0b21SZWJvdW5kRWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlUmVib3VuZEVscygpIHtcbiAgICBpZiAoXG4gICAgICBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmXG4gICAgICB0aGlzLmZvY3VzVHJhcHNUcmFja2VyLm5iRm9jdXNUcmFwcGVycyA9PT0gMSAmJlxuICAgICAgdGhpcy50b3BSZWJvdW5kRWwgJiZcbiAgICAgIHRoaXMuYm90dG9tUmVib3VuZEVsXG4gICAgKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9jdW1lbnQuYm9keSwgdGhpcy50b3BSZWJvdW5kRWwpO1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDaGlsZCh0aGlzLmRvY3VtZW50LmJvZHksIHRoaXMuYm90dG9tUmVib3VuZEVsKTtcblxuICAgICAgLy8gVGhlc2UgYXJlIGhlcmUgdG8gdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgIC8vIHdlIGNvbXBsZXRlbHkgZGVsZXRlIGFsbCB0cmFjZXMgb2YgdGhlIHJlbW92ZWQgRE9NIG9iamVjdHMuXG4gICAgICBkZWxldGUgdGhpcy50b3BSZWJvdW5kRWw7XG4gICAgICBkZWxldGUgdGhpcy5ib3R0b21SZWJvdW5kRWw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFByZXZpb3VzRm9jdXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50ICYmIHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50LmZvY3VzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgdGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+dGhpcy5kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHRoaXMuYWRkUmVib3VuZEVscygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVSZWJvdW5kRWxzKCk7XG4gICAgdGhpcy5zZXRQcmV2aW91c0ZvY3VzKCk7XG4gICAgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5hY3RpdmF0ZVByZXZpb3VzVHJhcHBlcigpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c1RyYXBEaXJlY3RpdmUgfSBmcm9tICcuL2ZvY3VzLXRyYXAuZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IEZPQ1VTX1RSQVBfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbRm9jdXNUcmFwRGlyZWN0aXZlXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGT0NVU19UUkFQX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0ZPQ1VTX1RSQVBfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtGT0NVU19UUkFQX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJGb2N1c1RyYXBNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBjb25zdCBVUF9BUlJPVzogbnVtYmVyID0gMzg7XG5leHBvcnQgY29uc3QgRE9XTl9BUlJPVzogbnVtYmVyID0gNDA7XG5leHBvcnQgY29uc3QgUklHSFRfQVJST1c6IG51bWJlciA9IDM5O1xuZXhwb3J0IGNvbnN0IExFRlRfQVJST1c6IG51bWJlciA9IDM3O1xuZXhwb3J0IGNvbnN0IEVOVEVSOiBudW1iZXIgPSAxMztcbmV4cG9ydCBjb25zdCBTUEFDRTogbnVtYmVyID0gMzI7XG5leHBvcnQgY29uc3QgVEFCOiBudW1iZXIgPSA5O1xuZXhwb3J0IGNvbnN0IEVTQzogbnVtYmVyID0gMjc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZW4tMDAxIHNob3J0IGxvY2FsZSBkYXRlIGZvcm1hdC4gU2V0dGluZyBhcyBkZWZhdWx0LlxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9MT0NBTEVfRk9STUFUOiBzdHJpbmcgPSAnZGQvTU0veSc7XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdGVfZm9ybWF0X2J5X2NvdW50cnlcbmV4cG9ydCBjb25zdCBMSVRUTEVfRU5ESUFOX1JFR0VYOiBSZWdFeHAgPSAvZCsuK20rLit5Ky9pO1xuZXhwb3J0IGNvbnN0IE1JRERMRV9FTkRJQU5fUkVHRVg6IFJlZ0V4cCA9IC9tKy4rZCsuK3krL2k7XG4vLyBObyBuZWVkIGZvciBCSUdfRU5ESUFOX1JFR0VYIGJlY2F1c2UgYW55dGhpbmcgdGhhdCBkb2Vzbid0IHNhdGlzZnkgdGhlIGFib3ZlIDJcbi8vIGlzIGF1dG9tYXRpY2FsbHkgQklHX0VORElBTlxuXG5leHBvcnQgY29uc3QgREVMSU1JVEVSX1JFR0VYOiBSZWdFeHAgPSAvZCt8bSt8eSsvaTtcblxuZXhwb3J0IGNvbnN0IFVTRVJfSU5QVVRfUkVHRVg6IFJlZ0V4cCA9IC9cXGQrL2c7XG5cbmV4cG9ydCBjb25zdCBNT0JJTEVfVVNFUkFHRU5UX1JFR0VYOiBSZWdFeHAgPSAvTW9iaS9pO1xuXG5leHBvcnQgY29uc3QgUlRMX1JFR0VYOiBSZWdFeHAgPSAvXFx1MjAwZi9nO1xuXG5leHBvcnQgY29uc3QgWUVBUjogc3RyaW5nID0gJ1lZWVknO1xuZXhwb3J0IGNvbnN0IE1PTlRIOiBzdHJpbmcgPSAnTU0nO1xuZXhwb3J0IGNvbnN0IERBVEU6IHN0cmluZyA9ICdERCc7XG5cbmV4cG9ydCB0eXBlIEZvcm1hdFR5cGUgPSAnTElUVExFX0VORElBTicgfCAnTUlERExFX0VORElBTicgfCAnQklHX0VORElBTic7XG5cbmV4cG9ydCB0eXBlIElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIHJlYWRvbmx5IG5hbWU6IEZvcm1hdFR5cGU7XG4gIHJlYWRvbmx5IGZvcm1hdDogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddO1xufTtcblxuZXhwb3J0IGNvbnN0IExJVFRMRV9FTkRJQU46IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIG5hbWU6ICdMSVRUTEVfRU5ESUFOJyxcbiAgZm9ybWF0OiBbREFURSwgTU9OVEgsIFlFQVJdLFxufTtcblxuZXhwb3J0IGNvbnN0IE1JRERMRV9FTkRJQU46IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIG5hbWU6ICdNSURETEVfRU5ESUFOJyxcbiAgZm9ybWF0OiBbTU9OVEgsIERBVEUsIFlFQVJdLFxufTtcblxuZXhwb3J0IGNvbnN0IEJJR19FTkRJQU46IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIG5hbWU6ICdCSUdfRU5ESUFOJyxcbiAgZm9ybWF0OiBbWUVBUiwgTU9OVEgsIERBVEVdLFxufTtcblxuZXhwb3J0IGNvbnN0IE5PX09GX0RBWVNfSU5fQV9XRUVLOiBudW1iZXIgPSA3O1xuZXhwb3J0IGNvbnN0IE5PX09GX1JPV1NfSU5fQ0FMRU5EQVJfVklFVzogbnVtYmVyID0gNjtcbmV4cG9ydCBjb25zdCBUT1RBTF9EQVlTX0lOX0RBWVNfVklFVzogbnVtYmVyID0gTk9fT0ZfREFZU19JTl9BX1dFRUsgKiBOT19PRl9ST1dTX0lOX0NBTEVOREFSX1ZJRVc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIElmIHdlIGdvIHRvIHRoZSBuZXh0IG1vbnRoLCBidXQgdXNlIGEgZGF5IG9mIDAsIGl0IHJldHVybnMgdGhlIGxhc3QgZGF5IGZyb20gdGhlIHByZXZpb3VzIG1vbnRoXG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIDApLmdldERhdGUoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXkgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGRhdGUgd2hlcmUgMCByZXByZXNlbnRzIFN1bmRheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERheSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlcik6IFdlZWtEYXkge1xuICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUpLmdldERheSgpO1xufVxuXG4vKipcbiAqIFRha2VzIGluIGEgeWVhciBhbmQgaWYgaXQgaXMgYSAyIGRpZ2l0IHllYXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgNCBkaWdpdCB5ZWFyLlxuICogV2luZG93IG9mIDgwIHllYXJzIGJlZm9yZSBhbmQgMjAgeWVhcnMgYWZ0ZXIgdGhlIHByZXNlbnQgeWVhci5cbiAqIENyZWRpdDogaHR0cHM6Ly9naXRodWIuY29tL2dsb2JhbGl6ZWpzL2dsb2JhbGl6ZS9ibG9iL2UxYjMxY2Q2YTRmMWNmZjc1YjE4NWI2OGI3YTMyMjIwYWFjNTE5NmYvc3JjL2RhdGUvcGFyc2UuanNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVG9Gb3VyRGlnaXRZZWFyKHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh5ZWFyID4gOTk5OSB8fCAoeWVhciA+IDEwMCAmJiB5ZWFyIDwgOTk5KSB8fCB5ZWFyIDwgMTApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHllYXIgPiA5OTkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfVxuICBjb25zdCBjdXJyWWVhcjogbnVtYmVyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBjZW50dXJ5OiBudW1iZXIgPSBNYXRoLmZsb29yKGN1cnJZZWFyIC8gMTAwKSAqIDEwMDtcbiAgbGV0IHJlc3VsdDogbnVtYmVyID0geWVhciArIGNlbnR1cnk7XG4gIGlmIChyZXN1bHQgPiBjdXJyWWVhciArIDIwKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IC0gMTAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXRlc0FyZUVxdWFsKGRhdGUxOiBEYXRlLCBkYXRlMjogRGF0ZSkge1xuICBpZiAoZGF0ZTEgaW5zdGFuY2VvZiBEYXRlICYmIGRhdGUyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBkYXRlMS5nZXRGdWxsWWVhcigpID09PSBkYXRlMi5nZXRGdWxsWWVhcigpICYmXG4gICAgICBkYXRlMS5nZXRNb250aCgpID09PSBkYXRlMi5nZXRNb250aCgpICYmXG4gICAgICBkYXRlMS5nZXREYXRlKCkgPT09IGRhdGUyLmdldERhdGUoKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi9kYXkubW9kZWwnO1xuXG5leHBvcnQgY2xhc3MgRGF5Vmlld01vZGVsIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGRheU1vZGVsOiBEYXlNb2RlbCxcbiAgICBwdWJsaWMgaXNUb2RheXNEYXRlOiBib29sZWFuID0gZmFsc2UsXG4gICAgcHVibGljIGlzRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBwdWJsaWMgaXNTZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlLFxuICAgIHB1YmxpYyBpc0ZvY3VzYWJsZTogYm9vbGVhbiA9IGZhbHNlXG4gICkge31cblxuICAvKipcbiAgICogR2V0cyB0aGUgdGFiIGluZGV4IGJhc2VkIG9uIHRoZSBpc0ZvY3VzYWJsZSBmbGFnLlxuICAgKi9cbiAgZ2V0IHRhYkluZGV4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaXNGb2N1c2FibGUgPyAwIDogLTE7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCB9IGZyb20gJy4uL3V0aWxzL2RhdGUtdXRpbHMnO1xuXG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vZGF5Lm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyTW9kZWwge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgeWVhcjogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgbW9udGg6IG51bWJlcikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZURheXNJbkNhbGVuZGFyKCk7XG4gIH1cblxuICBkYXlzOiBEYXlNb2RlbFtdO1xuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgdGhlIGRheXMgYXJyYXkgd2l0aCB0aGUgRGF5TW9kZWxzIGluIHRoZSBjdXJyZW50IENhbGVuZGFyLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplRGF5c0luQ2FsZW5kYXIoKTogdm9pZCB7XG4gICAgY29uc3Qgbm9PZkRheXNJbkNhbGVuZGFyOiBudW1iZXIgPSBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gICAgdGhpcy5kYXlzID0gQXJyYXkobm9PZkRheXNJbkNhbGVuZGFyKVxuICAgICAgLmZpbGwobnVsbClcbiAgICAgIC5tYXAoKGRhdGUsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgRGF5TW9kZWwodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCBpbmRleCArIDEpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjYWxlbmRhciBwYXNzZWQgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgY2FsZW5kYXIuXG4gICAqL1xuICBpc0VxdWFsKGNhbGVuZGFyOiBDYWxlbmRhck1vZGVsKSB7XG4gICAgaWYgKGNhbGVuZGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy55ZWFyID09PSBjYWxlbmRhci55ZWFyICYmIHRoaXMubW9udGggPT09IGNhbGVuZGFyLm1vbnRoO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgRGF5TW9kZWwgaXMgaW4gdGhlIENhbGVuZGFyXG4gICAqL1xuICBpc0RheUluQ2FsZW5kYXIoZGF5OiBEYXlNb2RlbCk6IGJvb2xlYW4ge1xuICAgIGlmIChkYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnllYXIgPT09IGRheS55ZWFyICYmIHRoaXMubW9udGggPT09IGRheS5tb250aDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgQ2FsZW5kYXJNb2RlbCBvZiB0aGUgcHJldmlvdXMgbW9udGguXG4gICAqL1xuICBwcmV2aW91c01vbnRoKCk6IENhbGVuZGFyTW9kZWwge1xuICAgIGlmICh0aGlzLm1vbnRoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENhbGVuZGFyTW9kZWwodGhpcy55ZWFyIC0gMSwgMTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IENhbGVuZGFyTW9kZWwodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgQ2FsZW5kYXJNb2RlbCBvZiB0aGUgbmV4dCBtb250aC5cbiAgICovXG4gIG5leHRNb250aCgpOiBDYWxlbmRhck1vZGVsIHtcbiAgICBpZiAodGhpcy5tb250aCA9PT0gMTEpIHtcbiAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnllYXIgKyAxLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhck1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCArIDEpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDYWxlbmRhck1vZGVsIH0gZnJvbSAnLi9jYWxlbmRhci5tb2RlbCc7XG5cbmV4cG9ydCBjbGFzcyBEYXlNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB5ZWFyOiBudW1iZXIsIHB1YmxpYyByZWFkb25seSBtb250aDogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgZGF0ZTogbnVtYmVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDYWxlbmRhciBmb3IgdGhlIGN1cnJlbnQgRGF5TW9kZWwuXG4gICAqL1xuICBnZXQgY2FsZW5kYXIoKTogQ2FsZW5kYXJNb2RlbCB7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhck1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXNzZWQgQ2FsZW5kYXJEYXRlIGlzIGVxdWFsIHRvIGl0c2VsZi5cbiAgICovXG4gIGlzRXF1YWwoZGF5OiBEYXlNb2RlbCkge1xuICAgIGlmIChkYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnllYXIgPT09IGRheS55ZWFyICYmIHRoaXMubW9udGggPT09IGRheS5tb250aCAmJiB0aGlzLmRhdGUgPT09IGRheS5kYXRlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0b0RhdGUoKTogRGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IERheU1vZGVsIHdoaWNoIGlzIGluY3JlbWVudGVkIGJhc2VkIG9uIHRoZSB2YWx1ZSBwYXNzZWQuXG4gICAqL1xuICBpbmNyZW1lbnRCeSh2YWx1ZTogbnVtYmVyKTogRGF5TW9kZWwge1xuICAgIC8vIENyZWF0aW5nIG5ldyBKYXZhc2NyaXB0IERhdGUgb2JqZWN0IHRvIGluY3JlbWVudCBiZWNhdXNlXG4gICAgLy8gaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHRha2UgY2FyZSBvZiBzd2l0Y2hpbmcgdG8gbmV4dCBvciBwcmV2aW91c1xuICAgIC8vIG1vbnRocyAmIHllYXJzIHdpdGhvdXQgd2UgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGl0LlxuICAgIGNvbnN0IGRhdGU6IERhdGUgPSBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF0ZSArIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IERheU1vZGVsKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBjdXJyZW50IGRheSBtb2RlbC5cbiAgICovXG4gIGNsb25lKCk6IERheU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IERheU1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXRlKTtcbiAgfVxuXG4gIHB1YmxpYyB0b0RhdGVTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBOT19PRl9EQVlTX0lOX0FfV0VFSywgTk9fT0ZfUk9XU19JTl9DQUxFTkRBUl9WSUVXLCBUT1RBTF9EQVlTX0lOX0RBWVNfVklFVyB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREYXkgfSBmcm9tICcuLi91dGlscy9kYXRlLXV0aWxzJztcblxuaW1wb3J0IHsgQ2FsZW5kYXJNb2RlbCB9IGZyb20gJy4vY2FsZW5kYXIubW9kZWwnO1xuaW1wb3J0IHsgRGF5Vmlld01vZGVsIH0gZnJvbSAnLi9kYXktdmlldy5tb2RlbCc7XG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vZGF5Lm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyVmlld01vZGVsIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNhbGVuZGFyOiBDYWxlbmRhck1vZGVsLFxuICAgIHByaXZhdGUgc2VsZWN0ZWREYXk6IERheU1vZGVsLFxuICAgIHByaXZhdGUgZm9jdXNhYmxlRGF5OiBEYXlNb2RlbCxcbiAgICBwcml2YXRlIHRvZGF5OiBEYXlNb2RlbCxcbiAgICBwdWJsaWMgZmlyc3REYXlPZldlZWs6IG51bWJlclxuICApIHtcbiAgICB0aGlzLmluaXRpYWxpemVDYWxlbmRhclZpZXcoKTtcbiAgfVxuXG4gIHByaXZhdGUgY3Vyck1vbnRoRGF5Vmlld3M6IERheVZpZXdNb2RlbFtdID0gW107XG5cbiAgcHJpdmF0ZSBfY2FsZW5kYXJWaWV3OiBEYXlWaWV3TW9kZWxbXVtdO1xuXG4gIC8qKlxuICAgKiBEYXlWaWV3TW9kZWwgbWF0cml4LiBTaXplIDZ4N1xuICAgKi9cbiAgZ2V0IGNhbGVuZGFyVmlldygpOiBEYXlWaWV3TW9kZWxbXVtdIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXJWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIDZ4NyBtYXRyaXggb2YgRGF5Vmlld01vZGVsIGJhc2VkIG9uIHRoZSBDYWxlbmRhci5cbiAgICogVGhlIDZ4NyBtYXRyaXggaXMgc3RydWN0dXJlZCBhY2NvcmRpbmcgdG8gdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICogNiByb3dzIHRvIGFjY29tbW9kYXRlIG1vbnRocyB3aGljaCBtaWdodCBoYXZlIGRhdGVzIHNwYW5uaW5nIG92ZXIgNiB3ZWVrcy5cbiAgICogNyBjb2x1bW5zIGJlY2F1c2UgdGhlcmUgYXJlIDcgZGF5cyBpbiBhIHdlZWsgOlAgOkRcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUNhbGVuZGFyVmlldygpOiB2b2lkIHtcbiAgICAvLyBHZW5lcmF0ZSBwcmV2IGFuZCBuZXh0IG1vbnRoIGNhbGVuZGFyIG1vZGVscy5cbiAgICBjb25zdCBwcmV2TW9udGhDYWxlbmRhcjogQ2FsZW5kYXJNb2RlbCA9IHRoaXMuY2FsZW5kYXIucHJldmlvdXNNb250aCgpO1xuICAgIGNvbnN0IG5leHRNb250aENhbGVuZGFyOiBDYWxlbmRhck1vZGVsID0gdGhpcy5jYWxlbmRhci5uZXh0TW9udGgoKTtcblxuICAgIC8vIEdldCBubyBvZiBkYXlzIGZyb20gcHJldiBhbmQgbmV4dCBtb250aHMuXG4gICAgY29uc3QgZGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXc6IG51bWJlciA9IHRoaXMubnVtRGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcoXG4gICAgICB0aGlzLmNhbGVuZGFyLnllYXIsXG4gICAgICB0aGlzLmNhbGVuZGFyLm1vbnRoXG4gICAgKTtcbiAgICBjb25zdCBkYXlzRnJvbU5leHRNb250aEluQ2FsVmlldzogbnVtYmVyID1cbiAgICAgIFRPVEFMX0RBWVNfSU5fREFZU19WSUVXIC0gKHRoaXMuY2FsZW5kYXIuZGF5cy5sZW5ndGggKyBkYXlzRnJvbVByZXZNb250aEluQ2FsVmlldyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBwcmV2LCBjdXJyIGFuZCBuZXh0IGRheSB2aWV3IG1vZGVsc1xuICAgIGxldCBwcmV2TW9udGhEYXlWaWV3czogRGF5Vmlld01vZGVsW10gPSBbXTtcbiAgICBsZXQgbmV4dE1vbnRoRGF5Vmlld3M6IERheVZpZXdNb2RlbFtdID0gW107XG5cbiAgICBpZiAoZGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcgPiAwKSB7XG4gICAgICBwcmV2TW9udGhEYXlWaWV3cyA9IHRoaXMuZ2VuZXJhdGVEYXlWaWV3TW9kZWxzKFxuICAgICAgICBwcmV2TW9udGhDYWxlbmRhci5kYXlzLnNsaWNlKC0xICogZGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcpLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJNb250aERheVZpZXdzID0gdGhpcy5nZW5lcmF0ZURheVZpZXdNb2RlbHModGhpcy5jYWxlbmRhci5kYXlzLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICBpZiAoZGF5c0Zyb21OZXh0TW9udGhJbkNhbFZpZXcgPiAwKSB7XG4gICAgICBuZXh0TW9udGhEYXlWaWV3cyA9IHRoaXMuZ2VuZXJhdGVEYXlWaWV3TW9kZWxzKFxuICAgICAgICBuZXh0TW9udGhDYWxlbmRhci5kYXlzLnNsaWNlKDAsIGRheXNGcm9tTmV4dE1vbnRoSW5DYWxWaWV3KSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgY2FsZW5kYXIgdmlldyBhbmQgaW5pdGlhbGl6ZSBmbGFnc1xuICAgIHRoaXMuX2NhbGVuZGFyVmlldyA9IHRoaXMuZ2VuZXJhdGVDYWxlbmRhclZpZXcocHJldk1vbnRoRGF5Vmlld3MsIHRoaXMuY3Vyck1vbnRoRGF5Vmlld3MsIG5leHRNb250aERheVZpZXdzKTtcbiAgICB0aGlzLmluaXRpYWxpemVTZWxlY3RlZERheSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZvY3VzYWJsZURheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIERheVZpZXdNb2RlbCBhcnJheSBiYXNlZCBvbiB0aGUgRGF5TW9kZWwgcGFzc2VkXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlRGF5Vmlld01vZGVscyhkYXlzOiBEYXlNb2RlbFtdLCBpc0Rpc2FibGVkOiBib29sZWFuLCBpc0N1cnJlbnRDYWxlbmRhcjogYm9vbGVhbik6IERheVZpZXdNb2RlbFtdIHtcbiAgICBjb25zdCBkYXlWaWV3czogRGF5Vmlld01vZGVsW10gPSBkYXlzLm1hcChkYXkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBEYXlWaWV3TW9kZWwoZGF5LCBmYWxzZSwgaXNEaXNhYmxlZCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBpZiAoaXNDdXJyZW50Q2FsZW5kYXIgJiYgdGhpcy5jYWxlbmRhci5pc0RheUluQ2FsZW5kYXIodGhpcy50b2RheSkpIHtcbiAgICAgIGRheVZpZXdzW3RoaXMudG9kYXkuZGF0ZSAtIDFdLmlzVG9kYXlzRGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkYXlWaWV3cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIGN1cnJlbnQgbW9udGggdG8gZmlndXJlIG91dCBob3cgbWFueSBkYXRlcyBvZiBwcmV2aW91cyBtb250aFxuICAgKiBhcmUgbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBDYWxlbmRhciBWaWV3IGJhc2VkIG9uIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIGVnOiBBc3N1bWluZyBsb2NhbGUgZW4tVVMsIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMgU3VuZGF5LFxuICAgKiBpZiBmaXJzdCBkYXkgb2YgdGhlIGN1cnJlbnQgbW9udGggbGFuZHMgb24gV2VkbmVzZGF5LCB0aGVuXG4gICAqICh0aGlzLmdldERheSBmdW5jdGlvbiB3b3VsZCByZXR1cm4gMyBzaW5jZVxuICAgKiBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMgMCksIHdlIG5lZWQgdGhlIDMgZGF5cyBmcm9tIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICovXG4gIHByaXZhdGUgbnVtRGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcoY3VycmVudFllYXI6IG51bWJlciwgY3VycmVudE1vbnRoOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGZpcnN0RGF5T2ZDdXJyTW9udGg6IG51bWJlciA9IGdldERheShjdXJyZW50WWVhciwgY3VycmVudE1vbnRoLCAxKTtcblxuICAgIGlmIChmaXJzdERheU9mQ3Vyck1vbnRoID49IHRoaXMuZmlyc3REYXlPZldlZWspIHtcbiAgICAgIHJldHVybiBmaXJzdERheU9mQ3Vyck1vbnRoIC0gdGhpcy5maXJzdERheU9mV2VlaztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE5PX09GX0RBWVNfSU5fQV9XRUVLICsgZmlyc3REYXlPZkN1cnJNb250aCAtIHRoaXMuZmlyc3REYXlPZldlZWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgRGF5IHBhc3NlZCBpcyBpbiB0aGUgQ2FsZW5kYXJWaWV3LlxuICAgKi9cbiAgcHJpdmF0ZSBpc0RheUluQ2FsZW5kYXJWaWV3KGRheTogRGF5TW9kZWwpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY2FsZW5kYXIuaXNEYXlJbkNhbGVuZGFyKGRheSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVXNpbmcgdGhlIERheVZpZXdNb2RlbHMgZnJvbSB0aGUgcHJldmlvdXMsIGN1cnJlbnQgYW5kIG5leHQgbW9udGgsIHRoaXMgZnVuY3Rpb25cbiAgICogZ2VuZXJhdGVzIHRoZSBDYWxlbmRhclZpZXcuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlQ2FsZW5kYXJWaWV3KHByZXY6IERheVZpZXdNb2RlbFtdLCBjdXJyOiBEYXlWaWV3TW9kZWxbXSwgbmV4dDogRGF5Vmlld01vZGVsW10pOiBEYXlWaWV3TW9kZWxbXVtdIHtcbiAgICBjb25zdCBjb21iaW5hdGlvbkFycjogRGF5Vmlld01vZGVsW10gPSBbLi4ucHJldiwgLi4uY3VyciwgLi4ubmV4dF07XG5cbiAgICBjb25zdCBjYWxlbmRhclZpZXc6IERheVZpZXdNb2RlbFtdW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5PX09GX1JPV1NfSU5fQ0FMRU5EQVJfVklFVzsgaSsrKSB7XG4gICAgICBjYWxlbmRhclZpZXdbaV0gPSBjb21iaW5hdGlvbkFyci5zbGljZShpICogTk9fT0ZfREFZU19JTl9BX1dFRUssIChpICsgMSkgKiBOT19PRl9EQVlTX0lOX0FfV0VFSyk7XG4gICAgfVxuICAgIHJldHVybiBjYWxlbmRhclZpZXc7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgc2VsZWN0ZWQgZGF5IGlmIHRoZSBkYXkgaXMgaW4gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplU2VsZWN0ZWREYXkoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWREYXkgJiYgdGhpcy5pc0RheUluQ2FsZW5kYXJWaWV3KHRoaXMuc2VsZWN0ZWREYXkpKSB7XG4gICAgICB0aGlzLmN1cnJNb250aERheVZpZXdzW3RoaXMuc2VsZWN0ZWREYXkuZGF0ZSAtIDFdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZm9jdXNhYmxlIGRheSBpZiB0aGUgZGF5IGlzIGluIHRoZSBjYWxlbmRhci4gSWYgZm9jdXNhYmxlIGRheSBpcyBub3Qgc2V0LCB0aGVuXG4gICAqIHdlIGNoZWNrIGZvciB0aGUgc2VsZWN0ZWQgZGF5LiBJZiBzZWxlY3RlZCBkYXkgaXMgbm90IHNldCB0aGVuIGNoZWNrIGlmIHRvZGF5IGlzIGluIHRoZSBjdXJyZW50XG4gICAqIGNhbGVuZGFyLiBJZiBub3QgdGhlbiBqdXN0IHNldCB0aGUgMTV0aCBvZiB0aGUgY3VycmVudCBjYWxlbmRhciBtb250aC5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUZvY3VzYWJsZURheSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5mb2N1c2FibGVEYXkgJiYgdGhpcy5pc0RheUluQ2FsZW5kYXJWaWV3KHRoaXMuZm9jdXNhYmxlRGF5KSkge1xuICAgICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMuZm9jdXNhYmxlRGF5LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWREYXkgJiYgdGhpcy5pc0RheUluQ2FsZW5kYXJWaWV3KHRoaXMuc2VsZWN0ZWREYXkpKSB7XG4gICAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcodGhpcy5zZWxlY3RlZERheSwgdHJ1ZSk7XG4gICAgICB0aGlzLmZvY3VzYWJsZURheSA9IHRoaXMuc2VsZWN0ZWREYXkuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXlJbkNhbGVuZGFyVmlldyh0aGlzLnRvZGF5KSkge1xuICAgICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMudG9kYXksIHRydWUpO1xuICAgICAgdGhpcy5mb2N1c2FibGVEYXkgPSB0aGlzLnRvZGF5LmNsb25lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9jdXNhYmxlRGF5ID0gbmV3IERheU1vZGVsKHRoaXMuY2FsZW5kYXIueWVhciwgdGhpcy5jYWxlbmRhci5tb250aCwgMTUpO1xuICAgICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMuZm9jdXNhYmxlRGF5LCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldEZvY3VzYWJsZUZsYWcoZGF5OiBEYXlNb2RlbCwgZmxhZzogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmIChkYXkpIHtcbiAgICAgIHRoaXMuY3Vyck1vbnRoRGF5Vmlld3NbZGF5LmRhdGUgLSAxXS5pc0ZvY3VzYWJsZSA9IGZsYWc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZvY3VzYWJsZSBkYXkgaW4gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgdXBkYXRlRm9jdXNhYmxlRGF5KGRheTogRGF5TW9kZWwpOiB2b2lkIHtcbiAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcodGhpcy5mb2N1c2FibGVEYXksIGZhbHNlKTtcbiAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcoZGF5LCB0cnVlKTtcbiAgICB0aGlzLmZvY3VzYWJsZURheSA9IGRheTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDYWxlbmRhck1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvY2FsZW5kYXIubW9kZWwnO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuLi9tb2RlbC9kYXkubW9kZWwnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBpcyByZXNwb25zaWJsZSBmb3I6XG4gKiAxLiBJbml0aWFsaXppbmcgdGhlIGRpc3BsYXllZCBjYWxlbmRhci5cbiAqIDIuIE1vdmluZyB0aGUgY2FsZW5kYXIgdG8gdGhlIG5leHQsIHByZXZpb3VzIG9yIGN1cnJlbnQgbW9udGhzXG4gKiAzLiBNYW5hZ2luZyB0aGUgZm9jdXNlZCBhbmQgc2VsZWN0ZWQgZGF5IG1vZGVscy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVOYXZpZ2F0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgX2Rpc3BsYXllZENhbGVuZGFyOiBDYWxlbmRhck1vZGVsO1xuXG4gIGdldCBkaXNwbGF5ZWRDYWxlbmRhcigpOiBDYWxlbmRhck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXI7XG4gIH1cblxuICAvLyBub3QgYSBzZXR0ZXIgYmVjYXVzZSBpIHdhbnQgdGhpcyB0byByZW1haW4gcHJpdmF0ZVxuICBwcml2YXRlIHNldERpc3BsYXllZENhbGVuZGFyKHZhbHVlOiBDYWxlbmRhck1vZGVsKSB7XG4gICAgaWYgKCF0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhci5pc0VxdWFsKHZhbHVlKSkge1xuICAgICAgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyQ2hhbmdlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFyaWFibGUgdG8gc3RvcmUgdG9kYXkncyBkYXRlLlxuICAgKi9cbiAgcHJpdmF0ZSBfdG9kYXlzRnVsbERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICBwcml2YXRlIF90b2RheTogRGF5TW9kZWw7XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplVG9kYXlzRGF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl90b2RheXNGdWxsRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5fdG9kYXkgPSBuZXcgRGF5TW9kZWwoXG4gICAgICB0aGlzLl90b2RheXNGdWxsRGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgdGhpcy5fdG9kYXlzRnVsbERhdGUuZ2V0TW9udGgoKSxcbiAgICAgIHRoaXMuX3RvZGF5c0Z1bGxEYXRlLmdldERhdGUoKVxuICAgICk7XG4gIH1cblxuICBnZXQgdG9kYXkoKTogRGF5TW9kZWwge1xuICAgIHJldHVybiB0aGlzLl90b2RheTtcbiAgfVxuXG4gIHB1YmxpYyBzZWxlY3RlZERheTogRGF5TW9kZWw7XG5cbiAgcHJpdmF0ZSBfc2VsZWN0ZWREYXlDaGFuZ2U6IFN1YmplY3Q8RGF5TW9kZWw+ID0gbmV3IFN1YmplY3Q8RGF5TW9kZWw+KCk7XG5cbiAgZ2V0IHNlbGVjdGVkRGF5Q2hhbmdlKCk6IE9ic2VydmFibGU8RGF5TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWREYXlDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhhdCB0aGUgc2VsZWN0ZWQgZGF5IGhhcyBjaGFuZ2VkIHNvIHRoYXQgdGhlIGRhdGUgY2FuIGJlIGVtaXR0ZWQgdG8gdGhlIHVzZXIuXG4gICAqIE5vdGU6IE9ubHkgdG8gYmUgY2FsbGVkIGZyb20gZGF5LnRzXG4gICAqL1xuICBub3RpZnlTZWxlY3RlZERheUNoYW5nZWQoZGF5TW9kZWw6IERheU1vZGVsKSB7XG4gICAgdGhpcy5zZWxlY3RlZERheSA9IGRheU1vZGVsO1xuICAgIHRoaXMuX3NlbGVjdGVkRGF5Q2hhbmdlLm5leHQoZGF5TW9kZWwpO1xuICB9XG5cbiAgcHVibGljIGZvY3VzZWREYXk6IERheU1vZGVsO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2FsZW5kYXIgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRheS5cbiAgICovXG4gIGluaXRpYWxpemVDYWxlbmRhcigpOiB2b2lkIHtcbiAgICB0aGlzLmZvY3VzZWREYXkgPSBudWxsOyAvLyBDYW4gYmUgcmVtb3ZlZCBsYXRlciBvbiB0aGUgc3RvcmUgZm9jdXNcbiAgICB0aGlzLmluaXRpYWxpemVUb2RheXNEYXRlKCk7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWREYXkpIHtcbiAgICAgIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyID0gbmV3IENhbGVuZGFyTW9kZWwodGhpcy5zZWxlY3RlZERheS55ZWFyLCB0aGlzLnNlbGVjdGVkRGF5Lm1vbnRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnRvZGF5LnllYXIsIHRoaXMudG9kYXkubW9udGgpO1xuICAgIH1cbiAgfVxuXG4gIGNoYW5nZU1vbnRoKG1vbnRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKG5ldyBDYWxlbmRhck1vZGVsKHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLnllYXIsIG1vbnRoKSk7XG4gIH1cblxuICBjaGFuZ2VZZWFyKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIobmV3IENhbGVuZGFyTW9kZWwoeWVhciwgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIubW9udGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgZGlzcGxheWVkIGNhbGVuZGFyIHRvIHRoZSBuZXh0IG1vbnRoLlxuICAgKi9cbiAgbW92ZVRvTmV4dE1vbnRoKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIodGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIubmV4dE1vbnRoKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBkaXNwbGF5ZWQgY2FsZW5kYXIgdG8gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgbW92ZVRvUHJldmlvdXNNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLnByZXZpb3VzTW9udGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGRpc3BsYXllZCBjYWxlbmRhciB0byB0aGUgY3VycmVudCBtb250aCBhbmQgeWVhci5cbiAgICovXG4gIG1vdmVUb0N1cnJlbnRNb250aCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZGlzcGxheWVkQ2FsZW5kYXIuaXNEYXlJbkNhbGVuZGFyKHRoaXMudG9kYXkpKSB7XG4gICAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKG5ldyBDYWxlbmRhck1vZGVsKHRoaXMudG9kYXkueWVhciwgdGhpcy50b2RheS5tb250aCkpO1xuICAgIH1cbiAgICB0aGlzLl9mb2N1c09uQ2FsZW5kYXJDaGFuZ2UubmV4dCgpO1xuICB9XG5cbiAgaW5jcmVtZW50Rm9jdXNEYXkodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZm9jdXNlZERheSA9IHRoaXMuZm9jdXNlZERheS5pbmNyZW1lbnRCeSh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLmlzRGF5SW5DYWxlbmRhcih0aGlzLmZvY3VzZWREYXkpKSB7XG4gICAgICB0aGlzLl9mb2N1c2VkRGF5Q2hhbmdlLm5leHQodGhpcy5mb2N1c2VkRGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREaXNwbGF5ZWRDYWxlbmRhcih0aGlzLmZvY3VzZWREYXkuY2FsZW5kYXIpO1xuICAgIH1cbiAgICB0aGlzLl9mb2N1c09uQ2FsZW5kYXJDaGFuZ2UubmV4dCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2U6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG9ic2VydmFibGUgbGV0cyB0aGUgc3Vic2NyaWJlciBrbm93IHRoYXQgdGhlIGRpc3BsYXllZCBjYWxlbmRhciBoYXMgY2hhbmdlZC5cbiAgICovXG4gIGdldCBkaXNwbGF5ZWRDYWxlbmRhckNoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9mb2N1c09uQ2FsZW5kYXJDaGFuZ2U6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG9ic2VydmFibGUgbGV0cyB0aGUgc3Vic2NyaWJlciBrbm93IHRoYXQgdGhlIGZvY3VzIHNob3VsZCBiZSBhcHBsaWVkIG9uIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIGdldCBmb2N1c09uQ2FsZW5kYXJDaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzT25DYWxlbmRhckNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZvY3VzZWREYXlDaGFuZ2U6IFN1YmplY3Q8RGF5TW9kZWw+ID0gbmV3IFN1YmplY3Q8RGF5TW9kZWw+KCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JzZXJ2YWJsZSBsZXRzIHRoZSBzdWJzY3JpYmVyIGtub3cgdGhhdCB0aGUgZm9jdXNlZCBkYXkgaW4gdGhlIGRpc3BsYXllZCBjYWxlbmRhciBoYXMgY2hhbmdlZC5cbiAgICovXG4gIGdldCBmb2N1c2VkRGF5Q2hhbmdlKCk6IE9ic2VydmFibGU8RGF5TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNlZERheUNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIE5nWm9uZSwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpcnN0LCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIGZvY3VzZXMgdGhlIGRheSB0aGF0IGlzIGZvY3VzYWJsZSBpbiB0aGUgY2FsZW5kYXIuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0KSB7fVxuXG4gIGZvY3VzQ2VsbChlbFJlZjogRWxlbWVudFJlZik6IHZvaWQge1xuICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLm5nWm9uZUlzU3RhYmxlSW5Ccm93c2VyKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXNFbCA9IGVsUmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignW3RhYmluZGV4PVwiMFwiXScpO1xuICAgICAgICBpZiAoZm9jdXNFbCkge1xuICAgICAgICAgIGZvY3VzRWwuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmb2N1c0lucHV0KGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5uZ1pvbmVJc1N0YWJsZUluQnJvd3NlcigpLnN1YnNjcmliZSgoKSA9PiBlbGVtZW50LmZvY3VzKCkpKTtcbiAgfVxuXG4gIGVsZW1lbnRJc0ZvY3VzZWQoZWxlbWVudDogSFRNTElucHV0RWxlbWVudCkge1xuICAgIHJldHVybiBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gIH1cblxuICBwcml2YXRlIG5nWm9uZUlzU3RhYmxlSW5Ccm93c2VyKCkge1xuICAgIC8vIENyZWRpdDogTWF0ZXJpYWw6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9ibG9iL21hc3Rlci9zcmMvbGliL2RhdGVwaWNrZXIvY2FsZW5kYXIudHNcbiAgICByZXR1cm4gdGhpcy5fbmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUoZmlyc3QoKSwgZmlsdGVyKCgpID0+IGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBGb3JtYXRXaWR0aCxcbiAgRm9ybVN0eWxlLFxuICBnZXRMb2NhbGVEYXRlRm9ybWF0LFxuICBnZXRMb2NhbGVEYXlOYW1lcyxcbiAgZ2V0TG9jYWxlRmlyc3REYXlPZldlZWssXG4gIGdldExvY2FsZU1vbnRoTmFtZXMsXG4gIFRyYW5zbGF0aW9uV2lkdGgsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIExPQ0FMRV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBleHRyYWN0cyB0aGUgQW5ndWxhciBDTERSIGRhdGEgbmVlZGVkIGJ5IHRoZSBkYXRlcGlja2VyLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTG9jYWxlSGVscGVyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoTE9DQUxFX0lEKSBwdWJsaWMgbG9jYWxlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmluaXRpYWxpemVMb2NhbGVEYXRhKCk7XG4gIH1cblxuICBwcml2YXRlIF9maXJzdERheU9mV2VlazogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfbG9jYWxlRGF5c05hcnJvdzogUmVhZG9ubHlBcnJheTxzdHJpbmc+O1xuICBwcml2YXRlIF9sb2NhbGVNb250aHNBYmJyZXZpYXRlZDogUmVhZG9ubHlBcnJheTxzdHJpbmc+O1xuICBwcml2YXRlIF9sb2NhbGVNb250aHNXaWRlOiBSZWFkb25seUFycmF5PHN0cmluZz47XG4gIHByaXZhdGUgX2xvY2FsZURhdGVGb3JtYXQ6IHN0cmluZztcblxuICBnZXQgZmlyc3REYXlPZldlZWsoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3REYXlPZldlZWs7XG4gIH1cblxuICBnZXQgbG9jYWxlRGF5c05hcnJvdygpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVEYXlzTmFycm93O1xuICB9XG5cbiAgZ2V0IGxvY2FsZU1vbnRoc0FiYnJldmlhdGVkKCk6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZU1vbnRoc0FiYnJldmlhdGVkO1xuICB9XG5cbiAgZ2V0IGxvY2FsZU1vbnRoc1dpZGUoKTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlTW9udGhzV2lkZTtcbiAgfVxuXG4gIGdldCBsb2NhbGVEYXRlRm9ybWF0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZURhdGVGb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsZSBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlRGF0YSgpOiB2b2lkIHtcbiAgICAvLyBPcmRlciBpbiB3aGljaCB0aGVzZSBmdW5jdGlvbnMgaXMgY2FsbGVkIGlzIHZlcnkgaW1wb3J0YW50LlxuICAgIHRoaXMuaW5pdGlhbGl6ZUZpcnN0RGF5T2ZXZWVrKCk7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlRGF0ZUZvcm1hdCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZU1vbnRoc0FiYnJldmlhdGVkKCk7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlTW9udGhzV2lkZSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZURheXNOYXJyb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGRheSBuYW1lcyBpbiB0aGUgVHJhbnNsYXRpb25XaWR0aC5OYXJyb3cgZm9ybWF0IGJhc2VkIG9uIHRoZSBsb2NhbGUuXG4gICAqIGVnOiBbUywgTSwgVC4uLl0gZm9yIGVuLVVTLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlRGF5c05hcnJvdygpOiB2b2lkIHtcbiAgICAvLyBHZXQgbG9jYWxlIGRheSBuYW1lcyBzdGFydGluZyB3aXRoIFN1bmRheVxuICAgIGNvbnN0IHRlbXBBcnI6IHN0cmluZ1tdID0gZ2V0TG9jYWxlRGF5TmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5TdGFuZGFsb25lLCBUcmFuc2xhdGlvbldpZHRoLk5hcnJvdykuc2xpY2UoKTtcbiAgICAvLyBHZXQgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgICBjb25zdCBmaXJzdERheU9mV2VlazogbnVtYmVyID0gdGhpcy5maXJzdERheU9mV2VlaztcbiAgICAvLyBSZWFycmFuZ2UgdGhlIHRlbXBBcnIgdG8gc3RhcnQgd2l0aCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBsb2NhbGUuXG4gICAgaWYgKGZpcnN0RGF5T2ZXZWVrID4gMCkge1xuICAgICAgY29uc3QgcHJldkRheXM6IHN0cmluZ1tdID0gdGVtcEFyci5zcGxpY2UoMCwgZmlyc3REYXlPZldlZWspO1xuICAgICAgdGVtcEFyci5wdXNoKC4uLnByZXZEYXlzKTtcbiAgICB9XG4gICAgdGhpcy5fbG9jYWxlRGF5c05hcnJvdyA9IHRlbXBBcnI7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGFycmF5IG9mIG1vbnRoIG5hbWVzIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkIGZvcm1hdC5cbiAgICogZS5nLiBgW0phbiwgRmViLCAuLi5dYCBmb3IgZW4tVVNcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZU1vbnRoc0FiYnJldmlhdGVkKCk6IHZvaWQge1xuICAgIHRoaXMuX2xvY2FsZU1vbnRoc0FiYnJldmlhdGVkID0gZ2V0TG9jYWxlTW9udGhOYW1lcyhcbiAgICAgIHRoaXMubG9jYWxlLFxuICAgICAgRm9ybVN0eWxlLlN0YW5kYWxvbmUsXG4gICAgICBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkXG4gICAgKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBhcnJheSBvZiBtb250aCBuYW1lcyBpbiB0aGUgVHJhbnNsYXRpb25XaWR0aC5XaWRlIGZvcm1hdC5cbiAgICogZS5nLiBgW0phbnVhcnksIEZlYnJ1YXJ5LCAuLi5dYCBmb3IgZW4tVVNcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZU1vbnRoc1dpZGUoKTogdm9pZCB7XG4gICAgdGhpcy5fbG9jYWxlTW9udGhzV2lkZSA9IGdldExvY2FsZU1vbnRoTmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5TdGFuZGFsb25lLCBUcmFuc2xhdGlvbldpZHRoLldpZGUpLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgbG9jYWxlLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplRmlyc3REYXlPZldlZWsoKTogdm9pZCB7XG4gICAgdGhpcy5fZmlyc3REYXlPZldlZWsgPSBnZXRMb2NhbGVGaXJzdERheU9mV2Vlayh0aGlzLmxvY2FsZSk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVMb2NhbGVEYXRlRm9ybWF0KCk6IHZvaWQge1xuICAgIHRoaXMuX2xvY2FsZURhdGVGb3JtYXQgPSBnZXRMb2NhbGVEYXRlRm9ybWF0KHRoaXMubG9jYWxlLCBGb3JtYXRXaWR0aC5TaG9ydCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBET1dOX0FSUk9XLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICcuLi8uLi91dGlscy9rZXktY29kZXMva2V5LWNvZGVzJztcblxuaW1wb3J0IHsgQ2FsZW5kYXJWaWV3TW9kZWwgfSBmcm9tICcuL21vZGVsL2NhbGVuZGFyLXZpZXcubW9kZWwnO1xuaW1wb3J0IHsgQ2FsZW5kYXJNb2RlbCB9IGZyb20gJy4vbW9kZWwvY2FsZW5kYXIubW9kZWwnO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL21vZGVsL2RheS5tb2RlbCc7XG5pbXBvcnQgeyBEYXRlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTk9fT0ZfREFZU19JTl9BX1dFRUsgfSBmcm9tICcuL3V0aWxzL2NvbnN0YW50cyc7XG5cbkBDb21wb25lbnQoeyBzZWxlY3RvcjogJ2Nsci1jYWxlbmRhcicsIHRlbXBsYXRlVXJsOiAnLi9jYWxlbmRhci5odG1sJyB9KVxuZXhwb3J0IGNsYXNzIENsckNhbGVuZGFyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfc3ViczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9sb2NhbGVIZWxwZXJTZXJ2aWNlOiBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2U6IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZWxSZWY6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgdGhpcy5nZW5lcmF0ZUNhbGVuZGFyVmlldygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN1YnNjcmlwdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxlbmRhciBWaWV3IE1vZGVsIHRvIGdlbmVyYXRlIHRoZSBDYWxlbmRhci5cbiAgICovXG4gIGNhbGVuZGFyVmlld01vZGVsOiBDYWxlbmRhclZpZXdNb2RlbDtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWxlIGRheXMgYWNjb3JkaW5nIHRvIHRoZSBUcmFuc2xhdGlvbldpZHRoLk5hcnJvdyBmb3JtYXQuXG4gICAqL1xuICBnZXQgbG9jYWxlRGF5c05hcnJvdygpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZURheXNOYXJyb3c7XG4gIH1cblxuICBnZXQgY2FsZW5kYXIoKTogQ2FsZW5kYXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhcjtcbiAgfVxuXG4gIGdldCBzZWxlY3RlZERheSgpOiBEYXlNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheTtcbiAgfVxuXG4gIGdldCBmb2N1c2VkRGF5KCk6IERheU1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzZWREYXk7XG4gIH1cblxuICBnZXQgdG9kYXkoKTogRGF5TW9kZWwge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UudG9kYXk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBzdWJzY3JpcHRpb25zIHRvOlxuICAgKiAxLiB1cGRhdGUgdGhlIGNhbGVuZGFyIHZpZXcgbW9kZWwuXG4gICAqIDIuIHVwZGF0ZSB0aGUgZm9jdXNhYmxlIGRheSBpbiB0aGUgY2FsZW5kYXIgdmlldyBtb2RlbC5cbiAgICogMy4gZm9jdXMgb24gdGhlIGZvY3VzYWJsZSBkYXkgaW4gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzLnB1c2goXG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNhbGVuZGFyVmlldygpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fc3Vicy5wdXNoKFxuICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzZWREYXlDaGFuZ2Uuc3Vic2NyaWJlKChmb2N1c2VkRGF5OiBEYXlNb2RlbCkgPT4ge1xuICAgICAgICB0aGlzLmNhbGVuZGFyVmlld01vZGVsLnVwZGF0ZUZvY3VzYWJsZURheShmb2N1c2VkRGF5KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX3N1YnMucHVzaChcbiAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5mb2N1c09uQ2FsZW5kYXJDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgQ2FsZW5kYXIgVmlldyBiYXNlZCBvbiB0aGUgY2FsZW5kYXIgcmV0cmlldmVkIGZyb20gdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZS5cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVDYWxlbmRhclZpZXcoKTogdm9pZCB7XG4gICAgdGhpcy5jYWxlbmRhclZpZXdNb2RlbCA9IG5ldyBDYWxlbmRhclZpZXdNb2RlbChcbiAgICAgIHRoaXMuY2FsZW5kYXIsXG4gICAgICB0aGlzLnNlbGVjdGVkRGF5LFxuICAgICAgdGhpcy5mb2N1c2VkRGF5LFxuICAgICAgdGhpcy50b2RheSxcbiAgICAgIHRoaXMuX2xvY2FsZUhlbHBlclNlcnZpY2UuZmlyc3REYXlPZldlZWtcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGVnYXRlcyBLZXlib2FyZCBhcnJvdyBuYXZpZ2F0aW9uIHRvIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIHRoaXMuZm9jdXNlZERheSkge1xuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5jcmVtZW50Rm9jdXNEYXkoLTEgKiBOT19PRl9EQVlTX0lOX0FfV0VFSyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5pbmNyZW1lbnRGb2N1c0RheShOT19PRl9EQVlTX0lOX0FfV0VFSyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5pbmNyZW1lbnRGb2N1c0RheSgtMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5jcmVtZW50Rm9jdXNEYXkoMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7IC8vIE5vIGRlZmF1bHQgY2FzZS4gVFNMaW50IHgtKFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIG9uIHRoZSBmb2N1c2FibGUgZGF5IHdoZW4gdGhlIENhbGVuZGFyIFZpZXcgaXMgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gc3Vic2NyaXB0aW9ucy5cbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZvY3VzU2VydmljZSB7XG4gIHByaXZhdGUgX2ZvY3VzZWQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICBnZXQgZm9jdXNDaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cbiAgc2V0IGZvY3VzZWQoc3RhdGU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9mb2N1c2VkLm5leHQoc3RhdGUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVGb3JtQ29udHJvbFNlcnZpY2Uge1xuICBwcml2YXRlIF90b3VjaGVkQ2hhbmdlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBnZXQgdG91Y2hlZENoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdG91Y2hlZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2RpcnR5Q2hhbmdlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBnZXQgZGlydHlDaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5Q2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbWFya0FzVG91Y2hlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl90b3VjaGVkQ2hhbmdlLm5leHQoKTtcbiAgfVxuXG4gIG1hcmtBc0RpcnR5KCk6IHZvaWQge1xuICAgIHRoaXMuX2RpcnR5Q2hhbmdlLm5leHQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIEJJR19FTkRJQU4sXG4gIERFRkFVTFRfTE9DQUxFX0ZPUk1BVCxcbiAgREVMSU1JVEVSX1JFR0VYLFxuICBJbnB1dERhdGVEaXNwbGF5Rm9ybWF0LFxuICBMSVRUTEVfRU5ESUFOLFxuICBMSVRUTEVfRU5ESUFOX1JFR0VYLFxuICBNSURETEVfRU5ESUFOLFxuICBNSURETEVfRU5ESUFOX1JFR0VYLFxuICBSVExfUkVHRVgsXG4gIFVTRVJfSU5QVVRfUkVHRVgsXG59IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoLCBwYXJzZVRvRm91ckRpZ2l0WWVhciB9IGZyb20gJy4uL3V0aWxzL2RhdGUtdXRpbHMnO1xuXG5pbXBvcnQgeyBMb2NhbGVIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnLi9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZUlPU2VydmljZSB7XG4gIHB1YmxpYyBjbGRyTG9jYWxlRGF0ZUZvcm1hdDogc3RyaW5nID0gREVGQVVMVF9MT0NBTEVfRk9STUFUO1xuICBwcml2YXRlIGxvY2FsZURpc3BsYXlGb3JtYXQ6IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSBMSVRUTEVfRU5ESUFOO1xuICBwcml2YXRlIGRlbGltaXRlcnM6IFtzdHJpbmcsIHN0cmluZ10gPSBbJy8nLCAnLyddO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xvY2FsZUhlbHBlclNlcnZpY2U6IExvY2FsZUhlbHBlclNlcnZpY2UpIHtcbiAgICB0aGlzLmNsZHJMb2NhbGVEYXRlRm9ybWF0ID0gdGhpcy5fbG9jYWxlSGVscGVyU2VydmljZS5sb2NhbGVEYXRlRm9ybWF0O1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZURpc3BsYXlGb3JtYXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZURpc3BsYXlGb3JtYXQoKTogdm9pZCB7XG4gICAgY29uc3QgZm9ybWF0OiBzdHJpbmcgPSB0aGlzLmNsZHJMb2NhbGVEYXRlRm9ybWF0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKExJVFRMRV9FTkRJQU5fUkVHRVgudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPSBMSVRUTEVfRU5ESUFOO1xuICAgIH0gZWxzZSBpZiAoTUlERExFX0VORElBTl9SRUdFWC50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9IE1JRERMRV9FTkRJQU47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBzZXQgdG8gQklHLUVORElBTiBGT1JNQVRcbiAgICAgIHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9IEJJR19FTkRJQU47XG4gICAgfVxuICAgIHRoaXMuZXh0cmFjdERlbGltaXRlcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdERlbGltaXRlcnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQpIHtcbiAgICAgIC8vIFNhbml0aXplIERhdGUgRm9ybWF0LiBSZW1vdmUgUlRMIGNoYXJhY3RlcnMuXG4gICAgICAvLyBGSVhNRTogV2hlbiB3ZSBzdXBwb3J0IFJUTCwgcmVtb3ZlIHRoaXMgYW5kIGhhbmRsZSBpdCBjb3JyZWN0bHkuXG4gICAgICBjb25zdCBsb2NhbGVGb3JtYXQ6IHN0cmluZyA9IHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQucmVwbGFjZShSVExfUkVHRVgsICcnKTtcbiAgICAgIGNvbnN0IGRlbGltaXRlcnM6IHN0cmluZ1tdID0gbG9jYWxlRm9ybWF0LnNwbGl0KERFTElNSVRFUl9SRUdFWCk7XG5cbiAgICAgIC8vIE5PVEU6IFRoZSBzcGxpdCBmcm9tIHRoZSBDTERSIGRhdGUgZm9ybWF0IHNob3VsZCBhbHdheXMgcmVzdWx0XG4gICAgICAvLyBpbiBhbiBhcmFyeSB3aXRoIDQgZWxlbWVudHMuIFRoZSAxc3QgYW5kIHRoZSAybmQgdmFsdWVzIGFyZSB0aGUgZGVsaW1pdGVyc1xuICAgICAgLy8gd2Ugd2lsbCB1c2UgaW4gb3JkZXIuXG4gICAgICAvLyBFZzogXCJkZC9NTS95XCIuc3BsaXQoL2QrfG0rfHkrL2kpIHJlc3VsdHMgaW4gW1wiXCIsIFwiL1wiLCBcIi9cIiwgXCJcIl1cbiAgICAgIGlmIChkZWxpbWl0ZXJzICYmIGRlbGltaXRlcnMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IFtkZWxpbWl0ZXJzWzFdLCBkZWxpbWl0ZXJzWzJdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZGF0ZSBmb3JtYXQgcmVjZWl2ZWQuIERlbGltaXRlcnMgZXh0cmFjdGVkOiAnLCBkZWxpbWl0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b0xvY2FsZURpc3BsYXlGb3JtYXRTdHJpbmcoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gICAgaWYgKGRhdGUpIHtcbiAgICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZU5vOiBudW1iZXIgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgIGNvbnN0IG1vbnRoTm86IG51bWJlciA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICBjb25zdCBkYXRlU3RyOiBzdHJpbmcgPSBkYXRlTm8gPiA5ID8gZGF0ZU5vLnRvU3RyaW5nKCkgOiAnMCcgKyBkYXRlTm87XG4gICAgICBjb25zdCBtb250aFN0cjogc3RyaW5nID0gbW9udGhObyA+IDkgPyBtb250aE5vLnRvU3RyaW5nKCkgOiAnMCcgKyBtb250aE5vO1xuICAgICAgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTElUVExFX0VORElBTikge1xuICAgICAgICByZXR1cm4gZGF0ZVN0ciArIHRoaXMuZGVsaW1pdGVyc1swXSArIG1vbnRoU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPT09IE1JRERMRV9FTkRJQU4pIHtcbiAgICAgICAgcmV0dXJuIG1vbnRoU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzBdICsgZGF0ZVN0ciArIHRoaXMuZGVsaW1pdGVyc1sxXSArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCkgKyB0aGlzLmRlbGltaXRlcnNbMF0gKyBtb250aFN0ciArIHRoaXMuZGVsaW1pdGVyc1sxXSArIGRhdGVTdHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGdldCBwbGFjZWhvbGRlclRleHQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBmb3JtYXQ6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXSA9IHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdC5mb3JtYXQ7XG4gICAgcmV0dXJuIGZvcm1hdFswXSArIHRoaXMuZGVsaW1pdGVyc1swXSArIGZvcm1hdFsxXSArIHRoaXMuZGVsaW1pdGVyc1sxXSArIGZvcm1hdFsyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG1vbnRoIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgdmFsaWQgb3Igbm90LlxuICAgKiBOb3RlOiBNb250aCBpcyAwIGJhc2VkLlxuICAgKi9cbiAgcHJpdmF0ZSBpc1ZhbGlkTW9udGgobW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBtb250aCA+IC0xICYmIG1vbnRoIDwgMTI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBkYXRlIGlzIHZhbGlkIGRlcGVuZGluZyBvbiB0aGUgeWVhciBhbmQgbW9udGggcHJvdmlkZWQuXG4gICAqL1xuICBwcml2YXRlIGlzVmFsaWREYXRlKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF0ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRhdGUgPiAwICYmIGRhdGUgPD0gZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCh5ZWFyLCBtb250aCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBwYXJhbWV0ZXJzIHByb3ZpZGVkIGFuZCByZXR1cm5zIHRoZSBkYXRlLlxuICAgKiBJZiB0aGUgcGFyYW1ldGVycyBhcmUgbm90XG4gICAqIHZhbGlkIHRoZW4gcmV0dXJuIG51bGwuXG4gICAqIE5PVEU6IChNb250aCBoZXJlIGlzIDEgYmFzZWQgc2luY2UgdGhlIHVzZXIgaGFzIHByb3ZpZGVkIHRoYXQgYXMgYW4gaW5wdXQpXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlQW5kR2V0RGF0ZSh5ZWFyOiBzdHJpbmcsIG1vbnRoOiBzdHJpbmcsIGRhdGU6IHN0cmluZyk6IERhdGUge1xuICAgIC8vIEkgZG9uJ3Qga25vdyB3aGF0cyB3cm9uZyB3aXRoIHRoZSBUUyBjb21waWxlci4gSXQgdGhyb3dzIGFuIGVycm9yIGlmIEkgd3JpdGVcbiAgICAvLyB0aGUgYmVsb3cgaWYgc3RhdGVtZW50LiBUaGUgZXJyb3IgaXM6XG4gICAgLy8gT3BlcmF0b3IgJyE9PScgY2Fubm90IGJlIGFwcGxpZWQgdG8gdHlwZXMgJzInIGFuZCAnNCdcbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMjc5NCNpc3N1ZWNvbW1lbnQtMjcwMzQyOTM2XG4gICAgLypcbiAgICAgICAgaWYgKHllYXIubGVuZ3RoICE9PSAyIHx8IHllYXIubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgLy8gSW5zdGVhZCBJIGhhdmUgdG8gd3JpdGUgdGhlIGxvZ2ljIGxpa2UgdGhpcyB4LShcbiAgICBjb25zdCB5OiBudW1iZXIgPSAreWVhcjtcbiAgICBjb25zdCBtOiBudW1iZXIgPSArbW9udGggLSAxOyAvLyBtb250aCBpcyAwIGJhc2VkXG4gICAgY29uc3QgZDogbnVtYmVyID0gK2RhdGU7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRNb250aChtKSB8fCAhdGhpcy5pc1ZhbGlkRGF0ZSh5LCBtLCBkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyID0gcGFyc2VUb0ZvdXJEaWdpdFllYXIoeSk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gLTEgPyBuZXcgRGF0ZShyZXN1bHQsIG0sIGQpIDogbnVsbDtcbiAgfVxuXG4gIGdldERhdGVWYWx1ZUZyb21EYXRlU3RyaW5nKGRhdGU6IHN0cmluZyk6IERhdGUge1xuICAgIGlmICghZGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRhdGVQYXJ0czogc3RyaW5nW10gPSBkYXRlLm1hdGNoKFVTRVJfSU5QVVRfUkVHRVgpO1xuICAgIGlmICghZGF0ZVBhcnRzIHx8IGRhdGVQYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0LCB0aGlyZFBhcnRdID0gZGF0ZVBhcnRzO1xuICAgIGlmICh0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPT09IExJVFRMRV9FTkRJQU4pIHtcbiAgICAgIC8vIHNlY29uZFBhcnQgaXMgbW9udGggJiYgZmlyc3RQYXJ0IGlzIGRhdGVcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQW5kR2V0RGF0ZSh0aGlyZFBhcnQsIHNlY29uZFBhcnQsIGZpcnN0UGFydCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPT09IE1JRERMRV9FTkRJQU4pIHtcbiAgICAgIC8vIGZpcnN0UGFydCBpcyBtb250aCAmJiBzZWNvbmRQYXJ0IGlzIGRhdGVcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQW5kR2V0RGF0ZSh0aGlyZFBhcnQsIGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNlY29uZFBhcnQgaXMgbW9udGggJiYgdGhpcmRQYXJ0IGlzIGRhdGVcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQW5kR2V0RGF0ZShmaXJzdFBhcnQsIHNlY29uZFBhcnQsIHRoaXJkUGFydCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8vIGlQYWQgbWluaSBzY3JlZW4gd2lkdGhcbi8vIGh0dHA6Ly9zdGVwaGVuLmlvL21lZGlhcXVlcmllcy8jaVBhZE1pbmlcbmV4cG9ydCBjb25zdCBEQVRFUElDS0VSX0VOQUJMRV9CUkVBS1BPSU5UOiBudW1iZXIgPSA3Njg7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEQVRFUElDS0VSX0VOQUJMRV9CUkVBS1BPSU5UIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMnO1xuaW1wb3J0IHsgTU9CSUxFX1VTRVJBR0VOVF9SRUdFWCB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlcGlja2VyRW5hYmxlZFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICB0aGlzLl9pc1VzZXJBZ2VudE1vYmlsZSA9IE1PQklMRV9VU0VSQUdFTlRfUkVHRVgudGVzdChfZG9jdW1lbnQuZGVmYXVsdFZpZXcubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB0aGlzLl9pbm5lcldpZHRoID0gX2RvY3VtZW50LmRlZmF1bHRWaWV3LmlubmVyV2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNVc2VyQWdlbnRNb2JpbGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaW5uZXJXaWR0aDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgYWN0aXZlIG9yIG5vdC5cbiAgICogSWYgdGhlIHVzZXIgYWdlbnQgaXMgbW9iaWxlIGFuZCB0aGUgc2NyZWVuIHdpZHRoIGlzIGxlc3MgdGhhbiBEQVRFUElDS0VSX0FDVElWRV9CUkVBS1BPSU5UXG4gICAqIHRoZW4gdGhlIGNhbGVuZGFyIGlzIGluYWN0aXZlLlxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jyb3dzZXJfZGV0ZWN0aW9uX3VzaW5nX3RoZV91c2VyX2FnZW50XG4gICAgLy8gV2hhdCB0aGV5IHJlY29tbWVuZCBpczpcbiAgICAvL1wiSW4gc3VtbWFyeSwgd2UgcmVjb21tZW5kIGxvb2tpbmcgZm9yIHRoZSBzdHJpbmcgJ01vYmknXG4gICAgLy8gYW55d2hlcmUgaW4gdGhlIFVzZXIgQWdlbnQgdG8gZGV0ZWN0IGEgbW9iaWxlIGRldmljZS5cIlxuICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgaWYgKHRoaXMuX2lubmVyV2lkdGggPCBEQVRFUElDS0VSX0VOQUJMRV9CUkVBS1BPSU5UICYmIHRoaXMuX2lzVXNlckFnZW50TW9iaWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgT25EZXN0cm95LCBPcHRpb25hbCwgQ29udGVudENoaWxkLCBJbmplY3QsIEhvc3RMaXN0ZW5lciwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IExheW91dFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5cbmltcG9ydCB7IERhdGVGb3JtQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWZvcm0tY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVJT1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWlvLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1lbmFibGVkLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9jYWxlSGVscGVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xvY2FsZS1oZWxwZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5pbXBvcnQgeyBJU19ORVdfRk9STVNfTEFZT1VUIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZXctZm9ybXMuc2VydmljZSc7XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgY29udGFpbnMgdHdvIHRlbXBsYXRlIGZvciB0aGUgb2xkIGFuZCBuZXcgZm9ybXMgbGF5b3V0cy5cbiAqIFdoZW4gaXQgaXMgdGltZSB0byByZW1vdmUgdGhlIG9sZCBmb3JtcyBsYXlvdXRzIHN1cHBvcnQsIHJlbW92ZSB0aGUgbmctdGVtcGxhdGVzXG4gKiBhbmQgbmctY29udGFpbmVyLCBhbmQganVzdCBrZWVwIHRoZSBpbm5lciBjb250ZW50IG9mIHRoZSAjbmV3TGF5b3V0IGFzIHRoZSB0ZW1wbGF0ZVxuICogYW5kIG1vdmUgdGhlIG5nLWNvbnRlbnQgZm9yIGNsckRhdGUuXG4gKi9cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRhdGUtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctdGVtcGxhdGUgI29sZExheW91dD5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY2xyRGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiZGF0ZXBpY2tlci10cmlnZ2VyXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVEYXRlcGlja2VyKCRldmVudClcIlxuICAgICAgICAgICAgKm5nSWY9XCJpc0VuYWJsZWRcIj5cbiAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNhbGVuZGFyXCIgY2xhc3M9XCJkYXRlcGlja2VyLXRyaWdnZXItaWNvblwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mua2V5cy5vcGVuXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxjbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXIgKmNscklmT3BlbiBjbHJGb2N1c1RyYXA+PC9jbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBcbiAgICA8bmctdGVtcGxhdGUgI25ld0xheW91dD5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGxhYmVsICpuZ0lmPVwiIWxhYmVsICYmIGFkZEdyaWQoKVwiPjwvbGFiZWw+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1pbnB1dC13cmFwcGVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNsci1pbnB1dC1ncm91cFwiIFtjbGFzcy5jbHItZm9jdXNdPVwiZm9jdXNcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjbHJEYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8YnV0dG9uICNhY3Rpb25CdXR0b24gXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIiBcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjbHItaW5wdXQtZ3JvdXAtaWNvbi1hY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMuZGF0ZXBpY2tlclRvZ2dsZVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmRhdGVwaWNrZXJUb2dnbGVcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiY29udHJvbD8uZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlRGF0ZXBpY2tlcigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJpc0VuYWJsZWRcIj5cbiAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2FsZW5kYXJcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8Y2xyLWRhdGVwaWNrZXItdmlldy1tYW5hZ2VyICpjbHJJZk9wZW4gY2xyRm9jdXNUcmFwPjwvY2xyLWRhdGVwaWNrZXItdmlldy1tYW5hZ2VyPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxjbHItaWNvbiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIj48L2Nsci1pY29uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8L2Rpdj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIFxuICAgIDxuZy10ZW1wbGF0ZSAjY2xyRGF0ZT5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJEYXRlXVwiPjwvbmctY29udGVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIFxuICAgIDxuZy10ZW1wbGF0ZSAjYnRuVGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImJ1dHRvblwiPjwvbmctY29udGVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIFxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJuZXdGb3Jtc0xheW91dDsgdGhlbiBuZXdMYXlvdXQgZWxzZSBvbGRMYXlvdXRcIj48L25nLWNvbnRhaW5lcj5cbiAgICBgLFxuICBwcm92aWRlcnM6IFtcbiAgICBDb250cm9sSWRTZXJ2aWNlLFxuICAgIElmT3BlblNlcnZpY2UsXG4gICAgTG9jYWxlSGVscGVyU2VydmljZSxcbiAgICBJZkVycm9yU2VydmljZSxcbiAgICBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIEZvY3VzU2VydmljZSxcbiAgICBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIERhdGVJT1NlcnZpY2UsXG4gICAgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIERhdGVwaWNrZXJFbmFibGVkU2VydmljZSxcbiAgICBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLFxuICAgIENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICBdLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRlLWNvbnRhaW5lcl0nOiAnIW5ld0Zvcm1zTGF5b3V0JyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2xdJzogJ25ld0Zvcm1zTGF5b3V0JyxcbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVDb250YWluZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25EZXN0cm95IHtcbiAgX2R5bmFtaWM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBmb2N1cyA9IGZhbHNlO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2U6IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSxcbiAgICBwcml2YXRlIGRhdGVGb3JtQ29udHJvbFNlcnZpY2U6IERhdGVGb3JtQ29udHJvbFNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIHByaXZhdGUgZm9jdXNTZXJ2aWNlOiBGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSVNfTkVXX0ZPUk1TX0xBWU9VVClcbiAgICBwdWJsaWMgbmV3Rm9ybXNMYXlvdXQ6IGJvb2xlYW4sXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZlxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX2lmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUob3BlbiA9PiB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplQ2FsZW5kYXIoKTtcbiAgICAgICAgICB0aGlzLmVzY2FwZVJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHN0YXRlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZXNjYXBlUmVhZHk7IC8vIEdhdGUgdG8gYmUgdXNlZCBieSB0aGlzIGVzY2FwZSBsaXN0ZW5lciBhbmQgdGhlIHN1YnNjcmlwdGlvbiBjaGFuZ2UgZXZlbnQgZnJvbSBpZk9wZW5TdmNcbiAgQEhvc3RMaXN0ZW5lcignYm9keTprZXl1cC5lc2NhcGUnLCBbJyRldmVudCddKVxuICBjbG9zZShldmVudCkge1xuICAgIGlmICh0aGlzLm5ld0Zvcm1zTGF5b3V0ICYmIHRoaXMuZXNjYXBlUmVhZHkpIHtcbiAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jbHItaW5wdXQtZ3JvdXAtaWNvbi1hY3Rpb24nKS5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMubmV3Rm9ybXNMYXlvdXQgJiYgdGhpcy5lc2NhcGVSZWFkeSkge1xuICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRhdGVwaWNrZXItdHJpZ2dlcicpLmZvY3VzKCk7XG4gICAgfVxuICAgIHRoaXMuZXNjYXBlUmVhZHkgPSBmYWxzZTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBjb250cm9sXG4gICAqL1xuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY29udHJvbCBuZWVkcyB0byBhZGQgZ3JpZCBjbGFzc2VzXG4gICAqL1xuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgRGF0ZXBpY2tlciBpcyBlbmFibGVkIG9yIG5vdC4gSWYgZGlzYWJsZWQsIGhpZGVzIHRoZSBkYXRlcGlja2VyIHRyaWdnZXIuXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UuaXNFbmFibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgdXNlciBpbnB1dCBhbmQgSW5pdGlhbGl6ZXMgdGhlIENhbGVuZGFyIGV2ZXJ5dGltZSB0aGUgZGF0ZXBpY2tlciBwb3BvdmVyIGlzIG9wZW4uXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVDYWxlbmRhcigpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5pdGlhbGl6ZUNhbGVuZGFyKCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgRGF0ZXBpY2tlciBQb3BvdmVyLlxuICAgKi9cbiAgdG9nZ2xlRGF0ZXBpY2tlcihldmVudDogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX2lmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UubWFya0FzVG91Y2hlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gc3Vic2NyaXB0aW9ucy5cbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBQTEFURk9STV9JRCxcbiAgUmVuZGVyZXIyLFxuICBTZWxmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGZpbHRlciwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyRGF0ZUNvbnRhaW5lciB9IGZyb20gJy4vZGF0ZS1jb250YWluZXInO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL21vZGVsL2RheS5tb2RlbCc7XG5pbXBvcnQgeyBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlSU9TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1pby5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZW5hYmxlZC5zZXJ2aWNlJztcbmltcG9ydCB7IElTX05FV19GT1JNU19MQVlPVVQgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25ldy1mb3Jtcy5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgZGF0ZXNBcmVFcXVhbCB9IGZyb20gJy4vdXRpbHMvZGF0ZS11dGlscyc7XG5cbi8vIFRoZXJlIGFyZSBmb3VyIHdheXMgdGhlIGRhdGVwaWNrZXIgdmFsdWUgaXMgc2V0XG4vLyAxLiBWYWx1ZSBzZXQgYnkgdXNlciB0eXBpbmcgaW50byB0ZXh0IGlucHV0IGFzIGEgc3RyaW5nIGV4OiAnMDEvMjgvMjAxNSdcbi8vIDIuIFZhbHVlIHNldCBleHBsaWNpdGx5IGJ5IEFuZ3VsYXIgRm9ybXMgQVBJcyBhcyBhIHN0cmluZyBleDogJzAxLzI4LzIwMTUnXG4vLyAzLiBWYWx1ZSBzZXQgYnkgdXNlciB2aWEgZGF0ZXBpY2tlciBVSSBhcyBhIERhdGUgT2JqZWN0XG4vLyA0LiBWYWx1ZSBzZXQgdmlhIGBjbHJEYXRlYCBpbnB1dCBhcyBhIERhdGUgT2JqZWN0XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJEYXRlXScsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGUtaW5wdXRdJzogJyFuZXdGb3Jtc0xheW91dCcsXG4gICAgJ1tjbGFzcy5jbHItaW5wdXRdJzogJ25ld0Zvcm1zTGF5b3V0JyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbRGF0ZXBpY2tlckZvY3VzU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVJbnB1dCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJEYXRlQ29udGFpbmVyPiBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZztcbiAgQElucHV0KCkgY2xyTmV3TGF5b3V0OiBib29sZWFuO1xuICBAT3V0cHV0KCdjbHJEYXRlQ2hhbmdlJykgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPihmYWxzZSk7XG4gIEBJbnB1dCgnY2xyRGF0ZScpXG4gIHNldCBkYXRlKGRhdGU6IERhdGUpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgIT09IGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh0aGlzLmdldFZhbGlkRGF0ZVZhbHVlRnJvbURhdGUoZGF0ZSkpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pbml0aWFsQ2xyRGF0ZUlucHV0VmFsdWUpIHtcbiAgICAgIHRoaXMuaW5pdGlhbENsckRhdGVJbnB1dFZhbHVlID0gZGF0ZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgaW5kZXggPSA0O1xuICBwcml2YXRlIGluaXRpYWxDbHJEYXRlSW5wdXRWYWx1ZTogRGF0ZTtcbiAgcHJpdmF0ZSBwcmV2aW91c0RhdGVDaGFuZ2U6IERhdGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJvdGVjdGVkIGVsOiBFbGVtZW50UmVmLFxuICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByb3RlY3RlZCBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250YWluZXI6IENsckRhdGVDb250YWluZXIsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkYXRlSU9TZXJ2aWNlOiBEYXRlSU9TZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZGF0ZU5hdmlnYXRpb25TZXJ2aWNlOiBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkYXRlcGlja2VyRW5hYmxlZFNlcnZpY2U6IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRhdGVGb3JtQ29udHJvbFNlcnZpY2U6IERhdGVGb3JtQ29udHJvbFNlcnZpY2UsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBmb2N1c1NlcnZpY2U6IEZvY3VzU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSVNfTkVXX0ZPUk1TX0xBWU9VVClcbiAgICBwdWJsaWMgbmV3Rm9ybXNMYXlvdXQ6IGJvb2xlYW4sXG4gICAgcHJpdmF0ZSBkYXRlcGlja2VyRm9jdXNTZXJ2aWNlOiBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlXG4gICkge1xuICAgIHN1cGVyKHZpZXdDb250YWluZXJSZWYsIENsckRhdGVDb250YWluZXIsIGluamVjdG9yLCBjb250cm9sLCByZW5kZXJlciwgZWwpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB0aGlzLnNldEZvcm1MYXlvdXQoKTtcbiAgICB0aGlzLnBvcHVsYXRlU2VydmljZXNGcm9tQ29udGFpbmVyQ29tcG9uZW50KCk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubGlzdGVuRm9yVXNlclNlbGVjdGVkRGF5Q2hhbmdlcygpLFxuICAgICAgdGhpcy5saXN0ZW5Gb3JDb250cm9sVmFsdWVDaGFuZ2VzKCksXG4gICAgICB0aGlzLmxpc3RlbkZvclRvdWNoQ2hhbmdlcygpLFxuICAgICAgdGhpcy5saXN0ZW5Gb3JEaXJ0eUNoYW5nZXMoKSxcbiAgICAgIHRoaXMubGlzdGVuRm9ySW5wdXRSZWZvY3VzKClcbiAgICApO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIEkgZG9uJ3Qga25vdyB3aHkgSSBoYXZlIHRvIGRvIHRoaXMgYnV0IGFmdGVyIHVzaW5nIHRoZSBuZXcgSG9zdFdyYXBwaW5nIE1vZHVsZSBJIGhhdmUgdG8gZGVsYXkgdGhlIHByb2Nlc3NpbmdcbiAgICAvLyBvZiB0aGUgaW5pdGlhbCBJbnB1dCBzZXQgYnkgdGhlIHVzZXIgdG8gaGVyZS4gSWYgSSBkbyBub3QgMiBpc3N1ZXMgb2NjdXI6XG4gICAgLy8gMS4gVGhlIElucHV0IHNldHRlciBpcyBjYWxsZWQgYmVmb3JlIG5nT25Jbml0LiBuZ09uSW5pdCBpbml0aWFsaXplcyB0aGUgc2VydmljZXMgd2l0aG91dCB3aGljaCB0aGUgc2V0dGVyIGZhaWxzLlxuICAgIC8vIDIuIFRoZSBSZW5kZXJlciBkb2Vzbid0IHdvcmsgYmVmb3JlIG5nQWZ0ZXJWaWV3SW5pdCAoSXQgdXNlZCB0byBiZWZvcmUgdGhlIG5ldyBIb3N0V3JhcHBpbmcgTW9kdWxlIGZvciBzb21lIHJlYXNvbikuXG4gICAgLy8gSSBuZWVkIHRoZSByZW5kZXJlciB0byBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IG9uIHRoZSBpbnB1dCB0byBtYWtlIHN1cmUgdGhhdCBpZiB0aGUgdXNlciBoYXMgc3VwcGxpZWQgYSBEYXRlXG4gICAgLy8gaW5wdXQgb2JqZWN0LCB3ZSByZWZsZWN0IGl0IHdpdGggdGhlIHJpZ2h0IGRhdGUgb24gdGhlIGlucHV0IGZpZWxkIHVzaW5nIHRoZSBJTyBzZXJ2aWNlLiBJIGFtIG5vdCBzdXJlIGlmXG4gICAgLy8gdGhlc2UgYXJlIG1ham9yIGlzc3VlcyBvciBub3QgYnV0IGp1c3Qgbm90aW5nIHRoZW0gZG93biBoZXJlLlxuICAgIHRoaXMucHJvY2Vzc0luaXRpYWxJbnB1dHMoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgc2V0Rm9jdXNTdGF0ZXMoKSB7XG4gICAgdGhpcy5zZXRGb2N1cyh0cnVlKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICB0cmlnZ2VyVmFsaWRhdGlvbigpIHtcbiAgICBzdXBlci50cmlnZ2VyVmFsaWRhdGlvbigpO1xuICAgIHRoaXMuc2V0Rm9jdXMoZmFsc2UpO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnBsYWNlaG9sZGVyJylcbiAgZ2V0IHBsYWNlaG9sZGVyVGV4dCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBsYWNlaG9sZGVyID8gdGhpcy5wbGFjZWhvbGRlciA6IHRoaXMuZGF0ZUlPU2VydmljZS5wbGFjZWhvbGRlclRleHQ7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpXG4gIGdldCBpbnB1dFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLnVzaW5nTmF0aXZlRGF0ZXBpY2tlcigpID8gJ2RhdGUnIDogJ3RleHQnO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJywgWyckZXZlbnQudGFyZ2V0J10pXG4gIG9uVmFsdWVDaGFuZ2UodGFyZ2V0OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgY29uc3QgdmFsaWREYXRlVmFsdWUgPSB0aGlzLmRhdGVJT1NlcnZpY2UuZ2V0RGF0ZVZhbHVlRnJvbURhdGVTdHJpbmcodGFyZ2V0LnZhbHVlKTtcbiAgICBpZiAodGhpcy51c2luZ0NsYXJpdHlEYXRlcGlja2VyKCkgJiYgdmFsaWREYXRlVmFsdWUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh2YWxpZERhdGVWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVzaW5nTmF0aXZlRGF0ZXBpY2tlcigpKSB7XG4gICAgICBjb25zdCBbeWVhciwgbW9udGgsIGRheV0gPSB0YXJnZXQudmFsdWUuc3BsaXQoJy0nKTtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZShuZXcgRGF0ZSgreWVhciwgK21vbnRoIC0gMSwgK2RheSksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXREYXRlT3V0cHV0KG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXNpbmdDbGFyaXR5RGF0ZXBpY2tlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UuaXNFbmFibGVkO1xuICB9XG5cbiAgcHJpdmF0ZSB1c2luZ05hdGl2ZURhdGVwaWNrZXIoKSB7XG4gICAgcmV0dXJuICF0aGlzLmRhdGVwaWNrZXJFbmFibGVkU2VydmljZS5pc0VuYWJsZWQ7XG4gIH1cblxuICBwcml2YXRlIHNldEZvY3VzKGZvY3VzOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmZvY3VzU2VydmljZS5mb2N1c2VkID0gZm9jdXM7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwb3B1bGF0ZVNlcnZpY2VzRnJvbUNvbnRhaW5lckNvbXBvbmVudCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmRhdGVJT1NlcnZpY2UgPSB0aGlzLmdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcihEYXRlSU9TZXJ2aWNlKTtcbiAgICAgIHRoaXMuZGF0ZU5hdmlnYXRpb25TZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXIoRGF0ZU5hdmlnYXRpb25TZXJ2aWNlKTtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXIoRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlKTtcbiAgICAgIHRoaXMuZGF0ZUZvcm1Db250cm9sU2VydmljZSA9IHRoaXMuZ2V0UHJvdmlkZXJGcm9tQ29udGFpbmVyKERhdGVGb3JtQ29udHJvbFNlcnZpY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc0luaXRpYWxJbnB1dHMoKSB7XG4gICAgaWYgKHRoaXMuZGF0ZXBpY2tlckhhc0Zvcm1Db250cm9sKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh0aGlzLmRhdGVJT1NlcnZpY2UuZ2V0RGF0ZVZhbHVlRnJvbURhdGVTdHJpbmcodGhpcy5jb250cm9sLnZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh0aGlzLmluaXRpYWxDbHJEYXRlSW5wdXRWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRGb3JtTGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmNsck5ld0xheW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm5ld0Zvcm1zTGF5b3V0ID0gISF0aGlzLmNsck5ld0xheW91dDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZURhdGUodmFsdWU6IERhdGUsIHNldEJ5VXNlckludGVyYWN0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBkYXRlID0gdGhpcy5nZXRWYWxpZERhdGVWYWx1ZUZyb21EYXRlKHZhbHVlKTtcblxuICAgIGlmIChzZXRCeVVzZXJJbnRlcmFjdGlvbikge1xuICAgICAgdGhpcy5lbWl0RGF0ZU91dHB1dChkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgPSBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGVOYXZpZ2F0aW9uU2VydmljZSkge1xuICAgICAgdGhpcy5kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBkYXRlXG4gICAgICAgID8gbmV3IERheU1vZGVsKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlSW5wdXQoZGF0ZSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUlucHV0KGRhdGU6IERhdGUpIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IHRoaXMuZGF0ZUlPU2VydmljZS50b0xvY2FsZURpc3BsYXlGb3JtYXRTdHJpbmcoZGF0ZSk7XG5cbiAgICAgIGlmICh0aGlzLmRhdGVwaWNrZXJIYXNGb3JtQ29udHJvbCgpICYmIGRhdGVTdHJpbmcgIT09IHRoaXMuY29udHJvbC52YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbnRyb2wuY29udHJvbC5zZXRWYWx1ZShkYXRlU3RyaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51c2luZ05hdGl2ZURhdGVwaWNrZXIoKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3ZhbHVlQXNEYXRlJywgZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgZGF0ZVN0cmluZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRWYWxpZERhdGVWYWx1ZUZyb21EYXRlKGRhdGU6IERhdGUpIHtcbiAgICBpZiAodGhpcy5kYXRlSU9TZXJ2aWNlKSB7XG4gICAgICBjb25zdCBkYXRlU3RyaW5nID0gdGhpcy5kYXRlSU9TZXJ2aWNlLnRvTG9jYWxlRGlzcGxheUZvcm1hdFN0cmluZyhkYXRlKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGVJT1NlcnZpY2UuZ2V0RGF0ZVZhbHVlRnJvbURhdGVTdHJpbmcoZGF0ZVN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdERhdGVPdXRwdXQoZGF0ZTogRGF0ZSkge1xuICAgIGlmICghZGF0ZXNBcmVFcXVhbChkYXRlLCB0aGlzLnByZXZpb3VzRGF0ZUNoYW5nZSkpIHtcbiAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KGRhdGUpO1xuICAgICAgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgPSBkYXRlO1xuICAgIH0gZWxzZSBpZiAoIWRhdGUgJiYgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KG51bGwpO1xuICAgICAgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGF0ZXBpY2tlckhhc0Zvcm1Db250cm9sKCkge1xuICAgIHJldHVybiAhIXRoaXMuY29udHJvbDtcbiAgfVxuXG4gIHByaXZhdGUgbGlzdGVuRm9yQ29udHJvbFZhbHVlQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gb2YodGhpcy5kYXRlcGlja2VySGFzRm9ybUNvbnRyb2woKSlcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIoaGFzQ29udHJvbCA9PiBoYXNDb250cm9sKSxcbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuY29udHJvbC52YWx1ZUNoYW5nZXMpLFxuICAgICAgICAvLyBvbmx5IHVwZGF0ZSBkYXRlIHZhbHVlIGlmIG5vdCBiZWluZyBzZXQgYnkgdXNlclxuICAgICAgICBmaWx0ZXIoKCkgPT4gIXRoaXMuZGF0ZXBpY2tlckZvY3VzU2VydmljZS5lbGVtZW50SXNGb2N1c2VkKHRoaXMuZWwubmF0aXZlRWxlbWVudCkpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCh2YWx1ZTogc3RyaW5nKSA9PiB0aGlzLnVwZGF0ZURhdGUodGhpcy5kYXRlSU9TZXJ2aWNlLmdldERhdGVWYWx1ZUZyb21EYXRlU3RyaW5nKHZhbHVlKSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBsaXN0ZW5Gb3JVc2VyU2VsZWN0ZWREYXlDaGFuZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheUNoYW5nZS5zdWJzY3JpYmUoZGF5TW9kZWwgPT4gdGhpcy51cGRhdGVEYXRlKGRheU1vZGVsLnRvRGF0ZSgpLCB0cnVlKSk7XG4gIH1cblxuICBwcml2YXRlIGxpc3RlbkZvclRvdWNoQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLnRvdWNoZWRDaGFuZ2VcbiAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmRhdGVwaWNrZXJIYXNGb3JtQ29udHJvbCgpKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb250cm9sLmNvbnRyb2wubWFya0FzVG91Y2hlZCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgbGlzdGVuRm9yRGlydHlDaGFuZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UuZGlydHlDaGFuZ2VcbiAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmRhdGVwaWNrZXJIYXNGb3JtQ29udHJvbCgpKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb250cm9sLmNvbnRyb2wubWFya0FzRGlydHkoKSk7XG4gIH1cblxuICBwcml2YXRlIGxpc3RlbkZvcklucHV0UmVmb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXlDaGFuZ2VcbiAgICAgIC5waXBlKGZpbHRlcihkYXRlID0+ICEhZGF0ZSkpXG4gICAgICAuc3Vic2NyaWJlKHYgPT4gdGhpcy5kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzSW5wdXQodGhpcy5lbC5uYXRpdmVFbGVtZW50KSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyVmlld0NoZWNrZWQsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3RhYmxlLFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBSZW5kZXJlcjIsXG4gIFNraXBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuaW1wb3J0IHsgUG9pbnQsIFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXInO1xuaW1wb3J0IHsgUG9wb3Zlck9wdGlvbnMgfSBmcm9tICcuL3BvcG92ZXItb3B0aW9ucy5pbnRlcmZhY2UnO1xuXG4vLyBMaXRlcmFsbHkgYW55IGFubm90YXRpb24gd291bGQgd29yayBoZXJlLCBidXQgd3JpdGluZyBvdXIgb3duIEBIb25leUJhZGdlciBhbm5vdGF0aW9uIGZlZWxzIG92ZXJraWxsLlxuQEluamVjdGFibGUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0UG9wb3ZlciBpbXBsZW1lbnRzIEFmdGVyVmlld0NoZWNrZWQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKGluamVjdG9yOiBJbmplY3RvciwgQFNraXBTZWxmKCkgcHJvdGVjdGVkIHBhcmVudEhvc3Q6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLmVsID0gaW5qZWN0b3IuZ2V0KEVsZW1lbnRSZWYpO1xuICAgIHRoaXMuaWZPcGVuU2VydmljZSA9IGluamVjdG9yLmdldChJZk9wZW5TZXJ2aWNlKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gaW5qZWN0b3IuZ2V0KFJlbmRlcmVyMik7XG4gICAgLy8gRGVmYXVsdCBhbmNob3IgaXMgdGhlIHBhcmVudCBob3N0XG4gICAgdGhpcy5hbmNob3JFbGVtID0gcGFyZW50SG9zdC5uYXRpdmVFbGVtZW50O1xuXG4gICAgdGhpcy5wb3BvdmVySW5zdGFuY2UgPSBuZXcgUG9wb3Zlcih0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoRVNDTGlzdGVuZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVsZWFzZSgpO1xuICAgICAgICB0aGlzLmRldGFjaEVTQ0xpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuaWZPcGVuU2VydmljZS5vcGVuKSB7XG4gICAgICB0aGlzLmFuY2hvcigpO1xuICAgICAgdGhpcy5hdHRhY2hFU0NMaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBlbDogRWxlbWVudFJlZjtcbiAgcHJvdGVjdGVkIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2U7XG4gIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyO1xuXG4gIHByaXZhdGUgcG9wb3Zlckluc3RhbmNlOiBQb3BvdmVyO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIHByaXZhdGUgdXBkYXRlQW5jaG9yID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIGFuY2hvckVsZW06IGFueTtcbiAgcHJvdGVjdGVkIGFuY2hvclBvaW50OiBQb2ludDtcbiAgcHJvdGVjdGVkIHBvcG92ZXJQb2ludDogUG9pbnQ7XG4gIHByb3RlY3RlZCBwb3BvdmVyT3B0aW9uczogUG9wb3Zlck9wdGlvbnMgPSB7fTtcblxuICBwcm90ZWN0ZWQgaWdub3JlZEVsZW1lbnQ6IGFueTtcblxuICBwcm90ZWN0ZWQgYW5jaG9yKCkge1xuICAgIHRoaXMudXBkYXRlQW5jaG9yID0gdHJ1ZTtcbiAgICAvLyBVZ2hcbiAgICB0aGlzLmlnbm9yZSA9IHRoaXMuaWZPcGVuU2VydmljZS5vcmlnaW5hbEV2ZW50O1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbGVhc2UoKSB7XG4gICAgdGhpcy5kZXRhY2hPdXRzaWRlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIHRoaXMucG9wb3Zlckluc3RhbmNlLnJlbGVhc2UoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICBpZiAodGhpcy51cGRhdGVBbmNob3IpIHtcbiAgICAgIHRoaXMudXBkYXRlQW5jaG9yID0gZmFsc2U7XG4gICAgICB0aGlzLnBvcG92ZXJJbnN0YW5jZVxuICAgICAgICAuYW5jaG9yKHRoaXMuYW5jaG9yRWxlbSwgdGhpcy5hbmNob3JQb2ludCwgdGhpcy5wb3BvdmVyUG9pbnQsIHRoaXMucG9wb3Zlck9wdGlvbnMpXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIC8vIGlmIGEgc2Nyb2xsIGV2ZW50IGlzIGRldGVjdGVkLCBjbG9zZSB0aGUgcG9wb3ZlclxuICAgICAgICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgdGhpcy5hdHRhY2hPdXRzaWRlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVsZWFzZSgpO1xuICAgIHRoaXMuZGV0YWNoRVNDTGlzdGVuZXIoKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLypcbiAgICAgKiBGYWxsYmFjayB0byBoaWRlIHdoZW4gKmNscklmT3BlbiBpcyBub3QgYmVpbmcgdXNlZFxuICAgICAqL1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MuaXMtb2ZmLXNjcmVlbicpXG4gIGdldCBpc09mZlNjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPyBmYWxzZSA6IHRydWU7XG4gIH1cblxuICAvKlxuICAgICAqIFVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzg3ODUgaXMgc3VwcG9ydGVkLCB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gaW5zdGFudGlhdGVcbiAgICAgKiBhIHNlcGFyYXRlIGRpcmVjdGl2ZSBvbiB0aGUgaG9zdC4gU28gbGV0J3MgZG8gZGlydHkgYnV0IHBlcmZvcm1hbnQgZm9yIG5vdy5cbiAgICAgKi9cbiAgcHVibGljIGNsb3NlT25PdXRzaWRlQ2xpY2sgPSBmYWxzZTtcbiAgcHJpdmF0ZSBob3N0Q2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBkb2N1bWVudENsaWNrTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgZG9jdW1lbnRFU0NMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBpZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgaWdub3JlOiBhbnk7XG5cbiAgcHJpdmF0ZSBhdHRhY2hFU0NMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucG9wb3Zlck9wdGlvbnMuaWdub3JlR2xvYmFsRVNDTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRFU0NMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5ID09PSAnRXNjJykge1xuICAgICAgICAgICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0YWNoRVNDTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZG9jdW1lbnRFU0NMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kb2N1bWVudEVTQ0xpc3RlbmVyKCk7XG4gICAgICBkZWxldGUgdGhpcy5kb2N1bWVudEVTQ0xpc3RlbmVyO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXR0YWNoT3V0c2lkZUNsaWNrTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VPbk91dHNpZGVDbGljaykge1xuICAgICAgdGhpcy5ob3N0Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2NsaWNrJywgZXZlbnQgPT4gKHRoaXMuaWdub3JlID0gZXZlbnQpKTtcbiAgICAgIGlmICh0aGlzLmlnbm9yZWRFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaWdub3JlZEVsZW1lbnRDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oXG4gICAgICAgICAgdGhpcy5pZ25vcmVkRWxlbWVudCxcbiAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgIGV2ZW50ID0+ICh0aGlzLmlnbm9yZSA9IGV2ZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudCA9PT0gdGhpcy5pZ25vcmUpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5pZ25vcmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXRhY2hPdXRzaWRlQ2xpY2tMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrKSB7XG4gICAgICBpZiAodGhpcy5ob3N0Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmhvc3RDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhvc3RDbGlja0xpc3RlbmVyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWdub3JlZEVsZW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuaWdub3JlZEVsZW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlnbm9yZWRFbGVtZW50Q2xpY2tMaXN0ZW5lcjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuY29uc3QgZW51bSBEYXRlcGlja2VyVmlld0VudW0ge1xuICBNT05USFZJRVcgPSAnTU9OVEhWSUVXJyxcbiAgWUVBUlZJRVcgPSAnWUVBUlZJRVcnLFxuICBEQVlWSUVXID0gJ0RBWVZJRVcnLFxufVxuXG4vKipcbiAqIFRoaXMgc2VydmljZSBtYW5hZ2VzIHdoaWNoIHZpZXcgaXMgdmlzaWJsZSBpbiB0aGUgZGF0ZXBpY2tlciBwb3BvdmVyLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmlld01hbmFnZXJTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfY3VycmVudFZpZXc6IERhdGVwaWNrZXJWaWV3RW51bSA9IERhdGVwaWNrZXJWaWV3RW51bS5EQVlWSUVXO1xuXG4gIGdldCBpc0RheVZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBEYXRlcGlja2VyVmlld0VudW0uREFZVklFVztcbiAgfVxuXG4gIGdldCBpc1llYXJWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmlldyA9PT0gRGF0ZXBpY2tlclZpZXdFbnVtLllFQVJWSUVXO1xuICB9XG5cbiAgZ2V0IGlzTW9udGhWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmlldyA9PT0gRGF0ZXBpY2tlclZpZXdFbnVtLk1PTlRIVklFVztcbiAgfVxuXG4gIGNoYW5nZVRvTW9udGhWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gRGF0ZXBpY2tlclZpZXdFbnVtLk1PTlRIVklFVztcbiAgfVxuXG4gIGNoYW5nZVRvWWVhclZpZXcoKTogdm9pZCB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSBEYXRlcGlja2VyVmlld0VudW0uWUVBUlZJRVc7XG4gIH1cblxuICBjaGFuZ2VUb0RheVZpZXcoKTogdm9pZCB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSBEYXRlcGlja2VyVmlld0VudW0uREFZVklFVztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBYnN0cmFjdFBvcG92ZXIgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9hYnN0cmFjdC1wb3BvdmVyJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlcic7XG5cbmltcG9ydCB7IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vZGF0ZXBpY2tlci12aWV3LW1hbmFnZXIuaHRtbCcsXG4gIHByb3ZpZGVyczogW1ZpZXdNYW5hZ2VyU2VydmljZSwgRGF0ZXBpY2tlckZvY3VzU2VydmljZV0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kYXRlcGlja2VyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRlcGlja2VyVmlld01hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdFBvcG92ZXIge1xuICBjb25zdHJ1Y3RvcihAU2tpcFNlbGYoKSBwYXJlbnQ6IEVsZW1lbnRSZWYsIF9pbmplY3RvcjogSW5qZWN0b3IsIHByaXZhdGUgX3ZpZXdNYW5hZ2VyU2VydmljZTogVmlld01hbmFnZXJTZXJ2aWNlKSB7XG4gICAgc3VwZXIoX2luamVjdG9yLCBwYXJlbnQpO1xuICAgIHRoaXMuY29uZmlndXJlUG9wb3ZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSBQb3BvdmVyIERpcmVjdGlvbiBhbmQgQ2xvc2UgaW5kaWNhdG9yc1xuICAgKi9cbiAgcHJpdmF0ZSBjb25maWd1cmVQb3BvdmVyKCk6IHZvaWQge1xuICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDtcbiAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgIHRoaXMuY2xvc2VPbk91dHNpZGVDbGljayA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudCB2aWV3IGlzIHRoZSBtb250aHBpY2tlci5cbiAgICovXG4gIGdldCBpc01vbnRoVmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld01hbmFnZXJTZXJ2aWNlLmlzTW9udGhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGN1cnJlbnQgdmlldyBpcyB0aGUgeWVhcnBpY2tlci5cbiAgICovXG4gIGdldCBpc1llYXJWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuaXNZZWFyVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjdXJyZW50IHZpZXcgaXMgdGhlIGRheXBpY2tlci5cbiAgICovXG4gIGdldCBpc0RheVZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5pc0RheVZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuaW1wb3J0IHsgRGF5Vmlld01vZGVsIH0gZnJvbSAnLi9tb2RlbC9kYXktdmlldy5tb2RlbCc7XG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vbW9kZWwvZGF5Lm1vZGVsJztcbmltcG9ydCB7IERhdGVGb3JtQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWZvcm0tY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRheScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzPVwiZGF5LWJ0blwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFtjbGFzcy5pcy10b2RheV09XCJkYXlWaWV3LmlzVG9kYXlzRGF0ZVwiXG4gICAgICAgICAgICBbY2xhc3MuaXMtZGlzYWJsZWRdPVwiZGF5Vmlldy5pc0Rpc2FibGVkXCJcbiAgICAgICAgICAgIFtjbGFzcy5pcy1zZWxlY3RlZF09XCJkYXlWaWV3LmlzU2VsZWN0ZWRcIlxuICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwiZGF5Vmlldy50YWJJbmRleFwiXG4gICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0RGF5KClcIlxuICAgICAgICAgICAgKGZvY3VzKT1cIm9uRGF5Vmlld0ZvY3VzKClcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJkYXlTdHJpbmdcIj5cbiAgICAgICAgICAgIHt7ZGF5Vmlldy5kYXlNb2RlbC5kYXRlfX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmRheV0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF5IHtcbiAgcHJpdmF0ZSBfZGF5VmlldzogRGF5Vmlld01vZGVsO1xuICBwdWJsaWMgZGF5U3RyaW5nOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfZGF0ZU5hdmlnYXRpb25TZXJ2aWNlOiBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSxcbiAgICBwcml2YXRlIGRhdGVGb3JtQ29udHJvbFNlcnZpY2U6IERhdGVGb3JtQ29udHJvbFNlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBEYXlWaWV3TW9kZWwgaW5wdXQgd2hpY2ggaXMgdXNlZCB0byBidWlsZCB0aGUgRGF5IFZpZXcuXG4gICAqL1xuXG4gIEBJbnB1dCgnY2xyRGF5VmlldycpXG4gIHB1YmxpYyBzZXQgZGF5VmlldyhkYXk6IERheVZpZXdNb2RlbCkge1xuICAgIHRoaXMuX2RheVZpZXcgPSBkYXk7XG4gICAgdGhpcy5kYXlTdHJpbmcgPSB0aGlzLl9kYXlWaWV3LmRheU1vZGVsLnRvRGF0ZVN0cmluZygpO1xuICB9XG5cbiAgcHVibGljIGdldCBkYXlWaWV3KCk6IERheVZpZXdNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RheVZpZXc7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZm9jdXNlZERheSBpbiB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHdoZW4gdGhlIENsckRheSBpcyBmb2N1c2VkLlxuICAgKi9cbiAgb25EYXlWaWV3Rm9jdXMoKSB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzZWREYXkgPSB0aGlzLmRheVZpZXcuZGF5TW9kZWw7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2VsZWN0ZWREYXkgd2hlbiB0aGUgQ2xyRGF5IGlzIHNlbGVjdGVkIGFuZCBjbG9zZXMgdGhlIGRhdGVwaWNrZXIgcG9wb3Zlci5cbiAgICovXG4gIHNlbGVjdERheSgpOiB2b2lkIHtcbiAgICBjb25zdCBkYXk6IERheU1vZGVsID0gdGhpcy5kYXlWaWV3LmRheU1vZGVsO1xuICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5ub3RpZnlTZWxlY3RlZERheUNoYW5nZWQoZGF5KTtcbiAgICB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UubWFya0FzRGlydHkoKTtcbiAgICB0aGlzLl9pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHsgc2VsZWN0b3I6ICdjbHItZGF5cGlja2VyJywgdGVtcGxhdGVVcmw6ICcuL2RheXBpY2tlci5odG1sJywgaG9zdDogeyAnW2NsYXNzLmRheXBpY2tlcl0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsckRheXBpY2tlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3ZpZXdNYW5hZ2VyU2VydmljZTogVmlld01hbmFnZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2xvY2FsZUhlbHBlclNlcnZpY2U6IExvY2FsZUhlbHBlclNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlXG4gICkge31cblxuICBnZXQgbW9udGhBdHRyU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbW9uU3RyaW5ncy5wYXJzZSh0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy5kYXRlcGlja2VyU2VsZWN0TW9udGhUZXh0LCB7XG4gICAgICBDQUxFTkRBUl9NT05USDogdGhpcy5jYWxlbmRhck1vbnRoLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHllYXJBdHRyU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbW9uU3RyaW5ncy5wYXJzZSh0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy5kYXRlcGlja2VyU2VsZWN0WWVhclRleHQsIHtcbiAgICAgIENBTEVOREFSX1lFQVI6IHRoaXMuY2FsZW5kYXJZZWFyLnRvU3RyaW5nKCksXG4gICAgfSk7XG4gIH1cblxuICBnZXQgYXJpYUxpdmVNb250aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbW1vblN0cmluZ3MucGFyc2UodGhpcy5jb21tb25TdHJpbmdzLmtleXMuZGF5cGlja2VyU1JDdXJyZW50TW9udGhQaHJhc2UsIHtcbiAgICAgIENVUlJFTlRfTU9OVEg6IHRoaXMuY2FsZW5kYXJNb250aCxcbiAgICB9KTtcbiAgfVxuXG4gIGdldCB1cGRhdGVBcmlhTGl2ZVllYXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb21tb25TdHJpbmdzLnBhcnNlKHRoaXMuY29tbW9uU3RyaW5ncy5rZXlzLmRheXBpY2tlclNSQ3VycmVudFllYXJQaHJhc2UsIHtcbiAgICAgIENVUlJFTlRfWUVBUjogdGhpcy5jYWxlbmRhclllYXIudG9TdHJpbmcoKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgVmlld01hbmFnZXJTZXJ2aWNlIHRvIGNoYW5nZSB0byB0aGUgbW9udGhwaWNrZXIgdmlldy5cbiAgICovXG4gIGNoYW5nZVRvTW9udGhWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb01vbnRoVmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBWaWV3TWFuYWdlclNlcnZpY2UgdG8gY2hhbmdlIHRvIHRoZSB5ZWFycGlja2VyIHZpZXcuXG4gICAqL1xuICBjaGFuZ2VUb1llYXJWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb1llYXJWaWV3KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbW9udGggdmFsdWUgb2YgdGhlIGNhbGVuZGFyIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkIGZvcm1hdC5cbiAgICovXG4gIGdldCBjYWxlbmRhck1vbnRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZUhlbHBlclNlcnZpY2UubG9jYWxlTW9udGhzQWJicmV2aWF0ZWRbdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyLm1vbnRoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB5ZWFyIHZhbHVlIG9mIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIGdldCBjYWxlbmRhclllYXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyLnllYXI7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZSB0byBtb3ZlIHRvIHRoZSBuZXh0IG1vbnRoLlxuICAgKi9cbiAgbmV4dE1vbnRoKCk6IHZvaWQge1xuICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5tb3ZlVG9OZXh0TW9udGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHRvIG1vdmUgdG8gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgcHJldmlvdXNNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UubW92ZVRvUHJldmlvdXNNb250aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gbW92ZSB0byB0aGUgY3VycmVudCBtb250aC5cbiAgICovXG4gIGN1cnJlbnRNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UubW92ZVRvQ3VycmVudE1vbnRoKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERPV05fQVJST1csIExFRlRfQVJST1csIFJJR0hUX0FSUk9XLCBVUF9BUlJPVyB9IGZyb20gJy4uLy4uL3V0aWxzL2tleS1jb2Rlcy9rZXktY29kZXMnO1xuXG5pbXBvcnQgeyBEYXRlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItbW9udGhwaWNrZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiY2FsZW5kYXItYnRuIG1vbnRoXCJcbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCBtb250aCBvZiBtb250aE5hbWVzOyBsZXQgbW9udGhJbmRleCA9IGluZGV4XCJcbiAgICAgICAgICAgIChjbGljayk9XCJjaGFuZ2VNb250aChtb250aEluZGV4KVwiXG4gICAgICAgICAgICBbY2xhc3MuaXMtc2VsZWN0ZWRdPVwibW9udGhJbmRleCA9PT0gY2FsZW5kYXJNb250aEluZGV4XCJcbiAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cImdldFRhYkluZGV4KG1vbnRoSW5kZXgpXCI+XG4gICAgICAgICAgICB7e21vbnRofX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MubW9udGhwaWNrZXJdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJNb250aHBpY2tlciBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF92aWV3TWFuYWdlclNlcnZpY2U6IFZpZXdNYW5hZ2VyU2VydmljZSxcbiAgICBwcml2YXRlIF9sb2NhbGVIZWxwZXJTZXJ2aWNlOiBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2U6IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZWxSZWY6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPSB0aGlzLmNhbGVuZGFyTW9udGhJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBmb2N1c2VkIG1vbnRoLlxuICAgKi9cbiAgcHJpdmF0ZSBfZm9jdXNlZE1vbnRoSW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9udGhzIGFycmF5IHdoaWNoIGlzIHVzZWQgdG8gcmVuZGVyZWQgdGhlIG1vbnRocGlja2VyIHZpZXcuXG4gICAqIE1vbnRocyBhcmUgaW4gdGhlIFRyYW5zbGF0aW9uV2lkdGguV2lkZSBmb3JtYXQuXG4gICAqL1xuICBnZXQgbW9udGhOYW1lcygpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZU1vbnRoc1dpZGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9udGggdmFsdWUgb2YgdGhlIENhbGVuZGFyLlxuICAgKi9cbiAgZ2V0IGNhbGVuZGFyTW9udGhJbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZGlzcGxheWVkQ2FsZW5kYXIubW9udGg7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZSB0byB1cGRhdGUgdGhlIG1vbnRoIHZhbHVlIG9mIHRoZSBjYWxlbmRhci5cbiAgICogQWxzbyBjaGFuZ2VzIHRoZSB2aWV3IHRvIHRoZSBkYXlwaWNrZXIuXG4gICAqL1xuICBjaGFuZ2VNb250aChtb250aEluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuY2hhbmdlTW9udGgobW9udGhJbmRleCk7XG4gICAgdGhpcy5fdmlld01hbmFnZXJTZXJ2aWNlLmNoYW5nZVRvRGF5VmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoZSBtb250aCBwYXNzZWQgdG8gdGhlIGZvY3VzZWQgbW9udGggYW5kIHJldHVybnMgdGhlIHRhYiBpbmRleC5cbiAgICovXG4gIGdldFRhYkluZGV4KG1vbnRoSW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIG1vbnRoSW5kZXggPT09IHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID8gMCA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIEtleWJvYXJkIGFycm93IG5hdmlnYXRpb24gZm9yIHRoZSBtb250aHBpY2tlci5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBOT1RFOiBEaWRuJ3QgbW92ZSB0aGlzIHRvIHRoZSBkYXRlIG5hdmlnYXRpb24gc2VydmljZSBiZWNhdXNlXG4gICAgLy8gdGhlIGxvZ2ljIGlzIGZhaXJseSBzaW1wbGUgYW5kIGl0IGRpZG4ndCBtYWtlIHNlbnNlIGZvciBtZVxuICAgIC8vIHRvIGNyZWF0ZSBleHRyYSBvYnNlcnZhYmxlcyBqdXN0IHRvIG1vdmUgdGhpcyBsb2dpYyB0byB0aGUgc2VydmljZS5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGtleUNvZGU6IG51bWJlciA9IGV2ZW50LmtleUNvZGU7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gVVBfQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4LS07XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gRE9XTl9BUlJPVyAmJiB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA8IDExKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4Kys7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gUklHSFRfQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPCA2KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID0gdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggKyA2O1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IExFRlRfQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPiA1KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID0gdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggLSA2O1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgb24gdGhlIGN1cnJlbnQgY2FsZW5kYXIgbW9udGggd2hlbiB0aGUgVmlldyBpcyBpbml0aWFsaXplZC5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuY29uc3QgWUVBUlNfVE9fRElTUExBWTogbnVtYmVyID0gMTA7XG5cbmV4cG9ydCBjbGFzcyBZZWFyUmFuZ2VNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgeWVhcjogbnVtYmVyKSB7XG4gICAgdGhpcy5nZW5lcmF0ZVllYXJSYW5nZSgpO1xuICB9XG5cbiAgeWVhclJhbmdlOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2UuXG4gICAqL1xuICBnZXQgbWlkZGxlWWVhcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnllYXJSYW5nZVtNYXRoLmZsb29yKHRoaXMueWVhclJhbmdlLmxlbmd0aCAvIDIpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHllYXIgcmFuZ2UgYmFzZWQgb24gdGhlIHllYXIgcGFyYW1ldGVyLlxuICAgKiBlZzogSWYgMjAxOCBpcyBwYXNzZWQgdGhlIG91dHB1dCB3aWxsIGJlIFsyMDEwLCAyMDExLCAuLi4sIDIwMTldXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlWWVhclJhbmdlKCkge1xuICAgIGNvbnN0IHJlbWFpbmRlcjogbnVtYmVyID0gdGhpcy55ZWFyICUgWUVBUlNfVE9fRElTUExBWTtcbiAgICBjb25zdCBmbG9vcjogbnVtYmVyID0gdGhpcy55ZWFyIC0gcmVtYWluZGVyO1xuICAgIGNvbnN0IGNlaWw6IG51bWJlciA9IGZsb29yICsgWUVBUlNfVE9fRElTUExBWTtcbiAgICB0aGlzLnllYXJSYW5nZSA9IHRoaXMuZ2VuZXJhdGVSYW5nZShmbG9vciwgY2VpbCk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGUgYSByYW5nZSBvZiBudW1iZXJzIGZyb20gZmxvb3IgdG8gY2VpbC5cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVSYW5nZShmbG9vcjogbnVtYmVyLCBjZWlsOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNlaWwgLSBmbG9vciB9LCAodiwgaykgPT4gayArIGZsb29yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGZvciB0aGUgbmV4dCBkZWNhZGUuXG4gICAqL1xuICBuZXh0RGVjYWRlKCk6IFllYXJSYW5nZU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IFllYXJSYW5nZU1vZGVsKHRoaXMueWVhciArIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGZvciB0aGUgcHJldmlvdXMgZGVjYWRlLlxuICAgKi9cbiAgcHJldmlvdXNEZWNhZGUoKTogWWVhclJhbmdlTW9kZWwge1xuICAgIHJldHVybiBuZXcgWWVhclJhbmdlTW9kZWwodGhpcy55ZWFyIC0gMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgZm9yIHRoZSBjdXJyZW50IGRlY2FkZS5cbiAgICovXG4gIGN1cnJlbnREZWNhZGUoKTogWWVhclJhbmdlTW9kZWwge1xuICAgIHJldHVybiBuZXcgWWVhclJhbmdlTW9kZWwobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGluIHRoZSBZZWFyUmFuZ2VNb2RlbC5cbiAgICovXG4gIGluUmFuZ2UodmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnllYXJSYW5nZS5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBET1dOX0FSUk9XLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICcuLi8uLi91dGlscy9rZXktY29kZXMva2V5LWNvZGVzJztcblxuaW1wb3J0IHsgWWVhclJhbmdlTW9kZWwgfSBmcm9tICcuL21vZGVsL3llYXItcmFuZ2UubW9kZWwnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckZvY3VzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBWaWV3TWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92aWV3LW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci15ZWFycGlja2VyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInllYXItc3dpdGNoZXJzXCI+XG4gICAgICAgICAgPGRpdiBhcmlhLWxpdmU9XCJwb2xpdGVcIiBjbGFzcz1cImNsci1zci1vbmx5XCI+XG4gICAgICAgICAgICB7eyBhcmlhTGl2ZURlY2FkZVRleHQgIH19LlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgIGNsYXNzPVwiY2FsZW5kYXItYnRuIHN3aXRjaGVyXCIgXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIiBcbiAgICAgICAgICAgICAgKGNsaWNrKT1cInByZXZpb3VzRGVjYWRlKClcIlxuICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbW1vblN0cmluZ3Mua2V5cy5kYXRlcGlja2VyUHJldmlvdXNEZWNhZGVcIj5cbiAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiYW5nbGVcIiBkaXI9XCJsZWZ0XCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmRhdGVwaWNrZXJQcmV2aW91c0RlY2FkZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgY2xhc3M9XCJjYWxlbmRhci1idG4gc3dpdGNoZXJcIiBcbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiIFxuICAgICAgICAgICAgICAoY2xpY2spPVwiY3VycmVudERlY2FkZSgpXCJcbiAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJjb21tb25TdHJpbmdzLmtleXMuZGF0ZXBpY2tlckN1cnJlbnREZWNhZGVcIj5cbiAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZXZlbnRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMuZGF0ZXBpY2tlckN1cnJlbnREZWNhZGVcIj48L2Nsci1pY29uPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgIGNsYXNzPVwiY2FsZW5kYXItYnRuIHN3aXRjaGVyXCIgXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIiBcbiAgICAgICAgICAgICAgKGNsaWNrKT1cIm5leHREZWNhZGUoKVwiXG4gICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmRhdGVwaWNrZXJOZXh0RGVjYWRlXCI+XG4gICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImFuZ2xlXCIgZGlyPVwicmlnaHRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMuZGF0ZXBpY2tlck5leHREZWNhZGVcIj48L2Nsci1pY29uPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInllYXJzXCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IHllYXIgb2YgeWVhclJhbmdlTW9kZWwueWVhclJhbmdlXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImNhbGVuZGFyLWJ0biB5ZWFyXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJnZXRUYWJJbmRleCh5ZWFyKVwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmlzLXNlbGVjdGVkXT1cInllYXIgPT09IGNhbGVuZGFyWWVhclwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImNoYW5nZVllYXIoeWVhcilcIj5cbiAgICAgICAgICAgICAgICB7e3llYXJ9fVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnllYXJwaWNrZXJdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJZZWFycGlja2VyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX3ZpZXdNYW5hZ2VyU2VydmljZTogVmlld01hbmFnZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2U6IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZWxSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMueWVhclJhbmdlTW9kZWwgPSBuZXcgWWVhclJhbmdlTW9kZWwodGhpcy5jYWxlbmRhclllYXIpO1xuICAgIHRoaXMuX2ZvY3VzZWRZZWFyID0gdGhpcy5jYWxlbmRhclllYXI7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnllYXJSYW5nZU1vZGVsKTtcbiAgfVxuXG4gIGdldCBhcmlhTGl2ZURlY2FkZVRleHQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb21tb25TdHJpbmdzLnBhcnNlKHRoaXMuY29tbW9uU3RyaW5ncy5rZXlzLmRheXBpY2tlclNSQ3VycmVudERlY2FkZVBocmFzZSwge1xuICAgICAgREVDQURFX1JBTkdFOiB0aGlzLmRlY2FkZVJhbmdlLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBkZWNhZGVSYW5nZTtcblxuICAvKipcbiAgICogWWVhclJhbmdlTW9kZWwgd2hpY2ggaXMgdXNlZCB0byBidWlsZCB0aGUgWWVhclBpY2tlciB2aWV3LlxuICAgKi9cbiAgeWVhclJhbmdlTW9kZWw6IFllYXJSYW5nZU1vZGVsO1xuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBmb2N1c2VkIHllYXIuXG4gICAqL1xuICBwcml2YXRlIF9mb2N1c2VkWWVhcjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB5ZWFyIHdoaWNoIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBvbi5cbiAgICovXG4gIGdldCBjYWxlbmRhclllYXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyLnllYXI7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50cyB0aGUgZm9jdXMgeWVhciBieSB0aGUgdmFsdWUgcGFzc2VkLiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCBpZiB0aGVcbiAgICogbmV3IHZhbHVlIGlzIG5vdCBpbiB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqL1xuICBwcml2YXRlIGluY3JlbWVudEZvY3VzWWVhckJ5KHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9mb2N1c2VkWWVhciA9IHRoaXMuX2ZvY3VzZWRZZWFyICsgdmFsdWU7XG4gICAgaWYgKCF0aGlzLnllYXJSYW5nZU1vZGVsLmluUmFuZ2UodGhpcy5fZm9jdXNlZFllYXIpKSB7XG4gICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgIHRoaXMueWVhclJhbmdlTW9kZWwgPSB0aGlzLnllYXJSYW5nZU1vZGVsLm5leHREZWNhZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueWVhclJhbmdlTW9kZWwgPSB0aGlzLnllYXJSYW5nZU1vZGVsLnByZXZpb3VzRGVjYWRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHRvIHVwZGF0ZSB0aGUgeWVhciB2YWx1ZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAqIEFsc28gY2hhbmdlcyB0aGUgdmlldyB0byB0aGUgZGF5cGlja2VyLlxuICAgKi9cbiAgY2hhbmdlWWVhcih5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuY2hhbmdlWWVhcih5ZWFyKTtcbiAgICB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuY2hhbmdlVG9EYXlWaWV3KCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgdG8gdGhlIHByZXZpb3VzIGRlY2FkZS5cbiAgICovXG4gIHByZXZpb3VzRGVjYWRlKCk6IHZvaWQge1xuICAgIHRoaXMueWVhclJhbmdlTW9kZWwgPSB0aGlzLnllYXJSYW5nZU1vZGVsLnByZXZpb3VzRGVjYWRlKCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnllYXJSYW5nZU1vZGVsKTtcbiAgICAvLyBZZWFyIGluIHRoZSB5ZWFycGlja2VyIGlzIG5vdCBmb2N1c2VkIGJlY2F1c2Ugd2hpbGUgbmF2aWdhdGluZyB0byBhIGRpZmZlcmVudCBkZWNhZGUsXG4gICAgLy8geW91IHdhbnQgdGhlIGZvY3VzIHRvIHJlbWFpbiBvbiB0aGUgZGVjYWRlIHN3aXRjaGVyIGFycm93cy5cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCB0byB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqL1xuICBjdXJyZW50RGVjYWRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy55ZWFyUmFuZ2VNb2RlbC5pblJhbmdlKHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS50b2RheS55ZWFyKSkge1xuICAgICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwuY3VycmVudERlY2FkZSgpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnllYXJSYW5nZU1vZGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCB0byB0aGUgbmV4dCBkZWNhZGUuXG4gICAqL1xuICBuZXh0RGVjYWRlKCk6IHZvaWQge1xuICAgIHRoaXMueWVhclJhbmdlTW9kZWwgPSB0aGlzLnllYXJSYW5nZU1vZGVsLm5leHREZWNhZGUoKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMueWVhclJhbmdlTW9kZWwpO1xuICAgIC8vIFllYXIgaW4gdGhlIHllYXJwaWNrZXIgaXMgbm90IGZvY3VzZWQgYmVjYXVzZSB3aGlsZSBuYXZpZ2F0aW5nIHRvIGEgZGlmZmVyZW50IGRlY2FkZSxcbiAgICAvLyB5b3Ugd2FudCB0aGUgZm9jdXMgdG8gcmVtYWluIG9uIHRoZSBkZWNhZGUgc3dpdGNoZXIgYXJyb3dzLlxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoZSB5ZWFyIHBhc3NlZCB0byB0aGUgZm9jdXNlZCB5ZWFyIGFuZCByZXR1cm5zIHRoZSB0YWIgaW5kZXguXG4gICAqL1xuICBnZXRUYWJJbmRleCh5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICghdGhpcy55ZWFyUmFuZ2VNb2RlbC5pblJhbmdlKHRoaXMuX2ZvY3VzZWRZZWFyKSkge1xuICAgICAgaWYgKHRoaXMueWVhclJhbmdlTW9kZWwuaW5SYW5nZSh0aGlzLmNhbGVuZGFyWWVhcikpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZFllYXIgPSB0aGlzLmNhbGVuZGFyWWVhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRZZWFyID0gdGhpcy55ZWFyUmFuZ2VNb2RlbC5taWRkbGVZZWFyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZm9jdXNlZFllYXIgPT09IHllYXIgPyAwIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgS2V5Ym9hcmQgYXJyb3cgbmF2aWdhdGlvbiBmb3IgdGhlIHllYXJwaWNrZXIuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgLy8gTk9URTogRGlkbid0IG1vdmUgdGhpcyB0byB0aGUgZGF0ZSBuYXZpZ2F0aW9uIHNlcnZpY2UgYmVjYXVzZVxuICAgIC8vIHRoZSBsb2dpYyBpcyBmYWlybHkgc2ltcGxlIGFuZCBpdCBkaWRuJ3QgbWFrZSBzZW5zZSBmb3IgbWVcbiAgICAvLyB0byBjcmVhdGUgZXh0cmEgb2JzZXJ2YWJsZXMganVzdCB0byBtb3ZlIHRoaXMgbG9naWMgdG8gdGhlIHNlcnZpY2UuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb25zdCBrZXlDb2RlOiBudW1iZXIgPSBldmVudC5rZXlDb2RlO1xuICAgICAgaWYgKGtleUNvZGUgPT09IFVQX0FSUk9XKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50Rm9jdXNZZWFyQnkoLTEpO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBET1dOX0FSUk9XKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50Rm9jdXNZZWFyQnkoMSk7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IFJJR0hUX0FSUk9XKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50Rm9jdXNZZWFyQnkoNSk7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IExFRlRfQVJST1cpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c1llYXJCeSgtNSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVSYW5nZSh5cm06IFllYXJSYW5nZU1vZGVsKTogdm9pZCB7XG4gICAgY29uc3QgZmxvb3IgPSB5cm0ueWVhclJhbmdlWzBdO1xuICAgIGNvbnN0IGNlaWwgPSB5cm0ueWVhclJhbmdlW3lybS55ZWFyUmFuZ2UubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5kZWNhZGVSYW5nZSA9IGAke2Zsb29yfSB0byAke2NlaWx9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIG9uIHRoZSBjdXJyZW50IGNhbGVuZGFyIHllYXIgd2hlbiB0aGUgVmlldyBpcyBpbml0aWFsaXplZC5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHZhbHVlIGZvciAgZGVjYWRlIHJhbmdlXG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENsckZvY3VzVHJhcE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySG9zdFdyYXBwaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyQ2FsZW5kYXIgfSBmcm9tICcuL2NhbGVuZGFyJztcbmltcG9ydCB7IENsckRhdGVDb250YWluZXIgfSBmcm9tICcuL2RhdGUtY29udGFpbmVyJztcbmltcG9ydCB7IENsckRhdGVJbnB1dCB9IGZyb20gJy4vZGF0ZS1pbnB1dCc7XG5pbXBvcnQgeyBDbHJEYXRlcGlja2VyVmlld01hbmFnZXIgfSBmcm9tICcuL2RhdGVwaWNrZXItdmlldy1tYW5hZ2VyJztcbmltcG9ydCB7IENsckRheSB9IGZyb20gJy4vZGF5JztcbmltcG9ydCB7IENsckRheXBpY2tlciB9IGZyb20gJy4vZGF5cGlja2VyJztcbmltcG9ydCB7IENsck1vbnRocGlja2VyIH0gZnJvbSAnLi9tb250aHBpY2tlcic7XG5pbXBvcnQgeyBDbHJZZWFycGlja2VyIH0gZnJvbSAnLi95ZWFycGlja2VyJztcblxuZXhwb3J0IGNvbnN0IENMUl9EQVRFUElDS0VSX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICBDbHJEYXksXG4gIENsckRhdGVDb250YWluZXIsXG4gIENsckRhdGVJbnB1dCxcbiAgQ2xyRGF0ZXBpY2tlclZpZXdNYW5hZ2VyLFxuICBDbHJNb250aHBpY2tlcixcbiAgQ2xyWWVhcnBpY2tlcixcbiAgQ2xyRGF5cGlja2VyLFxuICBDbHJDYWxlbmRhcixcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgQ2xySG9zdFdyYXBwaW5nTW9kdWxlLFxuICAgIENsckNvbmRpdGlvbmFsTW9kdWxlLFxuICAgIENsckljb25Nb2R1bGUsXG4gICAgQ2xyRm9jdXNUcmFwTW9kdWxlLFxuICAgIENsckNvbW1vbkZvcm1zTW9kdWxlLFxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfREFURVBJQ0tFUl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9EQVRFUElDS0VSX0RJUkVDVElWRVNdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJEYXRlQ29udGFpbmVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0ZXBpY2tlck1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItaW5wdXQtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtd3JhcHBlclwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJJbnB1dF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtJZkVycm9yU2VydmljZSwgTmdDb250cm9sU2VydmljZSwgQ29udHJvbElkU2VydmljZSwgQ29udHJvbENsYXNzU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENscklucHV0Q29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2Uuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoaW52YWxpZCA9PiB7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCkpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBPcHRpb25hbCwgVmlld0NvbnRhaW5lclJlZiwgUmVuZGVyZXIyLCBFbGVtZW50UmVmLCBJbmplY3RvciwgU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDbHJJbnB1dENvbnRhaW5lciB9IGZyb20gJy4vaW5wdXQtY29udGFpbmVyJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xySW5wdXRdJywgaG9zdDogeyAnW2NsYXNzLmNsci1pbnB1dF0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENscklucHV0IGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENscklucHV0Q29udGFpbmVyPiB7XG4gIHByb3RlY3RlZCBpbmRleCA9IDE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENscklucHV0Q29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uRm9ybXNNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vY29tbW9uLm1vZHVsZSc7XG5cbmltcG9ydCB7IENscklucHV0IH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDbHJJbnB1dENvbnRhaW5lciB9IGZyb20gJy4vaW5wdXQtY29udGFpbmVyJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRm9ybXNNb2R1bGUsIENsckljb25Nb2R1bGUsIENsckNvbW1vbkZvcm1zTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xySW5wdXQsIENscklucHV0Q29udGFpbmVyXSxcbiAgZXhwb3J0czogW0NsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJJbnB1dCwgQ2xySW5wdXRDb250YWluZXJdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJJbnB1dENvbnRhaW5lcl0sXG59KVxuZXhwb3J0IGNsYXNzIENscklucHV0TW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgSW5wdXQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IEZvY3VzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuXG5leHBvcnQgY29uc3QgVE9HR0xFX1NFUlZJQ0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48QmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+Pih1bmRlZmluZWQpO1xuZXhwb3J0IGZ1bmN0aW9uIFRvZ2dsZVNlcnZpY2VGYWN0b3J5KCkge1xuICByZXR1cm4gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG59XG5leHBvcnQgY29uc3QgVE9HR0xFX1NFUlZJQ0VfUFJPVklERVIgPSB7IHByb3ZpZGU6IFRPR0dMRV9TRVJWSUNFLCB1c2VGYWN0b3J5OiBUb2dnbGVTZXJ2aWNlRmFjdG9yeSB9O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcGFzc3dvcmQtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtd3JhcHBlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWlucHV0LWdyb3VwXCIgW2NsYXNzLmNsci1mb2N1c109XCJmb2N1c1wiPlxuICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJQYXNzd29yZF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgKm5nSWY9XCJjbHJUb2dnbGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSgpXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZFwiXG4gICAgICAgICAgICBjbGFzcz1cImNsci1pbnB1dC1ncm91cC1pY29uLWFjdGlvblwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICA8Y2xyLWljb25cbiAgICAgICAgICAgIFthdHRyLnNoYXBlXT1cInNob3cgPyAnZXllLWhpZGUnIDogJ2V5ZSdcIlxuICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwic2hvdyA/IGNvbW1vblN0cmluZ3Mua2V5cy5oaWRlIDogY29tbW9uU3RyaW5ncy5rZXlzLnNob3dcIj48L2Nsci1pY29uPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW1xuICAgIElmRXJyb3JTZXJ2aWNlLFxuICAgIE5nQ29udHJvbFNlcnZpY2UsXG4gICAgQ29udHJvbElkU2VydmljZSxcbiAgICBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIEZvY3VzU2VydmljZSxcbiAgICBUT0dHTEVfU0VSVklDRV9QUk9WSURFUixcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUGFzc3dvcmRDb250YWluZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcbiAgc2hvdyA9IGZhbHNlO1xuICBmb2N1cyA9IGZhbHNlO1xuICBwcml2YXRlIF90b2dnbGUgPSB0cnVlO1xuXG4gIEBJbnB1dCgnY2xyVG9nZ2xlJylcbiAgc2V0IGNsclRvZ2dsZShzdGF0ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3RvZ2dsZSA9IHN0YXRlO1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXQgY2xyVG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl90b2dnbGU7XG4gIH1cbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgcHVibGljIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBASW5qZWN0KFRPR0dMRV9TRVJWSUNFKSBwcml2YXRlIHRvZ2dsZVNlcnZpY2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHN0YXRlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnNob3cgPSAhdGhpcy5zaG93O1xuICAgIHRoaXMudG9nZ2xlU2VydmljZS5uZXh0KHRoaXMuc2hvdyk7XG4gIH1cblxuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBSZW5kZXJlcjIsXG4gIFNlbGYsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsclBhc3N3b3JkQ29udGFpbmVyLCBUT0dHTEVfU0VSVklDRSB9IGZyb20gJy4vcGFzc3dvcmQtY29udGFpbmVyJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhc3N3b3JkXScsIGhvc3Q6IHsgJ1tjbGFzcy5jbHItaW5wdXRdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJQYXNzd29yZCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJQYXNzd29yZENvbnRhaW5lcj4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByb3RlY3RlZCBpbmRleCA9IDE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChUT0dHTEVfU0VSVklDRSlcbiAgICBwcml2YXRlIHRvZ2dsZVNlcnZpY2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENsclBhc3N3b3JkQ29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcblxuICAgIGlmICghdGhpcy5mb2N1c1NlcnZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyUGFzc3dvcmQgcmVxdWlyZXMgYmVpbmcgd3JhcHBlZCBpbiA8Y2xyLXBhc3N3b3JkLWNvbnRhaW5lcj4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMudG9nZ2xlU2VydmljZS5zdWJzY3JpYmUodG9nZ2xlID0+IHtcbiAgICAgICAgcmVuZGVyZXIuc2V0UHJvcGVydHkoZWwubmF0aXZlRWxlbWVudCwgJ3R5cGUnLCB0b2dnbGUgPyAndGV4dCcgOiAncGFzc3dvcmQnKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgdHJpZ2dlckZvY3VzKCkge1xuICAgIGlmICh0aGlzLmZvY3VzU2VydmljZSkge1xuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignYmx1cicpXG4gIHRyaWdnZXJWYWxpZGF0aW9uKCkge1xuICAgIHN1cGVyLnRyaWdnZXJWYWxpZGF0aW9uKCk7XG4gICAgaWYgKHRoaXMuZm9jdXNTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmZvY3VzU2VydmljZS5mb2N1c2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyUGFzc3dvcmQgfSBmcm9tICcuL3Bhc3N3b3JkJztcbmltcG9ydCB7IENsclBhc3N3b3JkQ29udGFpbmVyIH0gZnJvbSAnLi9wYXNzd29yZC1jb250YWluZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyQ29tbW9uRm9ybXNNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDbHJQYXNzd29yZCwgQ2xyUGFzc3dvcmRDb250YWluZXJdLFxuICBleHBvcnRzOiBbQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsclBhc3N3b3JkLCBDbHJQYXNzd29yZENvbnRhaW5lcl0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsclBhc3N3b3JkQ29udGFpbmVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUGFzc3dvcmRNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmFkaW8td3JhcHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclJhZGlvXVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWxcIj48L2xhYmVsPlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItcmFkaW8td3JhcHBlcl0nOiAndHJ1ZScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0NvbnRyb2xJZFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJSYWRpb1dyYXBwZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25Jbml0IHtcbiAgLy8gV2UgbmVlZCBib3RoIF9keW5hbWljIGZvciBIb3N0V3JhcHBlciBhbmQgQ29udGVudENoaWxkKENsckxhYmVsKSBpbiBjYXNlcyB3aGVyZVxuICAvLyB0aGUgdXNlciBwdXRzIGEgcmFkaW8gaW5zaWRlIGEgd3JhcHBlciB3aXRob3V0IGEgbGFiZWwsIGhvc3Qgd3JhcHBpbmcgZG9lc24ndCBhcHBseVxuICAvLyBidXQgd2UnZCBzdGlsbCBuZWVkIHRvIGluc2VydCBhIGxhYmVsXG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbC5kaXNhYmxlR3JpZCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgT3B0aW9uYWwsIFJlbmRlcmVyMiwgU2VsZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcbmltcG9ydCB7IENsclJhZGlvV3JhcHBlciB9IGZyb20gJy4uL3JhZGlvL3JhZGlvLXdyYXBwZXInO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUmFkaW9dJyB9KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvIGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsclJhZGlvV3JhcHBlcj4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHN1cGVyKHZjciwgQ2xyUmFkaW9XcmFwcGVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXJhZGlvLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgPGxhYmVsICpuZ0lmPVwiIWxhYmVsICYmIGFkZEdyaWQoKVwiPjwvbGFiZWw+XG4gICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtjbGFzcy5jbHItY29udHJvbC1pbmxpbmVdPVwiY2xySW5saW5lXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1yYWRpby13cmFwcGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGRpdiBjbGFzcz1cImNsci1zdWJ0ZXh0LXdyYXBwZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlLCBJZkVycm9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvQ29udGFpbmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgcHJpdmF0ZSBpbmxpbmUgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuXG4gIC8qXG4gICAqIEhlcmUgd2Ugd2FudCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmcgY2FzZXNcbiAgICogY2xySW5saW5lIC0gdHJ1ZSBieSBwcmVzZW5jZVxuICAgKiBjbHJJbmxpbmU9XCJ0cnVlfGZhbHNlXCIgLSB1bmxlc3MgaXQgaXMgZXhwbGljaXRseSBmYWxzZSwgc3RyaW5ncyBhcmUgY29uc2lkZXJlZCB0cnVlXG4gICAqIFtjbHJJbmxpbmVdPVwidHJ1ZXxmYWxzZVwiIC0gZXhwZWN0IGEgYm9vbGVhblxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGNscklubGluZSh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmlubGluZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlubGluZSA9ICEhdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjbHJJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5saW5lO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpLCB0aGlzLmlubGluZSA/ICdjbHItY29udHJvbC1pbmxpbmUnIDogJycpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xySG9zdFdyYXBwaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyUmFkaW8gfSBmcm9tICcuL3JhZGlvJztcbmltcG9ydCB7IENsclJhZGlvQ29udGFpbmVyIH0gZnJvbSAnLi9yYWRpby1jb250YWluZXInO1xuaW1wb3J0IHsgQ2xyUmFkaW9XcmFwcGVyIH0gZnJvbSAnLi9yYWRpby13cmFwcGVyJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsckhvc3RXcmFwcGluZ01vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclJhZGlvLCBDbHJSYWRpb0NvbnRhaW5lciwgQ2xyUmFkaW9XcmFwcGVyXSxcbiAgZXhwb3J0czogW0NsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJSYWRpbywgQ2xyUmFkaW9Db250YWluZXIsIENsclJhZGlvV3JhcHBlcl0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsclJhZGlvV3JhcHBlcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IExheW91dFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zZWxlY3QtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGAgICAgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cIndyYXBwZXJDbGFzcygpXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclNlbGVjdF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG5cbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0lmRXJyb3JTZXJ2aWNlLCBOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sSWRTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU2VsZWN0Q29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIEBDb250ZW50Q2hpbGQoU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcikgbXVsdGlwbGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gIHByaXZhdGUgbXVsdGkgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgdGhpcy5tdWx0aSA9IGNvbnRyb2wudmFsdWVBY2Nlc3NvciBpbnN0YW5jZW9mIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgd3JhcHBlckNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpID8gJ2Nsci1tdWx0aXNlbGVjdC13cmFwcGVyJyA6ICdjbHItc2VsZWN0LXdyYXBwZXInO1xuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCkpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBWaWV3Q29udGFpbmVyUmVmLCBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBPcHRpb25hbCwgU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcbmltcG9ydCB7IENsclNlbGVjdENvbnRhaW5lciB9IGZyb20gJy4vc2VsZWN0LWNvbnRhaW5lcic7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJTZWxlY3RdJywgaG9zdDogeyAnW2NsYXNzLmNsci1zZWxlY3RdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJTZWxlY3QgZXh0ZW5kcyBXcmFwcGVkRm9ybUNvbnRyb2w8Q2xyU2VsZWN0Q29udGFpbmVyPiB7XG4gIHByb3RlY3RlZCBpbmRleCA9IDE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENsclNlbGVjdENvbnRhaW5lciwgaW5qZWN0b3IsIGNvbnRyb2wsIHJlbmRlcmVyLCBlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJTZWxlY3QgfSBmcm9tICcuL3NlbGVjdCc7XG5pbXBvcnQgeyBDbHJTZWxlY3RDb250YWluZXIgfSBmcm9tICcuL3NlbGVjdC1jb250YWluZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyQ29tbW9uRm9ybXNNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDbHJTZWxlY3QsIENsclNlbGVjdENvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyU2VsZWN0LCBDbHJTZWxlY3RDb250YWluZXJdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJTZWxlY3RDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTZWxlY3RNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRleHRhcmVhLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLXRleHRhcmVhLXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyVGV4dGFyZWFdXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2xdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZF0nOiAnY29udHJvbD8uZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbSWZFcnJvclNlcnZpY2UsIE5nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xJZFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUZXh0YXJlYUNvbnRhaW5lciBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGludmFsaWQgPSBmYWxzZTtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpKTtcbiAgfVxuXG4gIGFkZEdyaWQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0U2VydmljZSAmJiAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgVmlld0NvbnRhaW5lclJlZiwgUmVuZGVyZXIyLCBFbGVtZW50UmVmLCBJbmplY3RvciwgT3B0aW9uYWwsIFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5pbXBvcnQgeyBDbHJUZXh0YXJlYUNvbnRhaW5lciB9IGZyb20gJy4vdGV4dGFyZWEtY29udGFpbmVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclRleHRhcmVhXScsIGhvc3Q6IHsgJ1tjbGFzcy5jbHItdGV4dGFyZWFdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJUZXh0YXJlYSBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJUZXh0YXJlYUNvbnRhaW5lcj4ge1xuICBwcm90ZWN0ZWQgaW5kZXggPSAxO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgY29udHJvbDogTmdDb250cm9sLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgZWw6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgc3VwZXIodmNyLCBDbHJUZXh0YXJlYUNvbnRhaW5lciwgaW5qZWN0b3IsIGNvbnRyb2wsIHJlbmRlcmVyLCBlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJUZXh0YXJlYSB9IGZyb20gJy4vdGV4dGFyZWEnO1xuaW1wb3J0IHsgQ2xyVGV4dGFyZWFDb250YWluZXIgfSBmcm9tICcuL3RleHRhcmVhLWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclRleHRhcmVhLCBDbHJUZXh0YXJlYUNvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyVGV4dGFyZWEsIENsclRleHRhcmVhQ29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyVGV4dGFyZWFDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUZXh0YXJlYU1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQ2hlY2tib3hNb2R1bGUgfSBmcm9tICcuL2NoZWNrYm94L2NoZWNrYm94Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRGF0ZXBpY2tlck1vZHVsZSB9IGZyb20gJy4vZGF0ZXBpY2tlci9kYXRlcGlja2VyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJbnB1dE1vZHVsZSB9IGZyb20gJy4vaW5wdXQvaW5wdXQubW9kdWxlJztcbmltcG9ydCB7IENsclBhc3N3b3JkTW9kdWxlIH0gZnJvbSAnLi9wYXNzd29yZC9wYXNzd29yZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyUmFkaW9Nb2R1bGUgfSBmcm9tICcuL3JhZGlvL3JhZGlvLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTZWxlY3RNb2R1bGUgfSBmcm9tICcuL3NlbGVjdC9zZWxlY3QubW9kdWxlJztcbmltcG9ydCB7IENsclRleHRhcmVhTW9kdWxlIH0gZnJvbSAnLi90ZXh0YXJlYS90ZXh0YXJlYS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW1xuICAgIENsckNvbW1vbkZvcm1zTW9kdWxlLFxuICAgIENsckNoZWNrYm94TW9kdWxlLFxuICAgIENsckRhdGVwaWNrZXJNb2R1bGUsXG4gICAgQ2xySW5wdXRNb2R1bGUsXG4gICAgQ2xyUGFzc3dvcmRNb2R1bGUsXG4gICAgQ2xyUmFkaW9Nb2R1bGUsXG4gICAgQ2xyU2VsZWN0TW9kdWxlLFxuICAgIENsclRleHRhcmVhTW9kdWxlLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJGb3Jtc01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBDbHJMb2FkaW5nU3RhdGUgfSBmcm9tICcuLi8uLi9sb2FkaW5nL2xvYWRpbmcnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXhwYW5kIGltcGxlbWVudHMgTG9hZGluZ0xpc3RlbmVyIHtcbiAgcHVibGljIGV4cGFuZGFibGU6IG51bWJlciA9IDA7XG5cbiAgLy8gcHJpdmF0ZSBfcmVwbGFjZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9yZXBsYWNlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgcHVibGljIGdldCByZXBsYWNlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9yZXBsYWNlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG4gIHNldFJlcGxhY2UocmVwbGFjZVZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVwbGFjZS5uZXh0KHJlcGxhY2VWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9sb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBsb2FkaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICB9XG5cbiAgc2V0IGxvYWRpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9sb2FkaW5nKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgfVxuXG4gIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2V4cGFuZGVkKSB7XG4gICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuICAgICAgdGhpcy5fYW5pbWF0ZS5uZXh0KCk7XG4gICAgICB0aGlzLl9leHBhbmRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuX2V4cGFuZGVkO1xuICB9XG5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIHRoZSBkYXRhZ3JpZCBSb3dFeHBhbmQuXG4gIC8vIEkgc3BlbnQgc29tZSB0aW1lIGRvaW5nIHRoaXMgYnV0IHJhbiBpbnRvIGEgY291cGxlIG9mIGlzc3Vlc1xuICAvLyBXaWxsIHRha2UgY2FyZSBvZiB0aGlzIGxhdGVyLlxuICBwcml2YXRlIF9hbmltYXRlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgcHVibGljIGdldCBhbmltYXRlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZXhwYW5kQ2hhbmdlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgcHVibGljIGdldCBleHBhbmRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGFuZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGxvYWRpbmdTdGF0ZUNoYW5nZShzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlKTogdm9pZCB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuTE9BRElORzpcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZS5uZXh0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUmVuZGVyZXIyLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi9wcm92aWRlcnMvZXhwYW5kJztcblxuLyoqXG4gKiBUT0RPOiBtYWtlIHRoaXMgYSByZXVzYWJsZSBkaXJlY3RpdmUgb3V0c2lkZSBvZiBEYXRhZ3JpZCwgbGlrZSBbY2xyTG9hZGluZ10uXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkV4cGFuZGVkXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJJZkV4cGFuZGVkIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9leHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWQ7XG4gIH1cblxuICBASW5wdXQoJ2NscklmRXhwYW5kZWQnKVxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuZXhwYW5kLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NscklmRXhwYW5kZWRDaGFuZ2UnKSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgZXhwYW5kOiBFeHBhbmRcbiAgKSB7XG4gICAgZXhwYW5kLmV4cGFuZGFibGUrKztcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBleHBhbmQuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmQuZXhwYW5kZWQpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gYWxsIHRoZSBzZXJ2aWNlcyBhbmQgcXVlcmllcyBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIHByaXZhdGUgdXBkYXRlVmlldygpIHtcbiAgICBpZiAodGhpcy5leHBhbmQuZXhwYW5kZWQgJiYgdGhpcy5jb250YWluZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRlbXBsYXRlKSB7XG4gICAgICBpZiAodGhpcy5leHBhbmQuZXhwYW5kZWQpIHtcbiAgICAgICAgLy8gU2hvdWxkIHdlIHBhc3MgYSBjb250ZXh0PyBJIGRvbid0IHNlZSBhbnl0aGluZyB1c2VmdWwgdG8gcGFzcyByaWdodCBub3csXG4gICAgICAgIC8vIGJ1dCB3ZSBjYW4gY29tZSBiYWNrIHRvIGl0IGluIHRoZSBmdXR1cmUgYXMgYSBzb2x1dGlvbiBmb3IgYWRkaXRpb25hbCBmZWF0dXJlcy5cbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB3aGVuIHdlIG1vdmUgdGhlIGFuaW1hdGlvbiBsb2dpYyB0byBEYXRhZ3JpZCBSb3cgRXhwYW5kXG4gICAgICAgIC8vIFdlIGNsZWFyIGJlZm9yZSB0aGUgYW5pbWF0aW9uIGlzIG92ZXIuIE5vdCBpZGVhbCwgYnV0IGRvaW5nIGJldHRlciB3b3VsZCBpbnZvbHZlIGEgbXVjaCBoZWF2aWVyXG4gICAgICAgIC8vIHByb2Nlc3MgZm9yIHZlcnkgbGl0dGxlIGdhaW4uIE9uY2UgQW5ndWxhciBhbmltYXRpb25zIGFyZSBkeW5hbWljIGVub3VnaCwgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgICAgLy8gZ2V0IHRoZSBvcHRpbWFsIGJlaGF2aW9yLlxuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgdGVtcGxhdGUgcmVmLCB3ZSBmYWxsYmFjayB0byBhIGNydWRlIGRpc3BsYXk6IG5vbmUgZm9yIG5vdy5cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kLmV4cGFuZGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXNwbGF5JywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBXZSBjYXRjaCB0aGUgY2FzZSB3aGVyZSBjbHJJZkV4cGFuZGVkIHdhcyBwdXQgb24gYSBub24tRE9NIGVsZW1lbnQsIGFuZCB3ZSBqdXN0IGRvIG5vdGhpbmdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZXhwYW5kLmV4cGFuZGFibGUtLTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENscklmRXhwYW5kZWQgfSBmcm9tICcuL2lmLWV4cGFuZGVkJztcblxuZXhwb3J0ICogZnJvbSAnLi9pZi1leHBhbmRlZCc7XG5cbmV4cG9ydCBjb25zdCBFWFBBTkRfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xySWZFeHBhbmRlZF07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRVhQQU5EX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0VYUEFORF9ESVJFQ1RJVkVTXSwgZXhwb3J0czogW0VYUEFORF9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENscklmRXhwYW5kTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyTG9hZGluZyB9IGZyb20gJy4vbG9hZGluZyc7XG5cbmV4cG9ydCBjb25zdCBDTFJfTE9BRElOR19ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJMb2FkaW5nXTtcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0NMUl9MT0FESU5HX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbQ0xSX0xPQURJTkdfRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJMb2FkaW5nTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJPdXRzaWRlQ2xpY2tdJyB9KVxuZXhwb3J0IGNsYXNzIE91dHNpZGVDbGljayB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYpIHt9XG5cbiAgQElucHV0KCdjbHJTdHJpY3QnKSBzdHJpY3QgPSBmYWxzZTtcblxuICBAT3V0cHV0KCdjbHJPdXRzaWRlQ2xpY2snKSBvdXRzaWRlQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgZG9jdW1lbnRDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDsgLy8gR2V0IHRoZSBlbGVtZW50IGluIHRoZSBET00gb24gd2hpY2ggdGhlIG1vdXNlIHdhcyBjbGlja2VkXG4gICAgY29uc3QgaG9zdCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDsgLy8gR2V0IHRoZSBjdXJyZW50IGFjdGlvbk1lbnUgbmF0aXZlIEhUTUwgZWxlbWVudFxuXG4gICAgaWYgKHRhcmdldCA9PT0gaG9zdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RyaWN0ICYmIGhvc3QuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm91dHNpZGVDbGljay5lbWl0KGV2ZW50KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT3V0c2lkZUNsaWNrIH0gZnJvbSAnLi9vdXRzaWRlLWNsaWNrJztcblxuZXhwb3J0ICogZnJvbSAnLi9vdXRzaWRlLWNsaWNrJztcblxuZXhwb3J0IGNvbnN0IE9VU1RJREVfQ0xJQ0tfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbT3V0c2lkZUNsaWNrXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBPVVNUSURFX0NMSUNLX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW09VU1RJREVfQ0xJQ0tfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtPVVNUSURFX0NMSUNLX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xyT3V0c2lkZUNsaWNrTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qXG4gKiBJZiB3ZSBzb21lZGF5IHdhbnQgdG8gYmUgYWJsZSB0byByZW5kZXIgdGhlIGRhdGFncmlkIGluIGEgd2Vid29ya2VyLFxuICogdGhpcyBpcyB3aGVyZSB3ZSB3b3VsZCB0ZXN0IGlmIHdlJ3JlIGluIGhlYWRsZXNzIG1vZGUuIFJpZ2h0IG5vdyBpdCdzIG5vdCB0ZXN0aW5nIGFueXRoaW5nLCBidXQgYW55IGFjY2Vzc1xuICogdG8gbmF0aXZlIERPTSBlbGVtZW50cycgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBpbiB0aGUgRGF0YWdyaWQgaGFwcGVucyBoZXJlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERvbUFkYXB0ZXIge1xuICB1c2VyRGVmaW5lZFdpZHRoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RhdGFncmlkLWNlbGwtd2lkdGgtemVybycpO1xuICAgIGNvbnN0IHVzZXJEZWZpbmVkV2lkdGggPSB0aGlzLmNsaWVudFJlY3QoZWxlbWVudCkud2lkdGg7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkYXRhZ3JpZC1jZWxsLXdpZHRoLXplcm8nKTtcbiAgICByZXR1cm4gdXNlckRlZmluZWRXaWR0aDtcbiAgfVxuXG4gIHNjcm9sbEJhcldpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIHNjcm9sbFdpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFdpZHRoIHx8IDA7XG4gIH1cblxuICBjb21wdXRlZEhlaWdodChlbGVtZW50OiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpLCAxMCk7XG4gIH1cblxuICBjbGllbnRSZWN0KGVsZW1lbnQ6IGFueSk6IENsaWVudFJlY3Qge1xuICAgIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC50b3AsIDEwKSxcbiAgICAgIGJvdHRvbTogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QuYm90dG9tLCAxMCksXG4gICAgICBsZWZ0OiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC5sZWZ0LCAxMCksXG4gICAgICByaWdodDogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QucmlnaHQsIDEwKSxcbiAgICAgIHdpZHRoOiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC53aWR0aCwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC5oZWlnaHQsIDEwKSxcbiAgICB9O1xuICB9XG5cbiAgbWluV2lkdGgoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdtaW4td2lkdGgnKSwgMTApO1xuICB9XG5cbiAgZm9jdXMoZWxlbWVudDogYW55KTogdm9pZCB7XG4gICAgZWxlbWVudC5mb2N1cygpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UsIERyYWdQb2ludFBvc2l0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcblxuLy8gVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNvbnZlcnQgYW4gaW50ZXJuYWwgZXZlbnRcbi8vIHRvIGFuIGV4dGVybmFsIGV2ZW50IHRvIGJlIGVtaXR0ZWQuXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ0V2ZW50PFQ+IHtcbiAgcHVibGljIGRyYWdQb3NpdGlvbjogRHJhZ1BvaW50UG9zaXRpb247XG4gIHB1YmxpYyBncm91cDogc3RyaW5nIHwgc3RyaW5nW107XG4gIHB1YmxpYyBkcmFnRGF0YVRyYW5zZmVyOiBUO1xuICBwdWJsaWMgZHJvcFBvaW50UG9zaXRpb246IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSB7XG4gICAgdGhpcy5kcmFnUG9zaXRpb24gPSBkcmFnRXZlbnQuZHJhZ1Bvc2l0aW9uO1xuICAgIHRoaXMuZ3JvdXAgPSBkcmFnRXZlbnQuZ3JvdXA7XG4gICAgdGhpcy5kcmFnRGF0YVRyYW5zZmVyID0gZHJhZ0V2ZW50LmRyYWdEYXRhVHJhbnNmZXI7XG4gICAgdGhpcy5kcm9wUG9pbnRQb3NpdGlvbiA9IGRyYWdFdmVudC5kcm9wUG9pbnRQb3NpdGlvbjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuZXhwb3J0IGVudW0gRHJhZ0V2ZW50VHlwZSB7XG4gIERSQUdfU1RBUlQsXG4gIERSQUdfTU9WRSxcbiAgRFJBR19FTkQsXG4gIERSQUdfRU5URVIsXG4gIERSQUdfTEVBVkUsXG4gIERST1AsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ1BvaW50UG9zaXRpb24ge1xuICBwYWdlWDogbnVtYmVyO1xuICBwYWdlWTogbnVtYmVyO1xuICBtb3ZlWDogbnVtYmVyO1xuICBtb3ZlWTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYWdFdmVudEludGVyZmFjZTxUPiB7XG4gIHR5cGU6IERyYWdFdmVudFR5cGU7XG4gIGdyb3VwPzogc3RyaW5nIHwgc3RyaW5nW107XG4gIGdob3N0RWxlbWVudD86IGFueTtcbiAgZHJhZ1Bvc2l0aW9uOiBEcmFnUG9pbnRQb3NpdGlvbjtcbiAgZHJhZ0RhdGFUcmFuc2Zlcj86IFQ7XG4gIC8vIEZvciBkZWZhdWx0IGdob3N0cywgdGhpcyBkcm9wUG9pbnRQb3NpdGlvbiBkZW5vdGVzIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGdob3N0IGVsZW1lbnQuXG4gIC8vIFRoaXMgY2VudGVyIHBvaW50IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdob3N0IGlzIG92ZXIgZHJvcHBhYmxlIGVsZW1lbnRzIG9yIG5vdC5cbiAgZHJvcFBvaW50UG9zaXRpb24/OiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4ge1xuICBwcml2YXRlIGRyYWdTdGFydDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyYWdNb3ZlOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ0VuZDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyb3A6IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiA9IG5ldyBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4oKTtcblxuICBnZXQgZHJhZ1N0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ01vdmVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ01vdmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ0VuZGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBkcm9wcGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGJyb2FkY2FzdChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19TVEFSVDpcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQubmV4dChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEcmFnRXZlbnRUeXBlLkRSQUdfTU9WRTpcbiAgICAgICAgdGhpcy5kcmFnTW92ZS5uZXh0KGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19FTkQ6XG4gICAgICAgIHRoaXMuZHJhZ0VuZC5uZXh0KGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJPUDpcbiAgICAgICAgdGhpcy5kcm9wLm5leHQoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBEcmFnQW5kRHJvcEV2ZW50QnVzU2VydmljZSB9IGZyb20gJy4vZHJhZy1hbmQtZHJvcC1ldmVudC1idXMuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD4ge1xuICBwcml2YXRlIGRyYWdnYWJsZUVsOiBhbnk7XG5cbiAgLy8gY29udGFpbnMgdGhlIHN0YXJ0aW5nIGV2ZW50cyBzdWNoIGFzIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydFxuICBwcml2YXRlIGxpc3RlbmVyczogKCgpID0+IHZvaWQpW107XG4gIC8vIGNvbnRhaW5zIHRoZSBuZXN0ZWQgZXZlbnRzIHRoYXQgaGFwcGVucyBhZnRlci9pbnNpZGUgdGhlIHN0YXJ0aW5nIGV2ZW50c1xuICAvLyBzdWNoIGFzIHNlbGVjdHN0YXJ0LCBtb3VzZW1vdmUvdG91Y2htb3ZlLCBtb3VzZXVwL3RvdWNoZW5kXG4gIHByaXZhdGUgbmVzdGVkTGlzdGVuZXJzOiAoKCkgPT4gdm9pZClbXTtcblxuICBwcml2YXRlIGRyYWdTdGFydDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyYWdNb3ZlOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ0VuZDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuXG4gIHByaXZhdGUgaGFzRHJhZ1N0YXJ0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgZHJhZ1N0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ01vdmVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ01vdmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ0VuZGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBldmVudEJ1czogRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4pIHt9XG5cbiAgcHJpdmF0ZSBpbml0aWFsUG9zaXRpb246IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuXG4gIC8vIERyYWdnYWJsZSBjb21wb25lbnQgc2V0cyB0aGVzZSBwcm9wZXJ0aWVzOlxuICBwdWJsaWMgZHJhZ0RhdGFUcmFuc2Zlcj86IFQ7XG4gIHB1YmxpYyBncm91cD86IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIC8vIERyYWdnYWJsZUdob3N0IGNvbXBvbmVudCBzZXRzIHRoZXNlIHByb3BlcnRpZXM6XG4gIHB1YmxpYyBnaG9zdEVsZW1lbnQ/OiBhbnk7XG4gIHB1YmxpYyBkcm9wUG9pbnRQb3NpdGlvbj86IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuXG4gIHB1YmxpYyBhdHRhY2hEcmFnTGlzdGVuZXJzKGRyYWdnYWJsZUVsOiBOb2RlKSB7XG4gICAgdGhpcy5kcmFnZ2FibGVFbCA9IGRyYWdnYWJsZUVsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gW1xuICAgICAgdGhpcy5jdXN0b21EcmFnRXZlbnQodGhpcy5kcmFnZ2FibGVFbCwgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcpLFxuICAgICAgdGhpcy5jdXN0b21EcmFnRXZlbnQodGhpcy5kcmFnZ2FibGVFbCwgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJyksXG4gICAgXTtcbiAgfVxuXG4gIHB1YmxpYyBkZXRhY2hEcmFnTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmxpc3RlbmVycykge1xuICAgICAgdGhpcy5saXN0ZW5lcnMubWFwKGV2ZW50ID0+IGV2ZW50KCkpO1xuICAgIH1cblxuICAgIC8vIEluIG1vc3QgY2FzZXMsIG9uY2UgdXNlcnMgc3RhcnQgZHJhZ2dpbmcgd2l0aCBtb3VzZWRvd24vdG91Y2hzdGFydCBldmVudHMsXG4gICAgLy8gdGhleSB3aWxsIGVuZCBkcmFnZ2luZyBhdCBvbmUgcG9pbnQgd2l0aCBtb3VzZXVwL3RvdWNoZW5kLlxuICAgIC8vIEhvd2V2ZXIsIHRoZXJlIG1pZ2h0IGJlIGEgZmV3IGNhc2VzIHdoZXJlIG1vdXNlZG93bi90b3VjaHN0YXJ0IGV2ZW50cyBnZXQgcmVnaXN0ZXJlZCxcbiAgICAvLyBidXQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGdldHMgcmVtb3ZlZCBiZWZvcmUgdXNlciBlbmRzIGRyYWdnaW5nLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byByZW1vdmUgdGhlIGF0dGFjaGVkIGxpc3RlbmVycyB0aGF0IGhhcHBlbmVkIGR1cmluZyB0aGUgbW91c2Vkb3duL3RvdWNoc3RhcnQgZXZlbnRzLlxuICAgIGlmICh0aGlzLm5lc3RlZExpc3RlbmVycykge1xuICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMubWFwKGV2ZW50ID0+IGV2ZW50KCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TmF0aXZlRXZlbnRPYmplY3QoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KTogYW55IHtcbiAgICBpZiAoKDxUb3VjaEV2ZW50PmV2ZW50KS5oYXNPd25Qcm9wZXJ0eSgnY2hhbmdlZFRvdWNoZXMnKSkge1xuICAgICAgcmV0dXJuICg8VG91Y2hFdmVudD5ldmVudCkuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGN1c3RvbURyYWdFdmVudChlbGVtZW50OiBOb2RlLCBzdGFydE9uRXZlbnQ6IHN0cmluZywgbW92ZU9uRXZlbnQ6IHN0cmluZywgZW5kT25FdmVudDogc3RyaW5nKTogKCkgPT4gdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsIHN0YXJ0T25FdmVudCwgKHN0YXJ0RXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7XG4gICAgICAvLyBzYXZlIHRoZSBpbml0aWFsIHBvaW50IHRvIGluaXRpYWxQb3NpdGlvblxuICAgICAgLy8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGhvdyBmYXIgdGhlIGRyYWdnYWJsZSBoYXMgYmVlbiBkcmFnZ2VkIGZyb20gaXRzIGluaXRpYWwgcG9zaXRpb25cbiAgICAgIHRoaXMuaW5pdGlhbFBvc2l0aW9uID0ge1xuICAgICAgICBwYWdlWDogdGhpcy5nZXROYXRpdmVFdmVudE9iamVjdChzdGFydEV2ZW50KS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IHRoaXMuZ2V0TmF0aXZlRXZlbnRPYmplY3Qoc3RhcnRFdmVudCkucGFnZVksXG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIG5lc3RlZCBsaXN0ZW5lcnMnIHByb3BlcnR5IHdpdGggYSBuZXcgZW1wdHkgYXJyYXk7XG4gICAgICB0aGlzLm5lc3RlZExpc3RlbmVycyA9IFtdO1xuXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBkaXNhYmxlIHNlbGVjdGlvbiBkdXJpbmcgZHJhZ2dpbmcgKGVzcGVjaWFsbHkgaW4gRURHRS9JRTExKS5cbiAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzLnB1c2goXG4gICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdzZWxlY3RzdGFydCcsIChzZWxlY3RFdmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICBzZWxlY3RFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNlbGVjdEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gTGlzdGVuIHRvIG1vdXNlbW92ZS90b3VjaG1vdmUgZXZlbnRzIG91dHNpZGUgb2YgYW5ndWxhciB6b25lLlxuICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMucHVzaChcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCBtb3ZlT25FdmVudCwgKG1vdmVFdmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIGlzIG5lZWRlZCBoZXJlIHRvIHByZXZlbnQgbmVzdGVkIGRyYWdnYWJsZXMgZnJvbSBnZXR0aW5nIGRyYWdnZWRcbiAgICAgICAgICAgIC8vIGFsdG9nZXRoZXIuIFdlIHNob3VsZG4ndCB1c2UgRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgaGVyZSBhcyB3ZSBhcmUgbGlzdGVuaW5nIHRvIHRoZSBldmVudHNcbiAgICAgICAgICAgIC8vIG9uIHRoZSBnbG9iYWwgZWxlbWVudCBsZXZlbC5cblxuICAgICAgICAgICAgLy8gV2l0aCBFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgaXQgcmVnaXN0ZXJzIHRoZSBldmVudHMgc2VudCBmcm9tIHRoZSBpbm5lciBtb3N0IGRyYWdnYWJsZVxuICAgICAgICAgICAgLy8gZmlyc3QuIFRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhhdCwgaXQgc3RvcHMgbGlzdGVuaW5nIHRvIHRoZSBzYW1lIHR5cGUgb2YgZXZlbnRzIG9uIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBlbGVtZW50LiBTbyB0aGlzIHdpbGwgaGVscCB1cyB0byBub3QgcmVnaXN0ZXIgdGhlIHNhbWUgZXZlbnRzIHRoYXQgd291bGQgY29tZSBmcm9tIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGxldmVsIGRyYWdnYWJsZXMgZXZlbnR1YWxseS5cblxuICAgICAgICAgICAgbW92ZUV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYXNEcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIEZpcmUgXCJkcmFnc3RhcnRcIlxuICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChtb3ZlRXZlbnQsIERyYWdFdmVudFR5cGUuRFJBR19TVEFSVCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGaXJlIFwiZHJhZ21vdmVcIlxuICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChtb3ZlRXZlbnQsIERyYWdFdmVudFR5cGUuRFJBR19NT1ZFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIExpc3RlbiB0byBtb3VzZXVwL3RvdWNoZW5kIGV2ZW50cy5cbiAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzLnB1c2goXG4gICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsIGVuZE9uRXZlbnQsIChlbmRFdmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNEcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgLy8gRmlyZSBcImRyYWdlbmRcIiBvbmx5IGlmIGRyYWdzdGFydCBpcyByZWdpc3RlcmVkXG4gICAgICAgICAgICB0aGlzLmhhc0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChlbmRFdmVudCwgRHJhZ0V2ZW50VHlwZS5EUkFHX0VORCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2UgbXVzdCByZW1vdmUgdGhlIHRoZSBuZXN0ZWQgbGlzdGVuZXJzIGV2ZXJ5IHRpbWUgZHJhZyBjb21wbGV0ZXMuXG4gICAgICAgICAgaWYgKHRoaXMubmVzdGVkTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZExpc3RlbmVycy5tYXAoZXZlbnQgPT4gZXZlbnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYnJvYWRjYXN0KGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCwgZXZlbnRUeXBlOiBEcmFnRXZlbnRUeXBlKTogdm9pZCB7XG4gICAgY29uc3QgZHJhZ0V2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4gPSB0aGlzLmdlbmVyYXRlRHJhZ0V2ZW50KGV2ZW50LCBldmVudFR5cGUpO1xuXG4gICAgc3dpdGNoIChkcmFnRXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBEcmFnRXZlbnRUeXBlLkRSQUdfU1RBUlQ6XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0Lm5leHQoZHJhZ0V2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19NT1ZFOlxuICAgICAgICB0aGlzLmRyYWdNb3ZlLm5leHQoZHJhZ0V2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19FTkQ6XG4gICAgICAgIHRoaXMuZHJhZ0VuZC5uZXh0KGRyYWdFdmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBzZXQgYWZ0ZXIgdGhleSBhcmUgYnJvYWRjYXN0ZWQgdG8gdGhlIERyYWdnYWJsZUdob3N0IGNvbXBvbmVudC5cbiAgICBkcmFnRXZlbnQuZ2hvc3RFbGVtZW50ID0gdGhpcy5naG9zdEVsZW1lbnQ7XG4gICAgZHJhZ0V2ZW50LmRyb3BQb2ludFBvc2l0aW9uID0gdGhpcy5kcm9wUG9pbnRQb3NpdGlvbjtcblxuICAgIHRoaXMuZXZlbnRCdXMuYnJvYWRjYXN0KGRyYWdFdmVudCk7XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlRHJhZ0V2ZW50KGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCwgZXZlbnRUeXBlOiBEcmFnRXZlbnRUeXBlKTogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+IHtcbiAgICBjb25zdCBuYXRpdmVFdmVudDogYW55ID0gdGhpcy5nZXROYXRpdmVFdmVudE9iamVjdChldmVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgZHJhZ1Bvc2l0aW9uOiB7XG4gICAgICAgIHBhZ2VYOiBuYXRpdmVFdmVudC5wYWdlWCxcbiAgICAgICAgcGFnZVk6IG5hdGl2ZUV2ZW50LnBhZ2VZLFxuICAgICAgICBtb3ZlWDogbmF0aXZlRXZlbnQucGFnZVggLSB0aGlzLmluaXRpYWxQb3NpdGlvbi5wYWdlWCxcbiAgICAgICAgbW92ZVk6IG5hdGl2ZUV2ZW50LnBhZ2VZIC0gdGhpcy5pbml0aWFsUG9zaXRpb24ucGFnZVksXG4gICAgICB9LFxuICAgICAgZ3JvdXA6IHRoaXMuZ3JvdXAsXG4gICAgICBkcmFnRGF0YVRyYW5zZmVyOiB0aGlzLmRyYWdEYXRhVHJhbnNmZXIsXG4gICAgICBnaG9zdEVsZW1lbnQ6IHRoaXMuZ2hvc3RFbGVtZW50LFxuICAgIH07XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcblxuLy8gVGhpcyBzZXJ2aWNlIGlzIHVzZWQgdG8gY2FwdHVyZSB0aGUgc3RhdGUgb2YgY2xyRHJhZ2dhYmxlIGVsZW1lbnRcbi8vIGF0IGEgY2VydGFpbiBldmVudCBhbmQgcGFzc2VzIGl0IHRvIGNsckRyYWdnYWJsZUdob3N0IGNvbXBvbmVudC5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2U8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIpIHt9XG5cbiAgcHJpdmF0ZSBkcmFnZ2FibGVFbENsaWVudFJlY3Q6IENsaWVudFJlY3Q7XG4gIHByaXZhdGUgc25hcHNob3REcmFnRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPjtcblxuICBwdWJsaWMgY2FwdHVyZShlbDogTm9kZSwgZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPik6IHZvaWQge1xuICAgIHRoaXMuZHJhZ2dhYmxlRWxDbGllbnRSZWN0ID0gdGhpcy5kb21BZGFwdGVyLmNsaWVudFJlY3QoZWwpO1xuICAgIHRoaXMuc25hcHNob3REcmFnRXZlbnQgPSBldmVudDtcbiAgfVxuICBwdWJsaWMgZGlzY2FyZCgpOiB2b2lkIHtcbiAgICBkZWxldGUgdGhpcy5kcmFnZ2FibGVFbENsaWVudFJlY3Q7XG4gICAgZGVsZXRlIHRoaXMuc25hcHNob3REcmFnRXZlbnQ7XG4gIH1cbiAgZ2V0IGhhc0RyYWdnYWJsZVN0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuc25hcHNob3REcmFnRXZlbnQgJiYgISF0aGlzLmRyYWdnYWJsZUVsQ2xpZW50UmVjdDtcbiAgfVxuICBnZXQgY2xpZW50UmVjdCgpOiBDbGllbnRSZWN0IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGVFbENsaWVudFJlY3Q7XG4gIH1cbiAgZ2V0IGRyYWdFdmVudCgpOiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4ge1xuICAgIHJldHVybiB0aGlzLnNuYXBzaG90RHJhZ0V2ZW50O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgTmdab25lLCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJhZy1ldmVudC1saXN0ZW5lci5zZXJ2aWNlJztcbmltcG9ydCB7IERyYWdnYWJsZVNuYXBzaG90U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RyYWdnYWJsZS1zbmFwc2hvdC5zZXJ2aWNlJztcblxudHlwZSBQYWdlUG9zaXRpb24gPSB7XG4gIHBhZ2VYOiBudW1iZXI7XG4gIHBhZ2VZOiBudW1iZXI7XG59O1xudHlwZSBPZmZzZXRQb3NpdGlvbiA9IHtcbiAgdG9wOiBudW1iZXI7XG4gIGxlZnQ6IG51bWJlcjtcbn07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kcmFnZ2FibGUtZ2hvc3QnLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignbGVhdmVBbmltYXRpb24nLCBbXG4gICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgIHN0eWxlKHsgbGVmdDogJyonLCB0b3A6ICcqJyB9KSxcbiAgICAgICAgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgdG9wOiAne3t0b3B9fScsIGxlZnQ6ICd7e2xlZnR9fScgfSkpLFxuICAgICAgXSksXG4gICAgXSksXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyYWdnYWJsZUdob3N0PFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBkcmFnZ2FibGVHaG9zdEVsOiBhbnk7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIEBIb3N0QmluZGluZygnQGxlYXZlQW5pbWF0aW9uJykgbGVhdmVBbmltQ29uZmlnID0geyB2YWx1ZTogMCwgcGFyYW1zOiB7IHRvcDogJzBweCcsIGxlZnQ6ICcwcHgnIH0gfTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZHJhZ0V2ZW50TGlzdGVuZXI6IERyYWdFdmVudExpc3RlbmVyU2VydmljZTxUPixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRyYWdnYWJsZVNuYXBzaG90OiBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmVcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmRyYWdFdmVudExpc3RlbmVyIHx8ICF0aGlzLmRyYWdnYWJsZVNuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbHItZHJhZ2dhYmxlLWdob3N0IGNvbXBvbmVudCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsckRyYWdnYWJsZSBkaXJlY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnZ2FibGVHaG9zdEVsID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuXG4gICAgLy8gTmVlZCB0byB1c2UgUmVuZGVyZXIyIGFzIGl0IHJ1bnMgb3V0c2lkZSBvZiBOZ1pvbmVcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZHJhZ2dhYmxlR2hvc3RFbCwgJ2RyYWdnYWJsZS1naG9zdCcpO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGdob3N0IGVsZW1lbnQgaW4gRHJhZ0V2ZW50TGlzdGVuZXIgdG8gcGFzcyBpbiBhIENsckRyYWdFdmVudC5cbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmdob3N0RWxlbWVudCA9IHRoaXMuZHJhZ2dhYmxlR2hvc3RFbDtcblxuICAgIC8vIERlZmF1bHQgZ2hvc3Qgc2l6ZSBnZXRzIHRoZSBzaXplIG9mIENsckRyYWdnYWJsZSBlbGVtZW50LlxuICAgIHRoaXMuc2V0RGVmYXVsdEdob3N0U2l6ZSh0aGlzLmRyYWdnYWJsZUdob3N0RWwpO1xuXG4gICAgY29uc3Qgb2Zmc2V0OiBPZmZzZXRQb3NpdGlvbiA9IHtcbiAgICAgIHRvcDogdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5oYXNEcmFnZ2FibGVTdGF0ZVxuICAgICAgICA/IHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuZHJhZ0V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWSAtIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC50b3BcbiAgICAgICAgOiAwLFxuICAgICAgbGVmdDogdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5oYXNEcmFnZ2FibGVTdGF0ZVxuICAgICAgICA/IHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuZHJhZ0V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWCAtIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5sZWZ0XG4gICAgICAgIDogMCxcbiAgICB9O1xuXG4gICAgbGV0IGlzQW5pbWF0aW9uQ29uZmlndXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdNb3ZlZC5zdWJzY3JpYmUoKGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgLy8gT24gdGhlIGZpcnN0IGRyYWcgbW92ZSBldmVudCwgd2UgY29uZmlndXJlIHRoZSBhbmltYXRpb24gYXMgaXQncyBkZXBlbmRlbnQgb24gdGhlIGZpcnN0IGRyYWcgZXZlbnQuXG4gICAgICAgIGlmICghaXNBbmltYXRpb25Db25maWd1cmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuaGFzRHJhZ2dhYmxlU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvT25MZWF2ZShcbiAgICAgICAgICAgICAgYCR7dGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgIGAke3RoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5sZWZ0fXB4YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlVG9PbkxlYXZlKGAke2V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWX1weGAsIGAke2V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWH1weGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc0FuaW1hdGlvbkNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIGRyYWdnYWJsZSBnaG9zdC5cbiAgICAgICAgY29uc3QgdG9wTGVmdFBvc2l0aW9uOiBQYWdlUG9zaXRpb24gPSB0aGlzLmZpbmRUb3BMZWZ0UG9zaXRpb24oZXZlbnQuZHJhZ1Bvc2l0aW9uLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uU3R5bGUodGhpcy5kcmFnZ2FibGVHaG9zdEVsLCB0b3BMZWZ0UG9zaXRpb24ucGFnZVgsIHRvcExlZnRQb3NpdGlvbi5wYWdlWSk7XG4gICAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJvcFBvaW50UG9zaXRpb24gPSB0aGlzLmZpbmREcm9wUG9pbnRQb3NpdGlvbih0b3BMZWZ0UG9zaXRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXREZWZhdWx0R2hvc3RTaXplKGVsOiBOb2RlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuaGFzRHJhZ2dhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZVN0eWxlKGVsLCB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3Qud2lkdGgsIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5oZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYW5pbWF0ZVRvT25MZWF2ZSh0b3A6IHN0cmluZywgbGVmdDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgIHRoaXMubGVhdmVBbmltQ29uZmlnID0geyB2YWx1ZTogMCwgcGFyYW1zOiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0gfTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZFRvcExlZnRQb3NpdGlvbihkcmFnUG9zaXRpb246IFBhZ2VQb3NpdGlvbiwgb2Zmc2V0OiBPZmZzZXRQb3NpdGlvbik6IFBhZ2VQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHsgcGFnZVg6IGRyYWdQb3NpdGlvbi5wYWdlWCAtIG9mZnNldC5sZWZ0LCBwYWdlWTogZHJhZ1Bvc2l0aW9uLnBhZ2VZIC0gb2Zmc2V0LnRvcCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kRHJvcFBvaW50UG9zaXRpb24odG9wTGVmdFBvc2l0aW9uOiBQYWdlUG9zaXRpb24pOiBQYWdlUG9zaXRpb24ge1xuICAgIGlmICh0aGlzLmRyYWdnYWJsZVNuYXBzaG90Lmhhc0RyYWdnYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlWDogdG9wTGVmdFBvc2l0aW9uLnBhZ2VYICsgdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LndpZHRoIC8gMixcbiAgICAgICAgcGFnZVk6IHRvcExlZnRQb3NpdGlvbi5wYWdlWSArIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRvcExlZnRQb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldFNpemVTdHlsZShlbDogTm9kZSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAnd2lkdGgnLCBgJHt3aWR0aH1weGApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICdoZWlnaHQnLCBgJHtoZWlnaHR9cHhgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0UG9zaXRpb25TdHlsZShlbDogTm9kZSwgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICdsZWZ0JywgYCR7bGVmdH1weGApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICd0b3AnLCBgJHt0b3B9cHhgKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBTa2lwU2VsZiwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJhZy1ldmVudC1saXN0ZW5lci5zZXJ2aWNlJztcblxuLy8gVGhpcyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB3aWxsIGJlIHVzZWQgbWFpbmx5IHRvZ2V0aGVyIHdpdGggYGNsci1kcmFnZ2FibGUtZ2hvc3RgIGRpcmVjdGl2ZSBpbnNpZGUgb2YgY2xyRHJhZ2dhYmxlXG4vLyBkaXJlY3RpdmUuIFRoZSBkaXJlY3RpdmUgaXMgcmVzcG9uc2libGUgZm9yIGluc3RhbnRpYXRpbmcgYGNsci1kcmFnZ2FibGUtZ2hvc3RgIGRpcmVjdGl2ZSBvbmx5IGR1cmluZyBkcmFnZ2luZyBzb1xuLy8gdGhhdCBBbmd1bGFyIENoYW5nZSBEZXRlY3Rpb24gaXMgcHJldmVudGVkIGZyb20gcnVubmluZyBpZiBhIGNvbXBvbmVudCBvciBkaXJlY3RpdmUgaXMgcGxhY2VkIGluc2lkZSBvZiB0aGVcbi8vIGBjbHItZHJhZ2dhYmxlLWdob3N0YCBkaXJlY3RpdmUuXG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkRyYWdnZWRdJyB9KVxuZXhwb3J0IGNsYXNzIENscklmRHJhZ2dlZDxUPiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkcmFnRXZlbnRMaXN0ZW5lcjogRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlPFQ+XG4gICkge1xuICAgIGlmICghdGhpcy5kcmFnRXZlbnRMaXN0ZW5lciB8fCAhdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlICpjbHJJZkRyYWdnZWQgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyRHJhZ2dhYmxlIGRpcmVjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ1N0YXJ0ZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ0VuZGVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2UgfSBmcm9tICcuL2RyYWctZXZlbnQtbGlzdGVuZXIuc2VydmljZSc7XG5cbi8vIFRoaXMgcHJvdmlkZXIgcmVnaXN0ZXJzIHRoZSBkcmFnIGhhbmRsZSBlbGVtZW50LlxuLy8gV2hlbiBpdCByZWdpc3RlcnMgYSBlbGVtZW50IGFzIGEgZHJhZyBoYW5kbGUsIGl0IGF0dGFjaGVzIHRoYXQgZWxlbWVudCB0byB0aGUgbGlzdGVuZXJzIGZyb20gQ2xyRHJhZ0V2ZW50TGlzdGVuZXIuXG4vLyBBbHNvLCBpdCBhZGRzIHRoZSBcImRyYWctaGFuZGxlXCIgY3NzIGNsYXNzIHRvIHRoZSByZWdpc3RlcmVkIGVsZW1lbnQgdGhyb3VnaCBSZW5kZXJlci5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZTxUPiB7XG4gIHByaXZhdGUgX2N1c3RvbUhhbmRsZUVsOiBhbnk7XG4gIHByaXZhdGUgX2RlZmF1bHRIYW5kbGVFbDogYW55O1xuXG4gIGdldCBkZWZhdWx0SGFuZGxlRWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRIYW5kbGVFbDtcbiAgfVxuXG4gIHNldCBkZWZhdWx0SGFuZGxlRWwoZWw6IE5vZGUpIHtcbiAgICB0aGlzLl9kZWZhdWx0SGFuZGxlRWwgPSBlbDsgLy8gZGVmYXVsdEhhbmRsZUVsIHdpbGwgYmUgdXN1YWxseSB0aGUgY2xyRHJhZ2dhYmxlIGVsZW1lbnQuXG5cbiAgICAvLyBJZiB0aGUgY3VzdG9tSGFuZGxlRWwgaGFzIGJlZW4gcmVnaXN0ZXJlZCxcbiAgICAvLyBkb24ndCBtYWtlIHRoZSBkZWZhdWx0SGFuZGxlRWwgdGhlIGRyYWcgaGFuZGxlIHlldCB1bnRpbCB0aGUgY3VzdG9tSGFuZGxlRWwgaXMgdW5yZWdpc3RlcmVkLlxuICAgIGlmICghdGhpcy5fY3VzdG9tSGFuZGxlRWwpIHtcbiAgICAgIHRoaXMubWFrZUVsZW1lbnRIYW5kbGUodGhpcy5fZGVmYXVsdEhhbmRsZUVsKTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRyYWdFdmVudExpc3RlbmVyOiBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD4sIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBwcml2YXRlIG1ha2VFbGVtZW50SGFuZGxlKGVsOiBOb2RlKSB7XG4gICAgaWYgKHRoaXMuX2RlZmF1bHRIYW5kbGVFbCAmJiB0aGlzLl9kZWZhdWx0SGFuZGxlRWwgIT09IGVsKSB7XG4gICAgICAvLyBCZWZvcmUgbWFraW5nIGFuIGVsZW1lbnQgdGhlIGN1c3RvbSBoYW5kbGUgZWxlbWVudCxcbiAgICAgIC8vIHdlIHNob3VsZCByZW1vdmUgdGhlIGV4aXN0aW5nIGRyYWctaGFuZGxlIGNsYXNzIGZyb20gdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9kZWZhdWx0SGFuZGxlRWwsICdkcmFnLWhhbmRsZScpO1xuICAgIH1cbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmF0dGFjaERyYWdMaXN0ZW5lcnMoZWwpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWwsICdkcmFnLWhhbmRsZScpO1xuICB9XG5cbiAgZ2V0IGN1c3RvbUhhbmRsZUVsKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXN0b21IYW5kbGVFbDtcbiAgfVxuXG4gIHB1YmxpYyByZWdpc3RlckN1c3RvbUhhbmRsZShlbDogTm9kZSkge1xuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZGV0YWNoRHJhZ0xpc3RlbmVycygpOyAvLyByZW1vdmVzIHRoZSBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICB0aGlzLl9jdXN0b21IYW5kbGVFbCA9IGVsO1xuICAgIHRoaXMubWFrZUVsZW1lbnRIYW5kbGUodGhpcy5fY3VzdG9tSGFuZGxlRWwpO1xuICB9XG5cbiAgcHVibGljIHVucmVnaXN0ZXJDdXN0b21IYW5kbGUoKSB7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kZXRhY2hEcmFnTGlzdGVuZXJzKCk7IC8vIHJlbW92ZXMgdGhlIGV4aXN0aW5nIGxpc3RlbmVyc1xuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fY3VzdG9tSGFuZGxlRWwsICdkcmFnLWhhbmRsZScpO1xuICAgIGRlbGV0ZSB0aGlzLl9jdXN0b21IYW5kbGVFbDtcbiAgICAvLyBpZiBkZWZhdWx0IGhhbmRsZSBpcyBzZXQsIG1ha2UgdGhhdCBoYW5kbGVcbiAgICBpZiAodGhpcy5fZGVmYXVsdEhhbmRsZUVsKSB7XG4gICAgICB0aGlzLm1ha2VFbGVtZW50SGFuZGxlKHRoaXMuX2RlZmF1bHRIYW5kbGVFbCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gVGhpcyBzZXJ2aWNlIGNsYXNzIGFkZHMgYW5kIHJlbW92ZXMgdGhlIFwiaW4tZHJhZ1wiIGNsYXNzIHRvIHRoZSBkb2N1bWVudCBib2R5IGVsZW1lbnRcbi8vIHRocm91Z2ggaXRzIHB1YmxpYyBlbnRlcigpIGFuZCBleGl0KCkgbWV0aG9kcy5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHbG9iYWxEcmFnTW9kZVNlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cbiAgZW50ZXIoKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnaW4tZHJhZycpO1xuICB9XG5cbiAgZXhpdCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdpbi1kcmFnJyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudEZhY3RvcnksXG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgQ29udGVudENoaWxkLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IENsckRyYWdFdmVudCB9IGZyb20gJy4uL2RyYWctZXZlbnQnO1xuaW1wb3J0IHsgQ2xyRHJhZ2dhYmxlR2hvc3QgfSBmcm9tICcuLi9kcmFnZ2FibGUtZ2hvc3QnO1xuaW1wb3J0IHsgQ2xySWZEcmFnZ2VkIH0gZnJvbSAnLi4vaWYtZHJhZ2dlZCc7XG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcbmltcG9ydCB7IERyYWdFdmVudExpc3RlbmVyU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9kcmFnLWV2ZW50LWxpc3RlbmVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvZHJhZy1oYW5kbGUtcmVnaXN0cmFyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlU25hcHNob3RTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2RyYWdnYWJsZS1zbmFwc2hvdC5zZXJ2aWNlJztcbmltcG9ydCB7IEdsb2JhbERyYWdNb2RlU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9nbG9iYWwtZHJhZy1tb2RlLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRHJhZ2dhYmxlXScsXG4gIHByb3ZpZGVyczogW1xuICAgIERyYWdFdmVudExpc3RlbmVyU2VydmljZSxcbiAgICBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZSxcbiAgICBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2UsXG4gICAgR2xvYmFsRHJhZ01vZGVTZXJ2aWNlLFxuICAgIERvbUFkYXB0ZXIsXG4gIF0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kcmFnZ2FibGVdJzogJ3RydWUnLCAnW2NsYXNzLmJlaW5nLWRyYWdnZWRdJzogJ2RyYWdPbicgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ2dhYmxlPFQ+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBkcmFnZ2FibGVFbDogYW55O1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHByaXZhdGUgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxDbHJEcmFnZ2FibGVHaG9zdDxUPj47XG4gIHB1YmxpYyBkcmFnT246IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgZHJhZ0V2ZW50TGlzdGVuZXI6IERyYWdFdmVudExpc3RlbmVyU2VydmljZTxUPixcbiAgICBwcml2YXRlIGRyYWdIYW5kbGVSZWdpc3RyYXI6IERyYWdIYW5kbGVSZWdpc3RyYXJTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgZHJhZ2dhYmxlU25hcHNob3Q6IERyYWdnYWJsZVNuYXBzaG90U2VydmljZTxUPixcbiAgICBwcml2YXRlIGdsb2JhbERyYWdNb2RlOiBHbG9iYWxEcmFnTW9kZVNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5kcmFnZ2FibGVFbCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLmNmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeTxDbHJEcmFnZ2FibGVHaG9zdDxUPj4oQ2xyRHJhZ2dhYmxlR2hvc3QpO1xuICB9XG5cbiAgQENvbnRlbnRDaGlsZChDbHJJZkRyYWdnZWQpIGN1c3RvbUdob3N0OiBDbHJJZkRyYWdnZWQ8VD47XG5cbiAgQElucHV0KCdjbHJEcmFnZ2FibGUnKVxuICBzZXQgZGF0YVRyYW5zZmVyKHZhbHVlOiBUKSB7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnRGF0YVRyYW5zZmVyID0gdmFsdWU7XG4gIH1cblxuICBASW5wdXQoJ2Nsckdyb3VwJylcbiAgc2V0IGdyb3VwKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZ3JvdXAgPSB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGVmYXVsdEdob3N0KGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pIHtcbiAgICB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNhcHR1cmUodGhpcy5kcmFnZ2FibGVFbCwgZXZlbnQpO1xuICAgIC8vIE5PVEU6IFRoZSBkZWZhdWx0IGdob3N0IGVsZW1lbnQgd2lsbCBhcHBlYXJcbiAgICAvLyBuZXh0IHRvIHRoZSBjbHJEcmFnZ2FibGUgaW4gdGhlIERPTSBhcyBhIHNpYmxpbmcgZWxlbWVudC5cbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KHRoaXMuY29tcG9uZW50RmFjdG9yeSwgMCwgdGhpcy5pbmplY3RvciwgW1xuICAgICAgW3RoaXMuZHJhZ2dhYmxlRWwuY2xvbmVOb2RlKHRydWUpXSxcbiAgICBdKTtcbiAgfVxuXG4gIHByaXZhdGUgZGVzdHJveURlZmF1bHRHaG9zdCgpIHtcbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY2xlYXIoKTtcbiAgICB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmRpc2NhcmQoKTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRyYWdTdGFydCcpIGRyYWdTdGFydEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnTW92ZScpIGRyYWdNb3ZlRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyYWdFbmQnKSBkcmFnRW5kRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuZHJhZ0hhbmRsZVJlZ2lzdHJhci5kZWZhdWx0SGFuZGxlRWwgPSB0aGlzLmRyYWdnYWJsZUVsO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdTdGFydGVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbERyYWdNb2RlLmVudGVyKCk7XG4gICAgICAgIHRoaXMuZHJhZ09uID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUdob3N0KSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVEZWZhdWx0R2hvc3QoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kcmFnU3RhcnRFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChldmVudCkpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnTW92ZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuZHJhZ01vdmVFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChldmVudCkpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnRW5kZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRHJhZ01vZGUuZXhpdCgpO1xuICAgICAgICB0aGlzLmRyYWdPbiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tR2hvc3QpIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lEZWZhdWx0R2hvc3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdFbmRFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChldmVudCkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kZXRhY2hEcmFnTGlzdGVuZXJzKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IENsckRyYWdFdmVudCB9IGZyb20gJy4uL2RyYWctZXZlbnQnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBDbHJEcm9wVG9sZXJhbmNlSW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcm9wLXRvbGVyYW5jZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvZHJhZy1hbmQtZHJvcC1ldmVudC1idXMuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJEcm9wcGFibGVdJyxcbiAgcHJvdmlkZXJzOiBbRG9tQWRhcHRlcl0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kcm9wcGFibGVdJzogJ3RydWUnLCAnW2NsYXNzLmRyYWdnYWJsZS1tYXRjaF0nOiAnaXNEcmFnZ2FibGVNYXRjaCcgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJvcHBhYmxlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGRyYWdTdGFydFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGRyYWdNb3ZlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgZHJhZ0VuZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIHByaXZhdGUgZHJvcHBhYmxlRWw6IGFueTtcbiAgcHJpdmF0ZSBjbGllbnRSZWN0OiBDbGllbnRSZWN0O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBldmVudEJ1czogRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHtcbiAgICB0aGlzLmRyb3BwYWJsZUVsID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgcHJpdmF0ZSBpc0RyYWdnYWJsZU1hdGNoOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2lzRHJhZ2dhYmxlT3ZlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHNldCBpc0RyYWdnYWJsZU92ZXIodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAvLyBXZSBuZWVkIHRvIGFkZC9yZW1vdmUgdGhpcyBkcmFnZ2FibGUtb3ZlciBjbGFzcyB2aWEgUmVuZGVyZXIyXG4gICAgLy8gYmVjYXVzZSBpc0RyYWdnYWJsZU92ZXIgaXMgc2V0IG91dHNpZGUgb2YgTmdab25lLlxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmRyb3BwYWJsZUVsLCAnZHJhZ2dhYmxlLW92ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmRyb3BwYWJsZUVsLCAnZHJhZ2dhYmxlLW92ZXInKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGVPdmVyID0gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIF9ncm91cDogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgQElucHV0KCdjbHJHcm91cCcpXG4gIHNldCBncm91cCh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICB0aGlzLl9ncm91cCA9IHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfZHJvcFRvbGVyYW5jZTogQ2xyRHJvcFRvbGVyYW5jZUludGVyZmFjZSA9IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwIH07XG5cbiAgcHJpdmF0ZSBkcm9wVG9sZXJhbmNlR2VuZXJhdG9yKHRvcCA9IDAsIHJpZ2h0ID0gdG9wLCBib3R0b20gPSB0b3AsIGxlZnQgPSByaWdodCk6IENsckRyb3BUb2xlcmFuY2VJbnRlcmZhY2Uge1xuICAgIHJldHVybiB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9O1xuICB9XG5cbiAgQElucHV0KCdjbHJEcm9wVG9sZXJhbmNlJylcbiAgc2V0IGRyb3BUb2xlcmFuY2UodmFsdWU6IG51bWJlciB8IHN0cmluZyB8IENsckRyb3BUb2xlcmFuY2VJbnRlcmZhY2UpIHtcbiAgICAvLyBJZiB1c2VyIHByb3ZpZGVzIGFuIG9iamVjdCBoZXJlIGFuZCB3YW50cyB0byBtYW5pcHVsYXRlL3VwZGF0ZSBwcm9wZXJ0aWVzIGluZGl2aWR1YWxseSxcbiAgICAvLyB0aGUgb2JqZWN0IG11c3QgYmUgaW1tdXRhYmxlIGFzIHdlIGdlbmVyYXRlIG5ldyBvYmplY3QgYmFzZWQgdXNlcidzIGdpdmVuIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fZHJvcFRvbGVyYW5jZSA9IHRoaXMuZHJvcFRvbGVyYW5jZUdlbmVyYXRvcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB0b2xlcmFuY2VWYWx1ZXMgPSB2YWx1ZVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAgIC5tYXAodG9sZXJhbmNlID0+IHBhcnNlSW50KHRvbGVyYW5jZSwgMTApKTtcbiAgICAgIHRoaXMuX2Ryb3BUb2xlcmFuY2UgPSB0aGlzLmRyb3BUb2xlcmFuY2VHZW5lcmF0b3IoLi4udG9sZXJhbmNlVmFsdWVzKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAvLyBUaGUgdmFsdWUgY291bGQgYmUgcGFzc2VkIGluIGFzIHtsZWZ0OiAyMCwgdG9wOiAzMCB9XG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZXN0IG9mIHRoZSBkaXJlY3Rpb24gcHJvcGVydGllcyBzaG91bGQgYmUgMC5cbiAgICAgIC8vIFRoYXQncyB3aHkgd2UgaW5pdGlhbGl6ZSBwcm9wZXJ0aWVzIHdpdGggMCBmaXJzdCwgdGhlbiBvdmVycmlkZSB3aXRoIHVzZXIncyBnaXZlbiB2YWx1ZS5cbiAgICAgIHRoaXMuX2Ryb3BUb2xlcmFuY2UgPSB7IC4uLnRoaXMuZHJvcFRvbGVyYW5jZUdlbmVyYXRvcigwKSwgLi4udmFsdWUgfTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEcmFnU3RhcnQnKSBkcmFnU3RhcnRFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ01vdmUnKSBkcmFnTW92ZUVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnRW5kJykgZHJhZ0VuZEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnTGVhdmUnKSBkcmFnTGVhdmVFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ0VudGVyJykgZHJhZ0VudGVyRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyb3AnKSBkcm9wRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcHJpdmF0ZSB1bnN1YnNjcmliZUZyb20oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrR3JvdXBNYXRjaChkcmFnZ2FibGVHcm91cDogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICAvLyBCb3RoIERyYWdnYWJsZSBhbmQgRHJvcHBhYmxlIGhhdmUgY2xyR3JvdXAgaW5wdXQuXG4gICAgLy8gVGhlIGNsckdyb3VwIGlucHV0IGNhbiBiZSBib3RoIGEgc3RyaW5nIGtleSBvciBhcnJheSBvZiBzdHJpbmcga2V5cyBpbiBEcmFnZ2FibGUgYW5kIERyb3BwYWJsZS5cblxuICAgIC8vIEl0J3Mgbm90IG1hdGNoIGlmIERyYWdnYWJsZSBoYXMgbm8gZGVmaW5lZCB2YWx1ZSBhc3NpZ25lZCB0byBjbHJHcm91cCwgYnV0IERyb3BwYWJsZSBoYXMgYSBkZWZpbmVkIGNsckdyb3VwLlxuICAgIGlmICghZHJhZ2dhYmxlR3JvdXAgJiYgdGhpcy5fZ3JvdXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlIHNhbWUgaXMgdHJ1ZSB0aGUgb3RoZXIgd2F5IHJvdW5kLlxuICAgIGlmICghdGhpcy5fZ3JvdXAgJiYgZHJhZ2dhYmxlR3JvdXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJdCdzIG1hdGNoIGlmIGJvdGggRHJhZ2dhYmxlIGFuZCBEcm9wcGFibGUgaGF2ZSBubyBhc3NpZ25lZCB2YWx1ZSBmb3IgY2xyR3JvdXAuXG4gICAgaWYgKCF0aGlzLl9ncm91cCAmJiAhZHJhZ2dhYmxlR3JvdXApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEl0J3MgbWF0Y2ggaWYgYm90aCBEcmFnZ2FibGUgYW5kIERyb3BwYWJsZSBoYXZlIHNpbXBsZSBzdHJpbmcga2V5cyB0aGF0IGFyZSBtYXRjaGluZy5cbiAgICAvLyBJdCdzIG1hdGNoIGlmIERyYWdnYWJsZSdzIHNpbXBsZSBjbHJHcm91cCBrZXkgaXMgbWF0Y2hpbmcgd2l0aCBvbmUgb2YgdGhlIGNsckdyb3VwIGtleXMgb2YgRHJvcHBhYmxlLiBUaGVcbiAgICAvLyBzYW1lIGlzIHRydWUgdGhlIG90aGVyIHdheSByb3VuZC5cbiAgICAvLyBpdCdzIG1hdGNoIGlmIG9uZSBvZiB0aGUgY2xyR3JvdXAga2V5cyBvZiBEcm9wcGFibGUgaXMgbWF0Y2hpbmcgd2l0aCBvbmUgb2YgdGhlIGNsckdyb3VwIGtleXMgb2YgRHJhZ2dhYmxlLlxuICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlR3JvdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2dyb3VwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXAgPT09IGRyYWdnYWJsZUdyb3VwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwLmluZGV4T2YoZHJhZ2dhYmxlR3JvdXApID4gLTE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZ3JvdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkcmFnZ2FibGVHcm91cC5pbmRleE9mKHRoaXMuX2dyb3VwKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9ncm91cCBhcyBzdHJpbmdbXSkuc29tZShncm91cEtleSA9PiBkcmFnZ2FibGVHcm91cC5pbmRleE9mKGdyb3VwS2V5KSA+IC0xKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzSW5Ecm9wQXJlYShwb2ludDogeyBwYWdlWDogbnVtYmVyOyBwYWdlWTogbnVtYmVyIH0pOiBib29sZWFuIHtcbiAgICBpZiAoIXBvaW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuZG9tQWRhcHRlci5jbGllbnRSZWN0KHRoaXMuZHJvcHBhYmxlRWwpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHBvaW50LnBhZ2VYID49IHRoaXMuY2xpZW50UmVjdC5sZWZ0IC0gdGhpcy5fZHJvcFRvbGVyYW5jZS5sZWZ0ICYmXG4gICAgICBwb2ludC5wYWdlWCA8PSB0aGlzLmNsaWVudFJlY3QucmlnaHQgKyB0aGlzLl9kcm9wVG9sZXJhbmNlLnJpZ2h0ICYmXG4gICAgICBwb2ludC5wYWdlWSA+PSB0aGlzLmNsaWVudFJlY3QudG9wIC0gdGhpcy5fZHJvcFRvbGVyYW5jZS50b3AgJiZcbiAgICAgIHBvaW50LnBhZ2VZIDw9IHRoaXMuY2xpZW50UmVjdC5ib3R0b20gKyB0aGlzLl9kcm9wVG9sZXJhbmNlLmJvdHRvbVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uRHJhZ1N0YXJ0KGRyYWdTdGFydEV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBkcmFnZ2FibGUgYW5kIGRyb3BwYWJsZSBoYXZlIGEgbWF0Y2hpbmcgZ3JvdXAga2V5LlxuICAgIHRoaXMuaXNEcmFnZ2FibGVNYXRjaCA9IHRoaXMuY2hlY2tHcm91cE1hdGNoKGRyYWdTdGFydEV2ZW50Lmdyb3VwKTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBkcmFnTW92ZWQgYW5kIGRyYWdFbmRlZCBvbmx5IGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGhhdmUgYSBtYXRjaGluZyBncm91cCBrZXkuXG4gICAgaWYgKHRoaXMuaXNEcmFnZ2FibGVNYXRjaCkge1xuICAgICAgdGhpcy5kcmFnU3RhcnRFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcmFnU3RhcnRFdmVudCkpO1xuICAgICAgdGhpcy5kcmFnTW92ZVN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRCdXMuZHJhZ01vdmVkLnN1YnNjcmliZSgoZHJhZ01vdmVFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMub25EcmFnTW92ZShkcmFnTW92ZUV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcmFnRW5kU3Vic2NyaXB0aW9uID0gdGhpcy5ldmVudEJ1cy5kcmFnRW5kZWQuc3Vic2NyaWJlKChkcmFnRW5kRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLm9uRHJhZ0VuZChkcmFnRW5kRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkRyYWdNb3ZlKGRyYWdNb3ZlRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPik6IHZvaWQge1xuICAgIGNvbnN0IGlzSW5Ecm9wQXJlYSA9IHRoaXMuaXNJbkRyb3BBcmVhKGRyYWdNb3ZlRXZlbnQuZHJvcFBvaW50UG9zaXRpb24pO1xuICAgIGlmICghdGhpcy5faXNEcmFnZ2FibGVPdmVyICYmIGlzSW5Ecm9wQXJlYSkge1xuICAgICAgdGhpcy5pc0RyYWdnYWJsZU92ZXIgPSB0cnVlO1xuICAgICAgY29uc3QgZHJhZ0VudGVyRXZlbnQgPSB7IC4uLmRyYWdNb3ZlRXZlbnQsIHR5cGU6IERyYWdFdmVudFR5cGUuRFJBR19FTlRFUiB9O1xuICAgICAgdGhpcy5ldmVudEJ1cy5icm9hZGNhc3QoZHJhZ0VudGVyRXZlbnQpO1xuICAgICAgdGhpcy5kcmFnRW50ZXJFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcmFnRW50ZXJFdmVudCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNEcmFnZ2FibGVPdmVyICYmICFpc0luRHJvcEFyZWEpIHtcbiAgICAgIHRoaXMuaXNEcmFnZ2FibGVPdmVyID0gZmFsc2U7XG4gICAgICBjb25zdCBkcmFnTGVhdmVFdmVudCA9IHsgLi4uZHJhZ01vdmVFdmVudCwgdHlwZTogRHJhZ0V2ZW50VHlwZS5EUkFHX0xFQVZFIH07XG4gICAgICB0aGlzLmV2ZW50QnVzLmJyb2FkY2FzdChkcmFnTGVhdmVFdmVudCk7XG4gICAgICB0aGlzLmRyYWdMZWF2ZUVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdMZWF2ZUV2ZW50KSk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnTW92ZUVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdNb3ZlRXZlbnQpKTtcbiAgfVxuXG4gIHByaXZhdGUgb25EcmFnRW5kKGRyYWdFbmRFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dhYmxlT3Zlcikge1xuICAgICAgaWYgKGRyYWdFbmRFdmVudC5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgLy8gQnkgdGhpcyBwb2ludCwgdGhlIGRyYWdnYWJsZSBnaG9zdCBjb21wb25lbnQgaXMgZGVzdHJveWVkLFxuICAgICAgICAvLyBidXQgdGhlIGVsZW1lbnQgd291bGQgYmUgYWN0aXZlIHVudGlsIGl0cyBhbmltYXRpb24gY29tcGxldGVzLlxuICAgICAgICAvLyBBcyBzdWNoLCBvbmNlIHRoZSBnaG9zdCBpcyBkcm9wcGVkIG92ZXIsIHdlIHdpbGwgZ2l2ZSBpdCBcImRyb3BwZWRcIiBjbGFzcy5cblxuICAgICAgICAvLyBUaGlzIHByb2Nlc3MgY2Fubm90IGJlIGRvbmUgaW4gdGhlIGdob3N0IGNvbXBvbmVudFxuICAgICAgICAvLyBiZWNhdXNlIGFueSBzdWJzY3JpcHRpb24gdG8gdGhlIGRyb3AgZXZlbnQgaXMgaW5lZmZlY3RpdmUgb3IgaW52YWxpZFxuICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGhhZCBiZWVuIGFscmVhZHkgZGVzdHJveWVkLlxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGRyYWdFbmRFdmVudC5naG9zdEVsZW1lbnQsICdkcm9wcGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRyb3BFdmVudCA9IHsgLi4uZHJhZ0VuZEV2ZW50LCB0eXBlOiBEcmFnRXZlbnRUeXBlLkRST1AgfTtcbiAgICAgIHRoaXMuZXZlbnRCdXMuYnJvYWRjYXN0KGRyb3BFdmVudCk7XG4gICAgICB0aGlzLmRyb3BFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcm9wRXZlbnQpKTtcbiAgICAgIHRoaXMuaXNEcmFnZ2FibGVPdmVyID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZHJhZ0VuZEVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdFbmRFdmVudCkpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ01vdmVTdWJzY3JpcHRpb24pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ0VuZFN1YnNjcmlwdGlvbik7XG4gICAgdGhpcy5pc0RyYWdnYWJsZU1hdGNoID0gZmFsc2U7XG4gICAgZGVsZXRlIHRoaXMuY2xpZW50UmVjdDtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuZHJhZ1N0YXJ0U3Vic2NyaXB0aW9uID0gdGhpcy5ldmVudEJ1cy5kcmFnU3RhcnRlZC5zdWJzY3JpYmUoKGRyYWdTdGFydEV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgIHRoaXMub25EcmFnU3RhcnQoZHJhZ1N0YXJ0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnN1YnNjcmliZUZyb20odGhpcy5kcmFnU3RhcnRTdWJzY3JpcHRpb24pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ01vdmVTdWJzY3JpcHRpb24pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ0VuZFN1YnNjcmlwdGlvbik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RyYWctaGFuZGxlLXJlZ2lzdHJhci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckRyYWdIYW5kbGVdJywgaG9zdDogeyAnW2NsYXNzLmRyYWctaGFuZGxlXSc6ICd0cnVlJyB9IH0pXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ0hhbmRsZTxUPiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsIEBPcHRpb25hbCgpIHByaXZhdGUgZHJhZ0hhbmRsZVJlZ2lzdHJhcjogRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2U8VD4pIHtcbiAgICBpZiAoIXRoaXMuZHJhZ0hhbmRsZVJlZ2lzdHJhcikge1xuICAgICAgLy8gQ2xyRHJhZ0hhbmRsZVJlZ2lzdHJhciBpcyBwcm92aWRlZCBpbiBDbHJEcmFnZ2FibGUgc28gd2UgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnQgaGVyZVxuICAgICAgLy8gYXMgY2xyRHJhZ0hhbmRsZSBpcyByZXF1aXJlZCB0byBiZSB1c2VkIG9ubHkgaW5zaWRlIG9mIGEgY2xyRHJhZ2dhYmxlIGRpcmVjdGl2ZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsckRyYWdIYW5kbGUgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyRHJhZ2dhYmxlIGRpcmVjdGl2ZS4nKTtcbiAgICB9XG4gICAgdGhpcy5kcmFnSGFuZGxlUmVnaXN0cmFyLnJlZ2lzdGVyQ3VzdG9tSGFuZGxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVSZWdpc3RyYXIudW5yZWdpc3RlckN1c3RvbUhhbmRsZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRHJhZ2dhYmxlIH0gZnJvbSAnLi9kcmFnZ2FibGUvZHJhZ2dhYmxlJztcbmltcG9ydCB7IENsckRyb3BwYWJsZSB9IGZyb20gJy4vZHJvcHBhYmxlL2Ryb3BwYWJsZSc7XG5pbXBvcnQgeyBDbHJJZkRyYWdnZWQgfSBmcm9tICcuL2lmLWRyYWdnZWQnO1xuaW1wb3J0IHsgQ2xyRHJhZ0hhbmRsZSB9IGZyb20gJy4vZHJhZy1oYW5kbGUnO1xuaW1wb3J0IHsgQ2xyRHJhZ2dhYmxlR2hvc3QgfSBmcm9tICcuL2RyYWdnYWJsZS1naG9zdCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfRFJBR19BTkRfRFJPUF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyRHJhZ2dhYmxlLFxuICBDbHJEcm9wcGFibGUsXG4gIENscklmRHJhZ2dlZCxcbiAgQ2xyRHJhZ0hhbmRsZSxcbiAgQ2xyRHJhZ2dhYmxlR2hvc3QsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0RSQUdfQU5EX0RST1BfRElSRUNUSVZFU10sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsckRyYWdnYWJsZUdob3N0XSxcbiAgZXhwb3J0czogW0NMUl9EUkFHX0FORF9EUk9QX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcmFnQW5kRHJvcE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuQXR0cmlidXRlU2V0KHZhbHVlOiBzdHJpbmcgfCBib29sZWFuKTogYm9vbGVhbiB7XG4gIC8vIGZvciBudWxsIGp1c3QgcmV0dXJuIGZhbHNlIG5vIG5lZWQgdG8gY2hlY2sgYW55dGhpbmdcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRW1wdHkgc3RyaW5nIGlzIHZhbGlkLCAndHJ1ZScgYXMgc3RyaW5nIGlzIGFsc28gdmFsaWRcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IDA7XG4gIH1cbiAgLy8gQm9vbGVhbiB2YWx1ZSB3aWxsIGJlIHJlYWQgYXMgaXQgaXMsIGV2ZXJ5dGhpbmcgZWxzZSBpcyBmYWxzZVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgPyB2YWx1ZSA6IGZhbHNlO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzQm9vbGVhbkF0dHJpYnV0ZVNldCB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbXBvbmVudC9pcy1ib29sZWFuLWF0dHJpYnV0ZS1zZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3Bpbm5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLmFyaWEtbGl2ZV0nOiAnc2V0QXJpYUxpdmUnLFxuICAgICdbYXR0ci5hcmlhLWJ1c3ldJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTcGlubmVyIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgY2xhc3MgZm9yIGFsbCBzcGlubmVycy4gVGhpcyBjbGFzcyBpcyBhbHdheXMgdHJ1ZVxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zcGlubmVyJylcbiAgZ2V0IHNwaW5uZXJDbGFzcygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFN0eWxlXG4gIHByaXZhdGUgX2lubGluZTogYm9vbGVhbjtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zcGlubmVyLWlubGluZScpXG4gIGdldCBpbmxpbmVDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5faW5saW5lO1xuICB9XG5cbiAgQElucHV0KCdjbHJJbmxpbmUnKVxuICBzZXQgY2xySW5saW5lKHZhbHVlOiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgdGhpcy5faW5saW5lID0gaXNCb29sZWFuQXR0cmlidXRlU2V0KHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ludmVyc2U6IGJvb2xlYW47XG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3Bpbm5lci1pbnZlcnNlJylcbiAgZ2V0IGludmVyc2VDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5faW52ZXJzZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xySW52ZXJzZScpXG4gIHNldCBjbHJJbnZlcnNlKHZhbHVlOiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgdGhpcy5faW52ZXJzZSA9IGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh2YWx1ZSk7XG4gIH1cblxuICAvLyBTaXplXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IGFsbCBzcGlubmVycyBhcmUgTGFyZ2UuIChzcGlubmVyLWxnKVxuICAgKiBUbyBjaGFuZ2UgdGhlIHNpemUgeW91IG5lZWQgdG8gdXNlIHNldCBjbHJTbWFsbCBvciBjbHJNZWRpdW0gdG8gVFJVRS9cbiAgICovXG5cbiAgLyoqXG4gICAqIFNtYWxsXG4gICAqL1xuICBwcml2YXRlIF9zbWFsbDogYm9vbGVhbjtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zcGlubmVyLXNtJylcbiAgZ2V0IHNtYWxsQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NtYWxsO1xuICB9XG5cbiAgQElucHV0KCdjbHJTbWFsbCcpXG4gIHNldCBjbHJTbWFsbCh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIHRoaXMuX3NtYWxsID0gaXNCb29sZWFuQXR0cmlidXRlU2V0KHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNsclNtYWxsICYgY2xyTWVkaXVtIGFyZSBzZXQgYm90aCB0byB0cnVlLlxuICAgKiBUaGUgQ1NTIHdpdGggaGlnaCBwcmlvcml0eSB3aWxsIGJlIHNtYWxsIC0gc28gbWVkaXVtIHNpemUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBGb3IgdGhpcyByZWFzb24gaWYgY2xyU21hbGwgaXMgc2V0IHdlIHdvbid0IGFkZCBjbHJNZWRpdW0gY2xhc3MuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgaXMgZGljdGF0ZWQgYnkgdGhlIENTUyBydWxlcy5cbiAgICogRE9OJ1QgVVNFIGNsclNtYWxsICYgY2xyTWVkaXVtIHRvIHRvZ2dsZSBjbGFzc2VzLiBUaGlzIGNvdWxkIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAgICpcbiAgICogQWxzbyB0aGVyZSBpcyBubyBsb2dpY2FsIG5lZWQgdG8gaGF2ZSBib3RoIG9mIHRoZW0gc2V0IHRvIFRSVUUgb3IgRkFMU0UuXG4gICAqL1xuICBwcml2YXRlIF9tZWRpdW06IGJvb2xlYW47XG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3Bpbm5lci1tZCcpXG4gIGdldCBtZWRpdW1DbGFzcygpIHtcbiAgICBpZiAodGhpcy5fc21hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21lZGl1bTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyTWVkaXVtJylcbiAgc2V0IGNsck1lZGl1bSh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIHRoaXMuX21lZGl1bSA9IGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh2YWx1ZSk7XG4gIH1cblxuICAvLyBBcmlhIExpdmVcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCBhcmlhLWxpdmUgd2lsbCBiZSBzZXQgdG8gYHBvbGl0ZWAgLlxuICAgKiBUbyBjaGFuZ2UgaXMgaXQgeW91IG5lZWQgdG8gc2V0IGNsckFzc2VydGl2ZSBvciBjbHJPZmYgdG8gVFJVRVxuICAgKlxuICAgKiBUaGVyZSBpcyBwcmlvcml0eTpcbiAgICogICBEZWZhdWx0OiBwb2xpdGVcbiAgICogICBBc2VydGl2ZVxuICAgKiAgIE9mZlxuICAgKlxuICAgKiBJbiBjYXNlIHdoZW4gZm9yIHNvbWUgcmVhc29uIHlvdSBoYXZlIGNsckFzc2VydGl2ZT1UUlVFIGFuZCBjbHJPZmY9VFJVRSxcbiAgICogd2UgZ29ubmEgc2V0IGBhc3NlcnRpdmVgIGFzIHZhbHVlIG9mIGFyaWEtbGl2ZS5cbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyQXNzZXJ0aXZlJykgYXNzZXJ0aXZlOiBib29sZWFuO1xuICBASW5wdXQoJ2Nsck9mZicpIG9mZjogYm9vbGVhbjtcblxuICBnZXQgc2V0QXJpYUxpdmUoKSB7XG4gICAgaWYgKGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh0aGlzLmFzc2VydGl2ZSkpIHtcbiAgICAgIHJldHVybiAnYXNzZXJ0aXZlJztcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh0aGlzLm9mZikpIHtcbiAgICAgIHJldHVybiAnb2ZmJztcbiAgICB9XG4gICAgcmV0dXJuICdwb2xpdGUnO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsclNwaW5uZXIgfSBmcm9tICcuL3NwaW5uZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX1NQSU5ORVJfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyU3Bpbm5lcl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfU1BJTk5FUl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9TUElOTkVSX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTcGlubmVyTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qXG4gKiBUaGlzIGlzIGEgaGFjayB0aGF0IHdlIGhhdmUgdG8gd3JpdGUgZm9yIG5vdyBiZWNhdXNlIG9mIGJ1Z3MgYW5kIGxpbWl0YXRpb25zIGluIEFuZ3VsYXIsXG4gKiBwbGVhc2UgZG8gbm90IHVzZSB0aGlzIGFzIGFuIGV4YW1wbGUuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRnLXJvdycgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFJvd0V4cGFuZEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGV4cGFuZDogRXhwYW5kXG4gICkge1xuICAgIGlmIChleHBhbmQgJiYgZXhwYW5kLmFuaW1hdGUpIHtcbiAgICAgIGV4cGFuZC5hbmltYXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGFscmVhZHkgaGFkIGFuIGFuaW1hdGlvbiB3YWl0aW5nLCBzbyB3ZSBqdXN0IGhhdmUgdG8gcnVuIGluLCBub3QgcHJlcGFyZSBhZ2FpblxuICAgICAgICBpZiAodGhpcy5vbGRIZWlnaHQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJ1bm5pbmc6IGFueTtcbiAgcHJpdmF0ZSBvbGRIZWlnaHQ6IG51bWJlcjtcblxuICAvKlxuICAgICAqIERpcnR5IG1hbnVhbCBhbmltYXRpb24gaGFuZGxpbmcsIGJ1dCB3ZSBoYXZlIG5vIHdheSB0byB1c2UgZHluYW1pYyBoZWlnaHRzIGluIEFuZ3VsYXIncyBjdXJyZW50IEFQSS5cbiAgICAgKiBUaGV5J3JlIHdvcmtpbmcgb24gaXQsIGJ1dCBoYXZlIG5vIEVUQS5cbiAgICAgKi9cbiAgcHJpdmF0ZSBhbmltYXRlKCkge1xuICAgIC8vIENoZWNrIGlmIHdlIGRvIGhhdmUgd2ViLWFuaW1hdGlvbnMgYXZhaWxhYmxlLiBJZiBub3QsIGp1c3Qgc2tpcCB0aGUgYW5pbWF0aW9uLlxuICAgIGlmICghdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFuaW1hdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBoYWQgYW4gYW5pbWF0aW9uIHJ1bm5pbmcsIHdlIHNraXAgdG8gdGhlIGVuZFxuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVubmluZy5maW5pc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm9sZEhlaWdodCA9IHRoaXMuZG9tQWRhcHRlci5jb21wdXRlZEhlaWdodCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIC8vIEluIGNhc2UgaGVpZ2h0IGhhcyBub3QgeWV0IGJlZW4gc2V0LiBXaGVuIHN0YXJ0aW5nIGV4cGFuZGVkLCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS9jbGFyaXR5L2lzc3Vlcy8yOTA0XG4gICAgaWYgKGlzTmFOKHRoaXMub2xkSGVpZ2h0KSkge1xuICAgICAgdGhpcy5vbGRIZWlnaHQgPSAwO1xuICAgIH1cbiAgICAvLyBXZSBzZXQgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBpbW1lZGlhdGVseSB0byBhdm9pZCBhIGZsaWNrZXIgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdGhpcy5vbGRIZWlnaHQgKyAncHgnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ292ZXJmbG93LXknLCAnaGlkZGVuJyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5leHBhbmQubG9hZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBydW4oKSB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCBudWxsKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmRvbUFkYXB0ZXIuY29tcHV0ZWRIZWlnaHQodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuYW5pbWF0ZShcbiAgICAgIHsgaGVpZ2h0OiBbdGhpcy5vbGRIZWlnaHQgKyAncHgnLCBuZXdIZWlnaHQgKyAncHgnXSwgZWFzaW5nOiAnZWFzZS1pbi1vdXQnIH0sXG4gICAgICB7IGR1cmF0aW9uOiAyMDAgfVxuICAgICk7XG4gICAgdGhpcy5ydW5uaW5nLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvdy15JywgbnVsbCk7XG4gICAgICBkZWxldGUgdGhpcy5ydW5uaW5nO1xuICAgIH07XG4gICAgZGVsZXRlIHRoaXMub2xkSGVpZ2h0O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ3VzdG9tRmlsdGVyIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuLypcbiAqIFRoaXMgcHJvdmlkZXIgaW1wbGVtZW50cyBzb21lIGZvcm0gb2Ygc3luY2hyb25vdXMgZGVib3VuY2luZyB0aHJvdWdoIGEgbG9jayBwYXR0ZXJuXG4gKiB0byBhdm9pZCBlbWl0dGluZyBtdWx0aXBsZSBzdGF0ZSBjaGFuZ2VzIGZvciBhIHNpbmdsZSB1c2VyIGFjdGlvbi5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0YXRlRGVib3VuY2VyIHtcbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBnbG9iYWwgc3RhdGUgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgLy8gV2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoZSBTdWJqZWN0IGl0c2VsZiwgYnV0IHRoZSBPYnNlcnZhYmxlIHdoaWNoIGlzIHJlYWQtb25seVxuICBwdWJsaWMgZ2V0IGNoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLypcbiAgICAgKiBUaGlzIGlzIHRoZSBsb2NrLCB0byBvbmx5IGVtaXQgb25jZSBhbGwgdGhlIGNoYW5nZXMgaGF2ZSBmaW5pc2hlZCBwcm9jZXNzaW5nXG4gICAgICovXG4gIHByaXZhdGUgbmJDaGFuZ2VzID0gMDtcblxuICBwdWJsaWMgY2hhbmdlU3RhcnQoKSB7XG4gICAgdGhpcy5uYkNoYW5nZXMrKztcbiAgfVxuXG4gIHB1YmxpYyBjaGFuZ2VEb25lKCkge1xuICAgIGlmICgtLXRoaXMubmJDaGFuZ2VzID09PSAwKSB7XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQYWdlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGF0ZURlYm91bmNlcjogU3RhdGVEZWJvdW5jZXIpIHt9XG5cbiAgcHVibGljIGFjdGl2YXRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBQYWdlIHNpemUsIGEgdmFsdWUgb2YgMCBtZWFucyBubyBwYWdpbmF0aW9uXG4gICAqL1xuICBwcml2YXRlIF9zaXplID0gMDtcbiAgcHVibGljIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cbiAgcHVibGljIHNldCBzaXplKHNpemU6IG51bWJlcikge1xuICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLl9zaXplO1xuICAgIGlmIChzaXplICE9PSBvbGRTaXplKSB7XG4gICAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZVN0YXJ0KCk7XG4gICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gWWVhcC4gVGhhdCdzIHRoZSBmb3JtdWxhIHRvIGtlZXAgdGhlIGZpcnN0IGl0ZW0gZnJvbSB0aGUgb2xkIHBhZ2Ugc3RpbGxcbiAgICAgICAgLy8gZGlzcGxheWVkIGluIHRoZSBuZXcgb25lLlxuICAgICAgICB0aGlzLl9jdXJyZW50ID0gTWF0aC5mbG9vcihvbGRTaXplIC8gc2l6ZSAqICh0aGlzLl9jdXJyZW50IC0gMSkpICsgMTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGFsd2F5cyBlbWl0IGFuIGV2ZW50IGV2ZW4gaWYgdGhlIGN1cnJlbnQgcGFnZSBpbmRleCBkaWRuJ3QgY2hhbmdlLCBiZWNhdXNlXG4gICAgICAvLyB0aGUgc2l6ZSBjaGFuZ2luZyBtZWFucyB0aGUgaXRlbXMgaW5zaWRlIHRoZSBwYWdlIGFyZSBkaWZmZXJlbnRcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuX2N1cnJlbnQpO1xuICAgICAgdGhpcy5fc2l6ZUNoYW5nZS5uZXh0KHRoaXMuX3NpemUpO1xuICAgICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvdGFsIGl0ZW1zIChuZWVkZWQgdG8gZ3Vlc3MgdGhlIGxhc3QgcGFnZSlcbiAgICovXG4gIHByaXZhdGUgX3RvdGFsSXRlbXMgPSAwO1xuICBwdWJsaWMgZ2V0IHRvdGFsSXRlbXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxJdGVtcztcbiAgfVxuICBwdWJsaWMgc2V0IHRvdGFsSXRlbXModG90YWw6IG51bWJlcikge1xuICAgIHRoaXMuX3RvdGFsSXRlbXMgPSB0b3RhbDtcbiAgICAvLyBJZiB3ZSBoYXZlIGxlc3MgaXRlbXMgdGhhbiBiZWZvcmUsIHdlIG1pZ2h0IG5lZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IHBhZ2VcbiAgICBpZiAodGhpcy5jdXJyZW50ID4gdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmxhc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExhc3QgcGFnZVxuICAgKi9cbiAgcHJpdmF0ZSBfbGFzdDogbnVtYmVyO1xuICBwdWJsaWMgZ2V0IGxhc3QoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fbGFzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xhc3Q7XG4gICAgfVxuICAgIC8vIElmIHRoZSBsYXN0IHBhZ2UgaXNuJ3Qga25vd24sIHdlIGNvbXB1dGUgaXQgZnJvbSB0aGUgbGFzdCBpdGVtJ3MgaW5kZXhcbiAgICBpZiAodGhpcy5zaXplID4gMCAmJiB0aGlzLnRvdGFsSXRlbXMpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy50b3RhbEl0ZW1zIC8gdGhpcy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcHVibGljIHNldCBsYXN0KHBhZ2U6IG51bWJlcikge1xuICAgIHRoaXMuX2xhc3QgPSBwYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBwYWdlIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgLy8gV2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoZSBTdWJqZWN0IGl0c2VsZiwgYnV0IHRoZSBPYnNlcnZhYmxlIHdoaWNoIGlzIHJlYWQtb25seVxuICBwdWJsaWMgZ2V0IGNoYW5nZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9zaXplQ2hhbmdlID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuXG4gIHB1YmxpYyBnZXQgc2l6ZUNoYW5nZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9zaXplQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgcGFnZVxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudCA9IDE7XG4gIHB1YmxpYyBnZXQgY3VycmVudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICB9XG4gIHB1YmxpYyBzZXQgY3VycmVudChwYWdlOiBudW1iZXIpIHtcbiAgICBpZiAocGFnZSAhPT0gdGhpcy5fY3VycmVudCkge1xuICAgICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgICAgdGhpcy5fY3VycmVudCA9IHBhZ2U7XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dChwYWdlKTtcbiAgICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0byB0aGUgcHJldmlvdXMgcGFnZSBpZiBpdCBleGlzdHNcbiAgICovXG4gIHB1YmxpYyBwcmV2aW91cygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50ID4gMSkge1xuICAgICAgdGhpcy5jdXJyZW50LS07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRvIHRoZSBuZXh0IHBhZ2UgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50IDwgdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmN1cnJlbnQrKztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHBhZ2UsIHN0YXJ0aW5nIGF0IDBcbiAgICovXG4gIHB1YmxpYyBnZXQgZmlyc3RJdGVtKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5jdXJyZW50IC0gMSkgKiB0aGlzLnNpemU7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgaXRlbSBkaXNwbGF5ZWQgb24gdGhlIGN1cnJlbnQgcGFnZSwgc3RhcnRpbmcgYXQgMFxuICAgKi9cbiAgcHVibGljIGdldCBsYXN0SXRlbSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsSXRlbXMgLSAxO1xuICAgIH1cbiAgICBsZXQgbGFzdEluUGFnZSA9IHRoaXMuY3VycmVudCAqIHRoaXMuc2l6ZSAtIDE7XG4gICAgaWYgKHRoaXMudG90YWxJdGVtcykge1xuICAgICAgbGFzdEluUGFnZSA9IE1hdGgubWluKGxhc3RJblBhZ2UsIHRoaXMudG90YWxJdGVtcyAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluUGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHBhZ2Ugc2l6ZSB0byAwXG4gICAqL1xuICBwdWJsaWMgcmVzZXRQYWdlU2l6ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNpemUgPSAwO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuL3BhZ2UnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGaWx0ZXJzUHJvdmlkZXI8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlOiBQYWdlLCBwcml2YXRlIHN0YXRlRGVib3VuY2VyOiBTdGF0ZURlYm91bmNlcikge31cbiAgLyoqXG4gICAqIFRoaXMgc3ViamVjdCBpcyB0aGUgbGlzdCBvZiBmaWx0ZXJzIHRoYXQgY2hhbmdlZCBsYXN0LCBub3QgdGhlIHdob2xlIGxpc3QuXG4gICAqIFdlIGVtaXQgYSBsaXN0IHJhdGhlciB0aGFuIGp1c3Qgb25lIGZpbHRlciB0byBhbGxvdyBiYXRjaCBjaGFuZ2VzIHRvIHNldmVyYWwgYXQgb25jZS5cbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+W10+KCk7XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFsbCBmaWx0ZXJzLCB3aGV0aGVyIHRoZXkncmUgYWN0aXZlIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBfYWxsOiBSZWdpc3RlcmVkRmlsdGVyPFQsIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PltdID0gW107XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGF0IGxlYXN0IG9uZSBmaWx0ZXIgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgcHVibGljIGhhc0FjdGl2ZUZpbHRlcnMoKTogYm9vbGVhbiB7XG4gICAgLy8gV2UgZG8gbm90IHVzZSBnZXRBY3RpdmVGaWx0ZXJzKCkgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG11Y2ggbW9yZSBvZnRlblxuICAgIC8vIGFuZCBzdG9wcGluZyB0aGUgbG9vcCBlYXJseSBtaWdodCBiZSByZWxldmFudC5cbiAgICBmb3IgKGNvbnN0IHsgZmlsdGVyIH0gb2YgdGhpcy5fYWxsKSB7XG4gICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyc1xuICAgKi9cbiAgcHVibGljIGdldEFjdGl2ZUZpbHRlcnMoKTogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSB7XG4gICAgY29uc3QgcmV0OiBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdID0gW107XG4gICAgZm9yIChjb25zdCB7IGZpbHRlciB9IG9mIHRoaXMuX2FsbCkge1xuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICByZXQucHVzaChmaWx0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGZpbHRlciwgYW5kIHJldHVybnMgYSBkZXJlZ2lzdHJhdGlvbiBmdW5jdGlvblxuICAgKi9cbiAgcHVibGljIGFkZDxGIGV4dGVuZHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+KGZpbHRlcjogRik6IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRj4ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYWxsLmxlbmd0aDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBmaWx0ZXIuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZXNldFBhZ2VBbmRFbWl0RmlsdGVyQ2hhbmdlKFtmaWx0ZXJdKSk7XG4gICAgbGV0IGhhc1VucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWQgPSBuZXcgUmVnaXN0ZXJlZEZpbHRlcihmaWx0ZXIsICgpID0+IHtcbiAgICAgIGlmIChoYXNVbnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLl9hbGwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGlmIChmaWx0ZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLnJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoW10pO1xuICAgICAgfVxuICAgICAgaGFzVW5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLl9hbGwucHVzaChyZWdpc3RlcmVkKTtcbiAgICBpZiAoZmlsdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMucmVzZXRQYWdlQW5kRW1pdEZpbHRlckNoYW5nZShbZmlsdGVyXSk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3RlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYW4gaXRlbSBpZiBpdCBpcyBhY2NlcHRlZCBieSBhbGwgY3VycmVudGx5IGFjdGl2ZSBmaWx0ZXJzXG4gICAqL1xuICBwdWJsaWMgYWNjZXB0cyhpdGVtOiBUKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCB7IGZpbHRlciB9IG9mIHRoaXMuX2FsbCkge1xuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUoKSAmJiAhZmlsdGVyLmFjY2VwdHMoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRQYWdlQW5kRW1pdEZpbHRlckNoYW5nZShmaWx0ZXJzOiBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdKSB7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgIC8vIGZpbHRlcmluZyBtYXkgY2hhbmdlIHRoZSBwYWdlIG51bWJlciBzdWNoIHRoYXQgY3VycmVudCBwYWdlIG51bWJlciBkb2Vzbid0IGV4aXN0IGluIHRoZSBmaWx0ZXJlZCBkYXRhc2V0LlxuICAgIC8vIFNvIGhlcmUgd2UgYWx3YXlzIHNldCB0aGUgY3VycmVudCBwYWdlIHRvIDEgc28gdGhhdCBpdCdsbCBmZXRjaCBmaXJzdCBwYWdlJ3MgZGF0YSB3aXRoIHRoZSBnaXZlbiBmaWx0ZXIuXG4gICAgdGhpcy5fcGFnZS5jdXJyZW50ID0gMTtcbiAgICB0aGlzLl9jaGFuZ2UubmV4dChmaWx0ZXJzKTtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZURvbmUoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVnaXN0ZXJlZEZpbHRlcjxULCBGIGV4dGVuZHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+IHtcbiAgY29uc3RydWN0b3IocHVibGljIGZpbHRlcjogRiwgcHVibGljIHVucmVnaXN0ZXI6ICgpID0+IHZvaWQpIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciwgUmVnaXN0ZXJlZEZpbHRlciB9IGZyb20gJy4uL3Byb3ZpZGVycy9maWx0ZXJzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGFncmlkRmlsdGVyUmVnaXN0cmFyPFQsIEYgZXh0ZW5kcyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPikge31cblxuICBwdWJsaWMgcmVnaXN0ZXJlZDogUmVnaXN0ZXJlZEZpbHRlcjxULCBGPjtcblxuICBwdWJsaWMgZ2V0IGZpbHRlcigpOiBGIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkICYmIHRoaXMucmVnaXN0ZXJlZC5maWx0ZXI7XG4gIH1cblxuICBwdWJsaWMgc2V0RmlsdGVyKGZpbHRlcjogRiB8IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRj4pIHtcbiAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGhhZCBhbm90aGVyIGZpbHRlciwgd2UgdW5yZWdpc3RlciBpdFxuICAgIHRoaXMuZGVsZXRlRmlsdGVyKCk7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIFJlZ2lzdGVyZWRGaWx0ZXIpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkID0gdGhpcy5maWx0ZXJzLmFkZChmaWx0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZCkge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkLnVucmVnaXN0ZXIoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZGVsZXRlRmlsdGVyKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQsIFBMQVRGT1JNX0lELCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcbmltcG9ydCB7IFBvcG92ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlci1vcHRpb25zLmludGVyZmFjZSc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2ZpbHRlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ3VzdG9tRmlsdGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvY3VzdG9tLWZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIsIFJlZ2lzdGVyZWRGaWx0ZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9maWx0ZXJzJztcbmltcG9ydCB7IERhdGFncmlkRmlsdGVyUmVnaXN0cmFyIH0gZnJvbSAnLi91dGlscy9kYXRhZ3JpZC1maWx0ZXItcmVnaXN0cmFyJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBDdXN0b20gZmlsdGVyIHRoYXQgY2FuIGJlIGFkZGVkIGluIGFueSBjb2x1bW4gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2JqZWN0IHByb3BlcnR5IHN0cmluZyBmaWx0ZXIuXG4gKiBUaGUgcmVhc29uIHRoaXMgaXMgbm90IGp1c3QgYW4gaW5wdXQgb24gRGF0YWdyaWRDb2x1bW4gaXMgYmVjYXVzZSB3ZSBuZWVkIHRoZSBmaWx0ZXIncyB0ZW1wbGF0ZSB0byBiZSBwcm9qZWN0ZWQsXG4gKiBzaW5jZSBpdCBjYW4gYmUgYW55dGhpbmcgKG5vdCBqdXN0IGEgdGV4dCBpbnB1dCkuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1maWx0ZXInLFxuICAvLyBXZSByZWdpc3RlciB0aGlzIGNvbXBvbmVudCBhcyBhIEN1c3RvbUZpbHRlciwgZm9yIHRoZSBwYXJlbnQgY29sdW1uIHRvIGRldGVjdCBpdC5cbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDdXN0b21GaWx0ZXIsIHVzZUV4aXN0aW5nOiBDbHJEYXRhZ3JpZEZpbHRlciB9XSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiAjYW5jaG9yIGNsYXNzPVwiZGF0YWdyaWQtZmlsdGVyLXRvZ2dsZVwiIChjbGljayk9XCJ0b2dnbGUoKVwiXG4gICAgICAgICAgICBbY2xhc3MuZGF0YWdyaWQtZmlsdGVyLW9wZW5dPVwib3BlblwiIFtjbGFzcy5kYXRhZ3JpZC1maWx0ZXJlZF09XCJhY3RpdmVcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbKGNsclBvcG92ZXJPbGQpXT1cIm9wZW5cIiBbY2xyUG9wb3Zlck9sZEFuY2hvcl09XCJhbmNob3JcIiBbY2xyUG9wb3Zlck9sZEFuY2hvclBvaW50XT1cImFuY2hvclBvaW50XCJcbiAgICAgICAgICAgICBbY2xyUG9wb3Zlck9sZFBvcG92ZXJQb2ludF09XCJwb3BvdmVyUG9pbnRcIiBbY2xyUG9wb3Zlck9sZE9wdGlvbnNdPVwicG9wb3Zlck9wdGlvbnNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1maWx0ZXJcIj5cbiAgICAgICAgICAgICAgICA8IS0tIEZJWE1FOiB0aGlzIHdob2xlIGZpbHRlciBwYXJ0IG5lZWRzIGEgZmluYWwgZGVzaWduIGJlZm9yZSB3ZSBjYW4gdHJ5IHRvIGhhdmUgYSBjbGVhbmVyIERPTSAtLT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtZmlsdGVyLWNsb3NlLXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIChjbGljayk9XCJvcGVuID0gZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNsb3NlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmNsb3NlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRGaWx0ZXI8VCA9IGFueT4gZXh0ZW5kcyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhcjxULCBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj5cbiAgaW1wbGVtZW50cyBDdXN0b21GaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBfZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzU2VydmljZSxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdFxuICApIHtcbiAgICBzdXBlcihfZmlsdGVycyk7XG4gIH1cblxuICBwdWJsaWMgYW5jaG9yUG9pbnQ6IFBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICBwdWJsaWMgcG9wb3ZlclBvaW50OiBQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgcHVibGljIHBvcG92ZXJPcHRpb25zOiBQb3BvdmVyT3B0aW9ucyA9IHsgYWxsb3dNdWx0aXBsZU9wZW46IHRydWUgfTtcblxuICBAVmlld0NoaWxkKCdhbmNob3InLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgYW5jaG9yOiBFbGVtZW50UmVmO1xuXG4gIC8qKlxuICAgKiBUcmFja3Mgd2hldGhlciB0aGUgZmlsdGVyIGRyb3Bkb3duIGlzIG9wZW4gb3Igbm90XG4gICAqL1xuICBwcml2YXRlIF9vcGVuID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdGaWx0ZXJPcGVuJylcbiAgcHVibGljIHNldCBvcGVuKG9wZW46IGJvb2xlYW4pIHtcbiAgICBjb25zdCBib29sT3BlbiA9ICEhb3BlbjtcbiAgICBpZiAoYm9vbE9wZW4gIT09IHRoaXMuX29wZW4pIHtcbiAgICAgIHRoaXMuX29wZW4gPSBib29sT3BlbjtcbiAgICAgIHRoaXMub3BlbkNoYW5nZWQuZW1pdChib29sT3Blbik7XG4gICAgICBpZiAoIWJvb2xPcGVuICYmIGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgICAgdGhpcy5hbmNob3IubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnRmlsdGVyT3BlbkNoYW5nZScpIHB1YmxpYyBvcGVuQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIEBJbnB1dCgnY2xyRGdGaWx0ZXInKVxuICBwdWJsaWMgc2V0IGN1c3RvbUZpbHRlcihmaWx0ZXI6IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+IHwgUmVnaXN0ZXJlZEZpbHRlcjxULCBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj4pIHtcbiAgICB0aGlzLnNldEZpbHRlcihmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZmlsdGVyIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICovXG4gIHB1YmxpYyBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiAhIXRoaXMuZmlsdGVyICYmIHRoaXMuZmlsdGVyLmlzQWN0aXZlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MvaGlkZXMgdGhlIGZpbHRlciBkcm9wZG93blxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG4vKipcbiAqIEdlbmVyaWMgYWNjZXNzb3IgZm9yIGRlZXAgb2JqZWN0IHByb3BlcnRpZXNcbiAqIHRoYXQgY2FuIGJlIHNwZWNpZmllZCBhcyBzaW1wbGUgZG90LXNlcGFyYXRlZCBzdHJpbmdzLlxuICovXG5leHBvcnQgY2xhc3MgTmVzdGVkUHJvcGVydHk8VCA9IGFueT4ge1xuICBwcml2YXRlIHNwbGl0UHJvcDogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcm9wOiBzdHJpbmcpIHtcbiAgICBpZiAocHJvcC5pbmRleE9mKCcuJykgPj0gMCkge1xuICAgICAgdGhpcy5zcGxpdFByb3AgPSBwcm9wLnNwbGl0KCcuJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2FmZSBnZXR0ZXIgZm9yIGEgZGVlcCBvYmplY3QgcHJvcGVydHksIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGJ1dCByZXR1cm5cbiAgLy8gdW5kZWZpbmVkIGlmIG9uZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHByb3BlcnRpZXMgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gIHB1YmxpYyBnZXRQcm9wVmFsdWUoaXRlbTogVCk6IGFueSB7XG4gICAgaWYgKHRoaXMuc3BsaXRQcm9wKSB7XG4gICAgICBsZXQgdmFsdWUgPSBpdGVtO1xuICAgICAgZm9yIChjb25zdCBuZXN0ZWRQcm9wIG9mIHRoaXMuc3BsaXRQcm9wKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlW25lc3RlZFByb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtuZXN0ZWRQcm9wXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGl0ZW1bdGhpcy5wcm9wXTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9zdHJpbmctZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBOZXN0ZWRQcm9wZXJ0eSB9IGZyb20gJy4uL25lc3RlZC1wcm9wZXJ0eSc7XG5cbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyPFQgPSBhbnk+IGltcGxlbWVudHMgQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2U8VD4ge1xuICBwcml2YXRlIG5lc3RlZFByb3A6IE5lc3RlZFByb3BlcnR5PFQ+O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwcm9wOiBzdHJpbmcsIHB1YmxpYyBleGFjdCA9IGZhbHNlKSB7XG4gICAgdGhpcy5uZXN0ZWRQcm9wID0gbmV3IE5lc3RlZFByb3BlcnR5KHByb3ApO1xuICB9XG5cbiAgYWNjZXB0cyhpdGVtOiBULCBzZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByb3BWYWx1ZSA9IHRoaXMubmVzdGVkUHJvcC5nZXRQcm9wVmFsdWUoaXRlbSk7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV4YWN0KSB7XG4gICAgICByZXR1cm4gKCcnICsgcHJvcFZhbHVlKS50b0xvd2VyQ2FzZSgpID09PSBzZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoJycgKyBwcm9wVmFsdWUpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID49IDA7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFN0cmluZ0ZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvc3RyaW5nLWZpbHRlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlciB9IGZyb20gJy4vZGF0YWdyaWQtcHJvcGVydHktc3RyaW5nLWZpbHRlcic7XG5cbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGw8VCA9IGFueT4gaW1wbGVtZW50cyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXJGbjogQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2U8VD4pIHt9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHJlcXVpcmVkIGFzIHBhcnQgb2YgdGhlIEZpbHRlciBpbnRlcmZhY2VcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZXMgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2VzKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmF3IGlucHV0IHZhbHVlXG4gICAqL1xuICBwcml2YXRlIF9yYXdWYWx1ZTogc3RyaW5nID0gJyc7XG4gIHB1YmxpYyBnZXQgdmFsdWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3VmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIElucHV0IHZhbHVlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICovXG4gIHByaXZhdGUgX2xvd2VyQ2FzZVZhbHVlOiBzdHJpbmcgPSAnJztcbiAgcHVibGljIGdldCBsb3dlckNhc2VWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG93ZXJDYXNlVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENvbW1vbiBzZXR0ZXIgZm9yIHRoZSBpbnB1dCB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHNldCB2YWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yYXdWYWx1ZSkge1xuICAgICAgdGhpcy5fcmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2xvd2VyQ2FzZVZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICB0aGlzLl9jaGFuZ2VzLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGZpbHRlciBpcyBjdXJyZW50bHkgYWN0aXZlLCBtZWFuaW5nIHRoZSBpbnB1dCBpcyBub3QgZW1wdHlcbiAgICovXG4gIHB1YmxpYyBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGFuIGl0ZW0gbWF0Y2hlcyBhIHNlYXJjaCB0ZXh0XG4gICAqL1xuICBwdWJsaWMgYWNjZXB0cyhpdGVtOiBUKTogYm9vbGVhbiB7XG4gICAgLy8gV2UgYWx3YXlzIHRlc3Qgd2l0aCB0aGUgbG93ZXJjYXNlIHZhbHVlIG9mIHRoZSBpbnB1dCwgdG8gc3RheSBjYXNlIGluc2Vuc2l0aXZlXG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyRm4uYWNjZXB0cyhpdGVtLCB0aGlzLmxvd2VyQ2FzZVZhbHVlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4gaW5zdGFuY2VvZiBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wZXJ0eTogdGhpcy5maWx0ZXJGbi5wcm9wLFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGVxdWFscyhvdGhlcjogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VCwgYW55Pik6IGJvb2xlYW4ge1xuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCkge1xuICAgICAgaWYgKG90aGVyLmZpbHRlckZuIGluc3RhbmNlb2YgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRoaXMuZmlsdGVyRm4gaW5zdGFuY2VvZiBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyICYmXG4gICAgICAgICAgb3RoZXIuZmlsdGVyRm4ucHJvcCA9PT0gdGhpcy5maWx0ZXJGbi5wcm9wICYmXG4gICAgICAgICAgb3RoZXIudmFsdWUgPT09IHRoaXMudmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVyIH0gZnJvbSAnLi4vLi4vZGF0YWdyaWQtZmlsdGVyJztcbmltcG9ydCB7IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9zdHJpbmctZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDdXN0b21GaWx0ZXIgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvY3VzdG9tLWZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIsIFJlZ2lzdGVyZWRGaWx0ZXIgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvZmlsdGVycyc7XG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXIgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhZ3JpZC1maWx0ZXItcmVnaXN0cmFyJztcblxuaW1wb3J0IHsgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsIH0gZnJvbSAnLi9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLWltcGwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctc3RyaW5nLWZpbHRlcicsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ3VzdG9tRmlsdGVyLCB1c2VFeGlzdGluZzogRGF0YWdyaWRTdHJpbmdGaWx0ZXIgfV0sXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxjbHItZGctZmlsdGVyIFtjbHJEZ0ZpbHRlcl09XCJyZWdpc3RlcmVkXCIgWyhjbHJEZ0ZpbHRlck9wZW4pXT1cIm9wZW5cIj5cbiAgICAgICAgICAgIDwhLS1cbiAgICAgICAgICAgICAgICBFdmVuIHRob3VnaCB0aGlzICpuZ0lmIGxvb2tzIHVzZWxlc3MgYmVjYXVzZSB0aGUgZmlsdGVyIGNvbnRhaW5lciBhbHJlYWR5IGhhcyBvbmUsXG4gICAgICAgICAgICAgICAgaXQgcHJldmVudHMgTmdDb250cm9sU3RhdHVzIGFuZCBvdGhlciBkaXJlY3RpdmVzIGF1dG9tYXRpY2FsbHkgYWRkZWQgYnkgQW5ndWxhclxuICAgICAgICAgICAgICAgIG9uIGlucHV0cyB3aXRoIE5nTW9kZWwgZnJvbSBmcmVha2luZyBvdXQgYmVjYXVzZSBvZiB0aGVpciBob3N0IGJpbmRpbmcgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICBtaWQtY2hhbmdlIGRldGVjdGlvbiB3aGVuIHRoZSBpbnB1dCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAgICAtLT5cbiAgICAgICAgICAgIDxpbnB1dCAjaW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwic2VhcmNoXCIgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiICpuZ0lmPVwib3BlblwiXG4gICAgICAgICAgICAgICAgKGtleXVwLmVudGVyKT1cImNsb3NlKClcIiAoa2V5dXAuZXNjYXBlKT1cImNsb3NlKClcIi8+XG4gICAgICAgIDwvY2xyLWRnLWZpbHRlcj5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFN0cmluZ0ZpbHRlcjxUID0gYW55PiBleHRlbmRzIERhdGFncmlkRmlsdGVyUmVnaXN0cmFyPFQsIERhdGFncmlkU3RyaW5nRmlsdGVySW1wbDxUPj5cbiAgaW1wbGVtZW50cyBDdXN0b21GaWx0ZXIsIEFmdGVyVmlld0luaXQge1xuICBjb25zdHJ1Y3RvcihmaWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4sIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcikge1xuICAgIHN1cGVyKGZpbHRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbWl6YWJsZSBmaWx0ZXIgbG9naWMgYmFzZWQgb24gYSBzZWFyY2ggdGV4dFxuICAgKi9cbiAgQElucHV0KCdjbHJEZ1N0cmluZ0ZpbHRlcicpXG4gIHNldCBjdXN0b21TdHJpbmdGaWx0ZXIoXG4gICAgdmFsdWU6IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlPFQ+IHwgUmVnaXN0ZXJlZEZpbHRlcjxULCBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGw8VD4+XG4gICkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ2lzdGVyZWRGaWx0ZXIpIHtcbiAgICAgIHRoaXMuc2V0RmlsdGVyKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRGaWx0ZXIobmV3IERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGZpbHRlciBkcm9wZG93biBpcyBvcGVuXG4gICAqL1xuICBwdWJsaWMgb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBXZSBuZWVkIHRoZSBhY3R1YWwgaW5wdXQgZWxlbWVudCB0byBhdXRvbWF0aWNhbGx5IGZvY3VzIG9uIGl0XG4gICAqL1xuICBAVmlld0NoaWxkKCdpbnB1dCcpIHB1YmxpYyBpbnB1dDogRWxlbWVudFJlZjtcblxuICAvKipcbiAgICogV2UgZ3JhYiB0aGUgQ2xyRGF0YWdyaWRGaWx0ZXIgd2Ugd3JhcCB0byByZWdpc3RlciB0aGlzIFN0cmluZ0ZpbHRlciB0byBpdC5cbiAgICovXG4gIEBWaWV3Q2hpbGQoQ2xyRGF0YWdyaWRGaWx0ZXIpIHB1YmxpYyBmaWx0ZXJDb250YWluZXI6IENsckRhdGFncmlkRmlsdGVyPFQ+O1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5maWx0ZXJDb250YWluZXIub3BlbkNoYW5nZWQuc3Vic2NyaWJlKChvcGVuOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICAvLyBXZSBuZWVkIHRoZSB0aW1lb3V0IGJlY2F1c2UgYXQgdGhlIHRpbWUgdGhpcyBleGVjdXRlcywgdGhlIGlucHV0IGlzbid0XG4gICAgICAgIC8vIGRpc3BsYXllZCB5ZXQuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZG9tQWRhcHRlci5mb2N1cyh0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21tb24gc2V0dGVyIGZvciB0aGUgaW5wdXQgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyLnZhbHVlO1xuICB9XG4gIEBJbnB1dCgnY2xyRmlsdGVyVmFsdWUnKVxuICBwdWJsaWMgc2V0IHZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmlsdGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5maWx0ZXIudmFsdWUpIHtcbiAgICAgIHRoaXMuZmlsdGVyLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLmZpbHRlclZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckZpbHRlclZhbHVlQ2hhbmdlJykgZmlsdGVyVmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRDaGVja2VkLCBDaGFuZ2VEZXRlY3RvclJlZiwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFdpbGx5V29ua2EgfSBmcm9tICcuL3dpbGx5LXdvbmthJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE9vbXBhTG9vbXBhIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgLy8gRklYTUU6IFJlcXVlc3QgSW5qZWN0b3Igb25jZSB3ZSBtb3ZlIHRvIEFuZ3VsYXIgNC4yKywgaXQnbGwgYWxsb3cgZWFzaWVyIHJlZmFjdG9yc1xuICBjb25zdHJ1Y3RvcihjZHI6IENoYW5nZURldGVjdG9yUmVmLCB3aWxseVdvbmthOiBXaWxseVdvbmthKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB3aWxseVdvbmthLmNob2NvbGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMubGF0ZXN0Rmxhdm9yICE9PSB0aGlzLmZsYXZvcikge1xuICAgICAgICBjZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIGxhdGVzdEZsYXZvcjogYW55O1xuXG4gIGFic3RyYWN0IGdldCBmbGF2b3IoKTogYW55O1xuXG4gIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICB0aGlzLmxhdGVzdEZsYXZvciA9IHRoaXMuZmxhdm9yO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSb3dBY3Rpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBhY3Rpb25hYmxlQ291bnQgPSAwO1xuXG4gIHB1YmxpYyByZWdpc3RlcigpIHtcbiAgICB0aGlzLmFjdGlvbmFibGVDb3VudCsrO1xuICB9XG5cbiAgcHVibGljIHVucmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5hY3Rpb25hYmxlQ291bnQtLTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmYWxzZSBtZWFucyBubyByb3dzIHdpdGggYWN0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhhc0FjdGlvbmFibGVSb3coKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9uYWJsZUNvdW50ID4gMDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3Q2hlY2tlZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKlxuICogQWZ0ZXIgYSBjb252ZXJzYXRpb24gd2l0aCB0aGUgQW5ndWxhciBjb3JlIHRlYW0sIGl0IHR1cm5zIG91dCB3ZSBkb24ndCBoYXZlIG11Y2ggb2YgYSBjaG9pY2UgZm9yIG91clxuICogZGVjbGFyYXRpdmUgQVBJLCB3ZSBuZWVkIHRvIGZpZ2h0IGFnYWluc3QgY2hhbmdlIGRldGVjdGlvbiBhbmQgaXRzIG9uZS13YXkgZmxvdy4gVGhpcyBpc1xuICogY3VycmVudGx5IHRoZSBsZWFzdCBkaXJ0eSBzb2x1dGlvbiB0byBkbyB3aGF0IHdlIHdhbnQuXG4gKlxuICogRG8gbm90IG1vZGlmeSBvciBldmVuIHVzZSB0aGlzIGNsYXNzIHVubGVzcyB5b3Uga25vdyBleGFjdGx5IHdoYXQgeW91J3JlIGRvaW5nLlxuICogSXQgaGFzIHRoZSBwb3RlbnRpYWwgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3BzIG9yIGtpbGwgYXBwIHBlcmZvcm1hbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdpbGx5V29ua2EgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkIHtcbiAgcHJpdmF0ZSBfY2hvY29sYXRlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBwdWJsaWMgZ2V0IGNob2NvbGF0ZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hvY29sYXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgIHRoaXMuX2Nob2NvbGF0ZS5uZXh0KCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2lsbHlXb25rYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS93aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kYXRhZ3JpZCcgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFdpbGx5V29ua2EgZXh0ZW5kcyBXaWxseVdvbmthIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT29tcGFMb29tcGEgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IFJvd0FjdGlvblNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvcm93LWFjdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IERhdGFncmlkV2lsbHlXb25rYSB9IGZyb20gJy4vZGF0YWdyaWQtd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGF0YWdyaWQsIGNsci1kZy1yb3cnIH0pXG5leHBvcnQgY2xhc3MgQWN0aW9uYWJsZU9vbXBhTG9vbXBhIGV4dGVuZHMgT29tcGFMb29tcGEge1xuICBwcml2YXRlIHJvd0FjdGlvbnM6IFJvd0FjdGlvblNlcnZpY2U7XG5cbiAgY29uc3RydWN0b3IoY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgQE9wdGlvbmFsKCkgd2lsbHlXb25rYTogRGF0YWdyaWRXaWxseVdvbmthLCByb3dBY3Rpb25zOiBSb3dBY3Rpb25TZXJ2aWNlKSB7XG4gICAgaWYgKCF3aWxseVdvbmthKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1kZy1yb3cgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItZGF0YWdyaWQnKTtcbiAgICB9XG4gICAgc3VwZXIoY2RyLCB3aWxseVdvbmthKTtcbiAgICB0aGlzLnJvd0FjdGlvbnMgPSByb3dBY3Rpb25zO1xuICB9XG5cbiAgZ2V0IGZsYXZvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dBY3Rpb25zLmhhc0FjdGlvbmFibGVSb3c7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEV4cGFuZGFibGVSb3dzQ291bnQge1xuICBwcml2YXRlIGV4cGFuZGFibGVDb3VudCA9IDA7XG5cbiAgcHVibGljIHJlZ2lzdGVyKCkge1xuICAgIHRoaXMuZXhwYW5kYWJsZUNvdW50Kys7XG4gIH1cblxuICBwdWJsaWMgdW5yZWdpc3RlcigpIHtcbiAgICB0aGlzLmV4cGFuZGFibGVDb3VudC0tO1xuICB9XG5cbiAgLyoqXG4gICAqIGZhbHNlIG1lYW5zIG5vIHJvd3Mgd2l0aCBhY3Rpb25cbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzRXhwYW5kYWJsZVJvdygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlQ291bnQgPiAwO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT29tcGFMb29tcGEgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuLi9wcm92aWRlcnMvZ2xvYmFsLWV4cGFuZGFibGUtcm93cyc7XG5pbXBvcnQgeyBEYXRhZ3JpZFdpbGx5V29ua2EgfSBmcm9tICcuL2RhdGFncmlkLXdpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRhdGFncmlkLCBjbHItZGctcm93JyB9KVxuZXhwb3J0IGNsYXNzIEV4cGFuZGFibGVPb21wYUxvb21wYSBleHRlbmRzIE9vbXBhTG9vbXBhIHtcbiAgcHJpdmF0ZSBleHBhbmRhYmxlQ291bnQ6IEV4cGFuZGFibGVSb3dzQ291bnQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSB3aWxseVdvbmthOiBEYXRhZ3JpZFdpbGx5V29ua2EsXG4gICAgZXhwYW5kYWJsZUNvdW50OiBFeHBhbmRhYmxlUm93c0NvdW50XG4gICkge1xuICAgIGlmICghd2lsbHlXb25rYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItZGctcm93IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLWRhdGFncmlkJyk7XG4gICAgfVxuICAgIHN1cGVyKGNkciwgd2lsbHlXb25rYSk7XG4gICAgdGhpcy5leHBhbmRhYmxlQ291bnQgPSBleHBhbmRhYmxlQ291bnQ7XG4gIH1cblxuICBnZXQgZmxhdm9yKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGVDb3VudC5oYXNFeHBhbmRhYmxlUm93O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2NvbXBhcmF0b3IuaW50ZXJmYWNlJztcbmltcG9ydCB7IE5lc3RlZFByb3BlcnR5IH0gZnJvbSAnLi4vbmVzdGVkLXByb3BlcnR5JztcblxuZXhwb3J0IGNsYXNzIERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yPFQgPSBhbnk+IGltcGxlbWVudHMgQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+IHtcbiAgcHJpdmF0ZSBuZXN0ZWRQcm9wOiBOZXN0ZWRQcm9wZXJ0eTxUPjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcHJvcDogc3RyaW5nKSB7XG4gICAgdGhpcy5uZXN0ZWRQcm9wID0gbmV3IE5lc3RlZFByb3BlcnR5KHByb3ApO1xuICB9XG5cbiAgcHVibGljIGNvbXBhcmUoYTogVCwgYjogVCk6IG51bWJlciB7XG4gICAgbGV0IHByb3BBID0gdGhpcy5uZXN0ZWRQcm9wLmdldFByb3BWYWx1ZShhKTtcbiAgICBsZXQgcHJvcEIgPSB0aGlzLm5lc3RlZFByb3AuZ2V0UHJvcFZhbHVlKGIpO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wQSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3BBID0gcHJvcEEudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3BCID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvcEIgPSBwcm9wQi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvcEEgPT09ICd1bmRlZmluZWQnIHx8IHByb3BBID09PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BCID09PSAndW5kZWZpbmVkJyB8fCBwcm9wQiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BCID09PSAndW5kZWZpbmVkJyB8fCBwcm9wQiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHByb3BBIDwgcHJvcEIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChwcm9wQSA+IHByb3BCKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qKlxuICogRW51bWVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSBzb3J0aW5nIG9yZGVyIG9mIGEgZGF0YWdyaWQgY29sdW1uLiBJdCBpcyBhIGNvbnN0YW50IEVudW0sXG4gKiBpLmUuIGVhY2ggdmFsdWUgbmVlZHMgdG8gYmUgdHJlYXRlZCBhcyBhIGBudW1iZXJgLCBzdGFydGluZyBhdCBpbmRleCAwLlxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBlbnVtIENsckRhdGFncmlkU29ydE9yZGVyIHtcbiAgVU5TT1JURUQgPSAwLFxuICBBU0MgPSAxLFxuICBERVNDID0gLTEsXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29tcGFyYXRvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTb3J0PFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGF0ZURlYm91bmNlcjogU3RhdGVEZWJvdW5jZXIpIHt9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBhY3RpdmUgY29tcGFyYXRvclxuICAgKi9cbiAgcHJpdmF0ZSBfY29tcGFyYXRvcjogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+O1xuICBwdWJsaWMgZ2V0IGNvbXBhcmF0b3IoKTogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGFyYXRvcjtcbiAgfVxuICBwdWJsaWMgc2V0IGNvbXBhcmF0b3IodmFsdWU6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPikge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gdmFsdWU7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQXNjZW5kaW5nIG9yZGVyIGlmIGZhbHNlLCBkZXNjZW5kaW5nIGlmIHRydWVcbiAgICovXG4gIHByaXZhdGUgX3JldmVyc2U6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGdldCByZXZlcnNlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlO1xuICB9XG4gIHB1YmxpYyBzZXQgcmV2ZXJzZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICB0aGlzLl9yZXZlcnNlID0gdmFsdWU7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIHNvcnQgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8U29ydDxUPj4oKTtcbiAgcHJpdmF0ZSBlbWl0Q2hhbmdlKCkge1xuICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMpO1xuICB9XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxTb3J0PFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY29tcGFyYXRvciBhcyB0aGUgY3VycmVudCBvbmUsIG9yIHRvZ2dsZXMgcmV2ZXJzZSBpZiB0aGUgY29tcGFyYXRvciBpcyBhbHJlYWR5IHVzZWQuIFRoZVxuICAgKiBvcHRpb25hbCBmb3JjZVJldmVyc2UgaW5wdXQgcGFyYW1ldGVyIGFsbG93cyB0byBvdmVycmlkZSB0aGF0IHRvZ2dsaW5nIGJlaGF2aW9yIGJ5IHNvcnRpbmcgaW5cbiAgICogcmV2ZXJzZSBvcmRlciBpZiBgdHJ1ZWAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTb3J0XG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKHNvcnRCeTogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+LCBmb3JjZVJldmVyc2U/OiBib29sZWFuKSB7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgIC8vIFdlIG1vZGlmeSBwcml2YXRlIHByb3BlcnRpZXMgZGlyZWN0bHksIHRvIGJhdGNoIHRoZSBjaGFuZ2UgZXZlbnRcbiAgICBpZiAodGhpcy5jb21wYXJhdG9yID09PSBzb3J0QnkpIHtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSB0eXBlb2YgZm9yY2VSZXZlcnNlICE9PSAndW5kZWZpbmVkJyA/IGZvcmNlUmV2ZXJzZSB8fCAhdGhpcy5fcmV2ZXJzZSA6ICF0aGlzLl9yZXZlcnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb21wYXJhdG9yID0gc29ydEJ5O1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IHR5cGVvZiBmb3JjZVJldmVyc2UgIT09ICd1bmRlZmluZWQnID8gZm9yY2VSZXZlcnNlIDogZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY3VycmVudCBzb3J0aW5nIG9yZGVyXG4gICAqL1xuICBwdWJsaWMgY2xlYXIoKSB7XG4gICAgdGhpcy5jb21wYXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gb2JqZWN0cyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29tcGFyYXRvclxuICAgKi9cbiAgcHVibGljIGNvbXBhcmUoYTogVCwgYjogVCk6IG51bWJlciB7XG4gICAgcmV0dXJuICh0aGlzLnJldmVyc2UgPyAtMSA6IDEpICogdGhpcy5jb21wYXJhdG9yLmNvbXBhcmUoYSwgYik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRW1iZWRkZWRWaWV3UmVmLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkZy13cmFwcGVkLWNvbHVtbicsXG4gIHRlbXBsYXRlOiBgICAgICAgICBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNjb2x1bW5Qb3J0YWw+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgV3JhcHBlZENvbHVtbiBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBBZnRlclZpZXdJbml0IHtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcblxuICBAVmlld0NoaWxkKCdjb2x1bW5Qb3J0YWwnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8dm9pZD47XG4gIGNvbHVtblZpZXc6IEVtYmVkZGVkVmlld1JlZjx2b2lkPjsgLy8gdGhlIGNvbHVtbnMgcHJvamVjdGVkIHZpZXcgKGluIG1lbW9yeSlcblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBjZWxscyB2aWV3IGluIG1lbW9yeSwgbm90IHRoZSBET00uXG4gICAgdGhpcy5jb2x1bW5WaWV3ID0gdGhpcy50ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcobnVsbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEhvc3RXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRQcm9wZXJ0eUNvbXBhcmF0b3IgfSBmcm9tICcuL2J1aWx0LWluL2NvbXBhcmF0b3JzL2RhdGFncmlkLXByb3BlcnR5LWNvbXBhcmF0b3InO1xuaW1wb3J0IHsgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlciB9IGZyb20gJy4vYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1wcm9wZXJ0eS1zdHJpbmctZmlsdGVyJztcbmltcG9ydCB7IERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCB9IGZyb20gJy4vYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLWltcGwnO1xuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTb3J0T3JkZXIgfSBmcm9tICcuL2VudW1zL3NvcnQtb3JkZXIuZW51bSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvY29tcGFyYXRvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ3VzdG9tRmlsdGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvY3VzdG9tLWZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9maWx0ZXJzJztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL3Byb3ZpZGVycy9zb3J0JztcbmltcG9ydCB7IERhdGFncmlkRmlsdGVyUmVnaXN0cmFyIH0gZnJvbSAnLi91dGlscy9kYXRhZ3JpZC1maWx0ZXItcmVnaXN0cmFyJztcbmltcG9ydCB7IFdyYXBwZWRDb2x1bW4gfSBmcm9tICcuL3dyYXBwZWQtY29sdW1uJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcblxubGV0IG5iQ291bnQ6IG51bWJlciA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtY29sdW1uLWZsZXhcIj5cbiAgICAgICAgICAgIDwhLS0gSSdtIHJlYWxseSBub3QgaGFwcHkgd2l0aCB0aGF0IHNlbGVjdCBzaW5jZSBpdCdzIG5vdCB2ZXJ5IHNjYWxhYmxlIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWZpbHRlciwgY2xyLWRnLXN0cmluZy1maWx0ZXJcIj48L25nLWNvbnRlbnQ+XG5cbiAgICAgICAgICAgIDxjbHItZGctc3RyaW5nLWZpbHRlclxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImZpZWxkICYmICFjdXN0b21GaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICBbY2xyRGdTdHJpbmdGaWx0ZXJdPVwicmVnaXN0ZXJlZFwiXG4gICAgICAgICAgICAgICAgICAgIFsoY2xyRmlsdGVyVmFsdWUpXT1cImZpbHRlclZhbHVlXCI+PC9jbHItZGctc3RyaW5nLWZpbHRlcj5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNjb2x1bW5UaXRsZT5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi10aXRsZVwiIFxuICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbW1vblN0cmluZ3Mua2V5cy5zb3J0Q29sdW1uXCJcbiAgICAgICAgICAgICAgKm5nSWY9XCJzb3J0YWJsZVwiIFxuICAgICAgICAgICAgICAoY2xpY2spPVwic29ydCgpXCIgXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sdW1uVGl0bGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi10aXRsZVwiICpuZ0lmPVwiIXNvcnRhYmxlXCI+XG4gICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sdW1uVGl0bGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgPGNsci1kZy1jb2x1bW4tc2VwYXJhdG9yPjwvY2xyLWRnLWNvbHVtbi1zZXBhcmF0b3I+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLWNvbHVtbl0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1jb2x1bW4tLWhpZGRlbl0nOiAnaGlkZGVuJyxcbiAgICAnW2F0dHIuYXJpYS1zb3J0XSc6ICdhcmlhU29ydCcsXG4gICAgcm9sZTogJ2NvbHVtbmhlYWRlcicsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ29sdW1uPFQgPSBhbnk+IGV4dGVuZHMgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXI8VCwgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsPFQ+PlxuICBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc29ydDogU29ydDxUPixcbiAgICBmaWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4sXG4gICAgcHJpdmF0ZSB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlXG4gICkge1xuICAgIHN1cGVyKGZpbHRlcnMpO1xuICAgIHRoaXMuX3NvcnRTdWJzY3JpcHRpb24gPSBfc29ydC5jaGFuZ2Uuc3Vic2NyaWJlKHNvcnQgPT4ge1xuICAgICAgLy8gV2UncmUgb25seSBsaXN0ZW5pbmcgdG8gbWFrZSBzdXJlIHdlIGVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgY29sdW1uIGdvZXMgZnJvbSBzb3J0ZWQgdG8gdW5zb3J0ZWRcbiAgICAgIGlmICh0aGlzLnNvcnRPcmRlciAhPT0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuVU5TT1JURUQgJiYgc29ydC5jb21wYXJhdG9yICE9PSB0aGlzLl9zb3J0QnkpIHtcbiAgICAgICAgdGhpcy5fc29ydE9yZGVyID0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuVU5TT1JURUQ7XG4gICAgICAgIHRoaXMuc29ydE9yZGVyQ2hhbmdlLmVtaXQodGhpcy5fc29ydE9yZGVyKTtcbiAgICAgIH1cbiAgICAgIC8vIGRlcHJlY2F0ZWQ6IHRvIGJlIHJlbW92ZWQgLSBTVEFSVFxuICAgICAgaWYgKHRoaXMuc29ydGVkICYmIHNvcnQuY29tcGFyYXRvciAhPT0gdGhpcy5fc29ydEJ5KSB7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvcnRlZENoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIC8vIGRlcHJlY2F0ZWQ6IHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgICB9KTtcblxuICAgIHRoaXMuY29sdW1uSWQgPSAnZGctY29sLScgKyBuYkNvdW50LnRvU3RyaW5nKCk7IC8vIEFwcHJveGltYXRlIGEgR1VJRFxuICAgIG5iQ291bnQrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY29sdW1uSWRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgQ2xyRGF0YWdyaWRDb2x1bW4gY2xhc3MgdmFyaWFibGUgdGhhdCBob2xkcyB0aGUgbnVtYmVyIG9mIENsckRhdGFncmlkQ29sdW1uIGluc3RhbmNlcyBmb3IgYSBEYXRhZ3JpZC5cbiAgICogSXQgaXMgdXNlZCB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBpZCBmb3IgdGhlIENsckRhdGFncmlkQ29sdW1uIGluc3RhbmNlLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGNvbHVtbklkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoaWRkZW5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgcHJvcGVydHkgdGhhdCBhbGxvd3MgdGhlIGNvbHVtbiB0byBiZSBoaWRkZW4gLyBzaG93biB3aXRoIGNzc1xuICAgKiBOb3RlIHRoZSBkZWZhdWx0IGFsbG93cyB0aGUgQ2xyRGF0YWdyaWRDb2x1bW4gdG8gaGF2ZSBhbiAqbmdJZiBvbiBpdC4gKEVIQ0FJV0MgLSB3aWxsIG9jY3VyIGlmIGl0cyBub3RcbiAgICogaW5pdGlhbGl6ZWQpXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhpZGRlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmhpZGVhYmxlICYmIHRoaXMuaGlkZWFibGUuaGlkZGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbiB0byB0aGUgc29ydCBzZXJ2aWNlIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX3NvcnRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zb3J0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKlxuICAgICAqIFNpbXBsZSBvYmplY3QgcHJvcGVydHkgc2hvcnRjdXQsIGFjdGl2YXRlcyBib3RoIHNvcnRpbmcgYW5kIGZpbHRlcmluZ1xuICAgICAqIGJhc2VkIG9uIG5hdGl2ZSBjb21wYXJpc29uIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgb24gdGhlIGl0ZW1zLlxuICAgICAqL1xuICBwcml2YXRlIF9maWVsZDogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGZpZWxkKCkge1xuICAgIHJldHVybiB0aGlzLl9maWVsZDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdGaWVsZCcpXG4gIHB1YmxpYyBzZXQgZmllbGQoZmllbGQ6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9maWVsZCA9IGZpZWxkO1xuICAgICAgaWYgKCF0aGlzLmN1c3RvbUZpbHRlcikge1xuICAgICAgICB0aGlzLnNldEZpbHRlcihuZXcgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsKG5ldyBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyKGZpZWxkKSkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3J0QnkpIHtcbiAgICAgICAgdGhpcy5fc29ydEJ5ID0gbmV3IERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yKGZpZWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlIHRvIHVzZSB3aGVuIHNvcnRpbmcgdGhlIGNvbHVtblxuICAgKi9cblxuICBwcml2YXRlIF9zb3J0Qnk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPjtcblxuICBwdWJsaWMgZ2V0IHNvcnRCeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydEJ5O1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NvcnRCeScpXG4gIHB1YmxpYyBzZXQgc29ydEJ5KGNvbXBhcmF0b3I6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3NvcnRCeSA9IG5ldyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcihjb21wYXJhdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy5fc29ydEJ5ID0gY29tcGFyYXRvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9maWVsZCkge1xuICAgICAgICAgIHRoaXMuX3NvcnRCeSA9IG5ldyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcih0aGlzLl9maWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3NvcnRCeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZVxuICAgKi9cbiAgcHVibGljIGdldCBzb3J0YWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9zb3J0Qnk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBzb3J0ZWRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgc29vbiwgaW4gZmF2b3Igb2YgdGhlIHNvcnRPcmRlciBtZWNoYW5pc21cbiAgICovXG4gIHByaXZhdGUgX3NvcnRlZCA9IGZhbHNlO1xuICBwdWJsaWMgZ2V0IHNvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAqL1xuICBASW5wdXQoJ2NsckRnU29ydGVkJylcbiAgcHVibGljIHNldCBzb3J0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAoIXZhbHVlICYmIHRoaXMuc29ydGVkKSB7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NvcnQuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmICF0aGlzLnNvcnRlZCkge1xuICAgICAgdGhpcy5zb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAqL1xuICBAT3V0cHV0KCdjbHJEZ1NvcnRlZENoYW5nZScpIHB1YmxpYyBzb3J0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIEVORFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaG93IHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHNvcnRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydE9yZGVyOiBDbHJEYXRhZ3JpZFNvcnRPcmRlciA9IENsckRhdGFncmlkU29ydE9yZGVyLlVOU09SVEVEO1xuICBwdWJsaWMgZ2V0IHNvcnRPcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydE9yZGVyO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NvcnRPcmRlcicpXG4gIHB1YmxpYyBzZXQgc29ydE9yZGVyKHZhbHVlOiBDbHJEYXRhZ3JpZFNvcnRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBpZiB0aGUgaW5jb21pbmcgb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb25lXG4gICAgaWYgKHRoaXMuX3NvcnRPcmRlciA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAvLyB0aGUgVW5zb3J0ZWQgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIGN1cnJlbnQgc3RhdGUgaXMgZWl0aGVyIEFzYyBvciBEZXNjXG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRDpcbiAgICAgICAgdGhpcy5fc29ydC5jbGVhcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuQVNDOlxuICAgICAgICB0aGlzLnNvcnQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuREVTQzpcbiAgICAgICAgdGhpcy5zb3J0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFyaWFTb3J0KCkge1xuICAgIHN3aXRjaCAodGhpcy5fc29ydE9yZGVyKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRDpcbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuQVNDOlxuICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XG4gICAgICBjYXNlIENsckRhdGFncmlkU29ydE9yZGVyLkRFU0M6XG4gICAgICAgIHJldHVybiAnZGVzY2VuZGluZyc7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdTb3J0T3JkZXJDaGFuZ2UnKSBwdWJsaWMgc29ydE9yZGVyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJEYXRhZ3JpZFNvcnRPcmRlcj4oKTtcblxuICAvKipcbiAgICogU29ydHMgdGhlIGRhdGFncmlkIGJhc2VkIG9uIHRoaXMgY29sdW1uXG4gICAqL1xuICBwdWJsaWMgc29ydChyZXZlcnNlPzogYm9vbGVhbikge1xuICAgIGlmICghdGhpcy5zb3J0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NvcnQudG9nZ2xlKHRoaXMuX3NvcnRCeSwgcmV2ZXJzZSk7XG5cbiAgICAvLyBzZXR0aW5nIHRoZSBwcml2YXRlIHZhcmlhYmxlIHRvIG5vdCByZXRyaWdnZXIgdGhlIHNldHRlciBsb2dpY1xuICAgIHRoaXMuX3NvcnRPcmRlciA9IHRoaXMuX3NvcnQucmV2ZXJzZSA/IENsckRhdGFncmlkU29ydE9yZGVyLkRFU0MgOiBDbHJEYXRhZ3JpZFNvcnRPcmRlci5BU0M7XG4gICAgdGhpcy5zb3J0T3JkZXJDaGFuZ2UuZW1pdCh0aGlzLl9zb3J0T3JkZXIpO1xuXG4gICAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIFNUQVJUXG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNvcnRlZENoYW5nZS5lbWl0KHRydWUpO1xuICAgIC8vIGRlcHJlY2F0ZWQ6IHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlclxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hc2MnKVxuICBwdWJsaWMgZ2V0IGFzYygpIHtcbiAgICAvLyBkZXByZWNhdGVkOiBpZiBjb25kaXRpb24gdG8gYmUgcmVtb3ZlZCAtIFNUQVJUXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvcnRPcmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRlZCAmJiAhdGhpcy5fc29ydC5yZXZlcnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3J0T3JkZXIgPT09IENsckRhdGFncmlkU29ydE9yZGVyLkFTQztcbiAgICB9XG4gICAgLy8gZGVwcmVjYXRlZDogaWYgY29uZGl0aW9uIHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICovXG4gIEBIb3N0QmluZGluZygnY2xhc3MuZGVzYycpXG4gIHB1YmxpYyBnZXQgZGVzYygpIHtcbiAgICAvLyBkZXByZWNhdGVkOiBpZiBjb25kaXRpb24gdG8gYmUgcmVtb3ZlZCAtIFNUQVJUXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvcnRPcmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRlZCAmJiB0aGlzLl9zb3J0LnJldmVyc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRPcmRlciA9PT0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuREVTQztcbiAgICB9XG4gICAgLy8gZGVwcmVjYXRlZDogaWYgY29uZGl0aW9uIHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSBmaWx0ZXIgZm9yIHRoaXMgY29sdW1uIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBwcm9qZWN0ZWQgY29udGVudFxuICAgKi9cbiAgcHVibGljIGN1c3RvbUZpbHRlciA9IGZhbHNlO1xuXG4gIEBDb250ZW50Q2hpbGQoQ3VzdG9tRmlsdGVyKVxuICBwdWJsaWMgc2V0IHByb2plY3RlZEZpbHRlcihjdXN0b206IGFueSkge1xuICAgIGlmIChjdXN0b20pIHtcbiAgICAgIHRoaXMuZGVsZXRlRmlsdGVyKCk7XG4gICAgICB0aGlzLmN1c3RvbUZpbHRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBmaWx0ZXJWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIudmFsdWU7XG4gIH1cblxuICBASW5wdXQoJ2NsckZpbHRlclZhbHVlJylcbiAgcHVibGljIHNldCB1cGRhdGVGaWx0ZXJWYWx1ZShuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICBuZXdWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuZmlsdGVyLnZhbHVlKSB7XG4gICAgICB0aGlzLmZpbHRlci52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXQgZmlsdGVyVmFsdWUobmV3VmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMudXBkYXRlRmlsdGVyVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLmZpbHRlclZhbHVlQ2hhbmdlLmVtaXQodGhpcy5maWx0ZXIudmFsdWUpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyRmlsdGVyVmFsdWVDaGFuZ2UnKSBmaWx0ZXJWYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKioqKioqKioqKipcbiAgICpcbiAgICogQHByb3BlcnR5IGhpZGVhYmxlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBXaGVuIGEgY29sdW1uIGlzIGhpZGVhYmxlIHRoaXMgaXMgZGVmaW5lZCB3aXRoIGFuIGluc3RhbmNlIG9mIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbC5cbiAgICogV2hlbiBpdHMgbm90IGhpZGVhYmxlIHNob3VsZCBiZSB1bmRlZmluZWQuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgaGlkZWFibGU6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbDtcblxuICBwcml2YXRlIHdyYXBwZWRJbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy53cmFwcGVkSW5qZWN0b3IgPSBuZXcgSG9zdFdyYXBwZXIoV3JhcHBlZENvbHVtbiwgdGhpcy52Y3IpO1xuICB9XG5cbiAgcHVibGljIGdldCBfdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5qZWN0b3IuZ2V0KFdyYXBwZWRDb2x1bW4sIHRoaXMudmNyKS5jb2x1bW5WaWV3O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcGFnZSc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9zb3J0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEl0ZW1zPFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LCBwcml2YXRlIF9zb3J0OiBTb3J0PFQ+LCBwcml2YXRlIF9wYWdlOiBQYWdlKSB7fVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGRhdGEgaXMgY3VycmVudGx5IGxvYWRpbmdcbiAgICovXG4gIHB1YmxpYyBsb2FkaW5nID0gZmFsc2U7XG5cbiAgLy8gVE9ETzogVmVyaWZ5IHRoYXQgdHJhY2tCeSBpcyByZWdpc3RlcmVkIGZvciB0aGUgKm5nRm9yIGNhc2UgdG9vXG4gIC8qKlxuICAgKiBUcmFja2luZyBmdW5jdGlvbiB0byBpZGVudGlmeSBvYmplY3RzLiBEZWZhdWx0IGlzIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAgICovXG4gIHB1YmxpYyB0cmFja0J5OiBUcmFja0J5RnVuY3Rpb248VD4gPSAoaW5kZXg6IG51bWJlciwgaXRlbTogVCkgPT4gaXRlbTtcblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9ucyB0byB0aGUgb3RoZXIgcHJvdmlkZXJzIGNoYW5nZXMuXG4gICAqL1xuICBwcml2YXRlIF9maWx0ZXJzU3ViOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX3NvcnRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfcGFnZVN1YjogU3Vic2NyaXB0aW9uO1xuICAvKipcbiAgICogQ2xlYW5zIHVwIG91ciBzdWJzY3JpcHRpb25zIHRvIG90aGVyIHByb3ZpZGVyc1xuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlcnNTdWIpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnNTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnRTdWIpIHtcbiAgICAgIHRoaXMuX3NvcnRTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhZ2VTdWIpIHtcbiAgICAgIHRoaXMuX3BhZ2VTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgdXNlIHNtYXJ0IGl0ZW1zIGZvciB0aGlzIGRhdGFncmlkIG9yIGxldCB0aGUgdXNlciBoYW5kbGVcbiAgICogZXZlcnl0aGluZy5cbiAgICovXG4gIHByaXZhdGUgX3NtYXJ0ID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgc21hcnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3NtYXJ0O1xuICB9XG4gIHB1YmxpYyBzbWFydGVuVXAoKSB7XG4gICAgdGhpcy5fc21hcnQgPSB0cnVlO1xuICAgIC8qXG4gICAgICAgICAqIFRoZXNlIG9ic2VydmVycyB0cmlnZ2VyIGEgY2hhaW4gb2YgZnVuY3Rpb246IGZpbHRlciAtPiBzb3J0IC0+IHBhZ2luYXRlXG4gICAgICAgICAqIEFuIG9ic2VydmVyIHVwIHRoZSBjaGFpbiByZS10cmlnZ2VycyBhbGwgdGhlIG9wZXJhdGlvbnMgdGhhdCBmb2xsb3cgaXQuXG4gICAgICAgICAqL1xuICAgIHRoaXMuX2ZpbHRlcnNTdWIgPSB0aGlzLl9maWx0ZXJzLmNoYW5nZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZmlsdGVySXRlbXMoKSk7XG4gICAgdGhpcy5fc29ydFN1YiA9IHRoaXMuX3NvcnQuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UsIGlmIHRoZSBkYXRhZ3JpZCB3ZW50IGZyb20gc29ydGVkIHRvIHVuc29ydGVkLCB3ZSBoYXZlIHRvIHJlLWZpbHRlclxuICAgICAgLy8gdG8gZ2V0IHRoZSBvcmlnaW5hbCBvcmRlciBiYWNrXG4gICAgICBpZiAoIXRoaXMuX3NvcnQuY29tcGFyYXRvcikge1xuICAgICAgICB0aGlzLl9maWx0ZXJJdGVtcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcGFnZVN1YiA9IHRoaXMuX3BhZ2UuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9jaGFuZ2VQYWdlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYWxsIGl0ZW1zIGluIHRoZSBkYXRhZ3JpZFxuICAgKi9cbiAgcHJpdmF0ZSBfYWxsOiBUW107XG4gIHB1YmxpYyBnZXQgYWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9hbGw7XG4gIH1cbiAgcHVibGljIHNldCBhbGwoaXRlbXM6IFRbXSkge1xuICAgIHRoaXMuX2FsbCA9IGl0ZW1zO1xuICAgIHRoaXMuZW1pdEFsbENoYW5nZXMoaXRlbXMpO1xuICAgIGlmICh0aGlzLnNtYXJ0KSB7XG4gICAgICB0aGlzLl9maWx0ZXJJdGVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWQgPSBpdGVtcztcbiAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSByZWNvbXB1dGUgdGhlIGxpc3Qgb2YgZGlzcGxheWVkIGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5zbWFydCkge1xuICAgICAgdGhpcy5fZmlsdGVySXRlbXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgdGVtcG9yYXJ5IHN0ZXAsIHdoaWNoIHdlIHByZXNlcnZlIHRvIGF2b2lkIHJlLWZpbHRlcmluZyBvciByZS1zb3J0aW5nIGlmIG5vdCBuZWNlc3NhcnlcbiAgICovXG4gIHByaXZhdGUgX2ZpbHRlcmVkOiBUW107XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgaXRlbXMgY3VycmVudGx5IGRpc3BsYXllZFxuICAgKi9cbiAgcHJpdmF0ZSBfZGlzcGxheWVkOiBUW10gPSBbXTtcbiAgcHVibGljIGdldCBkaXNwbGF5ZWQoKTogVFtdIHtcbiAgICAvLyBJZGVhbGx5IHdlIGNvdWxkIHJldHVybiBhbiBpbW11dGFibGUgYXJyYXksIGJ1dCB3ZSBkb24ndCBoYXZlIGl0IGluIENsYXJpdHkgeWV0LlxuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIGl0ZW1zIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PFRbXT4oKTtcbiAgcHJpdmF0ZSBlbWl0Q2hhbmdlKCkge1xuICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuZGlzcGxheWVkKTtcbiAgfVxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8VFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FsbENoYW5nZXMgPSBuZXcgU3ViamVjdDxUW10+KCk7XG4gIHByaXZhdGUgZW1pdEFsbENoYW5nZXMoaXRlbXM6IFRbXSk6IHZvaWQge1xuICAgIHRoaXMuX2FsbENoYW5nZXMubmV4dChpdGVtcyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFsbENoYW5nZXMoKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gdGhpcy5fYWxsQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgd2UgZG9uJ3QgaGF2ZSBkYXRhIHRvIHByb2Nlc3MgeWV0LCB0byBhYm9ydCBlYXJseSBvcGVyYXRpb25zXG4gICAqL1xuICBwcml2YXRlIGdldCB1bmluaXRpYWxpemVkKCkge1xuICAgIHJldHVybiAhdGhpcy5fYWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnNQcm92aWRlciBpdGVtcyBmcm9tIHRoZSByYXcgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfZmlsdGVySXRlbXMoKSB7XG4gICAgaWYgKHRoaXMudW5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZmlsdGVycy5oYXNBY3RpdmVGaWx0ZXJzKCkpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcmVkID0gdGhpcy5fYWxsLmZpbHRlcihpdGVtID0+IHRoaXMuX2ZpbHRlcnMuYWNjZXB0cyhpdGVtKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdvcmsgb24gYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5LCB0byBub3QgbW9kaWZ5IHRoZSB1c2VyJ3MgbW9kZWxcbiAgICAgIHRoaXMuX2ZpbHRlcmVkID0gdGhpcy5fYWxsLnNsaWNlKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2UudG90YWxJdGVtcyA9IHRoaXMuX2ZpbHRlcmVkLmxlbmd0aDtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBpdGVtcyBpbiB0aGUgZmlsdGVyZWQgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydEl0ZW1zKCkge1xuICAgIGlmICh0aGlzLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnQuY29tcGFyYXRvcikge1xuICAgICAgdGhpcy5fZmlsdGVyZWQuc29ydCgoYSwgYikgPT4gdGhpcy5fc29ydC5jb21wYXJlKGEsIGIpKTtcbiAgICB9XG4gICAgdGhpcy5fY2hhbmdlUGFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgc29ydGVkIGxpc3RcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZVBhZ2UoKSB7XG4gICAgLy8gSWYgd2Uga25vdyB3ZSBoYXZlIHBhZ2luYXRpb24gYnV0IHRoZSBwYWdlIHNpemUgaGFzbid0IGJlZW4gc2V0IHlldCwgd2Ugd2FpdCBmb3IgaXQuXG4gICAgaWYgKHRoaXMudW5pbml0aWFsaXplZCB8fCAodGhpcy5fcGFnZS5hY3RpdmF0ZWQgJiYgdGhpcy5fcGFnZS5zaXplID09PSAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFnZS5zaXplID4gMCkge1xuICAgICAgdGhpcy5fZGlzcGxheWVkID0gdGhpcy5fZmlsdGVyZWQuc2xpY2UodGhpcy5fcGFnZS5maXJzdEl0ZW0sIHRoaXMuX3BhZ2UubGFzdEl0ZW0gKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzcGxheWVkID0gdGhpcy5fZmlsdGVyZWQ7XG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ0Zvck9mLCBOZ0Zvck9mQ29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIERvQ2hlY2ssXG4gIElucHV0LFxuICBJdGVyYWJsZURpZmZlcixcbiAgSXRlcmFibGVEaWZmZXJzLFxuICBUZW1wbGF0ZVJlZixcbiAgVHJhY2tCeUZ1bmN0aW9uLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBPbkRlc3Ryb3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vcHJvdmlkZXJzL2l0ZW1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRGdJdGVtc11bY2xyRGdJdGVtc09mXScsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkSXRlbXM8VD4gaW1wbGVtZW50cyBEb0NoZWNrLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGl0ZXJhYmxlUHJveHk6IE5nRm9yT2Y8VD47XG4gIHByaXZhdGUgX3Jhd0l0ZW1zOiBUW107XG4gIHByaXZhdGUgZGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJEZ0l0ZW1zT2YnKVxuICBwdWJsaWMgc2V0IHJhd0l0ZW1zKGl0ZW1zOiBUW10pIHtcbiAgICB0aGlzLl9yYXdJdGVtcyA9IGl0ZW1zID8gaXRlbXMgOiBbXTsgLy8gbG9jYWwgY29weSBmb3IgbmdPbkNoYW5nZSBkaWZmaW5nXG4gIH1cblxuICBASW5wdXQoJ2NsckRnSXRlbXNUcmFja0J5JylcbiAgc2V0IHRyYWNrQnkodmFsdWU6IFRyYWNrQnlGdW5jdGlvbjxUPikge1xuICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0ZvclRyYWNrQnkgPSB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LFxuICAgIHByaXZhdGUgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLFxuICAgIHByaXZhdGUgaXRlbXM6IEl0ZW1zLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIGl0ZW1zLnNtYXJ0ZW5VcCgpO1xuICAgIHRoaXMuaXRlcmFibGVQcm94eSA9IG5ldyBOZ0Zvck9mPFQ+KHRoaXMudmNyLCB0aGlzLnRlbXBsYXRlLCB0aGlzLmRpZmZlcnMpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgaXRlbXMuY2hhbmdlLnN1YnNjcmliZShuZXdJdGVtcyA9PiB7XG4gICAgICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0Zvck9mID0gbmV3SXRlbXM7XG4gICAgICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0RvQ2hlY2soKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAoIXRoaXMuZGlmZmVyKSB7XG4gICAgICB0aGlzLmRpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKHRoaXMuX3Jhd0l0ZW1zKS5jcmVhdGUodGhpcy5pdGVyYWJsZVByb3h5Lm5nRm9yVHJhY2tCeSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpZmZlcikge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYodGhpcy5fcmF3SXRlbXMpO1xuICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gVE9ETzogbm90IHZlcnkgZWZmaWNpZW50IHJpZ2h0IG5vdyxcbiAgICAgICAgLy8gYnV0IHByZW1hdHVyZSBvcHRpbWl6YXRpb24gaXMgdGhlIHJvb3Qgb2YgYWxsIGV2aWwuXG4gICAgICAgIHRoaXMuaXRlbXMuYWxsID0gdGhpcy5fcmF3SXRlbXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vcHJvdmlkZXJzL2l0ZW1zJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXBsYWNlaG9sZGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJkYXRhZ3JpZC1wbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbY2xhc3MuZGF0YWdyaWQtZW1wdHldPVwiZW1wdHlEYXRhZ3JpZFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1wbGFjZWhvbGRlci1pbWFnZVwiICpuZ0lmPVwiZW1wdHlEYXRhZ3JpZFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50ICpuZ0lmPVwiZW1wdHlEYXRhZ3JpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmRhdGFncmlkLXBsYWNlaG9sZGVyLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRQbGFjZWhvbGRlcjxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaXRlbXM6IEl0ZW1zPFQ+KSB7fVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGUgZGF0YWdyaWQgaXMgZW1wdHksIG1lYW5pbmcgaXQgZG9lc24ndCBjb250YWluIGFueSBpdGVtc1xuICAgKi9cbiAgcHVibGljIGdldCBlbXB0eURhdGFncmlkKCkge1xuICAgIHJldHVybiAhdGhpcy5pdGVtcy5sb2FkaW5nICYmICghdGhpcy5pdGVtcy5kaXNwbGF5ZWQgfHwgdGhpcy5pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoID09PSAwKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgUE9QT1ZFUl9IT1NUX0FOQ0hPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxFbGVtZW50UmVmPignUE9QT1ZFUl9IT1NUX0FOQ0hPUicpO1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNpZ25wb3N0SWRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfaWQ6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuICBzZXRJZChpZDogc3RyaW5nKSB7XG4gICAgdGhpcy5faWQubmV4dChpZCk7XG4gIH1cblxuICBnZXQgaWQoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5faWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiwgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2lnbnBvc3RJZFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9zaWducG9zdC1pZC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsclNpZ25wb3N0VHJpZ2dlcl0nLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICdzaWducG9zdC10cmlnZ2VyJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnY29tbW9uU3RyaW5ncy5rZXlzLnNpZ25wb3N0VG9nZ2xlJyxcbiAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAnYXJpYUV4cGFuZGVkJyxcbiAgICAnW2F0dHIuYXJpYS1jb250cm9sc10nOiAnYXJpYUNvbnRyb2wnLFxuICB9LFxufSlcblxuLyoqKioqKioqKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBEaXJlY3RpdmUgYWRkZWQgdG8gdGhlIENsclNpZ25wb3N0IFRyaWdnZXIgYnV0dG9uIHRoYXQgd2lsbCBjYWxsIHRoZSBDbHJTaWducG9zdC50b2dnbGUoKSBmdW5jdGlvbiB0byBoaWRlL3Nob3cgdGhlXG4gKiBDbHJTaWducG9zdENvbnRlbnQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xyU2lnbnBvc3RUcmlnZ2VyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwdWJsaWMgYXJpYUV4cGFuZGVkOiBib29sZWFuO1xuICBwdWJsaWMgYXJpYUNvbnRyb2w6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgc2lnbnBvc3RJZFNlcnZpY2U6IFNpZ25wb3N0SWRTZXJ2aWNlLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0XG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKChpc09wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnYWN0aXZlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdhY3RpdmUnKTtcbiAgICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJpYUV4cGFuZGVkID0gaXNPcGVuO1xuICAgICAgfSksXG4gICAgICB0aGlzLnNpZ25wb3N0SWRTZXJ2aWNlLmlkLnN1YnNjcmliZShpZENoYW5nZSA9PiAodGhpcy5hcmlhQ29udHJvbCA9IGlkQ2hhbmdlKSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogY2xpY2sgaGFuZGxlciBmb3IgdGhlIENsclNpZ25wb3N0IHRyaWdnZXIgYnV0dG9uIHVzZWQgdG8gaGlkZS9zaG93IENsclNpZ25wb3N0Q29udGVudC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcbiAgb25TaWducG9zdFRyaWdnZXJDbGljayhldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5pbXBvcnQgeyBQT1BPVkVSX0hPU1RfQU5DSE9SIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4nO1xuXG5pbXBvcnQgeyBDbHJTaWducG9zdFRyaWdnZXIgfSBmcm9tICcuL3NpZ25wb3N0LXRyaWdnZXInO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2lnbnBvc3RJZFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9zaWducG9zdC1pZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXNpZ25wb3N0JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiF1c2VDdXN0b21UcmlnZ2VyXCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJzaWducG9zdC1hY3Rpb24gYnRuIGJ0bi1zbWFsbCBidG4tbGlua1wiXG4gICAgICAgICAgICAgICAgY2xyU2lnbnBvc3RUcmlnZ2VyPlxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImluZm9cIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMuaW5mb1wiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLnNpZ25wb3N0XSc6ICd0cnVlJyB9LFxuICBwcm92aWRlcnM6IFtJZk9wZW5TZXJ2aWNlLCB7IHByb3ZpZGU6IFBPUE9WRVJfSE9TVF9BTkNIT1IsIHVzZUV4aXN0aW5nOiBFbGVtZW50UmVmIH0sIFNpZ25wb3N0SWRTZXJ2aWNlXSxcbn0pXG5cbi8qKioqKioqKipcbiAqXG4gKiBAY2xhc3MgQ2xyU2lnbnBvc3RcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENsYXNzIHVzZWQgdG8gY29uZmlndXJlIGFuZCBjb250cm9sIHRoZSBzdGF0ZSBvZiBhIENsclNpZ25wb3N0IGFuZCBpdHMgYXNzb2NpYXRlZCBDbHJTaWducG9zdENvbnRlbnQuXG4gKiBJdCBzdXBwb3J0cyB0aGUgY2xyUG9zaXRpb24gd2l0aCBhICdyaWdodC1taWRkbGUnIGRlZmF1bHQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xyU2lnbnBvc3Qge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UpIHt9XG5cbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IHVzZUN1c3RvbVRyaWdnZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEZsYWcgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byB1c2UgdGhlIGRlZmF1bHQgdHJpZ2dlciBvciBhIHVzZXIgc3VwcGxpZWQgdHJpZ2dlciBlbGVtZW50LlxuICAgKlxuICAgKi9cbiAgcHVibGljIHVzZUN1c3RvbVRyaWdnZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKioqKioqKioqKlxuICAgKiBAcHJvcGVydHkgc2lnblBvc3RUcmlnZ2VyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVc2VzIENvbnRlbnRDaGlsZCB0byBjaGVjayBmb3IgYSB1c2VyIHN1cHBsaWVkIGVsZW1lbnQgd2l0aCB0aGUgQ2xyU2lnbnBvc3RUcmlnZ2VyIG9uIGl0LlxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJTaWducG9zdFRyaWdnZXIpXG4gIHNldCBjdXN0b21UcmlnZ2VyKHRyaWdnZXI6IENsclNpZ25wb3N0VHJpZ2dlcikge1xuICAgIHRoaXMudXNlQ3VzdG9tVHJpZ2dlciA9ICEhdHJpZ2dlcjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBASW5qZWN0YWJsZSBwcm92aWRlciBjbGFzcyB0aGF0IGVuYWJsZXNcbiAqXG4gKiAxLiBNYW5hZ2luZywgdHJhY2sgaGlkZWFiaWxpdHkgb2YgRGF0YWdyaWRDb2x1bW5zXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIHtcbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IGRnSGlkZGVuQ29sdW1uTWFwXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBhcnJheSBvZiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uLlxuICAgKiBOT1RFOiBiZWNhdXNlIHdlIGNhbiBoYXZlIGNvbHVtbnMgdy9vIHRoZSAqY2xyRGdIaWRlYWJsZUNvbHVtbiBkaXJlY3RpdmVcbiAgICogdGhpcyBhcnJheSB3aWxsIGhhdmUgZW1wdHkgc3BhY2VzIGEuay5hIG51bGxzLiBUaGlzIGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIG1hcFxuICAgKiBEYXRhZ3JpZENlbGxzIHRvIERhdGFncmlkQ29sdW1ucyBpbiB0aGUgUm93UmVuZGVyZXIuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9jb2x1bW5MaXN0OiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSA9IFtdO1xuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBkZ0hpZGRlbkNvbHVtbk1hcENoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBiZWhhdmlvciBzdWJqZWN0IHRoYXQgY2FuIGJyb2FkY2FzdCB1cGRhdGVzIHRvIHRoZSBjb2x1bW4gbGlzdC5cbiAgICogTk9URTogSSBhbSB1c2luZyBCZWhhdmlvclN1YmplY3QgYmVjYXVzZSA8Y2xyLWRnLWNvbHVtbi10b2dnbGU+IGlzIG5vdCBnZXR0aW5nIHRoZSBsYXRlc3QgX2NvbHVtbkxpc3RDaGFuZ2VcbiAgICogb24gcGFnZSBsb2FkLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfY29sdW1uTGlzdENoYW5nZTogQmVoYXZpb3JTdWJqZWN0PERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8XG4gICAgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW11cbiAgPih0aGlzLl9jb2x1bW5MaXN0KTtcblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAcHJvcGVydHkgY2FuSGlkZU5leHRDb2x1bW5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNlcnZpY2UgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgYnkgY2xyLWRnLWNvbHVtbi10b2dnbGUgY29tcG9uZW50LiBVc2UgdGhpcyBpZiB5b3UgbmVlZCB0byBhc2sgaWYgeW91IGNhbiBoaWRlXG4gICAqIGEgY29sdW1uLiBJdCBhY3RzIGFzIGEgZ3VhcmQgYWdhaW5zdCBoaWRpbmcgYWxsIHRoZSBjb2x1bW5zIG1ha2luZyBzdXJlIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjb2x1bW4gZGlzcGxheWVkLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjYW5IaWRlTmV4dENvbHVtbigpOiBib29sZWFuIHtcbiAgICBjb25zdCBoaWRkZW5Db2x1bW5zID0gdGhpcy5fY29sdW1uTGlzdC5maWx0ZXIoY29sdW1uID0+IGNvbHVtbiAhPT0gdW5kZWZpbmVkKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5oaWRkZW4pO1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5MaXN0Lmxlbmd0aCAtIGhpZGRlbkNvbHVtbnMubGVuZ3RoID4gMTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBjaGVja0ZvckFsbENvbHVtbnNWaXNpYmxlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGb3Igd2hlbiB5b3UgbmVlZCB0byBrbm93IGlmIHRoZSBkYXRhZ3JpZCdzIGNvbHVtbnMgYXJlIGFsbCBzaG93aW5nLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjaGVja0ZvckFsbENvbHVtbnNWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5fY29sdW1uTGlzdC5zb21lKGNvbHVtbiA9PiBjb2x1bW4gJiYgY29sdW1uLmhpZGRlbik7XG4gIH1cblxuICAvKioqKioqKioqKipcbiAgICogQHByb3BlcnR5IGNvbHVtbkxpc3RDaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgcHVibGljIHByb3BlcnR5IHRoYXQgZW5hYmxlcyBzdWJzY3JpYmVycyB0byBoZWFyIHVwZGF0ZXMgdG8gdGhlIGNvbHVtbiBtYXAuXG4gICAqIFVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZyB3aGVuZXZlciB0aGUgRGF0YWdyaWQncyBjb2x1bW4gbGlzdCBpcyBjaGFuZ2VkIChpLmUgKm5nSWYgb24gYSBjb2x1bW4pLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjb2x1bW5MaXN0Q2hhbmdlKCk6IE9ic2VydmFibGU8RGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10+IHtcbiAgICByZXR1cm4gdGhpcy5fY29sdW1uTGlzdENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGxpc3Qgb2YgY29sdW1ucy4gSSBuZWVkZWQgYW4gYXJyYXkgb2YgdG8gaXRlcmF0ZSBvbiBpbiB0aGUgUm93UmVuZGVyZXJcbiAgICogYnV0IHN1YnNjcmliaW5nIHRvIHRoZSBfY29sdW1uTGlzdENoYW5nZSBjaGFuZ2VzIGRpZCBub3Qgc2VlbSBsaWtlIHRoZSBjb3JyZWN0IHdheSB0byBnZXQgaXQuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29sdW1ucygpOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkxpc3Q7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjdXJyZW50IF9jb2x1bW5MaXN0OlxuICAgKiAtIGlmIGl0IGhhcyBhIERhdGFncmlkSGlkZWFibGVDb2x1bW4gYW5kIGlzIGhpZGRlbiB0aGVuIHNob3cgaXQuXG4gICAqIC0gaWYgaXQncyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIHdhcyBwcmV2aW91c2x5IHRoZSBsYXN0IGNvbHVtbiB2aXNpYmxlLCB0dXJuIHRoYXQgZmxhZyBvZmYuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgc2hvd0hpZGRlbkNvbHVtbnMoKSB7XG4gICAgdGhpcy5fY29sdW1uTGlzdC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5oaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgY29sdW1uLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbikge1xuICAgICAgICBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uczogRGF0YWdyaWRDb2x1bW5bXVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uJ3MgfHwgbnVsbCBiYXNlZCBjb2x1bW4gYXJyYXkgcGFzc2VkIGFzIHBhcmFtLlxuICAgKiBJcyBkZXBlbmRlbnQgb24gdGhlIG9yZGVyIGluIEBDb250ZW50Q2hpbGRyZW4gaW4gRGF0YWdyaWQuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29sdW1uTGlzdChjb2x1bW5zOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSkge1xuICAgIHRoaXMuX2NvbHVtbkxpc3QgPSBjb2x1bW5zOyAvLyBjbGVhciB0aGUgbGlzdFxuICAgIHRoaXMudXBkYXRlRm9yTGFzdFZpc2libGVDb2x1bW4oKTsgLy8gVXBkYXRlIG91ciB2aXNpYmlsaXR5IHN0YXRlIGZvciBVSVxuICAgIHRoaXMuX2NvbHVtbkxpc3RDaGFuZ2UubmV4dCh0aGlzLl9jb2x1bW5MaXN0KTsgLy8gQnJvYWRjYXN0IGl0XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2V0cyB0aGUgY3VycmVudCB2aXNpYmxlIGNvdW50IGZvciBhbGwgY29sdW1ucy5cbiAgICogV2hlbiBpdCBpcyBncmVhdGVyIHRoYW4gMSBpdCBtYXJrcyBldmVyeXRoaW5nIGFzIGZhbHNlIGZvciB0aGUgbGFzdFZpc2libGVDb2x1bW4uXG4gICAqIFdoZW4gdmlzaWJsZSBjb3VudCBpcyBub3QgPiAxIChpLmUpIDEuICwgaXQgZmluZHMgdGhlIG9ubHkgY29sdW1uIHRoYXQgaXMgbm90IGhpZGRlbiBhbmQgbWFya3MgaXQgYXMgdGhlXG4gICAqIGxhc3RWaXNpYmxlQ29sdW1uLlxuICAgKlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUZvckxhc3RWaXNpYmxlQ29sdW1uKCk6IHZvaWQge1xuICAgIC8vIFRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29sdW1uIHNob3dpbmcsIG1ha2Ugc3VyZSBub3RoaW5nIGlzIG1hcmtlZCBsYXN0VmlzaWJsZUNvbHVtblxuICAgIGlmICh0aGlzLmNhbkhpZGVOZXh0Q29sdW1uKSB7XG4gICAgICB0aGlzLl9jb2x1bW5MaXN0Lm1hcChjb2x1bW4gPT4ge1xuICAgICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbikge1xuICAgICAgICAgIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHZpc2libGVDb3VudCBpcyBkb3duIHRvIG9ubHkgb25lIGNvbHVtbiBzaG93aW5nLiBGaW5kIGl0IGFuZCBmbGFnIGl0IGFzIHRoZSBsYXN0VmlzaWJsZUNvbHVtblxuICAgICAgdGhpcy5fY29sdW1uTGlzdC5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbiAmJiAhY29sdW1uLmhpZGRlbikge1xuICAgICAgICAgIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm4gYSBIaWRlYWJsZUNvbHVtbiBpbiB0aGlzLl9jb2x1bW5MaXN0IGZvciB0aGUgZ2l2ZW4gaWQuXG4gICAqXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29sdW1uQnlJZChpZDogc3RyaW5nKTogdW5kZWZpbmVkIHwgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5MaXN0LmZpbmQoY29sdW1uID0+IGNvbHVtbiAmJiBjb2x1bW4uaWQgPT09IGlkKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVtYmVkZGVkVmlld1JlZiwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGctd3JhcHBlZC1jZWxsJyxcbiAgdGVtcGxhdGU6IGAgICAgICAgIFxuICAgICAgICA8bmctdGVtcGxhdGUgI2NlbGxQb3J0YWw+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgV3JhcHBlZENlbGwgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgQWZ0ZXJWaWV3SW5pdCB7XG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBWaWV3Q2hpbGQoJ2NlbGxQb3J0YWwnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8dm9pZD47XG4gIGNlbGxWaWV3OiBFbWJlZGRlZFZpZXdSZWY8dm9pZD47IC8vIHRoZSBjZWxscyBwcm9qZWN0ZWQgdmlld1xuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLmNlbGxWaWV3ID0gdGhpcy50ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcobnVsbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJTaWducG9zdCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvc2lnbnBvc3Qvc2lnbnBvc3QnO1xuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5cbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFdyYXBwZWRDZWxsIH0gZnJvbSAnLi93cmFwcGVkLWNlbGwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctY2VsbCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1jZWxsXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLXNpZ25wb3N0LXRyaWdnZXJdJzogJ3NpZ25wb3N0Lmxlbmd0aCA+IDAnLFxuICAgIHJvbGU6ICdncmlkY2VsbCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ2VsbCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLyoqKioqKioqKlxuICAgKiBAcHJvcGVydHkgc2lnbnBvc3RcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEBDb250ZW50Q2hpbGQgaXMgdXNlZCB0byBkZXRlY3QgdGhlIHByZXNlbmNlIG9mIGEgU2lnbnBvc3QgaW4gdGhlIHByb2plY3RlZCBjb250ZW50LlxuICAgKiBPbiB0aGUgaG9zdCwgd2Ugc2V0IHRoZSAuZGF0YWdyaWQtc2lnbnBvc3QtdHJpZ2dlciBjbGFzcyBvbiB0aGUgY2VsbCB3aGVuIHNpZ25wb3N0Lmxlbmd0aCBpcyBncmVhdGVyIHRoYW4gMC5cbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyU2lnbnBvc3QpIHNpZ25wb3N0OiBRdWVyeUxpc3Q8Q2xyU2lnbnBvc3Q+O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaWRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIGlkZW50aWZpZXIgZm9yIGFuIGluc3RhbmNlIG9mIHRoaXMgY2VsbCB0aGF0IG1hcHMgaXQgdG8gYSBzcGVjaWZpYyBjb2x1bW5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG5cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIHRoaXMubWFwSGlkZWFibGVDb2x1bW4odGhpcy5faWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoaWRkZW5TdGF0ZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwcml2YXRlIF9lbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge31cblxuICBwcml2YXRlIG1hcEhpZGVhYmxlQ29sdW1uKGNvbHVtbklkOiBzdHJpbmcpIHtcbiAgICBpZiAoIWNvbHVtbklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGlkZWFibGVDb2x1bW4gPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5CeUlkKHRoaXMuX2lkKTtcblxuICAgIHRoaXMuc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW4uaGlkZGVuKTtcbiAgICB0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uID0gaGlkZWFibGVDb2x1bW4uaGlkZGVuQ2hhbmdlU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW4uaGlkZGVuKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW5WYWx1ZTogYm9vbGVhbikge1xuICAgIGlmIChoaWRlYWJsZUNvbHVtblZhbHVlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtY2VsbC0taGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1jZWxsLS1oaWRkZW4nKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHdyYXBwZWRJbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy53cmFwcGVkSW5qZWN0b3IgPSBuZXcgSG9zdFdyYXBwZXIoV3JhcHBlZENlbGwsIHRoaXMudmNyKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBfdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5qZWN0b3IuZ2V0KFdyYXBwZWRDZWxsLCB0aGlzLnZjcikuY2VsbFZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGVudW0gRGF0YWdyaWREaXNwbGF5TW9kZSB7XG4gIERJU1BMQVksXG4gIENBTENVTEFURSxcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGVudW0gRGF0YWdyaWRSZW5kZXJTdGVwIHtcbiAgQUxJR05fQ09MVU1OUyxcbiAgQ0FMQ1VMQVRFX01PREVfT04sXG4gIENBTENVTEFURV9NT0RFX09GRixcbiAgQ0xFQVJfV0lEVEhTLCAvLyBOb3RlIHRoaXMgaXMgbGlzdGVuZWQgdG8gYnkgYm90aCBjZWxscyBhbmQgY29sdW1uc1xuICBDT01QVVRFX0NPTFVNTl9XSURUSFMsXG4gIERFVEVDVF9TVFJJQ1RfV0lEVEhTLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIge1xuICBwcm90ZWN0ZWQgX3JlbmRlclN0ZXA6IFN1YmplY3Q8RGF0YWdyaWRSZW5kZXJTdGVwPiA9IG5ldyBTdWJqZWN0PERhdGFncmlkUmVuZGVyU3RlcD4oKTtcbiAgcHVibGljIGdldCByZW5kZXJTdGVwKCk6IE9ic2VydmFibGU8RGF0YWdyaWRSZW5kZXJTdGVwPiB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0ZXAuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgZmlsdGVyUmVuZGVyU3RlcHMoc3RlcDogRGF0YWdyaWRSZW5kZXJTdGVwKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyU3RlcC5waXBlKGZpbHRlcih0ZXN0U3RlcCA9PiBzdGVwID09PSB0ZXN0U3RlcCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhbHJlYWR5U2l6ZWQgPSBmYWxzZTtcblxuICBwdWJsaWMgd2lkdGhzOiB7IHB4OiBudW1iZXI7IHN0cmljdDogYm9vbGVhbiB9W10gPSBbXTtcblxuICBwdWJsaWMgcmVzaXplKCkge1xuICAgIHRoaXMud2lkdGhzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5DQUxDVUxBVEVfTU9ERV9PTik7XG4gICAgaWYgKHRoaXMuYWxyZWFkeVNpemVkKSB7XG4gICAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkNMRUFSX1dJRFRIUyk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuREVURUNUX1NUUklDVF9XSURUSFMpO1xuICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuQ09NUFVURV9DT0xVTU5fV0lEVEhTKTtcbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkFMSUdOX0NPTFVNTlMpO1xuICAgIHRoaXMuYWxyZWFkeVNpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkNBTENVTEFURV9NT0RFX09GRik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZERpc3BsYXlNb2RlIH0gZnJvbSAnLi4vZW51bXMvZGlzcGxheS1tb2RlLmVudW0nO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4uL3JlbmRlci9yZW5kZXItb3JnYW5pemVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERpc3BsYXlNb2RlU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJvdGVjdGVkIF92aWV3OiBCZWhhdmlvclN1YmplY3Q8RGF0YWdyaWREaXNwbGF5TW9kZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGFncmlkRGlzcGxheU1vZGU+KFxuICAgIERhdGFncmlkRGlzcGxheU1vZGUuRElTUExBWVxuICApO1xuXG4gIGNvbnN0cnVjdG9yKHJlbmRlck9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHJlbmRlck9yZ2FuaXplclxuICAgICAgICAuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkNBTENVTEFURV9NT0RFX09OKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3ZpZXcubmV4dChEYXRhZ3JpZERpc3BsYXlNb2RlLkNBTENVTEFURSkpXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgcmVuZGVyT3JnYW5pemVyXG4gICAgICAgIC5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuQ0FMQ1VMQVRFX01PREVfT0ZGKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3ZpZXcubmV4dChEYXRhZ3JpZERpc3BsYXlNb2RlLkRJU1BMQVkpKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZpZXcoKTogT2JzZXJ2YWJsZTxEYXRhZ3JpZERpc3BsYXlNb2RlPiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IHsgSXRlbXMgfSBmcm9tICcuL2l0ZW1zJztcblxubGV0IG5iU2VsZWN0aW9uOiBudW1iZXIgPSAwO1xuXG5leHBvcnQgZW51bSBTZWxlY3Rpb25UeXBlIHtcbiAgTm9uZSxcbiAgU2luZ2xlLFxuICBNdWx0aSxcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbjxUID0gYW55PiB7XG4gIHB1YmxpYyBpZDogc3RyaW5nO1xuICBwcml2YXRlIHByZXZTZWxlY3Rpb25SZWZzOiBUW10gPSBbXTsgLy8gUmVmcyBvZiBzZWxlY3RlZCBpdGVtc1xuICBwcml2YXRlIHByZXZTaW5nbGVTZWxlY3Rpb25SZWY6IFQ7IC8vIFJlZiBvZiBzaW5nbGUgc2VsZWN0ZWQgaXRlbVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2l0ZW1zOiBJdGVtczxUPiwgcHJpdmF0ZSBfZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+KSB7XG4gICAgdGhpcy5pZCA9ICdjbHItZGctc2VsZWN0aW9uJyArIG5iU2VsZWN0aW9uKys7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX2ZpbHRlcnMuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX2l0ZW1zLmFsbENoYW5nZXMuc3Vic2NyaWJlKHVwZGF0ZWRJdGVtcyA9PiB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZWxlY3Rpb25UeXBlKSB7XG4gICAgICAgICAgY2FzZSBTZWxlY3Rpb25UeXBlLk5vbmU6IHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5TaW5nbGU6IHtcbiAgICAgICAgICAgIGxldCBuZXdTaW5nbGU6IGFueTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrQnk6IFRyYWNrQnlGdW5jdGlvbjxUPiA9IHRoaXMuX2l0ZW1zLnRyYWNrQnk7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uVXBkYXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudFNpbmdsZSBoYXMgYmVlbiBzZXQgYmVmb3JlIGRhdGEgd2FzIGxvYWRlZCwgd2UgbG9vayB1cCBhbmQgc2F2ZSB0aGUgcmVmIGZyb20gY3VycmVudCBkYXRhIHNldFxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNpbmdsZSAmJiAhdGhpcy5wcmV2U2luZ2xlU2VsZWN0aW9uUmVmKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtcy5hbGwgJiYgdGhpcy5faXRlbXMudHJhY2tCeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMuX2l0ZW1zLmFsbC5maW5kSW5kZXgobWF5YmUgPT4gbWF5YmUgPT09IHRoaXMuY3VycmVudFNpbmdsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2U2luZ2xlU2VsZWN0aW9uUmVmID0gdGhpcy5faXRlbXMudHJhY2tCeShsb29rdXAsIHRoaXMuY3VycmVudFNpbmdsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlZEl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRyYWNrQnkoaW5kZXgsIGl0ZW0pO1xuICAgICAgICAgICAgICAvLyBJZiBvbmUgb2YgdGhlIHVwZGF0ZWQgaXRlbXMgaXMgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWRTaW5nbGUsIHNldCBpdCBhcyB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2U2luZ2xlU2VsZWN0aW9uUmVmID09PSByZWYpIHtcbiAgICAgICAgICAgICAgICBuZXdTaW5nbGUgPSBpdGVtO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgc21hcnQgZGF0YWdyaWRzLCB3ZSBleHBlY3QgYWxsIGl0ZW1zIHRvIGJlIHByZXNlbnQgaW4gdGhlIHVwZGF0ZWRJdGVtcyBhcnJheS5cbiAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgd2Ugc2hvdWxkIGRlbGV0ZSB0aGUgY3VycmVudFNpbmdsZSBpZiBpdCB1c2VkIHRvIGJlIGRlZmluZWQgYnV0IGRvZXNuJ3QgZXhpc3QgYW55bW9yZS5cbiAgICAgICAgICAgIC8vIE5vIGV4cGxpY2l0IFwiZGVsZXRlXCIgaXMgcmVxdWlyZWQsIHNpbmNlIG5ld1NpbmdsZSB3b3VsZCBiZSB1bmRlZmluZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgIC8vIE1hcmtpbmcgaXQgYXMgc2VsZWN0aW9uVXBkYXRlZCBoZXJlIHdpbGwgc2V0IGN1cnJlbnRTaW5nbGUgdG8gdW5kZWZpbmVkIGJlbG93IGluIHRoZSBzZXRUaW1lb3V0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLnNtYXJ0ICYmICFuZXdTaW5nbGUpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IERpc2N1c3NlZCB0aGlzIHdpdGggRXVkZXMgYW5kIHRoaXMgaXMgZmluZSBmb3Igbm93LlxuICAgICAgICAgICAgLy8gQnV0IHdlIG5lZWQgdG8gZmlndXJlIG91dCBhIGRpZmZlcmVudCBwYXR0ZXJuIGZvciB0aGVcbiAgICAgICAgICAgIC8vIGNoaWxkIHRyaWdnZXJpbmcgdGhlIHBhcmVudCBjaGFuZ2UgZGV0ZWN0aW9uIHByb2JsZW0uXG4gICAgICAgICAgICAvLyBVc2luZyBzZXRUaW1lb3V0IGZvciBub3cgdG8gZml4IHRoaXMuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTaW5nbGUgPSBuZXdTaW5nbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTZWxlY3Rpb25UeXBlLk11bHRpOiB7XG4gICAgICAgICAgICBsZXQgbGVmdE92ZXI6IGFueVtdID0gdGhpcy5jdXJyZW50LnNsaWNlKCk7XG4gICAgICAgICAgICBjb25zdCB0cmFja0J5OiBUcmFja0J5RnVuY3Rpb248YW55PiA9IHRoaXMuX2l0ZW1zLnRyYWNrQnk7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uVXBkYXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBoYXMgYmVlbiBzZXQgYmVmb3JlIGRhdGEgd2FzIGxvYWRlZCwgd2UgbG9vayB1cCBhbmQgc2F2ZSB0aGUgcmVmIGZyb20gY3VycmVudCBkYXRhIHNldFxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5sZW5ndGggPiAwICYmIHRoaXMucHJldlNlbGVjdGlvblJlZnMubGVuZ3RoICE9PSB0aGlzLmN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtcy5hbGwgJiYgdGhpcy5faXRlbXMudHJhY2tCeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldlNlbGVjdGlvblJlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMuX2l0ZW1zLmFsbC5maW5kSW5kZXgobWF5YmUgPT4gbWF5YmUgPT09IGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5wdXNoKHRoaXMuX2l0ZW1zLnRyYWNrQnkobG9va3VwLCBpdGVtKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2Ugd29yayBvbiBodHRwczovL2dpdGh1Yi5jb20vdm13YXJlL2NsYXJpdHkvaXNzdWVzLzIzNDJcbiAgICAgICAgICAgIC8vIGN1cnJlbnRseSwgdGhlIHNlbGVjdGlvbiBpcyBjbGVhcmVkIHdoZW4gZmlsdGVyIGlzIGFwcGxpZWQsIHNvIHRoZSBsb2dpYyBpbnNpZGVcbiAgICAgICAgICAgIC8vIHRoZSBpZiBzdGF0ZW1lbnQgYmVsb3cgcmVzdWx0cyBpbiBicm9rZW4gYmVoYXZpb3IuXG4gICAgICAgICAgICBpZiAobGVmdE92ZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB1cGRhdGVkSXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSB0cmFja0J5KGluZGV4LCBpdGVtKTtcbiAgICAgICAgICAgICAgICAvLyBMb29rIGluIGN1cnJlbnQgc2VsZWN0ZWQgcmVmcyBhcnJheSBpZiBpdGVtIGlzIHNlbGVjdGVkLCBhbmQgdXBkYXRlIGFjdHVhbCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLmluZGV4T2YocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBsZWZ0T3ZlcltzZWxlY3RlZEluZGV4XSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb25VcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgYW55IHVubWF0Y2hlZCBpdGVtcyBpZiB3ZSdyZSB1c2luZyBzbWFydCBkYXRhZ3JpZHMgd2hlcmUgd2UgZXhwZWN0IGFsbCBpdGVtcyB0byBiZVxuICAgICAgICAgICAgICAvLyBwcmVzZW50XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtcy5zbWFydCkge1xuICAgICAgICAgICAgICAgIGxlZnRPdmVyID0gbGVmdE92ZXIuZmlsdGVyKHNlbGVjdGVkID0+IHVwZGF0ZWRJdGVtcy5pbmRleE9mKHNlbGVjdGVkKSA+IC0xKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lmxlbmd0aCAhPT0gbGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb25VcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBUT0RPOiBEaXNjdXNzZWQgdGhpcyB3aXRoIEV1ZGVzIGFuZCB0aGlzIGlzIGZpbmUgZm9yIG5vdy5cbiAgICAgICAgICAgICAgLy8gQnV0IHdlIG5lZWQgdG8gZmlndXJlIG91dCBhIGRpZmZlcmVudCBwYXR0ZXJuIGZvciB0aGVcbiAgICAgICAgICAgICAgLy8gY2hpbGQgdHJpZ2dlcmluZyB0aGUgcGFyZW50IGNoYW5nZSBkZXRlY3Rpb24gcHJvYmxlbS5cbiAgICAgICAgICAgICAgLy8gVXNpbmcgc2V0VGltZW91dCBmb3Igbm93IHRvIGZpeCB0aGlzLlxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbGVmdE92ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGNsZWFyU2VsZWN0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudC5sZW5ndGggPSAwO1xuICAgIHRoaXMucHJldlNlbGVjdGlvblJlZnMgPSBbXTtcbiAgICB0aGlzLl9jdXJyZW50U2luZ2xlID0gbnVsbDtcbiAgICB0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYgPSBudWxsO1xuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2VsZWN0aW9uVHlwZTogU2VsZWN0aW9uVHlwZSA9IFNlbGVjdGlvblR5cGUuTm9uZTtcbiAgcHVibGljIGdldCBzZWxlY3Rpb25UeXBlKCk6IFNlbGVjdGlvblR5cGUge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25UeXBlO1xuICB9XG4gIHB1YmxpYyBzZXQgc2VsZWN0aW9uVHlwZSh2YWx1ZTogU2VsZWN0aW9uVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5zZWxlY3Rpb25UeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3NlbGVjdGlvblR5cGUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IFNlbGVjdGlvblR5cGUuTm9uZSkge1xuICAgICAgZGVsZXRlIHRoaXMuY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVDdXJyZW50KFtdLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJvd1NlbGVjdGlvbk1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGdldCBfc2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5NdWx0aSB8fCB0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZTtcbiAgfVxuICAvKipcbiAgICogSWdub3JlIGl0ZW1zIGNoYW5nZXMgaW4gdGhlIHNhbWUgY2hhbmdlIGRldGVjdGlvbiBjeWNsZS5cbiAgICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICBwcml2YXRlIGRlYm91bmNlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gdGhlIG90aGVyIHByb3ZpZGVycyBjaGFuZ2VzLlxuICAgKi9cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgb3VyIHN1YnNjcmlwdGlvbnMgdG8gb3RoZXIgcHJvdmlkZXJzXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiBzaW5nbGUgc2VsZWN0aW9uIHR5cGVcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnRTaW5nbGU6IFQ7XG4gIHB1YmxpYyBnZXQgY3VycmVudFNpbmdsZSgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFNpbmdsZTtcbiAgfVxuICBwdWJsaWMgc2V0IGN1cnJlbnRTaW5nbGUodmFsdWU6IFQpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMuX2N1cnJlbnRTaW5nbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFNpbmdsZSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9pdGVtcy5hbGwgJiYgdGhpcy5faXRlbXMudHJhY2tCeSAmJiB2YWx1ZSkge1xuICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gdmFsdWUpO1xuICAgICAgdGhpcy5wcmV2U2luZ2xlU2VsZWN0aW9uUmVmID0gdGhpcy5faXRlbXMudHJhY2tCeShsb29rdXAsIHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgLy8gSWdub3JlIGl0ZW1zIGNoYW5nZXMgaW4gdGhlIHNhbWUgY2hhbmdlIGRldGVjdGlvbiBjeWNsZS5cbiAgICAvLyBAVE9ETyBUaGlzIGNhbiBsaWtlbHkgYmUgcmVtb3ZlZCFcbiAgICB0aGlzLmRlYm91bmNlID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+ICh0aGlzLmRlYm91bmNlID0gZmFsc2UpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnQ6IFRbXTtcbiAgcHVibGljIGdldCBjdXJyZW50KCk6IFRbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gIH1cbiAgcHVibGljIHNldCBjdXJyZW50KHZhbHVlOiBUW10pIHtcbiAgICB0aGlzLnVwZGF0ZUN1cnJlbnQodmFsdWUsIHRydWUpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUN1cnJlbnQodmFsdWU6IFRbXSwgZW1pdDogYm9vbGVhbikge1xuICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcbiAgICBpZiAoZW1pdCkge1xuICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgICAvLyBJZ25vcmUgaXRlbXMgY2hhbmdlcyBpbiB0aGUgc2FtZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgICAgLy8gQFRPRE8gVGhpcyBjYW4gbGlrZWx5IGJlIHJlbW92ZWQhXG4gICAgICB0aGlzLmRlYm91bmNlID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gKHRoaXMuZGVib3VuY2UgPSBmYWxzZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gc2VsZWN0aW9uIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PFRbXSB8IFQ+KCk7XG4gIHByaXZhdGUgZW1pdENoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5TaW5nbGUpIHtcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuY3VycmVudFNpbmdsZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk11bHRpKSB7XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgfVxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8VFtdIHwgVD4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqL1xuICBwdWJsaWMgaXNTZWxlY3RlZChpdGVtOiBUKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuU2luZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2luZ2xlID09PSBpdGVtO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5NdWx0aSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudC5pbmRleE9mKGl0ZW0pID49IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGFuIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgc2VsZWN0SXRlbShpdGVtOiBUKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50LnB1c2goaXRlbSk7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLnRyYWNrQnkpIHtcbiAgICAgIC8vIFB1c2ggc2VsZWN0ZWQgcmVmIG9udG8gYXJyYXlcbiAgICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMuX2l0ZW1zLmFsbC5maW5kSW5kZXgobWF5YmUgPT4gbWF5YmUgPT09IGl0ZW0pO1xuICAgICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5wdXNoKHRoaXMuX2l0ZW1zLnRyYWNrQnkobG9va3VwLCBpdGVtKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0cyBhbiBpdGVtXG4gICAqL1xuICBwcml2YXRlIGRlc2VsZWN0SXRlbShpbmRleE9mSXRlbTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50LnNwbGljZShpbmRleE9mSXRlbSwgMSk7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLnRyYWNrQnkgJiYgaW5kZXhPZkl0ZW0gPCB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLmxlbmd0aCkge1xuICAgICAgLy8gS2VlcCBzZWxlY3RlZCByZWZzIGFycmF5IGluIHN5bmNcbiAgICAgIHRoaXMucHJldlNlbGVjdGlvblJlZnMuc3BsaWNlKGluZGV4T2ZJdGVtLCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyBvciBkZXNlbGVjdHMgYW4gaXRlbVxuICAgKi9cbiAgcHVibGljIHNldFNlbGVjdGVkKGl0ZW06IFQsIHNlbGVjdGVkOiBib29sZWFuKSB7XG4gICAgc3dpdGNoICh0aGlzLl9zZWxlY3Rpb25UeXBlKSB7XG4gICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTm9uZTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNlbGVjdGlvblR5cGUuU2luZ2xlOlxuICAgICAgICAvLyBpbiBzaW5nbGUgc2VsZWN0aW9uLCBzZXQgY3VycmVudFNpbmdsZSBtZXRob2Qgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTXVsdGk6XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmICFzZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuZGVzZWxlY3RJdGVtKGluZGV4KTtcbiAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IDAgJiYgc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFsbCBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW1zIGFyZSBzZWxlY3RlZFxuICAgKi9cbiAgcHVibGljIGlzQWxsU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgIT09IFNlbGVjdGlvblR5cGUuTXVsdGkgfHwgIXRoaXMuX2l0ZW1zLmRpc3BsYXllZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGF5ZWRJdGVtczogVFtdID0gdGhpcy5faXRlbXMuZGlzcGxheWVkO1xuICAgIGNvbnN0IG5iRGlzcGxheWVkID0gdGhpcy5faXRlbXMuZGlzcGxheWVkLmxlbmd0aDtcbiAgICBpZiAobmJEaXNwbGF5ZWQgPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRlbXA6IFRbXSA9IGRpc3BsYXllZEl0ZW1zLmZpbHRlcihpdGVtID0+IHRoaXMuY3VycmVudC5pbmRleE9mKGl0ZW0pID4gLTEpO1xuICAgIHJldHVybiB0ZW1wLmxlbmd0aCA9PT0gZGlzcGxheWVkSXRlbXMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgb3IgZGVzZWxlY3RzIGFsbCBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlQWxsKCkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk5vbmUgfHwgdGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5TaW5nbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLypcbiAgICAgICAgICogSWYgZXZlcnkgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtIGlzIGFscmVhZHkgc2VsZWN0ZWQsIHdlIGNsZWFyIHRoZW0uXG4gICAgICAgICAqIElmIGF0IGxlYXN0IG9uZSBpdGVtIGlzbid0IHNlbGVjdGVkLCB3ZSBzZWxlY3QgZXZlcnkgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtLlxuICAgICAgICAgKi9cbiAgICBpZiAodGhpcy5pc0FsbFNlbGVjdGVkKCkpIHtcbiAgICAgIHRoaXMuX2l0ZW1zLmRpc3BsYXllZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmN1cnJlbnQuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5kZXNlbGVjdEl0ZW0oY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2l0ZW1zLmRpc3BsYXllZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSkgPCAwKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRW1iZWRkZWRWaWV3UmVmLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkZy13cmFwcGVkLXJvdycsXG4gIHRlbXBsYXRlOiBgICAgICAgICBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNyb3dQb3J0YWw+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgV3JhcHBlZFJvdyBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBBZnRlclZpZXdJbml0IHtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcblxuICBAVmlld0NoaWxkKCdyb3dQb3J0YWwnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8dm9pZD47XG4gIHJvd1ZpZXc6IEVtYmVkZGVkVmlld1JlZjx2b2lkPjsgLy8gdGhlIHJvd3MgcHJvamVjdGVkIHZpZXcgKGluIG1lbW9yeSlcblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBjZWxscyB2aWV3IGluIG1lbW9yeSwgbm90IHRoZSBET00uXG4gICAgdGhpcy5yb3dWaWV3ID0gdGhpcy50ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcobnVsbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kJztcbmltcG9ydCB7IEhvc3RXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwZXInO1xuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDZWxsIH0gZnJvbSAnLi9kYXRhZ3JpZC1jZWxsJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcbmltcG9ydCB7IERhdGFncmlkRGlzcGxheU1vZGUgfSBmcm9tICcuL2VudW1zL2Rpc3BsYXktbW9kZS5lbnVtJztcbmltcG9ydCB7IERpc3BsYXlNb2RlU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2Rpc3BsYXktbW9kZS5zZXJ2aWNlJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJvd0FjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi9wcm92aWRlcnMvc2VsZWN0aW9uJztcbmltcG9ydCB7IFdyYXBwZWRSb3cgfSBmcm9tICcuL3dyYXBwZWQtcm93JztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcblxubGV0IG5iUm93OiBudW1iZXIgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcm93JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGFncmlkLXJvdy5odG1sJyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0YWdyaWQtcm93XSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgJ1thdHRyLmFyaWEtb3duc10nOiAnaWQnLFxuICAgIHJvbGU6ICdyb3dncm91cCcsXG4gIH0sXG4gIHByb3ZpZGVyczogW0V4cGFuZCwgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBFeHBhbmQgfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkUm93PFQgPSBhbnk+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG4gIHB1YmxpYyBpZDogc3RyaW5nO1xuICBwdWJsaWMgcmFkaW9JZDogc3RyaW5nO1xuICBwdWJsaWMgY2hlY2tib3hJZDogc3RyaW5nO1xuXG4gIC8qIHJlZmVyZW5jZSB0byB0aGUgZW51bSBzbyB0aGF0IHRlbXBsYXRlIGNhbiBhY2Nlc3MgKi9cbiAgcHVibGljIFNFTEVDVElPTl9UWVBFID0gU2VsZWN0aW9uVHlwZTtcblxuICAvKipcbiAgICogTW9kZWwgb2YgdGhlIHJvdywgdG8gdXNlIGZvciBzZWxlY3Rpb25cbiAgICovXG4gIEBJbnB1dCgnY2xyRGdJdGVtJykgaXRlbTogVDtcblxuICBwdWJsaWMgcmVwbGFjZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uPFQ+LFxuICAgIHB1YmxpYyByb3dBY3Rpb25TZXJ2aWNlOiBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBnbG9iYWxFeHBhbmRhYmxlOiBFeHBhbmRhYmxlUm93c0NvdW50LFxuICAgIHB1YmxpYyBleHBhbmQ6IEV4cGFuZCxcbiAgICBwdWJsaWMgaGlkZWFibGVDb2x1bW5TZXJ2aWNlOiBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBkaXNwbGF5TW9kZTogRGlzcGxheU1vZGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzU2VydmljZVxuICApIHtcbiAgICBuYlJvdysrO1xuICAgIHRoaXMuaWQgPSAnY2xyLWRnLXJvdycgKyBuYlJvdztcbiAgICB0aGlzLnJhZGlvSWQgPSAnY2xyLWRnLXJvdy1yZCcgKyBuYlJvdztcbiAgICB0aGlzLmNoZWNrYm94SWQgPSAnY2xyLWRnLXJvdy1jYicgKyBuYlJvdztcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgY29tYmluZUxhdGVzdCh0aGlzLmV4cGFuZC5yZXBsYWNlLCB0aGlzLmV4cGFuZC5leHBhbmRDaGFuZ2UpLnN1YnNjcmliZShcbiAgICAgICAgKFtleHBhbmRSZXBsYWNlVmFsdWUsIGV4cGFuZENoYW5nZVZhbHVlXSkgPT4ge1xuICAgICAgICAgIGlmIChleHBhbmRSZXBsYWNlVmFsdWUgJiYgZXhwYW5kQ2hhbmdlVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2VkIGFuZCBleHBhbmRpbmdcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1yb3ctcmVwbGFjZWQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gSGFuZGxlcyB0aGVzZSBjYXNlczogbm90IHJlcGxhY2VkIGFuZCBjb2xsYXBzaW5nICYgcmVwbGFjZWQgYW5kXG4gICAgICAgICAgICAvLyBjb2xsYXBzaW5nIGFuZCBub3QgcmVwbGFjZWQgYW5kIGV4cGFuZGluZy5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtcm93LXJlcGxhY2VkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NlbGVjdGVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHJvdyBpcyBzZWxlY3RlZFxuICAgKi9cbiAgcHVibGljIGdldCBzZWxlY3RlZCgpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5Ob25lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5pc1NlbGVjdGVkKHRoaXMuaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NlbGVjdGVkJylcbiAgcHVibGljIHNldCBzZWxlY3RlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk5vbmUpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGVkKHRoaXMuaXRlbSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnU2VsZWN0ZWRDaGFuZ2UnKSBzZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBwdWJsaWMgdG9nZ2xlKHNlbGVjdGVkID0gIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICBpZiAoc2VsZWN0ZWQgIT09IHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2VkLmVtaXQoc2VsZWN0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgZXhwYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kLmV4cGFuZGVkO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0V4cGFuZGVkJylcbiAgcHVibGljIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZXhwYW5kLmV4cGFuZGVkID0gdmFsdWU7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ0V4cGFuZGVkQ2hhbmdlJykgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBwdWJsaWMgdG9nZ2xlRXhwYW5kKCkge1xuICAgIGlmICh0aGlzLmV4cGFuZC5leHBhbmRhYmxlKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqKioqXG4gICAqIHByb3BlcnR5IGRnQ2VsbHNcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgUXVlcnkgTGlzdCBvZiB0aGUgQ2xyRGF0YWdyaWQgY2VsbHMgaW4gdGhpcyByb3cuXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkQ2VsbCkgZGdDZWxsczogUXVlcnlMaXN0PENsckRhdGFncmlkQ2VsbD47XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGluZ3MgZ2V0IHN0YXJ0ZWRcbiAgICBjb25zdCBjb2x1bW5zTGlzdCA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbnMoKTtcbiAgICB0aGlzLnVwZGF0ZUNlbGxzRm9yQ29sdW1ucyhjb2x1bW5zTGlzdCk7XG5cbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgQ2VsbHMgbGlzdCBjaGFuZ2VzIHBlciByb3ctcmVuZGVyZXJcbiAgICB0aGlzLmRnQ2VsbHMuY2hhbmdlcy5zdWJzY3JpYmUoY2VsbExpc3QgPT4ge1xuICAgICAgY29uc3QgY29sdW1uTGlzdCA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbnMoKTtcbiAgICAgIGlmIChjZWxsTGlzdC5sZW5ndGggPT09IGNvbHVtbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXNlZCB0byBzZXQgdGhpbmdzIHVwIHRoZSBmaXJzdCB0aW1lIGJ1dCBvbmx5IGFmdGVyIGFsbCB0aGUgY29sdW1ucyBhcmUgcmVhZHkuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jb2x1bW5MaXN0Q2hhbmdlLnN1YnNjcmliZShjb2x1bW5MaXN0ID0+IHtcbiAgICAgICAgLy8gUHJldmVudHMgY2VsbCB1cGRhdGVzIHdoZW4gY29scyBhbmQgY2VsbHMgYXJyYXkgYXJlIG5vdCBhbGlnbmVkIC0gb25seSBzZWVtcyB0byBydW4gb24gaW5pdCAvIGZpcnN0IHRpbWUuXG4gICAgICAgIGlmIChjb2x1bW5MaXN0Lmxlbmd0aCA9PT0gdGhpcy5kZ0NlbGxzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRpc3BsYXlNb2RlLnZpZXcuc3Vic2NyaWJlKHZpZXdDaGFuZ2UgPT4ge1xuICAgICAgICAvLyBMaXN0ZW4gZm9yIHZpZXcgY2hhbmdlcyBhbmQgbW92ZSBjZWxscyBhcm91bmQgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGRpc3BsYXlUeXBlXG4gICAgICAgIC8vIHJlbW92ZSBjZWxsIHZpZXdzIGZyb20gZGlzcGxheSB2aWV3XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9zY3JvbGxhYmxlQ2VsbHMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZUNlbGxzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBjZWxsIHZpZXdzIGZyb20gY2FsY3VsYXRlZCB2aWV3XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9jYWxjdWxhdGVkQ2VsbHMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlZENlbGxzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3Q2hhbmdlID09PSBEYXRhZ3JpZERpc3BsYXlNb2RlLkNBTENVTEFURSkge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUNlbGxzID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5kZ0NlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVkQ2VsbHMuaW5zZXJ0KGNlbGwuX3ZpZXcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUNlbGxzID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRnQ2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGVDZWxscy5pbnNlcnQoY2VsbC5fdmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAxLiBNYXBzIHRoZSBuZXcgY29sdW1uTGlzdENoYW5nZSB0byB0aGUgZGdDZWxscyBsaXN0IGJ5IGluZGV4XG4gICAqIDIuIFNldHMgdGhlIGhpZGRlbiBzdGF0ZSBvbiB0aGUgY2VsbFxuICAgKiBUYWtlIGEgQ29sdW1uIGxpc3QgYW5kIHVzZSBpbmRleCB0byBhY2Nlc3MgdGhlIGNvbHVtbnMgZm9yIGhpZGVhYmxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3Q6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdKSB7XG4gICAgLy8gTWFwIGNlbGxzIHRvIGNvbHVtbnMgd2l0aCBBcnJheS5pbmRleFxuICAgIHRoaXMuZGdDZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudENvbHVtbiA9IGNvbHVtbkxpc3RbaW5kZXhdOyAvLyBBY2NvdW50cyBmb3IgbnVsbCBzcGFjZS5cbiAgICAgIGlmIChjdXJyZW50Q29sdW1uKSB7XG4gICAgICAgIGNlbGwuaWQgPSBjdXJyZW50Q29sdW1uLmlkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHVibGljIGRpc3BsYXlDZWxscyA9IGZhbHNlO1xuXG4gIEBWaWV3Q2hpbGQoJ3N0aWNreUNlbGxzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9zdGlja3lDZWxsczogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgnc2Nyb2xsYWJsZUNlbGxzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9zY3JvbGxhYmxlQ2VsbHM6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ2NhbGN1bGF0ZWRDZWxscycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfY2FsY3VsYXRlZENlbGxzOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIHByaXZhdGUgd3JhcHBlZEluamVjdG9yOiBJbmplY3RvcjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLndyYXBwZWRJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcihXcmFwcGVkUm93LCB0aGlzLnZjcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0IF92aWV3KCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZWRJbmplY3Rvci5nZXQoV3JhcHBlZFJvdywgdGhpcy52Y3IpLnJvd1ZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSB7XG4gIGJ1dHRvbnM6IFRlbXBsYXRlUmVmPGFueT4gPSBudWxsO1xuICBzZWxlY3RBbGxEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3NlbGVjdEFsbEJ1dHRvbkNsaWNrZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwdWJsaWMgZ2V0IHNlbGVjdEFsbEJ1dHRvbkNsaWNrZWQoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdEFsbEJ1dHRvbkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgYnV0dG9uQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxCdXR0b25DbGlja2VkLm5leHQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvciB9IGZyb20gJy4uL2J1aWx0LWluL2NvbXBhcmF0b3JzL2RhdGFncmlkLXByb3BlcnR5LWNvbXBhcmF0b3InO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvc3RhdGUuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyIH0gZnJvbSAnLi9maWx0ZXJzJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuL3BhZ2UnO1xuaW1wb3J0IHsgU29ydCB9IGZyb20gJy4vc29ydCc7XG5pbXBvcnQgeyBTdGF0ZURlYm91bmNlciB9IGZyb20gJy4vc3RhdGUtZGVib3VuY2VyLnByb3ZpZGVyJztcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVyIGFnZ3JlZ2F0ZXMgc3RhdGUgY2hhbmdlcyBmcm9tIHRoZSB2YXJpb3VzIHByb3ZpZGVycyBvZiB0aGUgRGF0YWdyaWRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0YXRlUHJvdmlkZXI8VD4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPixcbiAgICBwcml2YXRlIHNvcnQ6IFNvcnQ8VD4sXG4gICAgcHJpdmF0ZSBwYWdlOiBQYWdlLFxuICAgIHByaXZhdGUgZGVib3VuY2VyOiBTdGF0ZURlYm91bmNlclxuICApIHt9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBnbG9iYWwgc3RhdGUgY2hhbmdlc1xuICAgKi9cbiAgY2hhbmdlOiBPYnNlcnZhYmxlPENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2U8VD4+ID0gdGhpcy5kZWJvdW5jZXIuY2hhbmdlLnBpcGUobWFwKCgpID0+IHRoaXMuc3RhdGUpKTtcblxuICAvKlxuICAgICAqIEJ5IG1ha2luZyB0aGlzIGEgZ2V0dGVyLCB3ZSBvcGVuIHRoZSBwb3NzaWJpbGl0eSBmb3IgYSBzZXR0ZXIgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBJdCdzIGJlZW4gcmVxdWVzdGVkIGEgY291cGxlIHRpbWVzLlxuICAgICAqL1xuICBnZXQgc3RhdGUoKTogQ2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZTxUPiB7XG4gICAgY29uc3Qgc3RhdGU6IENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2U8VD4gPSB7fTtcbiAgICBpZiAodGhpcy5wYWdlLnNpemUgPiAwKSB7XG4gICAgICBzdGF0ZS5wYWdlID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnBhZ2UuZmlyc3RJdGVtLFxuICAgICAgICB0bzogdGhpcy5wYWdlLmxhc3RJdGVtLFxuICAgICAgICBzaXplOiB0aGlzLnBhZ2Uuc2l6ZSxcbiAgICAgICAgY3VycmVudDogdGhpcy5wYWdlLmN1cnJlbnQsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5zb3J0LmNvbXBhcmF0b3IpIHtcbiAgICAgIGlmICh0aGlzLnNvcnQuY29tcGFyYXRvciBpbnN0YW5jZW9mIERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlIGZvciB0aGUgZGVmYXVsdCBvYmplY3QgcHJvcGVydHkgY29tcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgKiB3ZSBnaXZlIHRoZSBwcm9wZXJ0eSBuYW1lIGluc3RlYWQgb2YgdGhlIGFjdHVhbCBjb21wYXJhdG9yLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICBzdGF0ZS5zb3J0ID0geyBieTogKDxEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcjxUPj50aGlzLnNvcnQuY29tcGFyYXRvcikucHJvcCwgcmV2ZXJzZTogdGhpcy5zb3J0LnJldmVyc2UgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnNvcnQgPSB7IGJ5OiB0aGlzLnNvcnQuY29tcGFyYXRvciwgcmV2ZXJzZTogdGhpcy5zb3J0LnJldmVyc2UgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLmdldEFjdGl2ZUZpbHRlcnMoKTtcbiAgICBpZiAoYWN0aXZlRmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS5maWx0ZXJzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBhY3RpdmVGaWx0ZXJzKSB7XG4gICAgICAgIGlmIChmaWx0ZXIuc3RhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5maWx0ZXJzLnB1c2goZmlsdGVyLnN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEludGVybmFsIGRhdGFncmlkIHNlcnZpY2UgdGhhdCBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgY2xyLWRnLXRhYmxlIGVsZW1lbnQgYW5kIGV4cG9zZXMgYSBtZXRob2QgdG8gZ2V0IGhlaWdodC5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRhYmxlU2l6ZVNlcnZpY2Uge1xuICBwcml2YXRlIF90YWJsZVJlZjogSFRNTEVsZW1lbnQ7XG5cbiAgcHVibGljIGdldCB0YWJsZVJlZigpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX3RhYmxlUmVmO1xuICB9XG5cbiAgcHVibGljIHNldCB0YWJsZVJlZihlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuX3RhYmxlUmVmID0gZWxlbWVudDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0KSB7fVxuICBwdWJsaWMgc2V0IHRhYmxlKHRhYmxlOiBFbGVtZW50UmVmKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgdGFibGUubmF0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy50YWJsZVJlZiA9IHRhYmxlLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRhdGFncmlkLXRhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB3aGVuIHJlc2l6aW5nIGNvbHVtbnMgdG8gc2hvdyB0aGUgY29sdW1uIGJvcmRlciBiZWluZyBkcmFnZ2VkLlxuICBnZXRDb2x1bW5EcmFnSGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLnRhYmxlUmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLnRhYmxlUmVmLmNsaWVudEhlaWdodH1weGA7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVmlld0NoaWxkLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtbiB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uJztcbmltcG9ydCB7IENsckRhdGFncmlkSXRlbXMgfSBmcm9tICcuL2RhdGFncmlkLWl0ZW1zJztcbmltcG9ydCB7IENsckRhdGFncmlkUGxhY2Vob2xkZXIgfSBmcm9tICcuL2RhdGFncmlkLXBsYWNlaG9sZGVyJztcbmltcG9ydCB7IENsckRhdGFncmlkUm93IH0gZnJvbSAnLi9kYXRhZ3JpZC1yb3cnO1xuaW1wb3J0IHsgRGF0YWdyaWREaXNwbGF5TW9kZSB9IGZyb20gJy4vZW51bXMvZGlzcGxheS1tb2RlLmVudW0nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBEaXNwbGF5TW9kZVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kaXNwbGF5LW1vZGUuc2VydmljZSc7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9maWx0ZXJzJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IEl0ZW1zIH0gZnJvbSAnLi9wcm92aWRlcnMvaXRlbXMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UnO1xuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIFNlbGVjdGlvblR5cGUgfSBmcm9tICcuL3Byb3ZpZGVycy9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgU29ydCB9IGZyb20gJy4vcHJvdmlkZXJzL3NvcnQnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuaW1wb3J0IHsgU3RhdGVQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXJzL3N0YXRlLnByb3ZpZGVyJztcbmltcG9ydCB7IFRhYmxlU2l6ZVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJsZS1zaXplLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuL3JlbmRlci9yZW5kZXItb3JnYW5pemVyJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRhdGFncmlkJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGFncmlkLmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICBTZWxlY3Rpb24sXG4gICAgU29ydCxcbiAgICBGaWx0ZXJzUHJvdmlkZXIsXG4gICAgUGFnZSxcbiAgICBJdGVtcyxcbiAgICBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIEV4cGFuZGFibGVSb3dzQ291bnQsXG4gICAgSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIFN0YXRlRGVib3VuY2VyLFxuICAgIFN0YXRlUHJvdmlkZXIsXG4gICAgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UsXG4gICAgVGFibGVTaXplU2VydmljZSxcbiAgICBEaXNwbGF5TW9kZVNlcnZpY2UsXG4gIF0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kYXRhZ3JpZC1ob3N0XSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZDxUID0gYW55PiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY29sdW1uU2VydmljZTogSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBwdWJsaWMgaXRlbXM6IEl0ZW1zPFQ+LFxuICAgIHB1YmxpYyBleHBhbmRhYmxlUm93czogRXhwYW5kYWJsZVJvd3NDb3VudCxcbiAgICBwdWJsaWMgc2VsZWN0aW9uOiBTZWxlY3Rpb248VD4sXG4gICAgcHVibGljIHJvd0FjdGlvblNlcnZpY2U6IFJvd0FjdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBzdGF0ZVByb3ZpZGVyOiBTdGF0ZVByb3ZpZGVyPFQ+LFxuICAgIHByaXZhdGUgZGlzcGxheU1vZGU6IERpc3BsYXlNb2RlU2VydmljZSxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHBhZ2U6IFBhZ2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlXG4gICkge31cblxuICAvKiByZWZlcmVuY2UgdG8gdGhlIGVudW0gc28gdGhhdCB0ZW1wbGF0ZSBjYW4gYWNjZXNzICovXG4gIHB1YmxpYyBTRUxFQ1RJT05fVFlQRSA9IFNlbGVjdGlvblR5cGU7XG5cbiAgLyoqXG4gICAqIEZyZWV6ZXMgdGhlIGRhdGFncmlkIHdoaWxlIGRhdGEgaXMgbG9hZGluZ1xuICAgKi9cbiAgcHVibGljIGdldCBsb2FkaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmxvYWRpbmc7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnTG9hZGluZycpXG4gIHB1YmxpYyBzZXQgbG9hZGluZyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuaXRlbXMubG9hZGluZyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE91dHB1dCBlbWl0dGVkIHdoZW5ldmVyIHRoZSBkYXRhIG5lZWRzIHRvIGJlIHJlZnJlc2hlZCwgYmFzZWQgb24gdXNlciBhY3Rpb24gb3IgZXh0ZXJuYWwgb25lc1xuICAgKi9cbiAgQE91dHB1dCgnY2xyRGdSZWZyZXNoJykgcHVibGljIHJlZnJlc2ggPSBuZXcgRXZlbnRFbWl0dGVyPENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2U8VD4+KGZhbHNlKTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byByZS10cmlnZ2VyIHRoZSBjb21wdXRhdGlvbiBvZiBkaXNwbGF5ZWQgaXRlbXMgbWFudWFsbHlcbiAgICovXG4gIHB1YmxpYyBkYXRhQ2hhbmdlZCgpIHtcbiAgICB0aGlzLml0ZW1zLnJlZnJlc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBncmFiIHRoZSBzbWFydCBpdGVyYXRvciBmcm9tIHByb2plY3RlZCBjb250ZW50XG4gICAqL1xuICBAQ29udGVudENoaWxkKENsckRhdGFncmlkSXRlbXMpIHB1YmxpYyBpdGVyYXRvcjogQ2xyRGF0YWdyaWRJdGVtczxUPjtcblxuICAvKipcbiAgICogQXJyYXkgb2YgYWxsIHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBASW5wdXQoJ2NsckRnU2VsZWN0ZWQnKVxuICBzZXQgc2VsZWN0ZWQodmFsdWU6IFRbXSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9IFNlbGVjdGlvblR5cGUuTXVsdGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPSBTZWxlY3Rpb25UeXBlLk5vbmU7XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uLnVwZGF0ZUN1cnJlbnQodmFsdWUsIGZhbHNlKTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnU2VsZWN0ZWRDaGFuZ2UnKSBzZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRbXT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBTZWxlY3RlZCBpdGVtIGluIHNpbmdsZS1zZWxlY3QgbW9kZVxuICAgKi9cbiAgQElucHV0KCdjbHJEZ1NpbmdsZVNlbGVjdGVkJylcbiAgc2V0IHNpbmdsZVNlbGVjdGVkKHZhbHVlOiBUKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9IFNlbGVjdGlvblR5cGUuU2luZ2xlO1xuICAgIC8vIHRoZSBjbHJEZ1NpbmdsZVNlbGVjdGVkIGlzIHVwZGF0ZWQgaW4gb25lIG9mIHR3byBjYXNlczpcbiAgICAvLyAxLiBhbiBleHBsaWNpdCB2YWx1ZSBpcyBwYXNzZWRcbiAgICAvLyAyLiBpcyBiZWluZyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdoZXJlIHByZXZpb3VzbHkgaXQgaGFkIGEgdmFsdWVcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmN1cnJlbnRTaW5nbGUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLmN1cnJlbnRTaW5nbGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmN1cnJlbnRTaW5nbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnU2luZ2xlU2VsZWN0ZWRDaGFuZ2UnKSBzaW5nbGVTZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFQ+KGZhbHNlKTtcblxuICBASW5wdXQoKSBjbHJEZ1NpbmdsZVNlbGVjdGlvbkFyaWFMYWJlbDogc3RyaW5nID0gdGhpcy5jb21tb25TdHJpbmdzLmtleXMuc2luZ2xlU2VsZWN0aW9uQXJpYUxhYmVsO1xuICBASW5wdXQoKSBjbHJEZ1NpbmdsZUFjdGlvbmFibGVBcmlhTGFiZWw6IHN0cmluZyA9IHRoaXMuY29tbW9uU3RyaW5ncy5rZXlzLnNpbmdsZUFjdGlvbmFibGVBcmlhTGFiZWw7XG4gIEBJbnB1dCgpIGNsckRldGFpbEV4cGFuZGFibGVBcmlhTGFiZWw6IHN0cmluZyA9IHRoaXMuY29tbW9uU3RyaW5ncy5rZXlzLmRldGFpbEV4cGFuZGFibGVBcmlhTGFiZWw7XG5cbiAgLyoqXG4gICAqIFNlbGVjdGlvbi9EZXNlbGVjdGlvbiBvbiByb3cgY2xpY2sgbW9kZVxuICAgKi9cbiAgQElucHV0KCdjbHJEZ1Jvd1NlbGVjdGlvbicpXG4gIHNldCByb3dTZWxlY3Rpb25Nb2RlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ucm93U2VsZWN0aW9uTW9kZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiBhbGwgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtcyBhcmUgc2VsZWN0ZWRcbiAgICovXG4gIHB1YmxpYyBnZXQgYWxsU2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmlzQWxsU2VsZWN0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzL2Rlc2VsZWN0cyBhbGwgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtc1xuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgYWxsU2VsZWN0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAvKlxuICAgICAgICAgKiBUaGlzIGlzIGEgc2V0dGVyIGJ1dCB3ZSBpZ25vcmUgdGhlIHZhbHVlLlxuICAgICAgICAgKiBJdCdzIHN0cmFuZ2UsIGJ1dCBpdCBsZXRzIHVzIGhhdmUgYW4gaW5kZXRlcm1pbmF0ZSBzdGF0ZSB3aGVyZSBvbmx5XG4gICAgICAgICAqIHNvbWUgb2YgdGhlIGl0ZW1zIGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgdGhpcy5zZWxlY3Rpb24udG9nZ2xlQWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9tIHBsYWNlaG9sZGVyIGRldGVjdGlvblxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyKSBwdWJsaWMgcGxhY2Vob2xkZXI6IENsckRhdGFncmlkUGxhY2Vob2xkZXI8VD47XG5cbiAgLyoqXG4gICAqIEhpZGVhYmxlIENvbHVtbiBkYXRhIHNvdXJjZSAvIGRldGVjdGlvbi5cbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRDb2x1bW4pIHB1YmxpYyBjb2x1bW5zOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRDb2x1bW48VD4+O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBkYXRhZ3JpZCBpcyB1c2VyLW1hbmFnZWQgd2l0aG91dCB0aGUgc21hcnQgaXRlcmF0b3IsIHdlIGdldCB0aGUgaXRlbXMgZGlzcGxheWVkXG4gICAqIGJ5IHF1ZXJ5aW5nIHRoZSBwcm9qZWN0ZWQgY29udGVudC4gVGhpcyBpcyBuZWVkZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgbW9kZWxzIGN1cnJlbnRseVxuICAgKiBkaXNwbGF5ZWQsIHR5cGljYWxseSBmb3Igc2VsZWN0aW9uLlxuICAgKi9cblxuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkUm93KSByb3dzOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRSb3c8VD4+O1xuICBAVmlld0NoaWxkKCdzY3JvbGxhYmxlQ29sdW1ucycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBzY3JvbGxhYmxlQ29sdW1uczogVmlld0NvbnRhaW5lclJlZjtcblxuICBAVmlld0NoaWxkKCdkYXRhZ3JpZFRhYmxlJywgeyByZWFkOiBFbGVtZW50UmVmIH0pXG4gIGRhdGFncmlkVGFibGU6IEVsZW1lbnRSZWY7XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmICghdGhpcy5pdGVtcy5zbWFydCkge1xuICAgICAgdGhpcy5pdGVtcy5hbGwgPSB0aGlzLnJvd3MubWFwKChyb3c6IENsckRhdGFncmlkUm93PFQ+KSA9PiByb3cuaXRlbSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5yb3dzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW1zLnNtYXJ0KSB7XG4gICAgICAgICAgdGhpcy5pdGVtcy5hbGwgPSB0aGlzLnJvd3MubWFwKChyb3c6IENsckRhdGFncmlkUm93PFQ+KSA9PiByb3cuaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICB0aGlzLl9kaXNwbGF5ZWRSb3dzLmluc2VydChyb3cuX3ZpZXcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY29sdW1ucy5jaGFuZ2VzLnN1YnNjcmliZSgoY29sdW1uczogQ2xyRGF0YWdyaWRDb2x1bW48VD5bXSkgPT4ge1xuICAgICAgICB0aGlzLmNvbHVtblNlcnZpY2UudXBkYXRlQ29sdW1uTGlzdCh0aGlzLmNvbHVtbnMubWFwKGNvbCA9PiBjb2wuaGlkZWFibGUpKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEdldCBDb2x1bW5TZXJ2aWNlIHJlYWR5IGZvciBIaWRlYWJsZUNvbHVtbnMuXG4gICAgdGhpcy5jb2x1bW5TZXJ2aWNlLnVwZGF0ZUNvbHVtbkxpc3QodGhpcy5jb2x1bW5zLm1hcChjb2wgPT4gY29sLmhpZGVhYmxlKSk7XG4gIH1cblxuICAvKipcbiAgICogT3VyIHNldHVwIGhhcHBlbnMgaW4gdGhlIHZpZXcgb2Ygc29tZSBvZiBvdXIgY29tcG9uZW50cywgc28gd2Ugd2FpdCBmb3IgaXQgdG8gYmUgZG9uZSBiZWZvcmUgc3RhcnRpbmdcbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBUT0RPOiBkZXRlcm1pbmUgaWYgd2UgY2FuIGdldCByaWQgb2YgcHJvdmlkZXIgd2lyaW5nIGluIHZpZXcgaW5pdCBzbyB0aGF0IHN1YnNjcmlwdGlvbnMgY2FuIGJlIGRvbmUgZWFybGllclxuICAgIHRoaXMucmVmcmVzaC5lbWl0KHRoaXMuc3RhdGVQcm92aWRlci5zdGF0ZSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5zdGF0ZVByb3ZpZGVyLmNoYW5nZS5zdWJzY3JpYmUoc3RhdGUgPT4gdGhpcy5yZWZyZXNoLmVtaXQoc3RhdGUpKSxcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmNoYW5nZS5zdWJzY3JpYmUocyA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZSkge1xuICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0ZWRDaGFuZ2VkLmVtaXQoPFQ+cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5NdWx0aSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2VkLmVtaXQoPFRbXT5zKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0aGlzLnBhZ2UuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YWdyaWRUYWJsZS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9KSxcbiAgICAgIC8vIEEgc3Vic2NyaXB0aW9uIHRoYXQgbGlzdGVucyBmb3IgZGlzcGxheU1vZGUgY2hhbmdlcyBvbiB0aGUgZGF0YWdyaWRcbiAgICAgIHRoaXMuZGlzcGxheU1vZGUudmlldy5zdWJzY3JpYmUodmlld0NoYW5nZSA9PiB7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcHJvamVjdGVkIGNvbHVtbnMgZnJvbSB0aGUgcHJvamVjdGVkRGlzcGxheUNvbHVtbnMgY29udGFpbmVyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcm9qZWN0ZWREaXNwbGF5Q29sdW1ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLl9wcm9qZWN0ZWREaXNwbGF5Q29sdW1ucy5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYW55IHByb2plY3RlZCBjb2x1bW5zIGZyb20gdGhlIHByb2plY3RlZENhbGN1bGF0aW9uQ29sdW1ucyBjb250YWluZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3Byb2plY3RlZENhbGN1bGF0aW9uQ29sdW1ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLl9wcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFueSBwcm9qZWN0ZWQgcm93cyBmcm9tIHRoZSBjYWxjdWxhdGlvblJvd3MgY29udGFpbmVyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9jYWxjdWxhdGlvblJvd3MubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRpb25Sb3dzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcHJvamVjdGVkIHJvd3MgZnJvbSB0aGUgZGlzcGxheWVkUm93cyBjb250YWluZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2Rpc3BsYXllZFJvd3MubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fZGlzcGxheWVkUm93cy5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld0NoYW5nZSA9PT0gRGF0YWdyaWREaXNwbGF5TW9kZS5ESVNQTEFZKSB7XG4gICAgICAgICAgLy8gU2V0IHN0YXRlLCBzdHlsZSBmb3IgdGhlIGRhdGFncmlkIHRvIERJU1BMQVkgYW5kIGluc2VydCByb3cgJiBjb2x1bW5zIGludG8gY29udGFpbmVyc1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtY2FsY3VsYXRlLW1vZGUnKTtcbiAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdGVkRGlzcGxheUNvbHVtbnMuaW5zZXJ0KGNvbHVtbi5fdmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXllZFJvd3MuaW5zZXJ0KHJvdy5fdmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2V0IHN0YXRlLCBzdHlsZSBmb3IgdGhlIGRhdGFncmlkIHRvIENBTENVTEFURSBhbmQgaW5zZXJ0IHJvdyAmIGNvbHVtbnMgaW50byBjb250YWluZXJzXG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1jYWxjdWxhdGUtbW9kZScpO1xuICAgICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnMuaW5zZXJ0KGNvbHVtbi5fdmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0aW9uUm93cy5pbnNlcnQocm93Ll92aWV3KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gYWxsIHRoZSBzZXJ2aWNlcyBhbmQgcXVlcmllcyBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHJlc2l6ZSgpOiB2b2lkIHtcbiAgICB0aGlzLm9yZ2FuaXplci5yZXNpemUoKTtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ3Byb2plY3RlZERpc3BsYXlDb2x1bW5zJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9wcm9qZWN0ZWREaXNwbGF5Q29sdW1uczogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgncHJvamVjdGVkQ2FsY3VsYXRpb25Db2x1bW5zJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9wcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnM6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ2Rpc3BsYXllZFJvd3MnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgX2Rpc3BsYXllZFJvd3M6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ2NhbGN1bGF0aW9uUm93cycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfY2FsY3VsYXRpb25Sb3dzOiBWaWV3Q29udGFpbmVyUmVmO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1hY3Rpb24tYmFyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kYXRhZ3JpZC1hY3Rpb24tYmFyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZEFjdGlvbkJhciB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgRWxlbWVudFJlZixcbiAgTmdab25lLFxuICBJbmplY3QsXG4gIFBMQVRGT1JNX0lELFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcblxuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmxldCBjbHJEZ0FjdGlvbklkID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWFjdGlvbi1vdmVyZmxvdycsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b24gKGNsaWNrKT1cInRvZ2dsZSgkZXZlbnQpXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZGF0YWdyaWQtYWN0aW9uLXRvZ2dsZVwiICNhbmNob3Igcm9sZT1cImJ1dHRvblwiIFxuICAgICAgICAgICAgICAgICAgICBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIFthdHRyLmFyaWEtY29udHJvbHNdPVwicG9wb3ZlcklkXCIgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJvcGVuXCI+XG4gICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJlbGxpcHNpcy12ZXJ0aWNhbFwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mua2V5cy5yb3dBY3Rpb25zXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbKGNsclBvcG92ZXJPbGQpXT1cIm9wZW5cIiBbY2xyUG9wb3Zlck9sZEFuY2hvcl09XCJhbmNob3JcIiBbY2xyUG9wb3Zlck9sZEFuY2hvclBvaW50XT1cImFuY2hvclBvaW50XCJcbiAgICAgICAgICAgICAgICAgICAgIFtjbHJQb3BvdmVyT2xkUG9wb3ZlclBvaW50XT1cInBvcG92ZXJQb2ludFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWFjdGlvbi1vdmVyZmxvd1wiIChjbHJPdXRzaWRlQ2xpY2spPVwiY2xvc2UoJGV2ZW50KVwiIFtjbHJTdHJpY3RdPVwidHJ1ZVwiIFxuICAgICAgICAgICAgICAgICAgICByb2xlPVwibWVudVwiIFthdHRyLmlkXT1cInBvcG92ZXJJZFwiIFthdHRyLmFyaWEtaGlkZGVuXT1cIiFvcGVuXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRBY3Rpb25PdmVyZmxvdyBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHB1YmxpYyBhbmNob3JQb2ludDogUG9pbnQgPSBQb2ludC5SSUdIVF9DRU5URVI7XG4gIHB1YmxpYyBwb3BvdmVyUG9pbnQ6IFBvaW50ID0gUG9pbnQuTEVGVF9DRU5URVI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByb3dBY3Rpb25TZXJ2aWNlOiBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzU2VydmljZSxcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QsXG4gICAgcHJpdmF0ZSB6b25lOiBOZ1pvbmVcbiAgKSB7XG4gICAgdGhpcy5yb3dBY3Rpb25TZXJ2aWNlLnJlZ2lzdGVyKCk7XG4gICAgdGhpcy5wb3BvdmVySWQgPSAnY2xyLWFjdGlvbi1tZW51JyArIGNsckRnQWN0aW9uSWQrKztcbiAgfVxuXG4gIHBvcG92ZXJJZDogc3RyaW5nO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucm93QWN0aW9uU2VydmljZS51bnJlZ2lzdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIHdoZXRoZXIgdGhlIGFjdGlvbiBvdmVyZmxvdyBtZW51IGlzIG9wZW4gb3Igbm90XG4gICAqL1xuICBwcml2YXRlIF9vcGVuID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdBY3Rpb25PdmVyZmxvd09wZW4nKVxuICBwdWJsaWMgc2V0IG9wZW4ob3BlbjogYm9vbGVhbikge1xuICAgIGNvbnN0IGJvb2xPcGVuID0gISFvcGVuO1xuICAgIGlmIChib29sT3BlbiAhPT0gdGhpcy5fb3Blbikge1xuICAgICAgdGhpcy5fb3BlbiA9IGJvb2xPcGVuO1xuICAgICAgdGhpcy5vcGVuQ2hhbmdlZC5lbWl0KGJvb2xPcGVuKTtcbiAgICAgIGlmIChib29sT3BlbiAmJiBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEJ1dHRvbiA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5hY3Rpb24taXRlbScpO1xuICAgICAgICAgICAgaWYgKGZpcnN0QnV0dG9uKSB7XG4gICAgICAgICAgICAgIGZpcnN0QnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnQWN0aW9uT3ZlcmZsb3dPcGVuQ2hhbmdlJykgcHVibGljIG9wZW5DaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgLypcbiAgICAgKiBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBjbGljayB0aGF0IG9wZW5zIHRoZSBtZW51LCB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBjbG9zZSB0aGUgbWVudSBpbnN0YW50bHlcbiAgICAgKiB3aGVuIHRoZSBldmVudCBidWJibGVzIHVwIHRoZSBET00gYWxsIHRoZSB3YXkgdG8gdGhlIGRvY3VtZW50LCB3aGljaCB3ZSBhbHNvIGxpc3RlbiB0by5cbiAgICAgKi9cbiAgcHJpdmF0ZSBvcGVuaW5nRXZlbnQ6IGFueTtcblxuICAvKipcbiAgICogU2hvd3MvaGlkZXMgdGhlIGFjdGlvbiBvdmVyZmxvdyBtZW51XG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLm9wZW5pbmdFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW47XG4gIH1cblxuICBwdWJsaWMgY2xvc2UoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAvKlxuICAgICAgICAgKiBCZWNhdXNlIHRoaXMgbGlzdGVuZXIgaXMgYWRkZWQgc3luY2hyb25vdXNseSwgYmVmb3JlIHRoZSBldmVudCBmaW5pc2hlcyBidWJibGluZyB1cCB0aGUgRE9NLFxuICAgICAgICAgKiB3ZSBlbmQgdXAgZmlyaW5nIG9uIHRoZSB2ZXJ5IGNsaWNrIHRoYXQganVzdCBvcGVuZWQgdGhlIG1lbnUsXG4gICAgICAgICAqIHBvdGVudGlhbGx5IGNsb3NpbmcgaXQgaW1tZWRpYXRlbHkgZXZlcnkgdGltZS4gU28gd2UganVzdCBpZ25vcmUgaXQuXG4gICAgICAgICAqL1xuICAgIGlmIChldmVudCA9PT0gdGhpcy5vcGVuaW5nRXZlbnQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm9wZW5pbmdFdmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IENsckRyYWdFdmVudCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1ldmVudCc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4uL3JlbmRlci9yZW5kZXItb3JnYW5pemVyJztcblxuY29uc3QgTUlOX0NPTFVNTl9XSURUSCA9IDk2O1xuXG4vLyBUaGlzIHNlcnZpY2UgYWxsb3dzIERhdGFncmlkSGVhZGVyUmVuZGVyZXIgYW5kIENsckRhdGFncmlkQ29sdW1uU2VwYXJhdG9yXG4vLyB0byBzaGFyZSBjb2x1bW4gcmVzaXplIGRhdGEgd2l0aCBlYWNoIG90aGVyLlxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29sdW1uUmVzaXplclNlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIsIHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcikge31cblxuICBwcml2YXRlIHdpZHRoQmVmb3JlUmVzaXplOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfcmVzaXplZEJ5OiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyBnZXQgcmVzaXplZEJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNpemVkQnk7XG4gIH1cblxuICAvLyBpcyBpdCB3aXRoaW4gdGhlIG1heGltdW0gcmVzaXplIHJhbmdlIHRvIHRoZSBsZWZ0XG4gIHB1YmxpYyBpc1dpdGhpbk1heFJlc2l6ZVJhbmdlOiBib29sZWFuO1xuXG4gIHB1YmxpYyBnZXQgbWluQ29sdW1uV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tQWRhcHRlci5taW5XaWR0aCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpIHx8IE1JTl9DT0xVTU5fV0lEVEg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1heFJlc2l6ZVJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoQmVmb3JlUmVzaXplIC0gdGhpcy5taW5Db2x1bW5XaWR0aDtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydFJlc2l6ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9yZXNpemVkQnkgPSAwO1xuICAgIHRoaXMuaXNXaXRoaW5NYXhSZXNpemVSYW5nZSA9IHRydWU7XG4gICAgdGhpcy53aWR0aEJlZm9yZVJlc2l6ZSA9IHRoaXMuZG9tQWRhcHRlci5jbGllbnRSZWN0KHRoaXMuZWwubmF0aXZlRWxlbWVudCkud2lkdGg7XG4gIH1cblxuICBwdWJsaWMgZW5kUmVzaXplKCk6IHZvaWQge1xuICAgIHRoaXMub3JnYW5pemVyLnJlc2l6ZSgpO1xuICB9XG5cbiAgcHVibGljIGdldCB3aWR0aEFmdGVyUmVzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGhCZWZvcmVSZXNpemUgKyB0aGlzLl9yZXNpemVkQnk7XG4gIH1cblxuICBwdWJsaWMgY2FsY3VsYXRlUmVzaXplKGV2ZW50OiBDbHJEcmFnRXZlbnQ8YW55Pik6IHZvaWQge1xuICAgIGNvbnN0IG1vdmVYID0gZXZlbnQuZHJhZ1Bvc2l0aW9uLm1vdmVYO1xuICAgIC8vIHJldHVybnMgdGhlIHJlc2l6ZSBhbW91bnQgd2l0aGluIHRoZSBhbGxvd2VkIHJhbmdlXG4gICAgaWYgKG1vdmVYIDwgLXRoaXMubWF4UmVzaXplUmFuZ2UpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZWRCeSA9IC10aGlzLm1heFJlc2l6ZVJhbmdlO1xuICAgICAgdGhpcy5pc1dpdGhpbk1heFJlc2l6ZVJhbmdlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZWRCeSA9IG1vdmVYO1xuICAgICAgdGhpcy5pc1dpdGhpbk1heFJlc2l6ZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxubGV0IE5CX0lOU1RBTkNFUyA9IDA7XG5cbmV4cG9ydCBjb25zdCBVTklRVUVfSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nPignVU5JUVVFX0lEJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVJZEZhY3RvcnkoKSB7XG4gIHJldHVybiAnY2xyLWlkLScgKyBOQl9JTlNUQU5DRVMrKztcbn1cblxuZXhwb3J0IGNvbnN0IFVOSVFVRV9JRF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogVU5JUVVFX0lELFxuICB1c2VGYWN0b3J5OiB1bmlxdWVJZEZhY3RvcnksXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbmplY3QsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEcmFnRXZlbnQgfSBmcm9tICcuLi8uLi91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWctZXZlbnQnO1xuaW1wb3J0IHsgQ29sdW1uUmVzaXplclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb2x1bW4tcmVzaXplci5zZXJ2aWNlJztcbmltcG9ydCB7IFRhYmxlU2l6ZVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJsZS1zaXplLnNlcnZpY2UnO1xuaW1wb3J0IHsgVU5JUVVFX0lEX1BST1ZJREVSLCBVTklRVUVfSUQgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uLXNlcGFyYXRvcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi1oYW5kbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgY2xyRHJhZ2dhYmxlIFxuICAgICAgW2Nsckdyb3VwXT1cImNvbHVtblNlcGFyYXRvcklkXCIgXG4gICAgICAoY2xyRHJhZ1N0YXJ0KT1cInNob3dUcmFja2VyKHJlc2l6ZVRyYWNrZXJFbClcIiBcbiAgICAgIChjbHJEcmFnTW92ZSk9XCJtb3ZlVHJhY2tlcigkZXZlbnQsIHJlc2l6ZVRyYWNrZXJFbClcIiBcbiAgICAgIChjbHJEcmFnRW5kKT1cImhpZGVUcmFja2VyKHJlc2l6ZVRyYWNrZXJFbClcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtY29sdW1uLXJlc2l6ZS10cmFja2VyXCIgI3Jlc2l6ZVRyYWNrZXJFbD48L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1jb2x1bW4tc2VwYXJhdG9yXSc6ICd0cnVlJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbVU5JUVVFX0lEX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5TZXBhcmF0b3Ige1xuICAvLyBFdmVyeSBjb2x1bW4gZHJhZ2dhYmxlIHNlcGFyYXRvciBzaG91bGQgaGF2ZSBpdHMgb3duIHVuaXF1ZSBJRFxuICAvLyBpbiBvcmRlciB0byBub3QgY29uZmxpY3Qgd2l0aCBvdGhlciBkcmFnZ2FibGVzL2Ryb3BwYWJsZXMuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY29sdW1uUmVzaXplclNlcnZpY2U6IENvbHVtblJlc2l6ZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIHRhYmxlU2l6ZVNlcnZpY2U6IFRhYmxlU2l6ZVNlcnZpY2UsXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBkb2N1bWVudDogYW55LFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgY29sdW1uU2VwYXJhdG9ySWQ6IHN0cmluZ1xuICApIHt9XG5cbiAgcHVibGljIHNob3dUcmFja2VyKHJlc2l6ZVRyYWNrZXJFbDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLnN0YXJ0UmVzaXplKCk7XG4gICAgY29uc3QgdGFibGVIZWlnaHQgPSB0aGlzLnRhYmxlU2l6ZVNlcnZpY2UuZ2V0Q29sdW1uRHJhZ0hlaWdodCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocmVzaXplVHJhY2tlckVsLCAnaGVpZ2h0JywgdGFibGVIZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocmVzaXplVHJhY2tlckVsLCAnZGlzcGxheScsICdibG9jaycpO1xuICB9XG5cbiAgcHVibGljIG1vdmVUcmFja2VyKGV2ZW50OiBDbHJEcmFnRXZlbnQ8YW55PiwgcmVzaXplVHJhY2tlckVsOiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuY29sdW1uUmVzaXplclNlcnZpY2UuY2FsY3VsYXRlUmVzaXplKGV2ZW50KTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHJlc2l6ZVRyYWNrZXJFbCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGVYKCR7dGhpcy5jb2x1bW5SZXNpemVyU2VydmljZS5yZXNpemVkQnl9cHgpYCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmRvY3VtZW50LmJvZHksICdjdXJzb3InLCAnY29sLXJlc2l6ZScpO1xuICAgIHRoaXMucmVkRmxhZ1RyYWNrZXIocmVzaXplVHJhY2tlckVsKTtcbiAgfVxuXG4gIHB1YmxpYyBoaWRlVHJhY2tlcihyZXNpemVUcmFja2VyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5jb2x1bW5SZXNpemVyU2VydmljZS5lbmRSZXNpemUoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHJlc2l6ZVRyYWNrZXJFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocmVzaXplVHJhY2tlckVsLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVgoMHB4KWApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5kb2N1bWVudC5ib2R5LCAnY3Vyc29yJywgJ2F1dG8nKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVkRmxhZ1RyYWNrZXIocmVzaXplVHJhY2tlckVsOiBIVE1MRWxlbWVudCkge1xuICAgIGxldCBpc1dpdGhpbk1heFJlc2l6ZVJhbmdlOiBib29sZWFuO1xuICAgIGlmIChpc1dpdGhpbk1heFJlc2l6ZVJhbmdlICE9PSB0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLmlzV2l0aGluTWF4UmVzaXplUmFuZ2UpIHtcbiAgICAgIGlzV2l0aGluTWF4UmVzaXplUmFuZ2UgPSB0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLmlzV2l0aGluTWF4UmVzaXplUmFuZ2U7XG4gICAgICBpZiAoIWlzV2l0aGluTWF4UmVzaXplUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhyZXNpemVUcmFja2VyRWwsICdleGNlZWRlZC1tYXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MocmVzaXplVHJhY2tlckVsLCAnZXhjZWVkZWQtbWF4Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4tdG9nZ2xlLWJ1dHRvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVCdXR0b25zLmJ1dHRvbkNsaWNrZWQoKVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwidG9nZ2xlQnV0dG9ucy5zZWxlY3RBbGxEaXNhYmxlZFwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIHRvZ2dsZUJ1dHRvbnM6IENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4tdG9nZ2xlLXRpdGxlJyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFF1ZXJ5TGlzdCxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0LFxuICBOZ1pvbmUsXG4gIFBMQVRGT1JNX0lELFxuICBWaWV3Q2hpbGQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlcic7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLWJ1dHRvbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLXRpdGxlJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcbmltcG9ydCB7IENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvY29sdW1uLXRvZ2dsZS1idXR0b25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uLXRvZ2dsZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAjYW5jaG9yXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVVJKClcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tbGluayBjb2x1bW4tdG9nZ2xlLS1hY3Rpb25cIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInZpZXctY29sdW1uc1wiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mua2V5cy5waWNrQ29sdW1uc1wiPjwvY2xyLWljb24+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uLXN3aXRjaFwiXG4gICAgICAgICAgICAgKmNsclBvcG92ZXJPbGQ9XCJvcGVuOyBhbmNob3I6IGFuY2hvcjsgYW5jaG9yUG9pbnQ6IGFuY2hvclBvaW50OyBwb3BvdmVyUG9pbnQ6IHBvcG92ZXJQb2ludFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3Itb25seVwiIHRhYmluZGV4PVwiLTFcIiAjbWVudURlc2NyaXB0aW9uPnt7Y29tbW9uU3RyaW5ncy5rZXlzLnNob3dDb2x1bW5zTWVudURlc2NyaXB0aW9ufX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3Itb25seVwiIHRhYmluZGV4PVwiLTFcIiAjYWxsU2VsZWN0ZWQ+e3tjb21tb25TdHJpbmdzLmtleXMuYWxsQ29sdW1uc1NlbGVjdGVkfX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXRpdGxlXCI+U2hvdyBDb2x1bW5zPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGUtdGl0bGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmtcIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlVUkoKVwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2xvc2VcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMuY2xvc2VcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJzd2l0Y2gtY29udGVudCBsaXN0LXVuc3R5bGVkXCI+XG4gICAgICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uczt0cmFja0J5OiB0cmFja0J5Rm5cIj5cbiAgICAgICAgICAgICAgICAgICAgPGNsci1jaGVja2JveC13cmFwcGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsckNoZWNrYm94IHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJjb2x1bW4ubGFzdFZpc2libGVDb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdNb2RlbF09XCIhY29sdW1uLmhpZGRlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cInRvZ2dsZUNvbHVtbigkZXZlbnQsIGNvbHVtbilcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbD48bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uLnRlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT48L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8L2Nsci1jaGVja2JveC13cmFwcGVyPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1mb290ZXJcIiAqbmdJZj1cImJ1dHRvbnMubGVuZ3RoID4gMFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1jb2x1bW4tdG9nZ2xlLWJ1dHRvblwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1mb290ZXJcIiAqbmdJZj1cImJ1dHRvbnMubGVuZ3RoID09PSAwXCI+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tbGluayBwNiB0ZXh0LXVwcGVyY2FzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImFsbENvbHVtbnNWaXNpYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0QWxsKClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5TZWxlY3QgQWxsXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5jb2x1bW4tc3dpdGNoLXdyYXBwZXJdJzogJ3RydWUnLCAnW2NsYXNzLmFjdGl2ZV0nOiAnb3BlbicgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBfYWxsQ29sdW1uc1Zpc2libGU6IGJvb2xlYW47XG5cbiAgLyoqKlxuICAgKiBQb3BvdmVyIGluaXRcbiAgICovXG4gIHB1YmxpYyBhbmNob3JQb2ludDogUG9pbnQgPSBQb2ludC5UT1BfTEVGVDtcbiAgcHVibGljIHBvcG92ZXJQb2ludDogUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgcHVibGljIG9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKioqKlxuICAgKiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgaW5pdFxuICAgKi9cbiAgcHVibGljIGNvbHVtbnM6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdID0gW107XG5cbiAgcHVibGljIGdldCBhbGxDb2x1bW5zVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsQ29sdW1uc1Zpc2libGU7XG4gIH1cblxuICBwdWJsaWMgc2V0IGFsbENvbHVtbnNWaXNpYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fYWxsQ29sdW1uc1Zpc2libGUgPSB2YWx1ZTtcbiAgfVxuXG4gIEBDb250ZW50Q2hpbGQoQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZSkgdGl0bGU6IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGU7XG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24pIGJ1dHRvbnM6IFF1ZXJ5TGlzdDxDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbj47XG4gIEBWaWV3Q2hpbGQoJ21lbnVEZXNjcmlwdGlvbicsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICBwcml2YXRlIG1lbnVEZXNjcmlwdGlvbkVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuICBAVmlld0NoaWxkKCdhbGxTZWxlY3RlZCcsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICBwcml2YXRlIGFsbFNlbGVjdGVkRWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGhpZGVhYmxlQ29sdW1uU2VydmljZTogSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgY29sdW1uVG9nZ2xlQnV0dG9uczogQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHByaXZhdGUgem9uZTogTmdab25lXG4gICkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNvbHVtbkxpc3QgPT4ge1xuICAgICAgICAvLyBSZXNldCB0aGUgbGlzdCBvZiBjb2x1bW5zXG4gICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS51cGRhdGVGb3JMYXN0VmlzaWJsZUNvbHVtbigpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNWaXNpYmxlID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZTtcbiAgICAgICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkID0gdGhpcy5hbGxDb2x1bW5zVmlzaWJsZTtcblxuICAgICAgICAvLyBBZGQgb25seSB0aGUgaGlkZGVuIGNvbHVtbnMgdG8gdGhlIHRvZ2dsZXIuXG4gICAgICAgIGNvbHVtbkxpc3QuZm9yRWFjaChjb2wgPT4ge1xuICAgICAgICAgIGlmIChjb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbEJ1dHRvbkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBzZWxlY3RBbGwoKSB7XG4gICAgdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2Uuc2hvd0hpZGRlbkNvbHVtbnMoKTtcbiAgICB0aGlzLmFsbENvbHVtbnNWaXNpYmxlID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZTtcbiAgICB0aGlzLmNvbHVtblRvZ2dsZUJ1dHRvbnMuc2VsZWN0QWxsRGlzYWJsZWQgPSB0aGlzLmFsbENvbHVtbnNWaXNpYmxlO1xuICAgIGlmICh0aGlzLmFsbFNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgdGhpcy5hbGxTZWxlY3RlZEVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUNvbHVtbihldmVudDogYm9vbGVhbiwgY29sdW1uOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwpIHtcbiAgICBjb2x1bW4uaGlkZGVuID0gIWV2ZW50O1xuICAgIHRoaXMuYWxsQ29sdW1uc1Zpc2libGUgPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jaGVja0ZvckFsbENvbHVtbnNWaXNpYmxlO1xuICAgIHRoaXMuY29sdW1uVG9nZ2xlQnV0dG9ucy5zZWxlY3RBbGxEaXNhYmxlZCA9IHRoaXMuYWxsQ29sdW1uc1Zpc2libGU7XG4gICAgdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UudXBkYXRlRm9yTGFzdFZpc2libGVDb2x1bW4oKTtcbiAgfVxuXG4gIHRvZ2dsZVVJKCkge1xuICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW47XG4gICAgaWYgKHRoaXMub3BlbiAmJiBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIHRoaXMubWVudURlc2NyaXB0aW9uRWxlbWVudCkge1xuICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5tZW51RGVzY3JpcHRpb25FbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBXaXRob3V0IHRyYWNraW5nIHRoZSBjaGVja2JveGVzIGdldCByZXJlbmRlcmVkIG9uIG1vZGVsIHVwZGF0ZSwgd2hpY2ggbGVhZHNcbiAgLy8gdG8gbG9zcyBvZiBmb2N1cyBhZnRlciBjaGVja2JveCB0b2dnbGUuXG4gIHRyYWNrQnlGbihpbmRleCkge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuXG4vKlxuICogSSBkb24ndCB0aGluayB0aGlzIGRlc2VydmVzIHRvIGJlIGluIElmRXhwYW5kZWQgaXRzZWxmLFxuICogc28gSSdtIGFkZGluZyBhIHNlY29uZCBkaXJlY3RpdmUgb24gdGhlIHNhbWUgc2VsZWN0b3IgZm9yIG5vdyBqdXN0IGZvciB0aGUgZGF0YWdyaWRcbiAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklmRXhwYW5kZWRdJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkRGV0YWlsUmVnaXN0ZXJlciB7XG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgZXhwYW5kYWJsZVJvd3NDb3VudDogRXhwYW5kYWJsZVJvd3NDb3VudCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQpIHtcbiAgICAgIHRoaXMuZXhwYW5kYWJsZVJvd3NDb3VudC5yZWdpc3RlcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQpIHtcbiAgICAgIHRoaXMuZXhwYW5kYWJsZVJvd3NDb3VudC51bnJlZ2lzdGVyKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4vcHJvdmlkZXJzL3NlbGVjdGlvbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1mb290ZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdJZj1cIihzZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuTXVsdGkpICYmIChzZWxlY3Rpb24uY3VycmVudC5sZW5ndGggPiAwKVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItZm9ybS1jb250cm9sLWRpc2FibGVkXCI+XG4gICAgICAgICAgICAgIDxjbHItY2hlY2tib3gtd3JhcHBlciBjbGFzcz1cImRhdGFncmlkLWZvb3Rlci1zZWxlY3RcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgY2xyQ2hlY2tib3ggdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD1cImNoZWNrZWRcIiBkaXNhYmxlZD5cbiAgICAgICAgICAgICAgICA8bGFiZWw+e3tzZWxlY3Rpb24uY3VycmVudC5sZW5ndGh9fTwvbGFiZWw+XG4gICAgICAgICAgICA8L2Nsci1jaGVja2JveC13cmFwcGVyPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxjbHItZGctY29sdW1uLXRvZ2dsZSAqbmdJZj1cIiF0b2dnbGUgJiYgYWN0aXZlVG9nZ2xlclwiPjwvY2xyLWRnLWNvbHVtbi10b2dnbGU+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1mb290ZXItZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1wYWdpbmF0aW9uXCI+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLWZvb3Rlcl0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkRm9vdGVyPFQgPSBhbnk+IGltcGxlbWVudHMgT25Jbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uPFQ+LFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHt9XG5cbiAgcHVibGljIGFjdGl2ZVRvZ2dsZXI6IGJvb2xlYW47XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICAvKiByZWZlcmVuY2UgdG8gdGhlIGVudW0gc28gdGhhdCB0ZW1wbGF0ZSBjYW4gYWNjZXNzICovXG4gIHB1YmxpYyBTRUxFQ1RJT05fVFlQRSA9IFNlbGVjdGlvblR5cGU7XG5cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSkgdG9nZ2xlOiBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgIGNvbnN0IGhpZGRlbkNvbHVtbnNJblN1YiA9IGNoYW5nZS5maWx0ZXIoY29sID0+IGNvbCk7XG4gICAgICAgIGlmIChoaWRkZW5Db2x1bW5zSW5TdWIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlVG9nZ2xlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGhpZGRlbkNvbHVtbnMgPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5zKCkuZmlsdGVyKGNvbCA9PiBjb2wpO1xuXG4gICAgaWYgKGhpZGRlbkNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hY3RpdmVUb2dnbGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4ge1xuICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSB1dGlsaXR5IGNsYXNzIGZvciB0aGF0IGFkZHMgaGlkZS9zaG93IGZ1bmN0aW9uYWxpdHkgdG8gYSBjb2x1bW4sIGl0cyBjZWxscyBhbmQgZW5hYmxlcyBhIHRvZ2dsZXIgaW4gdGhlXG4gKiBEYXRhZ3JpZENvbHVtblRvZ2dsZSBDb21wb25lbnQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIHtcbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoaWRkZW5DaGFuZ2VzXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHN0cmVhbSBvZiBzdGF0ZSBjaGFuZ2VzIGFuIGluc3RhbmNlIG9mIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB3aWxsIGJyb2FkY2FzdCB0byBzdWJzY3JpYmVycy5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgaGlkZGVuQ2hhbmdlc1N0YXRlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBpbml0IGZ1bmN0aW9uIGZvciBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgaW5zdGFuY2VzIHRoYXQgZG9lcyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAxLiBTZXQgdmFsdWVzIGZvciB0aGUgcHJpdmF0ZSB2YXJpYWJsZXMgdGhhdCBlbmFibGUgYSBoaWRlYWJsZSBjb2x1bW5cbiAgICogMi4gQnJvYWRjYXN0IHRoZSBuZXh0IGhpZGRlbiBjaGFuZ2UgZm9yIGFueW9uZSAoYWxyZWFkeSkgc3Vic2NyaWJlZCB0byB0aGlzIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sIHByaXZhdGUgX2lkOiBzdHJpbmcsIHByaXZhdGUgX2hpZGRlbjogYm9vbGVhbiA9IGZhbHNlKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIFRlbXBsYXRlUmVmIG9mIHRoZSBEYXRhZ3JpZENvbHVtbiB0aGF0IGlzIGhpZGVhYmxlLiBUaGlzIGlzIGN1cnJlbnRseSB1c2VkIHRvXG4gICAqIHBvcHVsYXRlIHRoZSBEYXRhZ3JpZENvbHVtblRvZ2dsZSBVSSB3aXRoIHRoZSBjb3JyZWN0IENvbHVtbiBuYW1lLlxuICAgKlxuICAgKi9cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogcHVibGljIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaWQgb2YgYSBIaWRlYWJsZUNPbHVtbiBpbnN0YW5jZS4gVXNlZCBieSB0aGUgSGlkZWFibGVDT2x1bW5TZXJ2aWNlIGZvciBwYXNzaW5nXG4gICAqIHN0YXRlIGFuZCBhY3Rpb25zIGJldHdlZW4gRGF0ZUdyaWRDb2x1bW5zLCBEYXRhR3JpZENlbGxzICYgdGhlIERhdGFncmlkQ29sdW1uVG9nZ2xlIENvbXBvbmVudHMuXG4gICAqXG4gICAqL1xuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgaGlkZGVuIHZhbHVlIG9mIGEgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIGluc3RhbmNlLlxuICAgKlxuICAgKi9cbiAgZ2V0IGhpZGRlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgc2V0dGVyIGZvciBzZXR0aW5nIHRoZSBoaWRkZW4gc3RhdGUgb2YgYSBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgaW5zdGFuY2UuXG4gICAqIEl0IGFsc28gYnJvYWRjYXN0cyB0aGUgY2hhbmdlIGFmdGVyIGl0cyBzZXQuXG4gICAqXG4gICAqL1xuICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faGlkZGVuID0gdmFsdWU7XG4gICAgdGhpcy5oaWRkZW5DaGFuZ2VzU3RhdGUubmV4dCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIE9ic2VydmFibGUgZm9yIHRoZSBIaWRlYWJsZUNvbHVtbnMgaGlkZGVuIGNoYW5nZXMuXG4gICAqXG4gICAqL1xuICBnZXQgaGlkZGVuQ2hhbmdlU3RhdGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZGVuQ2hhbmdlc1N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLy8gRmxhZyB0aGlzIHRydWUgd2hlbiB0aGUgc2VydmljZSBvbmx5IGhhcyBvbmUgdmlzaWJsZSBjb2x1bW4gb3Blbi5cblxuICBwdWJsaWMgbGFzdFZpc2libGVDb2x1bW46IGJvb2xlYW4gPSBmYWxzZTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmLCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtbiB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckRnSGlkZWFibGVDb2x1bW5dJyB9KVxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RydWN0dXJhbCBkaXJlY3RpdmUgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgYSBjbHItZGctY29sdW1uIGNvbXBvbmVudC5cbiAqXG4gKiA8Y2xyLWRnLWNvbHVtbj5cbiAqICAgICAgIDxuZy1jb250YWluZXIgKmNsckRnSGlkZWFibGVDb2x1bW49XCJ7IGhpZGRlbjogdHJ1ZSB9XCI+XG4gKiAgICAgICAgICAgVXNlciBJRFxuICogICAgICAgPC9uZy1jb250YWluZXI+XG4gKiAgIDwvY2xyLWRnLWNvbHVtbj5cbiAqXG4gKiBJdCBzZXRzIHVwIHN0YXRlIGFuZCBwcm9wZXJ0aWVzIHNvIHRoYXQgY29sdW1ucyBjYW4gYmUgbWFuZ2VzIGZvciBoaWRlL3Nob3cgYnkgYSBzZXJ2aWNlIGFuZCBhbiBpbnRlcm5hbFxuICogZGF0YWdyaWQgdG9nZ2xlIGNvbXBvbmVudC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIHtcbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVc2VkIHRvIGluaXRpYWxpemUgdGhlIGNvbHVtbiB3aXRoIGVpdGhlciBoaWRkZW4gb3IgdmlzaWJsZSBzdGF0ZS5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2hpZGRlbjogYm9vbGVhbjtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldHRlciBmbiBmb3IgdGhlIEBJbnB1dCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhpcyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICogSXQgYWxsb3dzIHRoZSB1c2VyIHRvIHByZS1jb25maWd1cmUgdGhlIGNvbHVtbidzIGhpZGUvc2hvdyBzdGF0ZS4geyBoaWRkZW46IHRydWUgfVxuICAgKiBJdCdzIG1vcmUgdmVyYm9zZSBidXQgaGFzIG1vcmUgQ2xhcml0eS5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogKmNsckRnSGlkZWFibGVDb2x1bW5cbiAgICogKmNsckRnSGlkZWFibGVDb2x1bW49e2hpZGRlbjogZmFsc2V9XG4gICAqICpjbHJEZ0hpZGVhYmxlQ29sdW1uPXtoaWRkZW46IHRydWV9XG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NsckRnSGlkZWFibGVDb2x1bW4nKVxuICBzZXQgY2xyRGdIaWRlYWJsZUNvbHVtbih2YWx1ZTogeyBoaWRkZW46IGJvb2xlYW4gfSkge1xuICAgIHRoaXMuY2xyRGdIaWRkZW4gPSB2YWx1ZSAmJiB2YWx1ZS5oaWRkZW4gPyB2YWx1ZS5oaWRkZW4gOiBmYWxzZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdIaWRkZW4nKVxuICBzZXQgY2xyRGdIaWRkZW4oaGlkZGVuOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGlkZGVuID0gaGlkZGVuID8gaGlkZGVuIDogZmFsc2U7XG4gICAgaWYgKHRoaXMuZGdDb2x1bW4uaGlkZWFibGUpIHtcbiAgICAgIHRoaXMuZGdDb2x1bW4uaGlkZWFibGUuaGlkZGVuID0gdGhpcy5faGlkZGVuO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnSGlkZGVuQ2hhbmdlJykgcHVibGljIGhpZGRlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcGFzc2VkIGludG8gdGhlIGRpcmVjdGl2ZSBmcm9tIHRoZSBwYXJlbnQgKEEgRGF0YWdyaWRDb2x1bW4pLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGNvbHVtbklkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiBVdGlsaXR5IGNsYXNzIHRoYXQgaXMgdXNlZCB0bzpcbiAgICogMS4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEhpZGVhYmxlQ29sdW1uIHRoYXQgd2lsbCBtYW5hZ2UgdGhlIFRlbXBsYXRlUmVmLCBzdGF0ZSBhbmQgY29tbXVuaWNhdGlvblxuICAgKiAyLiBNYW5hZ2UgdGhlIGhpZGRlbi9zaG93biBzdGF0ZSBmb3IgdGhlIGNvbHVtbiB0byB3aGljaCB0aGlzIGRpcmVjdGl2ZSBpcyBhcHBsaWVkXG4gICAqIDMuIHRyYWNrIHRoZSBpZCBvZiB0aGUgaGlkZGVuIGNvbHVtbiBzbyBpdCBjYW4gYmUgdXNlZCBpbiBjZWxscyBhcyB3ZWxsIGFzIG9uIHRoZSBjb2x1bW5cbiAgICovXG4gIHB1YmxpYyBjb2x1bW46IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbDtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFVzZWQgdGhlIERhdGFncmlkQ29sdW1uIHRvIGdldCBhbmQgc2V0IGFuIGlkIGZvciB0aGlzIEhpZGRlbkNvbHVtblxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBkZ0NvbHVtbjogQ2xyRGF0YWdyaWRDb2x1bW48YW55PlxuICApIHtcbiAgICB0aGlzLmNvbHVtbklkID0gZGdDb2x1bW4uY29sdW1uSWQ7XG5cbiAgICAvLyBVc2UgdGhlIHRlbXBsYXRlUmVmIHRvIGNyZWF0ZSB0aGlzIHZpZXdcbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGVSZWYpO1xuXG4gICAgLy8gQ3JlYXRlIGluc3RhbmNlIG9mIHRoZSB1dGlsaXR5IGNsYXNzIERhdGFncmlkSGlkZWFibGVDb2x1bW4uXG4gICAgLy8gTm90ZSB0aGlzIGlzIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgRGF0YWdyaWRDb2x1bW4uXG4gICAgdGhpcy5kZ0NvbHVtbi5oaWRlYWJsZSA9IG5ldyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwodGhpcy50ZW1wbGF0ZVJlZiwgdGhpcy5jb2x1bW5JZCwgdGhpcy5faGlkZGVuKTtcbiAgICB0aGlzLmRnQ29sdW1uLmhpZGVhYmxlLmhpZGRlbkNoYW5nZVN0YXRlLnN1YnNjcmliZShzdGF0ZSA9PiB0aGlzLmhpZGRlbkNoYW5nZS5lbWl0KHN0YXRlKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9wdGlvbmFsLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSXRlbXMgfSBmcm9tICcuL3Byb3ZpZGVycy9pdGVtcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuZ0ZvclRyYWNrQnldJyxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRJdGVtc1RyYWNrQnk8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIF9pdGVtczogSXRlbXM8VD4pIHt9XG5cbiAgQElucHV0KCduZ0ZvclRyYWNrQnknKVxuICBzZXQgdHJhY2tCeSh2YWx1ZTogVHJhY2tCeUZ1bmN0aW9uPFQ+KSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9pdGVtcy50cmFja0J5ID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1wYWdlLXNpemUnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLXNlbGVjdC13cmFwcGVyXCI+XG4gICAgICA8c2VsZWN0IFtjbGFzcy5jbHItcGFnZS1zaXplLXNlbGVjdF09XCJ0cnVlXCIgWyhuZ01vZGVsKV09XCJwYWdlLnNpemVcIj5cbiAgICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIHBhZ2VTaXplT3B0aW9uc1wiIFtuZ1ZhbHVlXT1cIm9wdGlvblwiPnt7b3B0aW9ufX08L29wdGlvbj5cbiAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFBhZ2VTaXplIHtcbiAgQElucHV0KCdjbHJQYWdlU2l6ZU9wdGlvbnMnKSBwYWdlU2l6ZU9wdGlvbnM6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlOiBQYWdlKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICghdGhpcy5wYWdlU2l6ZU9wdGlvbnMgfHwgdGhpcy5wYWdlU2l6ZU9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VTaXplT3B0aW9ucyA9IFt0aGlzLnBhZ2Uuc2l6ZV07XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQYWdlU2l6ZSB9IGZyb20gJy4vZGF0YWdyaWQtcGFnZS1zaXplJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXBhZ2luYXRpb24nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uLXNpemVcIiAqbmdJZj1cIl9wYWdlU2l6ZUNvbXBvbmVudFwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLXBhZ2Utc2l6ZVwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicGFnaW5hdGlvbi1kZXNjcmlwdGlvblwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uLWxpc3RcIiAqbmdJZj1cInBhZ2UubGFzdCA+IDFcIj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiIFxuICAgICAgICBjbGFzcz1cInBhZ2luYXRpb24tZmlyc3RcIiBcbiAgICAgICAgW2Rpc2FibGVkXT1cInBhZ2UuY3VycmVudCA8PSAxXCIgXG4gICAgICAgIChjbGljayk9XCJwYWdlLmN1cnJlbnQgPSAxXCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJjb21tb25TdHJpbmdzLmtleXMuZmlyc3RQYWdlXCJcbiAgICAgICAgPlxuICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJzdGVwLWZvcndhcmQtMiBkb3duXCI+PC9jbHItaWNvbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1wcmV2aW91c1wiIFxuICAgICAgICBbZGlzYWJsZWRdPVwicGFnZS5jdXJyZW50IDw9IDFcIiBcbiAgICAgICAgKGNsaWNrKT1cInBhZ2UuY3VycmVudCA9IHBhZ2UuY3VycmVudCAtIDFcIlxuICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbW1vblN0cmluZ3Mua2V5cy5wcmV2aW91c1BhZ2VcIlxuICAgICAgICA+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImFuZ2xlIGxlZnRcIj48L2Nsci1pY29uPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8aW5wdXQgXG4gICAgICAgICNjdXJyZW50UGFnZUlucHV0IFxuICAgICAgICB0eXBlPVwidGV4dFwiIFxuICAgICAgICBjbGFzcz1cInBhZ2luYXRpb24tY3VycmVudFwiIFxuICAgICAgICBbc2l6ZV09XCJwYWdlLmxhc3QudG9TdHJpbmcoKS5sZW5ndGhcIiBcbiAgICAgICAgW3ZhbHVlXT1cInBhZ2UuY3VycmVudFwiXG4gICAgICAgIChrZXlkb3duLmVudGVyKT1cInVwZGF0ZUN1cnJlbnRQYWdlKCRldmVudClcIiBcbiAgICAgICAgKGJsdXIpPVwidXBkYXRlQ3VycmVudFBhZ2UoJGV2ZW50KVwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmN1cnJlbnRQYWdlXCJcbiAgICAgICAgLz5cbiAgICAgICAgJm5ic3A7LyZuYnNwOzxzcGFuIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLnRvdGFsUGFnZXNcIj57e3BhZ2UubGFzdH19PC9zcGFuPlxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1uZXh0XCIgXG4gICAgICAgIFtkaXNhYmxlZF09XCJwYWdlLmN1cnJlbnQgPj0gcGFnZS5sYXN0XCIgXG4gICAgICAgIChjbGljayk9XCJwYWdlLmN1cnJlbnQgPSBwYWdlLmN1cnJlbnQgKyAxXCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJjb21tb25TdHJpbmdzLmtleXMubmV4dFBhZ2VcIlxuICAgICAgICA+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImFuZ2xlIHJpZ2h0XCI+PC9jbHItaWNvbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiIFxuICAgICAgICBjbGFzcz1cInBhZ2luYXRpb24tbGFzdFwiIFxuICAgICAgICBbZGlzYWJsZWRdPVwicGFnZS5jdXJyZW50ID49IHBhZ2UubGFzdFwiIFxuICAgICAgICAoY2xpY2spPVwicGFnZS5jdXJyZW50ID0gcGFnZS5sYXN0XCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJjb21tb25TdHJpbmdzLmtleXMubGFzdFBhZ2VcIlxuICAgICAgICA+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInN0ZXAtZm9yd2FyZC0yIHVwXCI+PC9jbHItaWNvbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5wYWdpbmF0aW9uXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFBhZ2luYXRpb24gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIEBDb250ZW50Q2hpbGQoQ2xyRGF0YWdyaWRQYWdlU2l6ZSkgX3BhZ2VTaXplQ29tcG9uZW50OiBDbHJEYXRhZ3JpZFBhZ2VTaXplO1xuICBAVmlld0NoaWxkKCdjdXJyZW50UGFnZUlucHV0JykgY3VycmVudFBhZ2VJbnB1dFJlZjogRWxlbWVudFJlZjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZTogUGFnZSwgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlKSB7XG4gICAgdGhpcy5wYWdlLmFjdGl2YXRlZCA9IHRydWU7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKiBTdWJzY3JpcHRpb24gdG8gdGhlIFBhZ2Ugc2VydmljZSBmb3IgcGFnZSBjaGFuZ2VzLlxuICAgKiBOb3RlOiB0aGlzIG9ubHkgZW1pdHMgYWZ0ZXIgdGhlIGRhdGFncmlkIGlzIGluaXRpYWxpemVkL3N0YWJhbGl6ZWQgYW5kIHRoZSBwYWdlIGNoYW5nZXMuXG4gICAqL1xuICBuZ09uSW5pdCgpIHtcbiAgICAvKlxuICAgICAqIERlZmF1bHQgcGFnZSBzaXplIGlzIDEwLlxuICAgICAqIFRoZSByZWFzb24gd2Ugc2V0IGl0IGhlcmUgYW5kIG5vdCBpbiB0aGUgcHJvdmlkZXIgaXRzZWxmIGlzIGJlY2F1c2VcbiAgICAgKiB3ZSBkb24ndCB3YW50IHBhZ2luYXRpb24gaWYgdGhpcyBjb21wb25lbnQgaXNuJ3QgcHJlc2VudCBpbiB0aGUgZGF0YWdyaWQuXG4gICAgICovXG4gICAgaWYgKCF0aGlzLnBhZ2Uuc2l6ZSkge1xuICAgICAgdGhpcy5wYWdlLnNpemUgPSAxMDtcbiAgICB9XG4gICAgdGhpcy5fcGFnZVN1YnNjcmlwdGlvbiA9IHRoaXMucGFnZS5jaGFuZ2Uuc3Vic2NyaWJlKGN1cnJlbnQgPT4gdGhpcy5jdXJyZW50Q2hhbmdlZC5lbWl0KGN1cnJlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpcHRpb24gdG8gdGhlIHBhZ2Ugc2VydmljZSBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9wYWdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5wYWdlLnJlc2V0UGFnZVNpemUoKTtcbiAgICBpZiAodGhpcy5fcGFnZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fcGFnZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWdlIHNpemVcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFnZVNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLnNpemU7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnUGFnZVNpemUnKVxuICBwdWJsaWMgc2V0IHBhZ2VTaXplKHNpemU6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFnZS5zaXplID0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG90YWwgaXRlbXMgKG5lZWRlZCB0byBndWVzcyB0aGUgbGFzdCBwYWdlKVxuICAgKi9cbiAgcHVibGljIGdldCB0b3RhbEl0ZW1zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS50b3RhbEl0ZW1zO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1RvdGFsSXRlbXMnKVxuICBwdWJsaWMgc2V0IHRvdGFsSXRlbXModG90YWw6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgdG90YWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhZ2UudG90YWxJdGVtcyA9IHRvdGFsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMYXN0IHBhZ2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbGFzdFBhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmxhc3Q7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnTGFzdFBhZ2UnKVxuICBwdWJsaWMgc2V0IGxhc3RQYWdlKGxhc3Q6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFnZS5sYXN0ID0gbGFzdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCBwYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5jdXJyZW50O1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1BhZ2UnKVxuICBwdWJsaWMgc2V0IGN1cnJlbnRQYWdlKHBhZ2U6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgcGFnZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFnZS5jdXJyZW50ID0gcGFnZTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ1BhZ2VDaGFuZ2UnKSBjdXJyZW50Q2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRvIHRoZSBwcmV2aW91cyBwYWdlIGlmIGl0IGV4aXN0c1xuICAgKi9cbiAgcHVibGljIHByZXZpb3VzKCkge1xuICAgIHRoaXMucGFnZS5wcmV2aW91cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRvIHRoZSBuZXh0IHBhZ2UgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgbmV4dCgpIHtcbiAgICB0aGlzLnBhZ2UubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCBwYWdlLCBzdGFydGluZyBhdCAwXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpcnN0SXRlbSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2UuZmlyc3RJdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHBhZ2UsIHN0YXJ0aW5nIGF0IDBcbiAgICovXG4gIHB1YmxpYyBnZXQgbGFzdEl0ZW0oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmxhc3RJdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgYWRkcyBwYWdlIG51bWJlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3VycmVudCBwYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1pZGRsZVBhZ2VzKCk6IG51bWJlcltdIHtcbiAgICBjb25zdCBtaWRkbGVQYWdlczogbnVtYmVyW10gPSBbXTtcbiAgICBpZiAodGhpcy5wYWdlLmN1cnJlbnQgPiAxKSB7XG4gICAgICBtaWRkbGVQYWdlcy5wdXNoKHRoaXMucGFnZS5jdXJyZW50IC0gMSk7XG4gICAgfVxuICAgIG1pZGRsZVBhZ2VzLnB1c2godGhpcy5wYWdlLmN1cnJlbnQpO1xuICAgIGlmICh0aGlzLnBhZ2UuY3VycmVudCA8IHRoaXMucGFnZS5sYXN0KSB7XG4gICAgICBtaWRkbGVQYWdlcy5wdXNoKHRoaXMucGFnZS5jdXJyZW50ICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBtaWRkbGVQYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBvbmx5IHVwZGF0ZSB0aGUgcGFnaW5hdGlvbidzIGN1cnJlbnQgcGFnZSBvbiBibHVyIG9mIHRoZSBpbnB1dCBmaWVsZCwgb3JcbiAgICogd2hlbiB0aGV5IHByZXNzIGVudGVyLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUN1cnJlbnRQYWdlKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChldmVudC50YXJnZXQudmFsdWUsIDEwKTtcblxuICAgIC8vIGlmIHRoZSBpbnB1dCB2YWx1ZSwgaXMgbm90IGEgbnVtYmVyLCB3ZSBkb24ndCB1cGRhdGUgdGhlIHBhZ2VcbiAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgIGlmIChwYXJzZWQgPCAxKSB7XG4gICAgICAgIHRoaXMucGFnZS5jdXJyZW50ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VkID4gdGhpcy5wYWdlLmxhc3QpIHtcbiAgICAgICAgdGhpcy5wYWdlLmN1cnJlbnQgPSB0aGlzLnBhZ2UubGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFnZS5jdXJyZW50ID0gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW5wdXQncyB2YWx1ZSB0byB0aGUgbmV3IGN1cnJlbnQgcGFnZS4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgY29kZVxuICAgICAqIGFib3ZlIG1heSBoYXZlIGNoYW5nZWQgdGhlIHZhbHVlIGZyb20gd2hhdCB0aGUgdXNlciBlbnRlcmVkIGluLlxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFBhZ2VJbnB1dFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5wYWdlLmN1cnJlbnQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBFeHBhbmQgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvcHJvdmlkZXJzL2V4cGFuZCc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ2VsbCB9IGZyb20gJy4vZGF0YWdyaWQtY2VsbCc7XG5pbXBvcnQgeyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgfSBmcm9tICcuL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbCc7XG5pbXBvcnQgeyBFeHBhbmRhYmxlUm93c0NvdW50IH0gZnJvbSAnLi9wcm92aWRlcnMvZ2xvYmFsLWV4cGFuZGFibGUtcm93cyc7XG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBSb3dBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcm93LWFjdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4vcHJvdmlkZXJzL3NlbGVjdGlvbic7XG5cbi8qKlxuICogR2VuZXJpYyBibGFuZCBjb250YWluZXIgc2VydmluZyB2YXJpb3VzIHB1cnBvc2VzIGZvciBEYXRhZ3JpZC5cbiAqIEZvciBpbnN0YW5jZSwgaXQgY2FuIGhlbHAgc3BhbiBhIHRleHQgb3ZlciBtdWx0aXBsZSByb3dzIGluIGRldGFpbCB2aWV3LlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcm93LWRldGFpbCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhcmVwbGFjZWRSb3dcIj5cbiAgICAgICAgICAgIDwhLS0gc3BhY2UgZm9yIG11bHRpc2VsZWN0aW9uIHN0YXRlIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNlbGwgZGF0YWdyaWQtc2VsZWN0IGRhdGFncmlkLWZpeGVkLWNvbHVtblwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuTXVsdGlcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBzcGFjZSBmb3Igc2luZ2xlIHNlbGVjdGlvbiBzdGF0ZSAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1jZWxsIGRhdGFncmlkLXNlbGVjdCBkYXRhZ3JpZC1maXhlZC1jb2x1bW5cIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwic2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNFTEVDVElPTl9UWVBFLlNpbmdsZVwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tIHNwYWNlIGZvciBzaW5nbGUgcm93IGFjdGlvbjsgb25seSBkaXNwbGF5VHlwZSBpZiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBhY3Rpb25hYmxlIHJvdyBpbiBkYXRhZ3JpZCAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1jZWxsIGRhdGFncmlkLXJvdy1hY3Rpb25zIGRhdGFncmlkLWZpeGVkLWNvbHVtblwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJyb3dBY3Rpb25TZXJ2aWNlLmhhc0FjdGlvbmFibGVSb3dcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBzcGFjZSBmb3IgZXhwYW5kYWJsZSBjYXJldCBhY3Rpb247IG9ubHkgZGlzcGxheVR5cGUgaWYgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgZXhwYW5kYWJsZSByb3cgaW4gZGF0YWdyaWQgLS0+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiZXhwYW5kYWJsZVJvd3MuaGFzRXhwYW5kYWJsZVJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImRhdGFncmlkLWV4cGFuZGFibGUtY2FyZXQgZGF0YWdyaWQtZml4ZWQtY29sdW1uIGRhdGFncmlkLWNlbGxcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLXJvdy1mbGV4XSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLXJvdy1kZXRhaWxdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuZGF0YWdyaWQtY29udGFpbmVyXSc6ICdjZWxscy5sZW5ndGggPT09IDAnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFJvd0RldGFpbDxUID0gYW55PiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIC8qIHJlZmVyZW5jZSB0byB0aGUgZW51bSBzbyB0aGF0IHRlbXBsYXRlIGNhbiBhY2Nlc3MgaXQgKi9cbiAgcHVibGljIFNFTEVDVElPTl9UWVBFID0gU2VsZWN0aW9uVHlwZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgc2VsZWN0aW9uOiBTZWxlY3Rpb24sXG4gICAgcHVibGljIHJvd0FjdGlvblNlcnZpY2U6IFJvd0FjdGlvblNlcnZpY2UsXG4gICAgcHVibGljIGV4cGFuZDogRXhwYW5kLFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwdWJsaWMgZXhwYW5kYWJsZVJvd3M6IEV4cGFuZGFibGVSb3dzQ291bnRcbiAgKSB7fVxuXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRDZWxsKSBjZWxsczogUXVlcnlMaXN0PENsckRhdGFncmlkQ2VsbD47XG5cbiAgQElucHV0KCdjbHJEZ1JlcGxhY2UnKVxuICBzZXQgcmVwbGFjZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZXhwYW5kLnNldFJlcGxhY2UoISF2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHB1YmxpYyByZXBsYWNlZFJvdyA9IGZhbHNlO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBjb25zdCBjb2x1bW5zTGlzdCA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbnMoKTtcbiAgICB0aGlzLnVwZGF0ZUNlbGxzRm9yQ29sdW1ucyhjb2x1bW5zTGlzdCk7XG5cbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgQ2VsbHMgbGlzdCBjaGFuZ2VzIHBlciByb3ctcmVuZGVyZXJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY2VsbHMuY2hhbmdlcy5zdWJzY3JpYmUoY2VsbExpc3QgPT4ge1xuICAgICAgICBjb25zdCBjb2x1bW5MaXN0ID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpO1xuICAgICAgICBpZiAoY2VsbExpc3QubGVuZ3RoID09PSBjb2x1bW5MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBVc2VkIHRvIHNldCB0aGluZ3MgdXAgdGhlIGZpcnN0IHRpbWUgYnV0IG9ubHkgYWZ0ZXIgYWxsIHRoZSBjb2x1bW5zIGFyZSByZWFkeS5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNvbHVtbkxpc3QgPT4ge1xuICAgICAgICAvLyBQcmV2ZW50cyBjZWxsIHVwZGF0ZXMgd2hlbiBjb2xzIGFuZCBjZWxscyBhcnJheSBhcmUgbm90IGFsaWduZWRcbiAgICAgICAgaWYgKGNvbHVtbkxpc3QubGVuZ3RoID09PSB0aGlzLmNlbGxzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZXhwYW5kLnJlcGxhY2Uuc3Vic2NyaWJlKHJlcGxhY2VDaGFuZ2UgPT4ge1xuICAgICAgICB0aGlzLnJlcGxhY2VkUm93ID0gcmVwbGFjZUNoYW5nZTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdDogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10pIHtcbiAgICB0aGlzLmNlbGxzLmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50Q29sdW1uID0gY29sdW1uTGlzdFtpbmRleF07IC8vIEFjY291bnRzIGZvciBudWxsIHNwYWNlLlxuICAgICAgaWYgKGN1cnJlbnRDb2x1bW4pIHtcbiAgICAgICAgY2VsbC5pZCA9IGN1cnJlbnRDb2x1bW4uaWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBjb25zdCBOT19MQVlPVVRfQ0xBU1MgPSAnZGF0YWdyaWQtbm8tbGF5b3V0JztcbmV4cG9ydCBjb25zdCBDT01QVVRFX1dJRFRIX0NMQVNTID0gJ2RhdGFncmlkLWNvbXB1dGluZy1jb2x1bW5zLXdpZHRoJztcbmV4cG9ydCBjb25zdCBTVFJJQ1RfV0lEVEhfQ0xBU1MgPSAnZGF0YWdyaWQtZml4ZWQtd2lkdGgnO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuXG5pbXBvcnQgeyBTVFJJQ1RfV0lEVEhfQ0xBU1MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyLW9yZ2FuaXplcic7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1jZWxsJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkQ2VsbFJlbmRlcmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBvcmdhbml6ZXIuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkNMRUFSX1dJRFRIUykuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xlYXJXaWR0aCgpKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyV2lkdGgoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFNUUklDVF9XSURUSF9DTEFTUyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIG51bGwpO1xuICB9XG5cbiAgcHVibGljIHNldFdpZHRoKHN0cmljdDogYm9vbGVhbiwgdmFsdWU6IG51bWJlcikge1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCBTVFJJQ1RfV0lEVEhfQ0xBU1MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIHZhbHVlICsgJ3B4Jyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE91dHB1dCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuaW1wb3J0IHsgQ29sdW1uUmVzaXplclNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvY29sdW1uLXJlc2l6ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBTVFJJQ1RfV0lEVEhfQ0xBU1MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyLW9yZ2FuaXplcic7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4nLCBwcm92aWRlcnM6IFtDb2x1bW5SZXNpemVyU2VydmljZV0gfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZEhlYWRlclJlbmRlcmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyLFxuICAgIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcixcbiAgICBwcml2YXRlIGNvbHVtblJlc2l6ZXJTZXJ2aWNlOiBDb2x1bW5SZXNpemVyU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMub3JnYW5pemVyLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5DTEVBUl9XSURUSFMpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsZWFyV2lkdGgoKSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5vcmdhbml6ZXJcbiAgICAgICAgLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5ERVRFQ1RfU1RSSUNUX1dJRFRIUylcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRldGVjdFN0cmljdFdpZHRoKCkpXG4gICAgKTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnQ29sdW1uUmVzaXplJykgcmVzaXplRW1pdHRlcjogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGhhcyBhIHN0cmljdCB3aWR0aCwgc28gaXQgZG9lc24ndCBzaHJpbmsgb3IgZXhwYW5kIGJhc2VkIG9uIHRoZSBjb250ZW50LlxuICAgKi9cbiAgcHVibGljIHN0cmljdFdpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgd2lkdGhTZXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyV2lkdGgoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSB3aWR0aCBvbmx5IGlmIHdlIHNldCBpdCwgYW5kIGl0IGlzIG5vdCBjaGFuZ2VkIGJ5IGRyYWdnaW5nLlxuICAgIGlmICh0aGlzLndpZHRoU2V0ICYmICF0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLnJlc2l6ZWRCeSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0ZWN0U3RyaWN0V2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuY29sdW1uUmVzaXplclNlcnZpY2UucmVzaXplZEJ5KSB7XG4gICAgICB0aGlzLnN0cmljdFdpZHRoID0gdGhpcy5jb2x1bW5SZXNpemVyU2VydmljZS53aWR0aEFmdGVyUmVzaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0cmljdFdpZHRoID0gdGhpcy5kb21BZGFwdGVyLnVzZXJEZWZpbmVkV2lkdGgodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29tcHV0ZVdpZHRoKCk6IG51bWJlciB7XG4gICAgbGV0IHdpZHRoOiBudW1iZXIgPSB0aGlzLnN0cmljdFdpZHRoO1xuICAgIGlmICghd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5kb21BZGFwdGVyLnNjcm9sbFdpZHRoKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRXaWR0aCh3aWR0aDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0V2lkdGgpIHtcbiAgICAgIGlmICh0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLnJlc2l6ZWRCeSkge1xuICAgICAgICB0aGlzLnJlc2l6ZUVtaXR0ZXIuZW1pdCh3aWR0aCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCB3aWR0aCArICdweCcpO1xuICAgICAgICB0aGlzLndpZHRoU2V0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCBzZXQgd2lkdGggaWYgdGhlcmUgaXMgYSB1c2VyLWRlZmluZWQgb25lLiBKdXN0IGFkZCB0aGUgc3RyaWN0IHdpZHRoIGNsYXNzLlxuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFNUUklDVF9XSURUSF9DTEFTUyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCBTVFJJQ1RfV0lEVEhfQ0xBU1MpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCB3aWR0aCArICdweCcpO1xuICAgIHRoaXMud2lkdGhTZXQgPSB0cnVlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qXG4gKiBUaGlzIHZlcnNpb24gb2YgdGhlIERvbUFkYXB0ZXIgaXMgZm9yIHVzZSBvbiBub24tYnJvd3NlciBwbGF0Zm9ybXMsIHdoZXJlIHRoZXJlIGFyZSBub1xuICogbmF0aXZlRWxlbWVudHMgdG8gdXNlIGZvciBjYWxjdWxhdGlvbnMuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5vb3BEb21BZGFwdGVyIGltcGxlbWVudHMgRG9tQWRhcHRlciB7XG4gIHVzZXJEZWZpbmVkV2lkdGgoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHNjcm9sbEJhcldpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgc2Nyb2xsV2lkdGgoZWxlbWVudDogYW55KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb21wdXRlZEhlaWdodChlbGVtZW50OiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY2xpZW50UmVjdChlbGVtZW50OiBhbnkpOiBDbGllbnRSZWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIG1pbldpZHRoKGVsZW1lbnQ6IGFueSk6IG51bWJlciB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmb2N1cyhlbGVtZW50OiBhbnkpOiB2b2lkIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdDaGVja2VkLFxuICBBZnRlclZpZXdJbml0LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgT25EZXN0cm95LFxuICBQTEFURk9STV9JRCxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uIH0gZnJvbSAnLi4vZGF0YWdyaWQtY29sdW1uJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuaW1wb3J0IHsgSXRlbXMgfSBmcm9tICcuLi9wcm92aWRlcnMvaXRlbXMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9wYWdlJztcbmltcG9ydCB7IFRhYmxlU2l6ZVNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvdGFibGUtc2l6ZS5zZXJ2aWNlJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGFncmlkSGVhZGVyUmVuZGVyZXIgfSBmcm9tICcuL2hlYWRlci1yZW5kZXJlcic7XG5pbXBvcnQgeyBOb29wRG9tQWRhcHRlciB9IGZyb20gJy4vbm9vcC1kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyLW9yZ2FuaXplcic7XG5cbi8vIEZpeGVzIGJ1aWxkIGVycm9yXG4vLyBAZHluYW1pYyAoaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTk2OTgjaXNzdWVjb21tZW50LTMzODM0MDIxMSlcbmV4cG9ydCBjb25zdCBkb21BZGFwdGVyRmFjdG9yeSA9IChwbGF0Zm9ybUlkOiBPYmplY3QpID0+IHtcbiAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpKSB7XG4gICAgcmV0dXJuIG5ldyBEb21BZGFwdGVyKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBOb29wRG9tQWRhcHRlcigpO1xuICB9XG59O1xuXG4vLyBGaXhlcyBidWlsZCBlcnJvclxuLy8gQGR5bmFtaWMgKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE5Njk4I2lzc3VlY29tbWVudC0zMzgzNDAyMTEpXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdjbHItZGF0YWdyaWQnLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IERvbUFkYXB0ZXIsIHVzZUZhY3Rvcnk6IGRvbUFkYXB0ZXJGYWN0b3J5LCBkZXBzOiBbUExBVEZPUk1fSURdIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZE1haW5SZW5kZXJlcjxUID0gYW55PiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBwcml2YXRlIGl0ZW1zOiBJdGVtcyxcbiAgICBwcml2YXRlIHBhZ2U6IFBhZ2UsXG4gICAgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgdGFibGVTaXplU2VydmljZTogVGFibGVTaXplU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMub3JnYW5pemVyXG4gICAgICAgIC5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuQ09NUFVURV9DT0xVTU5fV0lEVEhTKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY29tcHV0ZUhlYWRlcnNXaWR0aCgpKVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucGFnZS5zaXplQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9oZWlnaHRTZXQpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0RGF0YWdyaWRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuaXRlbXMuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiAodGhpcy5zaG91bGRTdGFiaWxpemVDb2x1bW5zID0gdHJ1ZSkpKTtcbiAgfVxuXG4gIEBDb250ZW50Q2hpbGRyZW4oRGF0YWdyaWRIZWFkZXJSZW5kZXJlcikgcHVibGljIGhlYWRlcnM6IFF1ZXJ5TGlzdDxEYXRhZ3JpZEhlYWRlclJlbmRlcmVyPjtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJEYXRhZ3JpZENvbHVtbikgcHVibGljIGNvbHVtbnM6IFF1ZXJ5TGlzdDxDbHJEYXRhZ3JpZENvbHVtbj47XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5oZWFkZXJzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgLy8gVE9ETzogb25seSByZS1zdGFiaWxpemUgaWYgYSBjb2x1bW4gd2FzIGFkZGVkIG9yIHJlbW92ZWQuIFJlb3JkZXJpbmcgaXMgZmluZS5cbiAgICAgICAgdGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFiaWxpemVDb2x1bW5zKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGFuZCBzZXQgVGFibGUgd2lkdGggZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nIGhlcmUuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnRhYmxlU2l6ZVNlcnZpY2UudGFibGUgPSB0aGlzLmVsO1xuICB9XG5cbiAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgIGlmICh0aGlzLnNob3VsZFN0YWJpbGl6ZUNvbHVtbnMpIHtcbiAgICAgIHRoaXMuc3RhYmlsaXplQ29sdW1ucygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRDb21wdXRlSGVpZ2h0KCkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbXB1dGVEYXRhZ3JpZEhlaWdodCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaGVpZ2h0U2V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBzaG91bGRDb21wdXRlSGVpZ2h0KCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5faGVpZ2h0U2V0ICYmIHRoaXMucGFnZS5zaXplID4gMCkge1xuICAgICAgaWYgKHRoaXMuaXRlbXMuZGlzcGxheWVkLmxlbmd0aCA9PT0gdGhpcy5wYWdlLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBkYXRhZ3JpZC5cbiAgICpcbiAgICogTk9URTogV2UgaGFkIHRvIGNob29zZSB0byBzZXQgdGhlIGhlaWdodCBpbnN0ZWFkIG9mIHRoZSBtaW4taGVpZ2h0IGJlY2F1c2VcbiAgICogSUUgMTEgcmVxdWlyZXMgdGhlIGhlaWdodCBvbiB0aGUgcGFyZW50IGZvciB0aGUgY2hpbGRyZW4gZmxleCBncm93L3NocmluayBwcm9wZXJ0aWVzIHRvIHdvcmsuXG4gICAqIFdoZW4gd2UgdXNlZCBtaW4taGVpZ2h0LCAxIDEgYXV0byBkb2Vzbid0IHVzZWQgdG8gd29yayBpbiBJRTExIDotKFxuICAgKiBCdXQgdGhpcyBkb2Vzbid0IGFmZmVjdCB0aGUgZml4LiBJdCB3b3JrcyBpbiBib3RoIGZpeGVkICYgdmFyaWFibGUgaGVpZ2h0IGRhdGFncmlkcy5cbiAgICpcbiAgICogUmVmZXI6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQzOTYyMDUvZmxleC1ncm93LW5vdC13b3JraW5nLWluLWludGVybmV0LWV4cGxvcmVyLTExLTBcbiAgICovXG4gIHByaXZhdGUgY29tcHV0ZURhdGFncmlkSGVpZ2h0KCkge1xuICAgIC8vIElFIGRvZXNuJ3QgcmV0dXJuIGNvcnJlY3QgdmFsdWUgZm9yIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKVxuICAgIGNvbnN0IHZhbHVlOiBudW1iZXIgPSB0aGlzLmRvbUFkYXB0ZXIuY2xpZW50UmVjdCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIHZhbHVlICsgJ3B4Jyk7XG4gICAgdGhpcy5faGVpZ2h0U2V0ID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXREYXRhZ3JpZEhlaWdodCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsICcnKTtcbiAgICB0aGlzLl9oZWlnaHRTZXQgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGVhY2ggaGVhZGVyIGNvbXB1dGUgaXRzIHdpZHRoLlxuICAgKi9cbiAgcHJpdmF0ZSBjb21wdXRlSGVhZGVyc1dpZHRoKCkge1xuICAgIGNvbnN0IG5iQ29sdW1uczogbnVtYmVyID0gdGhpcy5oZWFkZXJzLmxlbmd0aDtcbiAgICBsZXQgYWxsU3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaCgoaGVhZGVyLCBpbmRleCkgPT4ge1xuICAgICAgLy8gT24gdGhlIGxhc3QgaGVhZGVyIGNvbHVtbiBjaGVjayB3aGV0aGVyIGFsbCBjb2x1bW5zIGhhdmUgc3RyaWN0IHdpZHRocy5cbiAgICAgIC8vIElmIGFsbCBjb2x1bW5zIGhhdmUgc3RyaWN0IHdpZHRocywgcmVtb3ZlIHRoZSBzdHJpY3Qgd2lkdGggZnJvbSB0aGUgbGFzdCBjb2x1bW4gYW5kIG1ha2UgaXQgdGhlIGNvbHVtbidzXG4gICAgICAvLyBtaW5pbXVtIHdpZHRoIHNvIHRoYXQgd2hlbiBhbGwgcHJldmlvdXMgY29sdW1ucyBzaHJpbmssIGl0IHdpbGwgZ2V0IGEgZmxleGlibGUgd2lkdGggYW5kIGNvdmVyIHRoZSBlbXB0eVxuICAgICAgLy8gZ2FwIGluIHRoZSBEYXRhZ3JpZC5cblxuICAgICAgaWYgKCFoZWFkZXIuc3RyaWN0V2lkdGgpIHtcbiAgICAgICAgYWxsU3RyaWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYkNvbHVtbnMgPT09IGluZGV4ICsgMSAmJiBhbGxTdHJpY3QpIHtcbiAgICAgICAgZGVsZXRlIGhlYWRlci5zdHJpY3RXaWR0aDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmdhbml6ZXIud2lkdGhzW2luZGV4XSA9IHsgcHg6IGhlYWRlci5jb21wdXRlV2lkdGgoKSwgc3RyaWN0OiAhIWhlYWRlci5zdHJpY3RXaWR0aCB9O1xuICAgIH0pO1xuXG4gICAgdGhpcy5oZWFkZXJzLmZvckVhY2goKGhlYWRlciwgaW5kZXgpID0+IGhlYWRlci5zZXRXaWR0aCh0aGlzLm9yZ2FuaXplci53aWR0aHNbaW5kZXhdLnB4KSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHdlIHdhbnQgdG8gcmUtY29tcHV0ZSBjb2x1bW5zIHdpZHRoLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbjpcbiAgICogMSkgV2hlbiBoZWFkZXJzIGNoYW5nZSwgd2l0aCBjb2x1bW5zIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWRcbiAgICogMikgV2hlbiByb3dzIGFyZSBsYXppbHkgbG9hZGVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgKi9cbiAgcHJpdmF0ZSBjb2x1bW5zU2l6ZXNTdGFibGUgPSBmYWxzZTtcblxuICBwcml2YXRlIHNob3VsZFN0YWJpbGl6ZUNvbHVtbnMgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIHdob2xlIHJlLXJlbmRyaW5nIGN5Y2xlIHRvIHNldCBjb2x1bW4gc2l6ZXMsIGlmIG5lZWRlZC5cbiAgICovXG4gIHByaXZhdGUgc3RhYmlsaXplQ29sdW1ucygpIHtcbiAgICB0aGlzLnNob3VsZFN0YWJpbGl6ZUNvbHVtbnMgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc2l6ZSB3aGVuIHRoZSByb3dzIGFyZSBsb2FkZWQuXG4gICAgaWYgKHRoaXMuaXRlbXMuZGlzcGxheWVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMub3JnYW5pemVyLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIE9uRGVzdHJveSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5cbmltcG9ydCB7IERhdGFncmlkQ2VsbFJlbmRlcmVyIH0gZnJvbSAnLi9jZWxsLXJlbmRlcmVyJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi9yZW5kZXItb3JnYW5pemVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRnLXJvdywgY2xyLWRnLXJvdy1kZXRhaWwnIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRSb3dSZW5kZXJlciBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcikge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgb3JnYW5pemVyLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5BTElHTl9DT0xVTU5TKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zZXRXaWR0aHMoKSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgQENvbnRlbnRDaGlsZHJlbihEYXRhZ3JpZENlbGxSZW5kZXJlcikgY2VsbHM6IFF1ZXJ5TGlzdDxEYXRhZ3JpZENlbGxSZW5kZXJlcj47XG5cbiAgcHJpdmF0ZSBzZXRXaWR0aHMoKSB7XG4gICAgaWYgKHRoaXMub3JnYW5pemVyLndpZHRocy5sZW5ndGggIT09IHRoaXMuY2VsbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2VsbHMuZm9yRWFjaCgoY2VsbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5vcmdhbml6ZXIud2lkdGhzW2luZGV4XTtcbiAgICAgIGNlbGwuc2V0V2lkdGgod2lkdGguc3RyaWN0LCB3aWR0aC5weCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5jZWxscy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnNldFdpZHRocygpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc2V0V2lkdGhzKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xyRm9ybXNNb2R1bGUgfSBmcm9tICcuLi8uLi9mb3Jtcy9mb3Jtcy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXIubW9kdWxlJztcbmltcG9ydCB7IENscklmRXhwYW5kTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ01vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyT3V0c2lkZUNsaWNrTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvb3V0c2lkZS1jbGljay9vdXRzaWRlLWNsaWNrLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJEcmFnQW5kRHJvcE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1hbmQtZHJvcC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyU3Bpbm5lck1vZHVsZSB9IGZyb20gJy4uLy4uL3Byb2dyZXNzL3NwaW5uZXIvc3Bpbm5lci5tb2R1bGUnO1xuaW1wb3J0IHsgRGF0YWdyaWRSb3dFeHBhbmRBbmltYXRpb24gfSBmcm9tICcuL2FuaW1hdGlvbi1oYWNrL3Jvdy1leHBhbmQtYW5pbWF0aW9uJztcbmltcG9ydCB7IERhdGFncmlkU3RyaW5nRmlsdGVyIH0gZnJvbSAnLi9idWlsdC1pbi9maWx0ZXJzL2RhdGFncmlkLXN0cmluZy1maWx0ZXInO1xuaW1wb3J0IHsgQWN0aW9uYWJsZU9vbXBhTG9vbXBhIH0gZnJvbSAnLi9jaG9jb2xhdGUvYWN0aW9uYWJsZS1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgRGF0YWdyaWRXaWxseVdvbmthIH0gZnJvbSAnLi9jaG9jb2xhdGUvZGF0YWdyaWQtd2lsbHktd29ua2EnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZU9vbXBhTG9vbXBhIH0gZnJvbSAnLi9jaG9jb2xhdGUvZXhwYW5kYWJsZS1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWQgfSBmcm9tICcuL2RhdGFncmlkJztcbmltcG9ydCB7IENsckRhdGFncmlkQWN0aW9uQmFyIH0gZnJvbSAnLi9kYXRhZ3JpZC1hY3Rpb24tYmFyJztcbmltcG9ydCB7IENsckRhdGFncmlkQWN0aW9uT3ZlcmZsb3cgfSBmcm9tICcuL2RhdGFncmlkLWFjdGlvbi1vdmVyZmxvdyc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENlbGwgfSBmcm9tICcuL2RhdGFncmlkLWNlbGwnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW4gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblNlcGFyYXRvciB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXNlcGFyYXRvcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXRvZ2dsZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbiB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS1idXR0b24nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZSB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS10aXRsZSc7XG5pbXBvcnQgeyBEYXRhZ3JpZERldGFpbFJlZ2lzdGVyZXIgfSBmcm9tICcuL2RhdGFncmlkLWRldGFpbC1yZWdpc3RlcmVyJztcbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1maWx0ZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRGb290ZXIgfSBmcm9tICcuL2RhdGFncmlkLWZvb3Rlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRJdGVtcyB9IGZyb20gJy4vZGF0YWdyaWQtaXRlbXMnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRJdGVtc1RyYWNrQnkgfSBmcm9tICcuL2RhdGFncmlkLWl0ZW1zLXRyYWNrYnknO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQYWdpbmF0aW9uIH0gZnJvbSAnLi9kYXRhZ3JpZC1wYWdpbmF0aW9uJztcbmltcG9ydCB7IENsckRhdGFncmlkUGFnZVNpemUgfSBmcm9tICcuL2RhdGFncmlkLXBhZ2Utc2l6ZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1wbGFjZWhvbGRlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFJvdyB9IGZyb20gJy4vZGF0YWdyaWQtcm93JztcbmltcG9ydCB7IENsckRhdGFncmlkUm93RGV0YWlsIH0gZnJvbSAnLi9kYXRhZ3JpZC1yb3ctZGV0YWlsJztcbmltcG9ydCB7IERhdGFncmlkQ2VsbFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvY2VsbC1yZW5kZXJlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZEhlYWRlclJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvaGVhZGVyLXJlbmRlcmVyJztcbmltcG9ydCB7IERhdGFncmlkTWFpblJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvbWFpbi1yZW5kZXJlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFJvd1JlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvcm93LXJlbmRlcmVyJztcbmltcG9ydCB7IFdyYXBwZWRDZWxsIH0gZnJvbSAnLi93cmFwcGVkLWNlbGwnO1xuaW1wb3J0IHsgV3JhcHBlZENvbHVtbiB9IGZyb20gJy4vd3JhcHBlZC1jb2x1bW4nO1xuaW1wb3J0IHsgV3JhcHBlZFJvdyB9IGZyb20gJy4vd3JhcHBlZC1yb3cnO1xuXG5leHBvcnQgY29uc3QgQ0xSX0RBVEFHUklEX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICAvLyBDb3JlXG4gIENsckRhdGFncmlkLFxuICBDbHJEYXRhZ3JpZEFjdGlvbkJhcixcbiAgQ2xyRGF0YWdyaWRBY3Rpb25PdmVyZmxvdyxcbiAgQ2xyRGF0YWdyaWRDb2x1bW4sXG4gIENsckRhdGFncmlkQ29sdW1uU2VwYXJhdG9yLFxuICBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSxcbiAgQ2xyRGF0YWdyaWRIaWRlYWJsZUNvbHVtbixcbiAgQ2xyRGF0YWdyaWRGaWx0ZXIsXG4gIENsckRhdGFncmlkSXRlbXMsXG4gIENsckRhdGFncmlkSXRlbXNUcmFja0J5LFxuICBDbHJEYXRhZ3JpZFJvdyxcbiAgQ2xyRGF0YWdyaWRSb3dEZXRhaWwsXG4gIERhdGFncmlkRGV0YWlsUmVnaXN0ZXJlcixcbiAgQ2xyRGF0YWdyaWRDZWxsLFxuICBDbHJEYXRhZ3JpZEZvb3RlcixcbiAgQ2xyRGF0YWdyaWRQYWdpbmF0aW9uLFxuICBDbHJEYXRhZ3JpZFBhZ2VTaXplLFxuICBDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyLFxuICBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbixcbiAgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZSxcbiAgV3JhcHBlZENlbGwsXG4gIFdyYXBwZWRDb2x1bW4sXG4gIFdyYXBwZWRSb3csXG5cbiAgLy8gUmVuZGVyZXJzXG4gIERhdGFncmlkTWFpblJlbmRlcmVyLFxuICBEYXRhZ3JpZEhlYWRlclJlbmRlcmVyLFxuICBEYXRhZ3JpZFJvd1JlbmRlcmVyLFxuICBEYXRhZ3JpZENlbGxSZW5kZXJlcixcblxuICAvLyBDaG9jb2xhdGVcbiAgRGF0YWdyaWRXaWxseVdvbmthLFxuICBBY3Rpb25hYmxlT29tcGFMb29tcGEsXG4gIEV4cGFuZGFibGVPb21wYUxvb21wYSxcblxuICAvLyBBbmltYXRpb24gaGFja1xuICBEYXRhZ3JpZFJvd0V4cGFuZEFuaW1hdGlvbixcblxuICAvLyBCdWlsdC1pbiBzaG9ydGN1dHNcbiAgRGF0YWdyaWRTdHJpbmdGaWx0ZXIsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIENsckljb25Nb2R1bGUsXG4gICAgQ2xyRm9ybXNNb2R1bGUsXG4gICAgRm9ybXNNb2R1bGUsXG4gICAgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSxcbiAgICBDbHJMb2FkaW5nTW9kdWxlLFxuICAgIENsck91dHNpZGVDbGlja01vZHVsZSxcbiAgICBDbHJEcmFnQW5kRHJvcE1vZHVsZSxcbiAgICBDbHJTcGlubmVyTW9kdWxlLFxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfREFUQUdSSURfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfREFUQUdSSURfRElSRUNUSVZFUywgQ2xySWZFeHBhbmRNb2R1bGVdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtXcmFwcGVkQ2VsbCwgV3JhcHBlZENvbHVtbiwgV3JhcHBlZFJvd10sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5wdXQsIE9uSW5pdCwgT3B0aW9uYWwsIE91dHB1dCwgU2tpcFNlbGYsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVU5JUVVFX0lELCBVTklRVUVfSURfUFJPVklERVIgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2stYmxvY2snLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkdCBjbGFzcz1cInN0YWNrLWJsb2NrLWxhYmVsXCJcbiAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUV4cGFuZCgpXCJcbiAgICAgICAgKGtleXVwLmVudGVyKT1cInRvZ2dsZUV4cGFuZCgpXCJcbiAgICAgICAgKGtleXVwLnNwYWNlKT1cInRvZ2dsZUV4cGFuZCgpXCJcbiAgICAgICAgKGZvY3VzKT1cImZvY3VzZWQgPSB0cnVlXCJcbiAgICAgICAgKGJsdXIpPVwiZm9jdXNlZCA9IGZhbHNlXCJcbiAgICAgICAgW2lkXT1cInVuaXF1ZUlkXCJcbiAgICAgICAgW2F0dHIucm9sZV09XCJyb2xlXCJcbiAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwidGFiSW5kZXhcIlxuICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImFyaWFFeHBhbmRlZFwiPlxuICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2FyZXRcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwic3RhY2stYmxvY2stY2FyZXRcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiZXhwYW5kYWJsZVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuZGlyXT1cImNhcmV0RGlyZWN0aW9uXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjYXJldFRpdGxlXCI+PC9jbHItaWNvbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiY2xyLXNyLW9ubHlcIiAqbmdJZj1cImdldENoYW5nZWRWYWx1ZVwiPnt7Y29tbW9uU3RyaW5ncy5rZXlzLnN0YWNrVmlld0NoYW5nZWR9fTwvc3Bhbj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1zdGFjay1sYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8L2R0PlxuICAgIDxkZCBjbGFzcz1cInN0YWNrLWJsb2NrLWNvbnRlbnRcIj5cbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L2RkPlxuICAgIDwhLS0gRklYTUU6IHJlbW92ZSB0aGlzIHN0cmluZyBjb25jYXRlbmF0aW9uIHdoZW4gYm9vbGVhbiBzdGF0ZXMgYXJlIHN1cHBvcnRlZCAtLT5cbiAgICA8ZGl2IFtAY29sbGFwc2VdPVwiJycrIWV4cGFuZGVkXCIgY2xhc3M9XCJzdGFjay1jaGlsZHJlblwiID5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1zdGFjay1ibG9ja1wiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgLy8gQ3VzdG9tIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICAgIDpob3N0IHsgZGlzcGxheTogYmxvY2s7IH1cbiAgICBgLFxuICBdLFxuICAvLyBNYWtlIHN1cmUgdGhlIGhvc3QgaGFzIHRoZSBwcm9wZXIgY2xhc3MgZm9yIHN0eWxpbmcgcHVycG9zZXNcbiAgaG9zdDogeyAnW2NsYXNzLnN0YWNrLWJsb2NrXSc6ICd0cnVlJyB9LFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignY29sbGFwc2UnLCBbXG4gICAgICBzdGF0ZSgndHJ1ZScsIHN0eWxlKHsgaGVpZ2h0OiAwLCBkaXNwbGF5OiAnbm9uZScgfSkpLFxuICAgICAgdHJhbnNpdGlvbigndHJ1ZSA9PiBmYWxzZScsIFthbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBoZWlnaHQ6ICcqJywgZGlzcGxheTogJyonIH0pKV0pLFxuICAgICAgdHJhbnNpdGlvbignZmFsc2UgPT4gdHJ1ZScsIFtzdHlsZSh7IGhlaWdodDogJyonLCBkaXNwbGF5OiAnKicgfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKV0pLFxuICAgIF0pLFxuICBdLFxuICBwcm92aWRlcnM6IFtVTklRVUVfSURfUFJPVklERVJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja0Jsb2NrIGltcGxlbWVudHMgT25Jbml0IHtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zdGFjay1ibG9jay1leHBhbmRlZCcpXG4gIEBJbnB1dCgnY2xyU2JFeHBhbmRlZCcpXG4gIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG4gIEBPdXRwdXQoJ2NsclNiRXhwYW5kZWRDaGFuZ2UnKSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3RhY2stYmxvY2stZXhwYW5kYWJsZScpXG4gIEBJbnB1dCgnY2xyU2JFeHBhbmRhYmxlJylcbiAgZXhwYW5kYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfY2hhbmdlZENoaWxkcmVuOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9mdWxseUluaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2NoYW5nZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnN0YWNrLWJsb2NrLWNoYW5nZWQnKVxuICBnZXQgZ2V0Q2hhbmdlZFZhbHVlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkIHx8ICh0aGlzLl9jaGFuZ2VkQ2hpbGRyZW4gPiAwICYmICF0aGlzLmV4cGFuZGVkKTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyU2JOb3RpZnlDaGFuZ2UnKVxuICBzZXQgc2V0Q2hhbmdlZFZhbHVlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY2hhbmdlZCA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMuX2Z1bGx5SW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5fY2hhbmdlZENoaWxkcmVuKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudC5fY2hhbmdlZENoaWxkcmVuLS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICAgKiBUaGlzIHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHdpdGggQENvbnRlbnRDaGlsZHJlbiwgd2l0aCB0aGUgcGFyZW50IENsclN0YWNrQmxvY2tcbiAgICAgKiBxdWVyeWluZyBmb3IgY2hpbGRyZW4gU3RhY2tCbG9ja3MsIGJ1dCB0aGlzIGZlYXR1cmUgaXMgbm90IGF2YWlsYWJsZSB3aGVuIGRvd25ncmFkaW5nXG4gICAgICogdGhlIGNvbXBvbmVudCBmb3IgQW5ndWxhciAxLlxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBAU2tpcFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHJpdmF0ZSBwYXJlbnQ6IENsclN0YWNrQmxvY2ssXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyB1bmlxdWVJZDogc3RyaW5nLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzU2VydmljZVxuICApIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuYWRkQ2hpbGQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAvLyBpbiBvcmRlciB0byBhY2Nlc3MgdGhlIHBhcmVudCBDbHJTdGFja0Jsb2NrJ3MgcHJvcGVydGllcyxcbiAgICAvLyB0aGUgY2hpbGQgQ2xyU3RhY2tCbG9jayBoYXMgdG8gYmUgZnVsbHkgaW5pdGlhbGl6ZWQgYXQgZmlyc3QuXG4gICAgdGhpcy5fZnVsbHlJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhZGRDaGlsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmV4cGFuZGFibGUgPSB0cnVlO1xuICB9XG5cbiAgdG9nZ2xlRXhwYW5kKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICB9XG4gIH1cblxuICBnZXQgY2FyZXREaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/ICdkb3duJyA6ICdyaWdodCc7XG4gIH1cblxuICBnZXQgY2FyZXRUaXRsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGVkID8gdGhpcy5jb21tb25TdHJpbmdzLmtleXMuY29sbGFwc2UgOiB0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy5leHBhbmQ7XG4gIH1cblxuICBnZXQgcm9sZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGUgPyAnYnV0dG9uJyA6IG51bGw7XG4gIH1cblxuICBnZXQgdGFiSW5kZXgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlID8gJzAnIDogbnVsbDtcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnY2xhc3Mub24tZm9jdXMnKVxuICBnZXQgb25TdGFja0xhYmVsRm9jdXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZSAmJiAhdGhpcy5leHBhbmRlZCAmJiB0aGlzLmZvY3VzZWQ7XG4gIH1cblxuICBnZXQgYXJpYUV4cGFuZGVkKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zdGFjay12aWV3JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXN0YWNrLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICAgICAgPGRsIGNsYXNzPVwic3RhY2stdmlld1wiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2RsPlxuICAgIGAsXG4gIC8vIEN1c3RvbSBlbGVtZW50cyBhcmUgaW5saW5lIGJ5IGRlZmF1bHQuXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfVxuICAgIGAsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrVmlldyB7XG4gIC8qKlxuICAgKiBVbmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmU6IGlubGluZSBlZGl0aW5nLlxuICAgKi9cbiAgZWRpdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBAT3V0cHV0KCdjbHJTdGFja1NhdmUnKSBzYXZlOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KGZhbHNlKTtcblxuICBwcml2YXRlIF9lZGl0TW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGVkaXRpbmdDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIGdldCBlZGl0aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmVkaXRhYmxlICYmIHRoaXMuX2VkaXRNb2RlO1xuICB9XG5cbiAgc2V0IGVkaXRpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5lZGl0YWJsZSkge1xuICAgICAgdGhpcy5fZWRpdE1vZGUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZWRpdGluZ0NoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zYXZlLmVtaXQobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbmQgb2YgdW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlLlxuICAgKi9cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLWhlYWRlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxoNCBjbGFzcz1cInN0YWNrLWhlYWRlclwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGFjay10aXRsZVwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhY2stYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5zdGFjay1hY3Rpb25cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPCEtLSBVbmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmU6IGlubGluZSBlZGl0aW5nLiAtLT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uICpuZ0lmPVwic3RhY2tWaWV3LmVkaXRhYmxlXCIgY2xhc3M9XCJzdGFjay1hY3Rpb24gYnRuIGJ0bi1zbSBidG4tbGlua1wiIFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInN0YWNrVmlldy5lZGl0aW5nID0gIXN0YWNrVmlldy5lZGl0aW5nXCIgdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgRWRpdFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwhLS0gRW5kIG9mIHVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZS4gLS0+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvaDQ+XG4gICAgYCxcbiAgLy8gQ3VzdG9tIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICAgIDpob3N0IHsgZGlzcGxheTogYmxvY2s7IH1cbiAgICBgLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja0hlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdGFja1ZpZXc6IENsclN0YWNrVmlldykge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbi8qKlxuICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAqL1xuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsclN0YWNrVmlldyB9IGZyb20gJy4vc3RhY2stdmlldyc7XG5cbmV4cG9ydCBjbGFzcyBTdGFja0NvbnRyb2wge1xuICBtb2RlbDogYW55O1xuICBtb2RlbENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzdGFja1ZpZXc6IENsclN0YWNrVmlldykge1xuICAgIC8vIE1ha2UgdGhlIENsclN0YWNrVmlldyBlZGl0YWJsZSwgc2luY2UgaXQgY29udGFpbnMgYSBTdGFja0NvbnRyb2xcbiAgICB0aGlzLnN0YWNrVmlldy5lZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5zdGFja1ZpZXcuZWRpdGluZ0NoYW5nZS5zdWJzY3JpYmUoKGVkaXRpbmc6IGJvb2xlYW4pID0+IHtcbiAgICAgIC8vIEVkaXQgbW9kZSB3YXMgY2xvc2VkXG4gICAgICBpZiAoIWVkaXRpbmcpIHtcbiAgICAgICAgdGhpcy5tb2RlbENoYW5nZS5lbWl0KHRoaXMubW9kZWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG4vKipcbiAqIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuXG4gKlxuICogVE9ETzogc3VwcG9ydCBtb3JlIHR5cGVzIG9mIGlucHV0czogY2hlY2tib3gsIHJhZGlvLCAuLi5cbiAqIFRPRE86IE1pcnJvciBpbnB1dCBhdHRyaWJ1dGVzIGZyb20gdGhlIGhvc3QgdG8gdGhlIGFjdHVhbCBpbnB1dDogc2l6ZSwgbWluLCBtYXgsIHBsYWNlaG9sZGVyLCAuLi5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN0YWNrQ29udHJvbCB9IGZyb20gJy4vc3RhY2stY29udHJvbCc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXcgfSBmcm9tICcuL3N0YWNrLXZpZXcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2staW5wdXQnLFxuICBpbnB1dHM6IFsnbW9kZWw6IGNsck1vZGVsJywgJ3R5cGUnXSxcbiAgb3V0cHV0czogWydtb2RlbENoYW5nZTogY2xyTW9kZWxDaGFuZ2UnXSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhc3RhY2tWaWV3LmVkaXRpbmdcIj57e21vZGVsfX08L3NwYW4+XG4gICAgICAgIDxpbnB1dCBbdHlwZV09XCJ0eXBlXCIgKm5nSWY9XCJzdGFja1ZpZXcuZWRpdGluZ1wiIFsobmdNb2RlbCldPVwibW9kZWxcIi8+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tJbnB1dCBleHRlbmRzIFN0YWNrQ29udHJvbCB7XG4gIHR5cGU6IHN0cmluZyA9ICd0ZXh0JztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3RhY2tWaWV3OiBDbHJTdGFja1ZpZXcpIHtcbiAgICBzdXBlcihzdGFja1ZpZXcpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG4vKipcbiAqIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuXG4gKlxuICogVE9ETzogT2ZmZXIgYSBhIHdheSB0byBjdXN0b21pemUgdGhlIHZhbHVlIGRpc3BsYXllZCwgcGxhaW4gdmFsdWUgbWF5IGJlIHVucmVhZGFibGUuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdGFja0NvbnRyb2wgfSBmcm9tICcuL3N0YWNrLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLXNlbGVjdCcsXG4gIGlucHV0czogWydtb2RlbDogY2xyTW9kZWwnXSxcbiAgb3V0cHV0czogWydtb2RlbENoYW5nZTogY2xyTW9kZWxDaGFuZ2UnXSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhc3RhY2tWaWV3LmVkaXRpbmdcIj57e21vZGVsfX08L3NwYW4+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWxlY3RcIiAqbmdJZj1cInN0YWNrVmlldy5lZGl0aW5nXCIgPlxuICAgICAgICAgICAgPHNlbGVjdCBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrU2VsZWN0IGV4dGVuZHMgU3RhY2tDb250cm9sIHtcbiAgY29uc3RydWN0b3IocHVibGljIHN0YWNrVmlldzogQ2xyU3RhY2tWaWV3KSB7XG4gICAgc3VwZXIoc3RhY2tWaWV3KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1zdGFjay1sYWJlbCwgY2xyLXN0YWNrLWNvbnRlbnQnIH0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tWaWV3Q3VzdG9tVGFncyB7XG4gIC8vIE5vIGJlaGF2aW9yXG4gIC8vIFRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gXCJkZWNsYXJlXCIgdGhlIHRhZyBpbiBBbmd1bGFyXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVU5JUVVFX0lEIH0gZnJvbSAnLi4vLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsclN0YWNrSW5wdXRdJyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWlucHV0XSc6ICd0cnVlJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICd1bmlxdWVJZCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrQ29udGVudElucHV0IHtcbiAgY29uc3RydWN0b3IoQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyB1bmlxdWVJZDogc3RyaW5nKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDbHJTdGFja0Jsb2NrIH0gZnJvbSAnLi9zdGFjay1ibG9jayc7XG5pbXBvcnQgeyBDbHJTdGFja0hlYWRlciB9IGZyb20gJy4vc3RhY2staGVhZGVyJztcbmltcG9ydCB7IENsclN0YWNrSW5wdXQgfSBmcm9tICcuL3N0YWNrLWlucHV0JztcbmltcG9ydCB7IENsclN0YWNrU2VsZWN0IH0gZnJvbSAnLi9zdGFjay1zZWxlY3QnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcbmltcG9ydCB7IENsclN0YWNrVmlld0N1c3RvbVRhZ3MgfSBmcm9tICcuL3N0YWNrLXZpZXctY3VzdG9tLXRhZ3MnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyU3RhY2tDb250ZW50SW5wdXQgfSBmcm9tICcuL3N0YWNrLWNvbnRlbnQtaW5wdXQnO1xuXG5leHBvcnQgY29uc3QgQ0xSX1NUQUNLX1ZJRVdfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbXG4gIENsclN0YWNrVmlldyxcbiAgQ2xyU3RhY2tIZWFkZXIsXG4gIENsclN0YWNrQmxvY2ssXG4gIENsclN0YWNrQ29udGVudElucHV0LFxuICBDbHJTdGFja1ZpZXdDdXN0b21UYWdzLFxuICAvKipcbiAgICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAgICovXG4gIENsclN0YWNrSW5wdXQsXG4gIENsclN0YWNrU2VsZWN0LFxuICAvKipcbiAgICogRW5kIG9mIHVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZS5cbiAgICovXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9TVEFDS19WSUVXX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1NUQUNLX1ZJRVdfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrVmlld01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vLyBUT0RPOiBJJ2QgbGlrZSB0aGlzIHRvIGJlIGEgQ2hlY2tlZFN0YXRlIGVudW0gZm9yIHRoZSBjaGVja2JveGVzIGluIHRoZSBmdXR1cmUuXG5leHBvcnQgZW51bSBDbHJTZWxlY3RlZFN0YXRlIHtcbiAgLy8gV0FSTklORyEgVW5zZWxlY3RlZCBoYXMgdGhlIHZhbHVlIDAsXG4gIC8vIHNvIGl0J3MgYWN0dWFsbHkgdGhlIG9ubHkgb25lIHRoYXQgd2lsbCBldmFsdWF0ZSB0byBmYWxzZSBpZiBjYXN0IHRvIGEgYm9vbGVhbi5cbiAgLy8gRG9uJ3QgbWVzcyB3aXRoIHRoZSBvcmRlciFcbiAgVU5TRUxFQ1RFRCA9IDAsXG4gIFNFTEVDVEVELFxuICBJTkRFVEVSTUlOQVRFLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDbHJTZWxlY3RlZFN0YXRlIH0gZnJvbSAnLi9zZWxlY3RlZC1zdGF0ZS5lbnVtJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJlZU5vZGVNb2RlbDxUPiB7XG4gIHNlbGVjdGVkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDbHJTZWxlY3RlZFN0YXRlPihDbHJTZWxlY3RlZFN0YXRlLlVOU0VMRUNURUQpO1xuICBtb2RlbDogVCB8IG51bGw7XG4gIC8qXG4gICAqIElkZWFsbHksIEkgd291bGQgbGlrZSB0byB1c2UgYSBwb2x5bW9ycGhpYyB0aGlzIHR5cGUgaGVyZSB0byBlbnN1cmUgaG9tb2dlbmVpdHkgb2YgdGhlIHRyZWUsIHNvbWV0aGluZyBsaWtlOlxuICAgKiBhYnN0cmFjdCBwYXJlbnQ6IHRoaXM8VD4gfCBudWxsO1xuICAgKiBhYnN0cmFjdCBjaGlsZHJlbjogdGhpczxUPltdO1xuICAgKiBCdXQgSSdtIGhpdHRpbmcgbGltaXRhdGlvbnMgb24gdHlwZXNjcmlwdCBub3QgYWxsb3dpbmcgdGhhdCB0eXBlIGluIGNvbnN0cnVjdG9ycyBvciBzdGF0aWMgbWV0aG9kcy5cbiAgICogU28gSSdtIHJlc29ydGluZyB0byBmb3JjaW5nIG92ZXJyaWRlIHdpdGggbW9yZSBwcmVjaXNlIHR5cGVzIGJ5IG1hcmtpbmcgdGhlc2UgYWJzdHJhY3QuXG4gICAqL1xuICBhYnN0cmFjdCBwYXJlbnQ6IFRyZWVOb2RlTW9kZWw8VD4gfCBudWxsO1xuICBhYnN0cmFjdCBjaGlsZHJlbjogVHJlZU5vZGVNb2RlbDxUPltdO1xuXG4gIC8qXG4gICAqIEJlaW5nIGFibGUgdG8gcHVzaCB0aGlzIGRvd24gdG8gdGhlIFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwgd291bGQgcmVxdWlyZSB0b28gbXVjaCB3b3JrIG9uIHRoZSBhbmd1bGFyIGNvbXBvbmVudHNcbiAgICogcmlnaHQgbm93IGZvciB0aGVtIHRvIGtub3cgd2hpY2gga2luZCBvZiBtb2RlbCB0aGV5IGFyZSB1c2luZy4gU28gSSdtIGxpZnRpbmcgdGhlIHB1YmxpYyBwcm9wZXJ0aWVzIHRvIHRoaXNcbiAgICogYWJzdHJhY3QgcGFyZW50IGNsYXNzIGZvciBub3cgYW5kIHdlIGNhbiByZXZpc2l0IGl0IGxhdGVyLCB3aGVuIHdlJ3JlIG5vdCBmYWNpbmcgc3VjaCBhIGNsb3NlIGRlYWRsaW5lLlxuICAgKi9cbiAgbG9hZGluZyA9IGZhbHNlO1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gSnVzdCB0byBiZSBzYWZlXG4gICAgdGhpcy5zZWxlY3RlZC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLy8gUHJvcGFnYXRlIGJ5IGRlZmF1bHQgd2hlbiBlYWdlciwgZG9uJ3QgcHJvcGFnYXRlIGluIHRoZSBsYXp5LWxvYWRlZCB0cmVlLlxuICBzZXRTZWxlY3RlZChzdGF0ZTogQ2xyU2VsZWN0ZWRTdGF0ZSwgcHJvcGFnYXRlVXA6IGJvb2xlYW4sIHByb3BhZ2F0ZURvd246IGJvb2xlYW4pIHtcbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuc2VsZWN0ZWQudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZC5uZXh0KHN0YXRlKTtcbiAgICBpZiAocHJvcGFnYXRlRG93biAmJiBzdGF0ZSAhPT0gQ2xyU2VsZWN0ZWRTdGF0ZS5JTkRFVEVSTUlOQVRFICYmIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5zZXRTZWxlY3RlZChzdGF0ZSwgZmFsc2UsIHRydWUpKTtcbiAgICB9XG4gICAgaWYgKHByb3BhZ2F0ZVVwICYmIHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5fdXBkYXRlU2VsZWN0aW9uRnJvbUNoaWxkcmVuKCk7XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlU2VsZWN0aW9uKHByb3BhZ2F0ZTogYm9vbGVhbikge1xuICAgIC8vIEJvdGggdW5zZWxlY3RlZCBhbmQgaW5kZXRlcm1pbmF0ZSB0b2dnbGUgdG8gc2VsZWN0ZWRcbiAgICBjb25zdCBuZXdTdGF0ZSA9XG4gICAgICB0aGlzLnNlbGVjdGVkLnZhbHVlID09PSBDbHJTZWxlY3RlZFN0YXRlLlNFTEVDVEVEID8gQ2xyU2VsZWN0ZWRTdGF0ZS5VTlNFTEVDVEVEIDogQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRDtcbiAgICAvLyBOT1RFOiB3ZSBhbHdheXMgcHJvcGFnYXRlIHNlbGVjdGlvbiB1cCBpbiB0aGlzIG1ldGhvZCBiZWNhdXNlIGl0IGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIHVzZXIgdGFrZXMgYW4gYWN0aW9uLlxuICAgIC8vIEl0IHNob3VsZCBuZXZlciBiZSBjYWxsZWQgZnJvbSBsaWZlY3ljbGUgaG9va3Mgb3IgYXBwLXByb3ZpZGVkIGlucHV0cy5cbiAgICB0aGlzLnNldFNlbGVjdGVkKG5ld1N0YXRlLCB0cnVlLCBwcm9wYWdhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlU2VsZWN0aW9uU3RhdGVGcm9tQ2hpbGRyZW4oKSB7XG4gICAgbGV0IG9uZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgbGV0IG9uZVVuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAvLyBVc2luZyBhIGdvb2Qgb2xkIGZvciBsb29wIHRvIGV4aXQgYXMgc29vbiBhcyB3ZSBjYW4gdGVsbCwgZm9yIGJldHRlciBwZXJmb3JtYW5jZSBvbiBsYXJnZSB0cmVlcy5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHN3aXRjaCAoY2hpbGQuc2VsZWN0ZWQudmFsdWUpIHtcbiAgICAgICAgY2FzZSBDbHJTZWxlY3RlZFN0YXRlLklOREVURVJNSU5BVEU6XG4gICAgICAgICAgcmV0dXJuIENsclNlbGVjdGVkU3RhdGUuSU5ERVRFUk1JTkFURTtcbiAgICAgICAgY2FzZSBDbHJTZWxlY3RlZFN0YXRlLlNFTEVDVEVEOlxuICAgICAgICAgIG9uZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob25lVW5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIENsclNlbGVjdGVkU3RhdGUuSU5ERVRFUk1JTkFURTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2xyU2VsZWN0ZWRTdGF0ZS5VTlNFTEVDVEVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIERlZmF1bHQgaXMgdGhlIHNhbWUgYXMgdW5zZWxlY3RlZCwgaW4gY2FzZSBhbiB1bmRlZmluZWQgc29tZWhvdyBtYWRlIGl0IGFsbCB0aGUgd2F5IGhlcmUuXG4gICAgICAgICAgb25lVW5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKG9uZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xyU2VsZWN0ZWRTdGF0ZS5JTkRFVEVSTUlOQVRFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvbmVTZWxlY3RlZCkge1xuICAgICAgcmV0dXJuIENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9IGVsc2UgaWYgKCFvbmVVbnNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRDtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBJbnRlcm5hbCwgYnV0IG5lZWRzIHRvIGJlIGNhbGxlZCBieSBvdGhlciBub2Rlc1xuICAgKi9cbiAgX3VwZGF0ZVNlbGVjdGlvbkZyb21DaGlsZHJlbigpIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuY29tcHV0ZVNlbGVjdGlvblN0YXRlRnJvbUNoaWxkcmVuKCk7XG4gICAgaWYgKG5ld1N0YXRlID09PSB0aGlzLnNlbGVjdGVkLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0ZWQubmV4dChuZXdTdGF0ZSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5fdXBkYXRlU2VsZWN0aW9uRnJvbUNoaWxkcmVuKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IFRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL3RyZWUtbm9kZS5tb2RlbCc7XG5cbi8qXG4gKiBBIGRlY2xhcmF0aXZlIG1vZGVsIGlzIGJ1aWx0IGJ5IHRyYXZlcnNpbmcgdGhlIEFuZ3VsYXIgY29tcG9uZW50IHRyZWUuXG4gKiBEZWNsYXJhdGl2ZSA9IFRyZWUgbm9kZSBjb21wb25lbnRzIGRpY3RhdGUgdGhlIG1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4gZXh0ZW5kcyBUcmVlTm9kZU1vZGVsPFQ+IHtcbiAgY29uc3RydWN0b3IocGFyZW50OiBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4gfCBudWxsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuX2FkZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gIH1cblxuICAvLyBPdmVycmlkZSBmb3IgYSBtb3JlIHByZWNpc2UgdHlwZVxuICBwYXJlbnQ6IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbDxUPiB8IG51bGw7XG4gIGNoaWxkcmVuOiBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD5bXTtcblxuICBfYWRkQ2hpbGQoY2hpbGQ6IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbDxUPikge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIH1cblxuICBfcmVtb3ZlQ2hpbGQoY2hpbGQ6IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbDxUPikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3JlY3Vyc2l2ZS10cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQ2xyUmVjdXJzaXZlRm9yT2ZDb250ZXh0IH0gZnJvbSAnLi9yZWN1cnNpdmUtZm9yLW9mJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4ge1xuICBzZWxlY3RhYmxlID0gZmFsc2U7XG4gIGVhZ2VyID0gdHJ1ZTtcbiAgcmVjdXJzaW9uOiB7XG4gICAgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPj47XG4gICAgcm9vdDogUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPltdO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJlZUZlYXR1cmVzRmFjdG9yeTxUPihleGlzdGluZzogVHJlZUZlYXR1cmVzU2VydmljZTxUPikge1xuICByZXR1cm4gZXhpc3RpbmcgfHwgbmV3IFRyZWVGZWF0dXJlc1NlcnZpY2UoKTtcbn1cblxuZXhwb3J0IGNvbnN0IFRSRUVfRkVBVFVSRVNfUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IFRyZWVGZWF0dXJlc1NlcnZpY2UsXG4gIHVzZUZhY3Rvcnk6IHRyZWVGZWF0dXJlc0ZhY3RvcnksXG4gIC8qXG4gICAqIFRoZSBPcHRpb25hbCArIFNraXBTZWxmIHBhdHRlcm4gZW5zdXJlcyB0aGF0IGluIGNhc2Ugb2YgbmVzdGVkIGNvbXBvbmVudHMsIG9ubHkgdGhlIHJvb3Qgb25lIHdpbGxcbiAgICogaW5zdGFudGlhdGUgYSBuZXcgc2VydmljZSBhbmQgYWxsIGl0cyBjaGlsZHJlbiB3aWxsIHJldXNlIHRoZSByb290J3MgaW5zdGFuY2UuXG4gICAqIElmIHRoZXJlIGFyZSBzZXZlcmFsIHJvb3RzIChpbiB0aGlzIGNhc2UsIHNldmVyYWwgaW5kZXBlbmRlbnQgdHJlZXMgb24gYSBwYWdlKSwgZWFjaCByb290IHdpbGwgaW5zdGFudGlhdGVcbiAgICogaXRzIG93biBzZXJ2aWNlIHNvIHRoZXkgd29uJ3QgaW50ZXJmZXJlIHdpdGggb25lIGFub3RoZXIuXG4gICAqXG4gICAqIFRMO0RSIC0gT3B0aW9uYWwgKyBTa2lwU2VsZiA9IDEgaW5zdGFuY2Ugb2YgVHJlZUZlYXR1cmVzU2VydmljZSBwZXIgdHJlZS5cbiAgICovXG4gIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBUcmVlRmVhdHVyZXNTZXJ2aWNlXV0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBhbmltYXRlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBTa2lwU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVU5JUVVFX0lELCBVTklRVUVfSURfUFJPVklERVIgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcbmltcG9ydCB7IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL2RlY2xhcmF0aXZlLXRyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBDbHJTZWxlY3RlZFN0YXRlIH0gZnJvbSAnLi9tb2RlbHMvc2VsZWN0ZWQtc3RhdGUuZW51bSc7XG5pbXBvcnQgeyBUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi9tb2RlbHMvdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IFRSRUVfRkVBVFVSRVNfUFJPVklERVIsIFRyZWVGZWF0dXJlc1NlcnZpY2UgfSBmcm9tICcuL3RyZWUtZmVhdHVyZXMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10cmVlLW5vZGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vdHJlZS1ub2RlLmh0bWwnLFxuICBwcm92aWRlcnM6IFtVTklRVUVfSURfUFJPVklERVIsIFRSRUVfRkVBVFVSRVNfUFJPVklERVIsIEV4cGFuZCwgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBFeHBhbmQgfV0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdjaGlsZE5vZGVzU3RhdGUnLCBbXG4gICAgICBzdGF0ZSgnZXhwYW5kZWQnLCBzdHlsZSh7IGhlaWdodDogJyonLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nIH0pKSxcbiAgICAgIHN0YXRlKCdjb2xsYXBzZWQnLCBzdHlsZSh7IGhlaWdodDogMCwgJ292ZXJmbG93LXknOiAnaGlkZGVuJyB9KSksXG4gICAgICB0cmFuc2l0aW9uKCdleHBhbmRlZCA8PT4gY29sbGFwc2VkJywgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpKSxcbiAgICBdKSxcbiAgXSxcbiAgaG9zdDogeyAnW2NsYXNzLmNsci10cmVlLW5vZGVdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRyZWVOb2RlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBTVEFURVMgPSBDbHJTZWxlY3RlZFN0YXRlO1xuICBwcml2YXRlIHNraXBFbWl0Q2hhbmdlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBub2RlSWQ6IHN0cmluZyxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcGFyZW50OiBDbHJUcmVlTm9kZTxUPixcbiAgICBwdWJsaWMgZmVhdHVyZXNTZXJ2aWNlOiBUcmVlRmVhdHVyZXNTZXJ2aWNlPFQ+LFxuICAgIHB1YmxpYyBleHBhbmRTZXJ2aWNlOiBFeHBhbmQsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIGluamVjdG9yOiBJbmplY3RvclxuICApIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uKSB7XG4gICAgICAvLyBJJ20gY29tcGxldGVseSBzdHVjaywgd2UgaGF2ZSB0byBoYWNrIGludG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIHVudGlsIGVpdGhlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTQ5MzUgb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU5OThcbiAgICAgIC8vIGFyZSBmaXhlZFxuICAgICAgdGhpcy5fbW9kZWwgPSAoPGFueT5pbmplY3Rvcikudmlldy5jb250ZXh0LmNsck1vZGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JjZSBjYXN0IGZvciBub3csIG5vdCBzdXJlIGhvdyB0byB0aWUgdGhlIGNvcnJlY3QgdHlwZSBoZXJlIHRvIGZlYXR1cmVzU2VydmljZS5yZWN1cnNpb25cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbChwYXJlbnQgPyA8RGVjbGFyYXRpdmVUcmVlTm9kZU1vZGVsPFQ+PnBhcmVudC5fbW9kZWwgOiBudWxsKTtcbiAgICB9XG4gIH1cblxuICBfbW9kZWw6IFRyZWVOb2RlTW9kZWw8VD47XG5cbiAgaXNFeHBhbmRhYmxlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5leHBhbmRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZTtcbiAgICB9XG4gICAgcmV0dXJuICEhdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZGFibGUgfHwgdGhpcy5fbW9kZWwuY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyU2VsZWN0ZWQnKVxuICBnZXQgc2VsZWN0ZWQoKTogQ2xyU2VsZWN0ZWRTdGF0ZSB8IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5zZWxlY3RlZC52YWx1ZTtcbiAgfVxuICBzZXQgc2VsZWN0ZWQodmFsdWU6IENsclNlbGVjdGVkU3RhdGUgfCBib29sZWFuKSB7XG4gICAgdGhpcy5mZWF0dXJlc1NlcnZpY2Uuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgZmFsc3kgc3RhdGVzIGxpa2UgbnVsbCBvciB1bmRlZmluZWQgYmVjYXVzZSBpdCdzIGp1c3QgZWFzaWVyIHRoYW4gYW5zd2VyaW5nIHF1ZXN0aW9ucy5cbiAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gd2l0aCBzdHJpY3QgdHlwaW5nIG9uIHRoZSBhcHAncyBzaWRlLCBidXQgaXQncyBub3QgdXAgdG8gdXMuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gQ2xyU2VsZWN0ZWRTdGF0ZS5VTlNFTEVDVEVEO1xuICAgIH1cbiAgICAvLyBXZSBtYXRjaCBib29sZWFucyB0byB0aGUgY29ycmVzcG9uZGluZyBDbHJTZWxlY3RlZFN0YXRlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID8gQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRCA6IENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9XG4gICAgLy8gV2UgcHJvcGFnYXRlIG9ubHkgaWYgdGhlIHRyZWUgaXMgaW4gc21hcnQgbW9kZSwgYW5kIHNraXAgZW1pdHRpbmcgdGhlIG91dHB1dCB3aGVuIHdlIHNldCB0aGUgaW5wdXRcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS9jbGFyaXR5L2lzc3Vlcy8zMDczXG4gICAgdGhpcy5za2lwRW1pdENoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fbW9kZWwuc2V0U2VsZWN0ZWQodmFsdWUsIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyLCB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlcik7XG4gICAgdGhpcy5za2lwRW1pdENoYW5nZSA9IGZhbHNlO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyU2VsZWN0ZWRDaGFuZ2UnKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Q2xyU2VsZWN0ZWRTdGF0ZT4oZmFsc2UpO1xuXG4gIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgZ2V0IHRyZWVOb2RlUm9sZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5wYXJlbnQgPyAndHJlZWl0ZW0nIDogJ3RyZWUnO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtbXVsdGlzZWxlY3RhYmxlJylcbiAgZ2V0IHJvb3RBcmlhTXVsdGlTZWxlY3RhYmxlKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl9tb2RlbC5wYXJlbnQgfHwgIXRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1zZWxlY3RlZCcpXG4gIGdldCBhcmlhU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgPyB0aGlzLl9tb2RlbC5zZWxlY3RlZC52YWx1ZSA9PT0gQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRCA6IG51bGw7XG4gIH1cblxuICAvLyBBbGxvd3MgdGhlIGNvbnN1bWVyIHRvIG92ZXJyaWRlIG91ciBsb2dpYyBkZWNpZGluZyBpZiBhIG5vZGUgaXMgZXhwYW5kYWJsZS5cbiAgLy8gVXNlZnVsIGZvciByZWN1cnNpdmUgdHJlZXMgdGhhdCBkb24ndCB3YW50IHRvIHByZS1sb2FkIG9uZSBsZXZlbCBhaGVhZCBqdXN0IHRvIGtub3cgd2hpY2ggbm9kZXMgYXJlIGV4cGFuZGFibGUuXG4gIEBJbnB1dCgnY2xyRXhwYW5kYWJsZScpIGV4cGFuZGFibGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgLy8gSSdtIGNhdmluZyBvbiB0aGlzLCBmb3IgdHJlZSBub2RlcyBJIHRoaW5rIHdlIGNhbiB0b2xlcmF0ZSBoYXZpbmcgYSB0d28td2F5IGJpbmRpbmcgb24gdGhlIGNvbXBvbmVudFxuICAvLyByYXRoZXIgdGhhbiBlbmZvcmNlIHRoZSBjbHJJZkV4cGFuZGVkIHN0cnVjdHVyYWwgZGlyZWN0aXZlIGZvciBkeW5hbWljIGNhc2VzLiBNb3N0bHkgYmVjYXVzZSBmb3IgdGhlIHNtYXJ0XG4gIC8vIGNhc2UsIHlvdSBjYW4ndCB1c2UgYSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSwgaXQgd291bGQgbmVlZCB0byBnbyBvbiBhbiBuZy1jb250YWluZXIuXG4gIEBJbnB1dCgnY2xyRXhwYW5kZWQnKVxuICBnZXQgZXhwYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZDtcbiAgfVxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckV4cGFuZGVkQ2hhbmdlJykgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5fbW9kZWwuc2VsZWN0ZWQucGlwZShmaWx0ZXIoKCkgPT4gIXRoaXMuc2tpcEVtaXRDaGFuZ2UpKS5zdWJzY3JpYmUodmFsdWUgPT4gdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHZhbHVlKSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKHZhbHVlID0+IHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSkpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX21vZGVsLmRlc3Ryb3koKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRSRUVfRkVBVFVSRVNfUFJPVklERVIsIFRyZWVGZWF0dXJlc1NlcnZpY2UgfSBmcm9tICcuL3RyZWUtZmVhdHVyZXMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10cmVlJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPGNsci1yZWN1cnNpdmUtY2hpbGRyZW4gKm5nSWY9XCJmZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2hpbGRyZW5dPVwiZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbi5yb290XCI+PC9jbHItcmVjdXJzaXZlLWNoaWxkcmVuPlxuICBgLFxuICBwcm92aWRlcnM6IFtUUkVFX0ZFQVRVUkVTX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZTxUPiB7XG4gIC8vIFRoaXMgY29tcG9uZW50IGNhbiBhbHNvIGJlIHVzZWQganVzdCB0byBkZWNsYXJlIHByb3ZpZGVycyBvbmNlIGZvciB0cmVlcyB3aXRoIG11bHRpcGxlIHJvb3Qgbm9kZXMuXG5cbiAgY29uc3RydWN0b3IocHVibGljIGZlYXR1cmVzU2VydmljZTogVHJlZUZlYXR1cmVzU2VydmljZTxUPikge31cblxuICBASW5wdXQoJ2NsckxhenknKVxuICBzZXQgbGF6eSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyID0gIXZhbHVlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHBlb3BsZSBjYW4gZ2l2ZSB1cyBudWxsIG9yIHVuZGVmaW5lZCBjaGlsZHJlbiBldmVuIGlmIHRoZXkgcnVuIHN0cmljdCB0eXBlIGNoZWNraW5nLlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgdHlwZSBBc3luY0FycmF5PFQ+ID1cbiAgfCBUW11cbiAgfCBudWxsXG4gIHwgdW5kZWZpbmVkXG4gIHwgUHJvbWlzZTxUW10gfCBudWxsIHwgdW5kZWZpbmVkPlxuICB8IE9ic2VydmFibGU8VFtdIHwgbnVsbCB8IHVuZGVmaW5lZD47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2U8VD4obzogQXN5bmNBcnJheTxUPik6IG8gaXMgUHJvbWlzZTxUW10+IHtcbiAgLy8gU2hhbWVsZXNzbHkgY29waWVkIGZyb20gZXZlcnkgb3Blbi1zb3VyY2UgcHJvamVjdCBvdXQgdGhlcmUuXG4gIHJldHVybiBvICYmIHR5cGVvZiAoPGFueT5vKS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc09ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi90cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQXN5bmNBcnJheSwgaXNQcm9taXNlIH0gZnJvbSAnLi9hc3luYy1hcnJheSc7XG5cbi8qXG4gKiBBIHJlY3Vyc2l2ZSBtb2RlbCBpcyBidWlsdCByZWNlaXZlZCBmcm9tIHRoZSBhcHAgYW5kIHRyYXZlcnNlZCB0byBjcmVhdGUgdGhlIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50cy5cbiAqIFJlY3Vyc2l2ZSA9IE1vZGVsIGRpY3RhdGVzIHRoZSB0cmVlIG5vZGUgY29tcG9uZW50c1xuICovXG5leHBvcnQgY2xhc3MgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPiBleHRlbmRzIFRyZWVOb2RlTW9kZWw8VD4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBtb2RlbDogVCxcbiAgICBwYXJlbnQ6IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWw8VD4gfCBudWxsLFxuICAgIHByaXZhdGUgZ2V0Q2hpbGRyZW46IChub2RlOiBUKSA9PiBBc3luY0FycmF5PFQ+IHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG5cbiAgcGFyZW50OiBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsPFQ+IHwgbnVsbDtcblxuICBwcml2YXRlIGNoaWxkcmVuRmV0Y2hlZCA9IGZhbHNlO1xuXG4gIGNsZWFyQ2hpbGRyZW4oKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5kZXN0cm95KCkpO1xuICAgIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbjtcbiAgICB0aGlzLmNoaWxkcmVuRmV0Y2hlZCA9IGZhbHNlO1xuICB9XG5cbiAgZmV0Y2hDaGlsZHJlbigpIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbkZldGNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhc3luY0NoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbih0aGlzLm1vZGVsKTtcbiAgICBpZiAoaXNQcm9taXNlKGFzeW5jQ2hpbGRyZW4pKSB7XG4gICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgYXN5bmNDaGlsZHJlbi50aGVuKHJhdyA9PiB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gdGhpcy53cmFwQ2hpbGRyZW4ocmF3KTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZShhc3luY0NoaWxkcmVuKSkge1xuICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gYXN5bmNDaGlsZHJlbi5zdWJzY3JpYmUocmF3ID0+IHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSB0aGlzLndyYXBDaGlsZHJlbihyYXcpO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoYXN5bmNDaGlsZHJlbikge1xuICAgICAgLy8gU3luY2hyb25vdXMgY2FzZVxuICAgICAgdGhpcy5fY2hpbGRyZW4gPSB0aGlzLndyYXBDaGlsZHJlbihhc3luY0NoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jaGlsZHJlbkZldGNoZWQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSB3cmFwQ2hpbGRyZW4ocmF3TW9kZWxzOiBUW10pIHtcbiAgICByZXR1cm4gcmF3TW9kZWxzLm1hcChtID0+IG5ldyBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsKG0sIHRoaXMsIHRoaXMuZ2V0Q2hpbGRyZW4pKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NoaWxkcmVuOiBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsPFQ+W10gPSBbXTtcbiAgZ2V0IGNoaWxkcmVuKCk6IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWw8VD5bXSB7XG4gICAgdGhpcy5mZXRjaENoaWxkcmVuKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICB9XG4gIHNldCBjaGlsZHJlbih2YWx1ZTogUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPltdKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4gPSB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkNoYW5nZXMsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmVlRmVhdHVyZXNTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZlYXR1cmVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3JlY3Vyc2l2ZS10cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3RyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBBc3luY0FycmF5IH0gZnJvbSAnLi9tb2RlbHMvYXN5bmMtYXJyYXknO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPiB7XG4gICRpbXBsaWNpdDogVDtcbiAgY2xyTW9kZWw6IFRyZWVOb2RlTW9kZWw8VD47XG59XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJSZWN1cnNpdmVGb3JdW2NsclJlY3Vyc2l2ZUZvck9mXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJSZWN1cnNpdmVGb3JPZjxUPiBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPj4sXG4gICAgcHJpdmF0ZSBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD5cbiAgKSB7fVxuXG4gIC8vIFRPRE86IGFjY2VwdCBOZ0l0ZXJhYmxlPFQ+XG4gIEBJbnB1dCgnY2xyUmVjdXJzaXZlRm9yT2YnKSBub2RlczogVCB8IFRbXTtcblxuICAvLyBUT0RPOiBhY2NlcHQgTmdJdGVyYWJsZTxUPiByZXR1cm4gdHlwZVxuICBASW5wdXQoJ2NsclJlY3Vyc2l2ZUZvckdldENoaWxkcmVuJykgZ2V0Q2hpbGRyZW46IChub2RlOiBUKSA9PiBBc3luY0FycmF5PFQ+O1xuXG4gIC8vIEknbSB1c2luZyBPbkNoYW5nZXMgaW5zdGVhZCBvZiBPbkluaXQgdG8gZWFzaWx5IGtlZXAgdXAgdG8gZGF0ZSB3aXRoIGR5bmFtaWMgdHJlZXMuIE1heWJlIG9wdGltaXphYmxlIGxhdGVyLlxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBsZXQgd3JhcHBlZDogUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPltdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubm9kZXMpKSB7XG4gICAgICB3cmFwcGVkID0gdGhpcy5ub2Rlcy5tYXAobm9kZSA9PiBuZXcgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbChub2RlLCBudWxsLCB0aGlzLmdldENoaWxkcmVuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyYXBwZWQgPSBbbmV3IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwodGhpcy5ub2RlcywgbnVsbCwgdGhpcy5nZXRDaGlsZHJlbildO1xuICAgIH1cbiAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24gPSB7XG4gICAgICB0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgICAgIHJvb3Q6IHdyYXBwZWQsXG4gICAgfTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kJztcbmltcG9ydCB7IFRyZWVGZWF0dXJlc1NlcnZpY2UgfSBmcm9tICcuL3RyZWUtZmVhdHVyZXMuc2VydmljZSc7XG5pbXBvcnQgeyBUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi9tb2RlbHMvdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dCB9IGZyb20gJy4vcmVjdXJzaXZlLWZvci1vZic7XG5pbXBvcnQgeyBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi9tb2RlbHMvcmVjdXJzaXZlLXRyZWUtbm9kZS5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1yZWN1cnNpdmUtY2hpbGRyZW4nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJzaG91bGRSZW5kZXIoKVwiPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY2hpbGQgb2YgcGFyZW50Py5jaGlsZHJlbiB8fCBjaGlsZHJlblwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbi50ZW1wbGF0ZTsgY29udGV4dDogZ2V0Q29udGV4dChjaGlsZClcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxufSlcbi8qKlxuICogSW50ZXJuYWwgY29tcG9uZW50LCBkbyBub3QgZXhwb3J0IVxuICogVGhpcyBpcyBwYXJ0IG9mIHRoZSBoYWNrIHRvIGdldCBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU5OThcbiAqL1xuZXhwb3J0IGNsYXNzIFJlY3Vyc2l2ZUNoaWxkcmVuPFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIGZlYXR1cmVzU2VydmljZTogVHJlZUZlYXR1cmVzU2VydmljZTxUPiwgQE9wdGlvbmFsKCkgcHJpdmF0ZSBleHBhbmRTZXJ2aWNlOiBFeHBhbmQpIHtcbiAgICBpZiAoZXhwYW5kU2VydmljZSkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy5wYXJlbnQgJiYgIXRoaXMuZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyICYmIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbikge1xuICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGxhenktbG9hZGluZyByZWN1cnNpdmUgdHJlZXMsIHdlIGNsZWFyIHRoZSBjaGlsZHJlbiBvbiBjb2xsYXBzZS5cbiAgICAgICAgICAvLyBUaGlzIGlzIGJldHRlciBpbiBjYXNlIHRoZXkgY2hhbmdlIGJldHdlZW4gdHdvIHVzZXIgaW50ZXJhY3Rpb24sIGFuZCB0aGF0IHdheVxuICAgICAgICAgIC8vIHRoZSBhcHAgaXRzZWxmIGNhbiBkZWNpZGUgd2hldGhlciB0byBjYWNoZSB0aGVtIG9yIG5vdC5cbiAgICAgICAgICAoPFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWw8VD4+dGhpcy5wYXJlbnQpLmNsZWFyQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc2hvdWxkUmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24gJiZcbiAgICAgIC8vIEluIHRoZSBzbWFydCBjYXNlLCB3ZSBlYWdlcmx5IHJlbmRlciBhbGwgdGhlIHJlY3Vyc2l2ZSBjaGlsZHJlblxuICAgICAgLy8gdG8gbWFrZSBzdXJlIHR3by13YXkgYmluZGluZ3MgZm9yIHNlbGVjdGlvbiBhcmUgYXZhaWxhYmxlLlxuICAgICAgLy8gVGhleSB3aWxsIGJlIGhpZGRlbiB3aXRoIENTUyBieSB0aGUgcGFyZW50LlxuICAgICAgKHRoaXMuZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyIHx8ICF0aGlzLmV4cGFuZFNlcnZpY2UgfHwgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZGVkKVxuICAgICk7XG4gIH1cblxuICAvLyBPZmZlcmluZyB0aGUgb3B0aW9uIHRvIGVpdGhlciBnaXZlIHRoZSBwYXJlbnQgbm9kZSB0byByZWN1cnNlIHBvdGVudGlhbGx5IGxhemlseSxcbiAgLy8gb3IgZGlyZWN0bHkgdGhlIGxpc3Qgb2YgY2hpbGRyZW4gdG8gZGlzcGxheS5cbiAgQElucHV0KCdwYXJlbnQnKSBwYXJlbnQ6IFRyZWVOb2RlTW9kZWw8VD47XG4gIEBJbnB1dCgnY2hpbGRyZW4nKSBjaGlsZHJlbjogVHJlZU5vZGVNb2RlbDxUPltdO1xuXG4gIGdldENvbnRleHQobm9kZTogVHJlZU5vZGVNb2RlbDxUPik6IENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICRpbXBsaWNpdDogbm9kZS5tb2RlbCxcbiAgICAgIGNsck1vZGVsOiBub2RlLFxuICAgIH07XG4gIH1cblxuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJMb2FkaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJZkV4cGFuZE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGFuZC9pZi1leHBhbmQubW9kdWxlJztcbmltcG9ydCB7IENsclRyZWVOb2RlIH0gZnJvbSAnLi90cmVlLW5vZGUnO1xuaW1wb3J0IHsgQ2xyVHJlZSB9IGZyb20gJy4vdHJlZSc7XG5pbXBvcnQgeyBDbHJSZWN1cnNpdmVGb3JPZiB9IGZyb20gJy4vcmVjdXJzaXZlLWZvci1vZic7XG5pbXBvcnQgeyBSZWN1cnNpdmVDaGlsZHJlbiB9IGZyb20gJy4vcmVjdXJzaXZlLWNoaWxkcmVuJztcblxuZXhwb3J0IGNvbnN0IENMUl9UUkVFX1ZJRVdfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyVHJlZSwgQ2xyVHJlZU5vZGUsIENsclJlY3Vyc2l2ZUZvck9mXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyTG9hZGluZ01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9UUkVFX1ZJRVdfRElSRUNUSVZFUywgUmVjdXJzaXZlQ2hpbGRyZW5dLFxuICBleHBvcnRzOiBbQ0xSX1RSRUVfVklFV19ESVJFQ1RJVkVTLCBDbHJJZkV4cGFuZE1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRyZWVWaWV3TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZE1vZHVsZSB9IGZyb20gJy4vZGF0YWdyaWQvZGF0YWdyaWQubW9kdWxlJztcbmltcG9ydCB7IENsclN0YWNrVmlld01vZHVsZSB9IGZyb20gJy4vc3RhY2stdmlldy9zdGFjay12aWV3Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJUcmVlVmlld01vZHVsZSB9IGZyb20gJy4vdHJlZS12aWV3L3RyZWUtdmlldy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoeyBleHBvcnRzOiBbQ2xyRGF0YWdyaWRNb2R1bGUsIENsclN0YWNrVmlld01vZHVsZSwgQ2xyVHJlZVZpZXdNb2R1bGVdIH0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YU1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGb2N1c2FibGVJdGVtIHtcbiAgaWQ6IHN0cmluZztcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xuXG4gIGFic3RyYWN0IGZvY3VzKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGJsdXIoKTogdm9pZDtcbiAgYWJzdHJhY3QgYWN0aXZhdGU/KCk6IHZvaWQ7XG5cbiAgdXA/OiBGb2N1c2FibGVJdGVtIHwgT2JzZXJ2YWJsZTxGb2N1c2FibGVJdGVtPjtcbiAgZG93bj86IEZvY3VzYWJsZUl0ZW0gfCBPYnNlcnZhYmxlPEZvY3VzYWJsZUl0ZW0+O1xuICBsZWZ0PzogRm9jdXNhYmxlSXRlbSB8IE9ic2VydmFibGU8Rm9jdXNhYmxlSXRlbT47XG4gIHJpZ2h0PzogRm9jdXNhYmxlSXRlbSB8IE9ic2VydmFibGU8Rm9jdXNhYmxlSXRlbT47XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVOSVFVRV9JRF9QUk9WSURFUiB9IGZyb20gJy4uLy4uL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBGb2N1c2FibGVJdGVtIH0gZnJvbSAnLi9mb2N1c2FibGUtaXRlbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21Gb2N1c2FibGVJdGVtUHJvdmlkZXI8VD4oaW1wbGVtZW50YXRpb246IFR5cGU8VD4pIHtcbiAgcmV0dXJuIFtcbiAgICBVTklRVUVfSURfUFJPVklERVIsXG4gICAgaW1wbGVtZW50YXRpb24sXG4gICAge1xuICAgICAgcHJvdmlkZTogRm9jdXNhYmxlSXRlbSxcbiAgICAgIHVzZUV4aXN0aW5nOiBpbXBsZW1lbnRhdGlvbixcbiAgICB9LFxuICBdO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgZW51bSBBcnJvd0tleURpcmVjdGlvbiB7XG4gIFVQID0gJ3VwJyxcbiAgRE9XTiA9ICdkb3duJyxcbiAgTEVGVCA9ICdsZWZ0JyxcbiAgUklHSFQgPSAncmlnaHQnLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCwgUmVuZGVyZXIyLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBBcnJvd0tleURpcmVjdGlvbiB9IGZyb20gJy4vYXJyb3cta2V5LWRpcmVjdGlvbi5lbnVtJztcbmltcG9ydCB7IEZvY3VzYWJsZUl0ZW0gfSBmcm9tICcuL2ZvY3VzYWJsZS1pdGVtL2ZvY3VzYWJsZS1pdGVtJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZvY3VzU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBwcml2YXRlIF91bmxpc3RlbkZ1bmNzID0gW107XG4gIHByaXZhdGUgX2N1cnJlbnQ6IEZvY3VzYWJsZUl0ZW07XG4gIHB1YmxpYyBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuXG4gIHJlc2V0KGZpcnN0OiBGb2N1c2FibGVJdGVtKSB7XG4gICAgdGhpcy5fY3VycmVudCA9IGZpcnN0O1xuICB9XG5cbiAgbGlzdGVuVG9BcnJvd0tleXMoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBsaXN0ZW5lcnMgcmV0dXJuIGZhbHNlIHdoZW4gdGhlcmUgd2FzIGFuIGFjdGlvbiB0byB0YWtlIGZvciB0aGUga2V5IHByZXNzZWQsXG4gICAgLy8gaW4gb3JkZXIgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGF0IGtleS5cbiAgICB0aGlzLl91bmxpc3RlbkZ1bmNzLnB1c2goXG4gICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbCwgJ2tleWRvd24uYXJyb3d1cCcsIGV2ZW50ID0+ICF0aGlzLm1vdmUoQXJyb3dLZXlEaXJlY3Rpb24uVVAsIGV2ZW50KSlcbiAgICApO1xuICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaChcbiAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsLCAna2V5ZG93bi5hcnJvd2Rvd24nLCBldmVudCA9PiAhdGhpcy5tb3ZlKEFycm93S2V5RGlyZWN0aW9uLkRPV04sIGV2ZW50KSlcbiAgICApO1xuICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaChcbiAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsLCAna2V5ZG93bi5hcnJvd2xlZnQnLCBldmVudCA9PiAhdGhpcy5tb3ZlKEFycm93S2V5RGlyZWN0aW9uLkxFRlQsIGV2ZW50KSlcbiAgICApO1xuICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaChcbiAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsLCAna2V5ZG93bi5hcnJvd3JpZ2h0JywgZXZlbnQgPT4gIXRoaXMubW92ZShBcnJvd0tleURpcmVjdGlvbi5SSUdIVCwgZXZlbnQpKVxuICAgICk7XG4gIH1cblxuICByZWdpc3RlckNvbnRhaW5lcihlbDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbCwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICB0aGlzLmxpc3RlblRvQXJyb3dLZXlzKGVsKTtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGxpc3RlbmVycyByZXR1cm4gZmFsc2Ugd2hlbiB0aGVyZSB3YXMgYW4gYWN0aW9uIHRvIHRha2UgZm9yIHRoZSBrZXkgcHJlc3NlZCxcbiAgICAvLyBpbiBvcmRlciB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoYXQga2V5LlxuICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaCh0aGlzLnJlbmRlcmVyLmxpc3RlbihlbCwgJ2tleWRvd24uc3BhY2UnLCAoKSA9PiAhdGhpcy5hY3RpdmF0ZUN1cnJlbnQoKSkpO1xuICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaCh0aGlzLnJlbmRlcmVyLmxpc3RlbihlbCwgJ2tleWRvd24uZW50ZXInLCAoKSA9PiAhdGhpcy5hY3RpdmF0ZUN1cnJlbnQoKSkpO1xuICB9XG5cbiAgbW92ZVRvKGl0ZW06IEZvY3VzYWJsZUl0ZW0pIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQuYmx1cigpO1xuICAgIH1cbiAgICBpdGVtLmZvY3VzKCk7XG4gICAgdGhpcy5fY3VycmVudCA9IGl0ZW07XG4gIH1cblxuICBtb3ZlKGRpcmVjdGlvbjogQXJyb3dLZXlEaXJlY3Rpb24sIGV2ZW50OiBhbnkgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICAvLyBXZSB3YW50IHRvIHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvciB0aGF0IHJlc3VsdHMgZnJvbSB0aGUga2V5ZG93bixcbiAgICAgIC8vIHdoaWNoIG1heSB1bmRlc2lyYWJseSBtb3ZlIHRoZSBjdXJzb3IgYXJvdW5kIHdoZW4gdXNpbmcgYSBzY3JlZW4gcmVhZGVyXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dCA9IHRoaXMuY3VycmVudFtkaXJlY3Rpb25dO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgLy8gVHVybmluZyB0aGUgdmFsdWUgaW50byBhbiBPYnNlcnZhYmxlIGlzbid0IGdyZWF0LCBidXQgaXQncyB0aGUgZmFzdGVzdCB3YXkgdG8gYXZvaWQgY29kZSBkdXBsaWNhdGlvbi5cbiAgICAgICAgLy8gSWYgcGVyZm9ybWFuY2UgZXZlciBtYXR0ZXJzIGZvciB0aGlzLCB3ZSBjYW4gcmVmYWN0b3IgdXNpbmcgYWRkaXRpb25hbCBwcml2YXRlIG1ldGhvZHMuXG4gICAgICAgIGNvbnN0IG5leHRPYnMgPSBpc09ic2VydmFibGUobmV4dCkgPyBuZXh0IDogb2YobmV4dCk7XG4gICAgICAgIG5leHRPYnMuc3Vic2NyaWJlKGl0ZW0gPT4ge1xuICAgICAgICAgIHRoaXMubW92ZVRvKGl0ZW0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYWN0aXZhdGVDdXJyZW50KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQgJiYgdGhpcy5jdXJyZW50LmFjdGl2YXRlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZGV0YWNoTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX3VubGlzdGVuRnVuY3MuZm9yRWFjaCgodW5saXN0ZW46ICgpID0+IHZvaWQpID0+IHVubGlzdGVuKCkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHJGb2N1c1NlcnZpY2VGYWN0b3J5KGV4aXN0aW5nOiBGb2N1c1NlcnZpY2UsIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgcmV0dXJuIGV4aXN0aW5nIHx8IG5ldyBGb2N1c1NlcnZpY2UocmVuZGVyZXIpO1xufVxuXG5leHBvcnQgY29uc3QgRk9DVVNfU0VSVklDRV9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogRm9jdXNTZXJ2aWNlLFxuICB1c2VGYWN0b3J5OiBjbHJGb2N1c1NlcnZpY2VGYWN0b3J5LFxuICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgRm9jdXNTZXJ2aWNlXSwgUmVuZGVyZXIyXSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFycm93S2V5RGlyZWN0aW9uIH0gZnJvbSAnLi4vYXJyb3cta2V5LWRpcmVjdGlvbi5lbnVtJztcbmltcG9ydCB7IEZvY3VzYWJsZUl0ZW0gfSBmcm9tICcuL2ZvY3VzYWJsZS1pdGVtJztcblxuLyoqXG4gKiBMaW5rcyBhIHNldCBvZiBmb2N1c2FibGUgaXRlbXMgdG8gYSBwYXJlbnQgYWxvbmcgb25lIGRpcmVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlua1BhcmVudChcbiAgaXRlbXM6IEZvY3VzYWJsZUl0ZW1bXSxcbiAgcGFyZW50OiBGb2N1c2FibGVJdGVtIHwgT2JzZXJ2YWJsZTxGb2N1c2FibGVJdGVtPixcbiAgZGlyZWN0aW9uOiBBcnJvd0tleURpcmVjdGlvblxuKSB7XG4gIGl0ZW1zLmZvckVhY2goaXRlbSA9PiAoaXRlbVtkaXJlY3Rpb25dID0gcGFyZW50KSk7XG59XG5cbi8qKlxuICogRG91YmxlLWxpbmtzIGEgc2V0IG9mIGZvY3VzYWJsZSBpdGVtcyB2ZXJ0aWNhbGx5LCBwb3NzaWJseSBsb29waW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5rVmVydGljYWwoaXRlbXM6IEZvY3VzYWJsZUl0ZW1bXSwgbG9vcCA9IHRydWUpIHtcbiAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBpdGVtLnVwID0gaXRlbXNbaW5kZXggLSAxXTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgaXRlbS5kb3duID0gaXRlbXNbaW5kZXggKyAxXTtcbiAgICB9XG4gIH0pO1xuICBpZiAobG9vcCAmJiBpdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgaXRlbXNbMF0udXAgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5kb3duID0gaXRlbXNbMF07XG4gIH1cbn1cblxuLy8gUmlnaHQgbm93IEkgb25seSBuZWVkIHRoZSB0d28gbGlua2VycyBhYm92ZSwgYnV0IHdlIGNhbiBlYXNpbHkgYWRkIG1vcmUgbGlua2Vycy4gQSBjb3VwbGUgZXhhbXBsZXM6XG4vLyBleHBvcnQgZnVuY3Rpb24gbGlua0hvcml6b250YWwoaXRlbXM6IEZvY3VzYWJsZUl0ZW1bXSwgbG9vcCA9IHRydWUpO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGxpbmtUYWJsZShpdGVtczogRm9jdXNhYmxlSXRlbVtdW10pO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE9ic2VydmFibGU8VD4oXG4gIG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4sXG4gIG9uU3Vic2NyaWJlPzogKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4gdm9pZCxcbiAgb25VbnN1YnNjcmliZT86IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHZvaWRcbik6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xuICAgIG9uU3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9uVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgb25VbnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFBMQVRGT1JNX0lELCBSZW5kZXJlcjIsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5pbXBvcnQgeyBjdXN0b21Gb2N1c2FibGVJdGVtUHJvdmlkZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9mb2N1cy9mb2N1c2FibGUtaXRlbS9jdXN0b20tZm9jdXNhYmxlLWl0ZW0tcHJvdmlkZXInO1xuaW1wb3J0IHsgVU5JUVVFX0lEIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7IEFycm93S2V5RGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZm9jdXMvYXJyb3cta2V5LWRpcmVjdGlvbi5lbnVtJztcbmltcG9ydCB7IEZvY3VzU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2ZvY3VzL2ZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgRm9jdXNhYmxlSXRlbSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2ZvY3VzL2ZvY3VzYWJsZS1pdGVtL2ZvY3VzYWJsZS1pdGVtJztcbmltcG9ydCB7IGxpbmtQYXJlbnQsIGxpbmtWZXJ0aWNhbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2ZvY3VzL2ZvY3VzYWJsZS1pdGVtL2xpbmtlcnMnO1xuaW1wb3J0IHsgd3JhcE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi8uLi91dGlscy9mb2N1cy93cmFwLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERyb3Bkb3duRm9jdXNIYW5kbGVyIGltcGxlbWVudHMgRm9jdXNhYmxlSXRlbSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgaWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgQFNraXBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByaXZhdGUgcGFyZW50OiBEcm9wZG93bkZvY3VzSGFuZGxlcixcbiAgICBwcml2YXRlIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBmb2N1c1NlcnZpY2U6IEZvY3VzU2VydmljZSxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdFxuICApIHtcbiAgICB0aGlzLnJlc2V0Q2hpbGRyZW4oKTtcbiAgICB0aGlzLm1vdmVUb0ZpcnN0SXRlbVdoZW5PcGVuKCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVSb290Rm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF91bmxpc3RlbkZ1bmNzID0gW107XG5cbiAgLyoqXG4gICAqIElmIHRoZSBkcm9wZG93biB3YXMgb3BlbmVkIGJ5IGNsaWNraW5nIG9uIHRoZSB0cmlnZ2VyLCB3ZSBhdXRvbWF0aWNhbGx5IG1vdmUgdG8gdGhlIGZpcnN0IGl0ZW1cbiAgICovXG4gIG1vdmVUb0ZpcnN0SXRlbVdoZW5PcGVuKCkge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZShvcGVuID0+IHtcbiAgICAgIGlmIChvcGVuICYmIHRoaXMuaWZPcGVuU2VydmljZS5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIC8vIEV2ZW4gaWYgd2UgcHJvcGVybHkgd2FpdGVkIGZvciBuZ0FmdGVyVmlld0luaXQsIHRoZSBjb250YWluZXIgc3RpbGwgd291bGRuJ3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgICAgLy8gU28gc2V0VGltZW91dCBpcyB0aGUgb25seSB3YXkgdG8gd2FpdCBmb3IgdGhlIGNvbnRhaW5lciB0byBiZSByZWFkeSB0byBtb3ZlIGZvY3VzIHRvIGZpcnN0IGl0ZW0uXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLm1vdmVUbyh0aGlzKTtcbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLm1vdmUoQXJyb3dLZXlEaXJlY3Rpb24uUklHSFQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzU2VydmljZS5tb3ZlKEFycm93S2V5RGlyZWN0aW9uLkRPV04pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZvY3VzQmFja09uVHJpZ2dlciA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBGb2N1cyBvbiB0aGUgbWVudSB3aGVuIGl0IG9wZW5zLCBhbmQgZm9jdXMgYmFjayBvbiB0aGUgcm9vdCB0cmlnZ2VyIHdoZW4gdGhlIHdob2xlIGRyb3Bkb3duIGJlY29tZXMgY2xvc2VkXG4gICAqL1xuICBoYW5kbGVSb290Rm9jdXMoKSB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKG9wZW4gPT4ge1xuICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgIC8vIFdlIHJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgZm9jdXMgc2VydmljZSBib3RoIG9uIGluaXRpYWxpemF0aW9uIGFuZCB3aGVuIGNsb3NpbmcuXG4gICAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLnJlc2V0KHRoaXMpO1xuICAgICAgICAvLyBCdXQgd2Ugb25seSBhY3RpdmVseSBmb2N1cyB0aGUgdHJpZ2dlciB3aGVuIGNsb3NpbmcsIG5vdCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuZm9jdXNCYWNrT25UcmlnZ2VyKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZvY3VzQmFja09uVHJpZ2dlciA9IG9wZW47XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF90cmlnZ2VyOiBIVE1MRWxlbWVudDtcbiAgZ2V0IHRyaWdnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyaWdnZXI7XG4gIH1cbiAgc2V0IHRyaWdnZXIoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fdHJpZ2dlciA9IGVsO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKGVsLCAnaWQnLCB0aGlzLmlkKTtcblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5fdW5saXN0ZW5GdW5jcy5wdXNoKFxuICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbCwgJ2tleWRvd24uYXJyb3dyaWdodCcsIGV2ZW50ID0+IHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdW5saXN0ZW5GdW5jcy5wdXNoKFxuICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbCwgJ2tleWRvd24uYXJyb3d1cCcsIGV2ZW50ID0+IHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpKVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaChcbiAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWwsICdrZXlkb3duLmFycm93ZG93bicsIGV2ZW50ID0+IHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpKVxuICAgICAgKTtcbiAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLmxpc3RlblRvQXJyb3dLZXlzKGVsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jb250YWluZXI6IEhUTUxFbGVtZW50O1xuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH1cbiAgc2V0IGNvbnRhaW5lcihlbDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBlbDtcblxuICAgIC8vIHdoZXRoZXIgcm9vdCBjb250YWluZXIgb3Igbm90LCB0YWIga2V5IHNob3VsZCBhbHdheXMgdG9nZ2xlIChpLmUuIGNsb3NlKSB0aGUgY29udGFpbmVyXG4gICAgdGhpcy5fdW5saXN0ZW5GdW5jcy5wdXNoKFxuICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWwsICdrZXlkb3duLnRhYicsIGV2ZW50ID0+IHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpKVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIC8vIGlmIGl0J3MgYSBuZXN0ZWQgY29udGFpbmVyLCBwcmVzc2luZyBlc2MgaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBwcmVzc2luZyBsZWZ0IGtleSwgd2hpY2ggY2xvc2VzIHRoZSBjdXJyZW50XG4gICAgICAvLyBwb3B1cCBhbmQgbW92ZXMgdXAgdG8gaXRzIHBhcmVudC4gSGVyZSwgd2Ugc3RvcCBwcm9wYWdhdGlvbiBzbyB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyXG4gICAgICAvLyBkb2Vzbid0IHJlY2VpdmUgdGhlIGVzYyBrZXlkb3duXG4gICAgICB0aGlzLl91bmxpc3RlbkZ1bmNzLnB1c2goXG4gICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsLCAna2V5ZG93bi5lc2MnLCBldmVudCA9PiB7XG4gICAgICAgICAgdGhpcy5mb2N1c1NlcnZpY2UubW92ZShBcnJvd0tleURpcmVjdGlvbi5MRUZULCBldmVudCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcm9vdCBjb250YWluZXIgaXMgdGhlIG9ubHkgb25lIHdlIHJlZ2lzdGVyIHRvIHRoZSBmb2N1cyBzZXJ2aWNlLCBvdGhlcnMgZG8gbm90IG5lZWQgZm9jdXNcbiAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLnJlZ2lzdGVyQ29udGFpbmVyKGVsKTtcblxuICAgICAgLy8gVGhlIHJvb3QgY29udGFpbmVyIHdpbGwgc2ltcGx5IGNsb3NlIHRoZSBjb250YWluZXIgd2hlbiBlc2Mga2V5IGlzIHByZXNzZWRcbiAgICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaChcbiAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWwsICdrZXlkb3duLmVzYycsIGV2ZW50ID0+IHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpKVxuICAgICAgKTtcblxuICAgICAgLy8gV2hlbiB0aGUgdXNlciBtb3ZlcyBmb2N1cyBvdXRzaWRlIG9mIHRoZSBtZW51LCB3ZSBjbG9zZSB0aGUgZHJvcGRvd25cbiAgICAgIHRoaXMuX3VubGlzdGVuRnVuY3MucHVzaChcbiAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWwsICdibHVyJywgZXZlbnQgPT4ge1xuICAgICAgICAgIC8vIHdlIGNsZWFyIG91dCBhbnkgZXhpc3RpbmcgZm9jdXMgb24gdGhlIGl0ZW1zXG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi5waXBlKHRha2UoMSkpLnN1YnNjcmliZShpdGVtcyA9PiBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5ibHVyKCkpKTtcblxuICAgICAgICAgIC8vIGV2ZW50LnJlbGF0ZWRUYXJnZXQgaXMgbnVsbCBpbiBJRTExLiBJbiB0aGF0IGNhc2Ugd2UgdXNlIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgd2hpY2ggY29ycmVjdGx5IHBvaW50c1xuICAgICAgICAgIC8vIHRvIHRoZSBlbGVtZW50IHdlIHdhbnQgdG8gY2hlY2suIE5vdGUgdGhhdCBvdGhlciBicm93c2VycyBtaWdodCBwb2ludCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHRvIHRoZVxuICAgICAgICAgIC8vIHdyb25nIGVsZW1lbnQuIFRoaXMgaXMgb2ssIGJlY2F1c2UgYWxsIHRoZSBvdGhlciBicm93c2VycyB3ZSBzdXBwb3J0IHJlbGllcyBvbiBldmVudC5yZWxhdGVkVGFyZ2V0LlxuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtIHdoaWNoIHRyaWdnZXJzIHRoZSBibHVyLCB3ZSBkb24ndCB3YW50IHRvIGNsb3NlIGl0IHNpbmNlIGl0IG1heSBvcGVuIGEgc3VibWVudS5cbiAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBuZWVkaW5nIHRvIGNsb3NlIGl0IChpLmUuIHVzZXIgc2VsZWN0ZWQgYW4gaXRlbSBhbmQgdGhlIGRyb3Bkb3duIG1lbnUgaXMgc2V0IHRvIGNsb3NlIG9uXG4gICAgICAgICAgLy8gc2VsZWN0aW9uKSwgZHJvcGRvd24taXRlbS50cyBoYW5kbGVzIGl0LlxuICAgICAgICAgIGlmICh0YXJnZXQgJiYgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgaWYgKGVsLmNvbnRhaW5zKHRhcmdldCkgfHwgdGFyZ2V0ID09PSB0aGlzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSBsZXQgdGhlIHVzZXIgbW92ZSBmb2N1cyB0byB3aGVyZSB0aGUgd2FudCwgd2UgZG9uJ3QgZm9yY2UgdGhlIGZvY3VzIGJhY2sgb24gdGhlIHRyaWdnZXJcbiAgICAgICAgICB0aGlzLmZvY3VzQmFja09uVHJpZ2dlciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZvY3VzKCkge1xuICAgIGlmICh0aGlzLnRyaWdnZXIgJiYgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgdGhpcy50cmlnZ2VyLmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGJsdXIoKSB7XG4gICAgaWYgKHRoaXMudHJpZ2dlciAmJiBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLnRyaWdnZXIuYmx1cigpO1xuICAgIH1cbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLnRyaWdnZXIuY2xpY2soKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoaWxkcmVuOiBSZXBsYXlTdWJqZWN0PEZvY3VzYWJsZUl0ZW1bXT47XG4gIHJpZ2h0PzogT2JzZXJ2YWJsZTxGb2N1c2FibGVJdGVtPjtcbiAgZG93bj86IE9ic2VydmFibGU8Rm9jdXNhYmxlSXRlbT47XG4gIHVwPzogT2JzZXJ2YWJsZTxGb2N1c2FibGVJdGVtPjtcblxuICBwcml2YXRlIG9wZW5BbmRHZXRDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gd3JhcE9ic2VydmFibGUodGhpcy5jaGlsZHJlbiwgKCkgPT4gKHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gdHJ1ZSkpO1xuICB9XG4gIHByaXZhdGUgY2xvc2VBbmRHZXRUaGlzKCkge1xuICAgIHJldHVybiB3cmFwT2JzZXJ2YWJsZShvZih0aGlzKSwgKCkgPT4gKHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2UpKTtcbiAgfVxuXG4gIHJlc2V0Q2hpbGRyZW4oKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBSZXBsYXlTdWJqZWN0PEZvY3VzYWJsZUl0ZW1bXT4oMSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5vcGVuQW5kR2V0Q2hpbGRyZW4oKS5waXBlKG1hcChhbGwgPT4gYWxsWzBdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG93biA9IHRoaXMub3BlbkFuZEdldENoaWxkcmVuKCkucGlwZShtYXAoYWxsID0+IGFsbFswXSkpO1xuICAgICAgdGhpcy51cCA9IHRoaXMub3BlbkFuZEdldENoaWxkcmVuKCkucGlwZShtYXAoYWxsID0+IGFsbFthbGwubGVuZ3RoIC0gMV0pKTtcbiAgICB9XG4gIH1cblxuICBhZGRDaGlsZHJlbihjaGlsZHJlbjogRm9jdXNhYmxlSXRlbVtdKSB7XG4gICAgbGlua1ZlcnRpY2FsKGNoaWxkcmVuKTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGxpbmtQYXJlbnQoY2hpbGRyZW4sIHRoaXMuY2xvc2VBbmRHZXRUaGlzKCksIEFycm93S2V5RGlyZWN0aW9uLkxFRlQpO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuLm5leHQoY2hpbGRyZW4pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5saXN0ZW5GdW5jcy5mb3JFYWNoKCh1bmxpc3RlbjogKCkgPT4gdm9pZCkgPT4gdW5saXN0ZW4oKSk7XG4gICAgdGhpcy5mb2N1c1NlcnZpY2UuZGV0YWNoTGlzdGVuZXJzKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERST1BET1dOX0ZPQ1VTX0hBTkRMRVJfUFJPVklERVIgPSBjdXN0b21Gb2N1c2FibGVJdGVtUHJvdmlkZXIoRHJvcGRvd25Gb2N1c0hhbmRsZXIpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSb290RHJvcGRvd25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfY2hhbmdlczogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgZ2V0IGNoYW5nZXMoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBjbG9zZU1lbnVzKCk6IHZvaWQge1xuICAgIHRoaXMuX2NoYW5nZXMubmV4dChmYWxzZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsclJvb3REcm9wZG93bkZhY3RvcnkoZXhpc3Rpbmc6IFJvb3REcm9wZG93blNlcnZpY2UpIHtcbiAgcmV0dXJuIGV4aXN0aW5nIHx8IG5ldyBSb290RHJvcGRvd25TZXJ2aWNlKCk7XG59XG5cbmV4cG9ydCBjb25zdCBST09UX0RST1BET1dOX1BST1ZJREVSID0ge1xuICBwcm92aWRlOiBSb290RHJvcGRvd25TZXJ2aWNlLFxuICB1c2VGYWN0b3J5OiBjbHJSb290RHJvcGRvd25GYWN0b3J5LFxuICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgUm9vdERyb3Bkb3duU2VydmljZV1dLFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuaW1wb3J0IHsgUE9QT1ZFUl9IT1NUX0FOQ0hPUiB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuJztcbmltcG9ydCB7IERST1BET1dOX0ZPQ1VTX0hBTkRMRVJfUFJPVklERVIgfSBmcm9tICcuL3Byb3ZpZGVycy9kcm9wZG93bi1mb2N1cy1oYW5kbGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRk9DVVNfU0VSVklDRV9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL2ZvY3VzLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBST09UX0RST1BET1dOX1BST1ZJREVSLCBSb290RHJvcGRvd25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJvcGRvd24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kcm9wZG93bicsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRyb3Bkb3duXSc6ICd0cnVlJyxcbiAgICAvLyBGSVhNRTogcmVtb3ZlIHRoaXMgYXMgc29vbiBhcyB3ZSBzdG9wIHN1cHBvcnRpbmcgdGhpcyBvbGQgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj4gc3ludGF4XG4gICAgJ1tjbGFzcy5vcGVuXSc6ICdpZk9wZW5TZXJ2aWNlLm9wZW4nLFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICBJZk9wZW5TZXJ2aWNlLFxuICAgIFJPT1RfRFJPUERPV05fUFJPVklERVIsXG4gICAgeyBwcm92aWRlOiBQT1BPVkVSX0hPU1RfQU5DSE9SLCB1c2VFeGlzdGluZzogRWxlbWVudFJlZiB9LFxuICAgIEZPQ1VTX1NFUlZJQ0VfUFJPVklERVIsXG4gICAgRFJPUERPV05fRk9DVVNfSEFORExFUl9QUk9WSURFUixcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJvcGRvd24gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQFNraXBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHB1YmxpYyBwYXJlbnQ6IENsckRyb3Bkb3duLFxuICAgIHB1YmxpYyBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBkcm9wZG93blNlcnZpY2U6IFJvb3REcm9wZG93blNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goZHJvcGRvd25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKHZhbHVlID0+ICh0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IHZhbHVlKSkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKGlmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUodmFsdWUgPT4gdGhpcy5jZHIubWFya0ZvckNoZWNrKCkpKTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyQ2xvc2VNZW51T25JdGVtQ2xpY2snKSBpc01lbnVDbG9zYWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVOSVFVRV9JRCwgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7IEZvY3VzYWJsZUl0ZW0gfSBmcm9tICcuL2ZvY3VzYWJsZS1pdGVtJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEJhc2ljRm9jdXNhYmxlSXRlbSBpbXBsZW1lbnRzIEZvY3VzYWJsZUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFVOSVFVRV9JRCkgcHVibGljIGlkOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0XG4gICkge1xuICAgIHJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbC5uYXRpdmVFbGVtZW50LCAnaWQnLCBpZCk7XG4gICAgcmVuZGVyZXIuc2V0QXR0cmlidXRlKGVsLm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcsICctMScpO1xuICB9XG5cbiAgZGlzYWJsZWQgPSBmYWxzZTtcblxuICBmb2N1cygpIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGJsdXIoKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEJBU0lDX0ZPQ1VTQUJMRV9JVEVNX1BST1ZJREVSID0gW1xuICBVTklRVUVfSURfUFJPVklERVIsXG4gIHtcbiAgICBwcm92aWRlOiBGb2N1c2FibGVJdGVtLFxuICAgIHVzZUNsYXNzOiBCYXNpY0ZvY3VzYWJsZUl0ZW0sXG4gIH0sXG5dO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRyb3Bkb3duIH0gZnJvbSAnLi9kcm9wZG93bic7XG5pbXBvcnQgeyBCQVNJQ19GT0NVU0FCTEVfSVRFTV9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL2ZvY3VzYWJsZS1pdGVtL2Jhc2ljLWZvY3VzYWJsZS1pdGVtLnNlcnZpY2UnO1xuaW1wb3J0IHsgRm9jdXNhYmxlSXRlbSB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL2ZvY3VzYWJsZS1pdGVtL2ZvY3VzYWJsZS1pdGVtJztcbmltcG9ydCB7IFJvb3REcm9wZG93blNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kcm9wZG93bi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsckRyb3Bkb3duSXRlbV0nLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuZHJvcGRvd24taXRlbV0nOiAndHJ1ZScsXG4gICAgJ1thdHRyLnJvbGVdJzogJ1wibWVudWl0ZW1cIicsXG4gICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAnW2F0dHIuZGlzYWJsZWRdJzogXCIoZGlzYWJsZWQgJiYgc2V0QnlEZXByZWNhdGVkRGlzYWJsZWQpPyAnJyA6IG51bGxcIixcbiAgfSxcbiAgcHJvdmlkZXJzOiBbQkFTSUNfRk9DVVNBQkxFX0lURU1fUFJPVklERVJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93bkl0ZW0gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkcm9wZG93bjogQ2xyRHJvcGRvd24sXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgcHJpdmF0ZSBfZHJvcGRvd25TZXJ2aWNlOiBSb290RHJvcGRvd25TZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGZvY3VzYWJsZUl0ZW06IEZvY3VzYWJsZUl0ZW1cbiAgKSB7fVxuXG4gIHByaXZhdGUgdW5saXN0ZW47XG4gIHB1YmxpYyBzZXRCeURlcHJlY2F0ZWREaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgnY2xyRGlzYWJsZWQnKVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmcgYXR0cmlidXRlIGV2YWx1YXRlcyB0byBmYWxzZSBidXQgc2hvdWxkIGRpc2FibGUgdGhlIGl0ZW0sIHNvIHdlIG5lZWQgdG8gYWRkIGEgc3BlY2lhbCBjYXNlIGZvciBpdC5cbiAgICB0aGlzLmZvY3VzYWJsZUl0ZW0uZGlzYWJsZWQgPSAhIXZhbHVlIHx8IHZhbHVlID09PSAnJztcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c2FibGVJdGVtLmRpc2FibGVkO1xuICB9XG5cbiAgLypcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgMy4wLCByZW1vdmUgaW4gNC4wLiB0aGUgcHJlc2VuY2Ugb2YgdGhpcyBhdHRyaWJ1dGUgbWFrZXMgaXQgbm90LWZvY3VzYWJsZSBpbiBJRTExLiBVc2UgW2NsckRpc2FibGVkXSBpbnB1dCBpbnN0ZWFkLlxuICAgKi9cbiAgQElucHV0KCdkaXNhYmxlZCcpXG4gIHNldCBkaXNhYmxlZERlcHJlY2F0ZWQodmFsdWU6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmcgYXR0cmlidXRlIGV2YWx1YXRlcyB0byBmYWxzZSBidXQgc2hvdWxkIGRpc2FibGUgdGhlIGl0ZW0sIHNvIHdlIG5lZWQgdG8gYWRkIGEgc3BlY2lhbCBjYXNlIGZvciBpdC5cbiAgICB0aGlzLmZvY3VzYWJsZUl0ZW0uZGlzYWJsZWQgPSAhIXZhbHVlIHx8IHZhbHVlID09PSAnJztcbiAgICB0aGlzLnNldEJ5RGVwcmVjYXRlZERpc2FibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZERlcHJlY2F0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXNhYmxlSXRlbS5kaXNhYmxlZDtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnVubGlzdGVuID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoKSA9PiB0aGlzLm9uRHJvcGRvd25JdGVtQ2xpY2soKSk7XG4gIH1cblxuICBvbkRyb3Bkb3duSXRlbUNsaWNrKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRyb3Bkb3duLmlzTWVudUNsb3NhYmxlICYmICF0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICB0aGlzLl9kcm9wZG93blNlcnZpY2UuY2xvc2VNZW51cygpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdCxcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBRdWVyeUxpc3QsXG4gIFNraXBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0UG9wb3ZlciB9IGZyb20gJy4uL2NvbW1vbi9hYnN0cmFjdC1wb3BvdmVyJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXInO1xuaW1wb3J0IHsgUE9QT1ZFUl9IT1NUX0FOQ0hPUiB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuJztcbmltcG9ydCB7IERyb3Bkb3duRm9jdXNIYW5kbGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJvcGRvd24tZm9jdXMtaGFuZGxlci5zZXJ2aWNlJztcbmltcG9ydCB7IEZvY3VzYWJsZUl0ZW0gfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9mb2N1c2FibGUtaXRlbS9mb2N1c2FibGUtaXRlbSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kcm9wZG93bi1tZW51JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRyb3Bkb3duLW1lbnVdJzogJ3RydWUnLFxuICAgICdbYXR0ci5yb2xlXSc6ICdcIm1lbnVcIicsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyb3Bkb3duTWVudSBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoUE9QT1ZFUl9IT1NUX0FOQ0hPUilcbiAgICBwYXJlbnRIb3N0OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgbmVzdGVkOiBDbHJEcm9wZG93bk1lbnUsXG4gICAgZm9jdXNIYW5kbGVyOiBEcm9wZG93bkZvY3VzSGFuZGxlclxuICApIHtcbiAgICBpZiAoIXBhcmVudEhvc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyLWRyb3Bkb3duLW1lbnUgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItZHJvcGRvd24nKTtcbiAgICB9XG4gICAgc3VwZXIoaW5qZWN0b3IsIHBhcmVudEhvc3QpO1xuICAgIGlmICghbmVzdGVkKSB7XG4gICAgICAvLyBEZWZhdWx0IHBvc2l0aW9uaW5nIGZvciBub3JtYWwgZHJvcGRvd24gaXMgYm90dG9tLWxlZnRcbiAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDtcbiAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZmF1bHQgcG9zaXRpb25pbmcgZm9yIG5lc3RlZCBkcm9wZG93biBpcyByaWdodC10b3BcbiAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgIH1cbiAgICB0aGlzLnBvcG92ZXJPcHRpb25zLmFsbG93TXVsdGlwbGVPcGVuID0gdHJ1ZTtcbiAgICB0aGlzLnBvcG92ZXJPcHRpb25zLmlnbm9yZUdsb2JhbEVTQ0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gZm9jdXNIYW5kbGVyO1xuICB9XG5cbiAgQElucHV0KCdjbHJQb3NpdGlvbicpXG4gIHNldCBwb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKSB7XG4gICAgLy8gc2V0IHRoZSBwb3BvdmVyIHZhbHVlcyBiYXNlZCBvbiBtZW51IHBvc2l0aW9uXG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9SSUdIVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuVE9QX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9SSUdIVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQtdG9wJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodC1ib3R0b20nOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQtdG9wJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0LWJvdHRvbSc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZvY3VzSGFuZGxlcjogRHJvcGRvd25Gb2N1c0hhbmRsZXI7XG4gIEBDb250ZW50Q2hpbGRyZW4oRm9jdXNhYmxlSXRlbSkgaXRlbXM6IFF1ZXJ5TGlzdDxGb2N1c2FibGVJdGVtPjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5mb2N1c0hhbmRsZXIuY29udGFpbmVyID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgIHRoaXMuaXRlbXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5mb2N1c0hhbmRsZXIuYWRkQ2hpbGRyZW4odGhpcy5pdGVtcy50b0FycmF5KCkpKTtcbiAgICAvLyBJIHNhdyB0aGlzIG9uIEdpdEh1YiBhcyBhIHNvbHV0aW9uIHRvIGF2b2lkIGNvZGUgZHVwbGljYXRpb24gYmVjYXVzZSBvZiBtaXNzZWQgUXVlcnlMaXN0IGNoYW5nZXNcbiAgICB0aGlzLml0ZW1zLm5vdGlmeU9uQ2hhbmdlcygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICB0aGlzLmZvY3VzSGFuZGxlci5yZXNldENoaWxkcmVuKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBDbHJEcm9wZG93biB9IGZyb20gJy4vZHJvcGRvd24nO1xuaW1wb3J0IHsgRHJvcGRvd25Gb2N1c0hhbmRsZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9kcm9wZG93bi1mb2N1cy1oYW5kbGVyLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgLy8gV2Ugc3VwcG9ydCBib3RoIHNlbGVjdG9ycyBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgc2VsZWN0b3I6ICdbY2xyRHJvcGRvd25UcmlnZ2VyXSxbY2xyRHJvcGRvd25Ub2dnbGVdJyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZHJvcGRvd24tdG9nZ2xlXSc6ICdpc1Jvb3RMZXZlbFRvZ2dsZScsXG4gICAgJ1tjbGFzcy5kcm9wZG93bi1pdGVtXSc6ICchaXNSb290TGV2ZWxUb2dnbGUnLFxuICAgICdbY2xhc3MuZXhwYW5kYWJsZV0nOiAnIWlzUm9vdExldmVsVG9nZ2xlJyxcbiAgICAnW2NsYXNzLmFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICAnW2F0dHIuYXJpYS1oYXNwb3B1cF0nOiAnXCJtZW51XCInLFxuICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdhY3RpdmUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93blRyaWdnZXIge1xuICBwdWJsaWMgaXNSb290TGV2ZWxUb2dnbGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGRyb3Bkb3duOiBDbHJEcm9wZG93bixcbiAgICBwcml2YXRlIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgZWw6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIGZvY3VzSGFuZGxlcjogRHJvcGRvd25Gb2N1c0hhbmRsZXJcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGNvbnRhaW5pbmcgZHJvcGRvd24gaGFzIGEgcGFyZW50LCB0aGVuIHRoaXMgaXMgbm90IHRoZSByb290IGxldmVsIG9uZVxuICAgIGlmIChkcm9wZG93bi5wYXJlbnQpIHtcbiAgICAgIHRoaXMuaXNSb290TGV2ZWxUb2dnbGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9jdXNIYW5kbGVyLnRyaWdnZXIgPSBlbC5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW47XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gIG9uRHJvcGRvd25UcmlnZ2VyQ2xpY2soZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXIubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyRHJvcGRvd24gfSBmcm9tICcuL2Ryb3Bkb3duJztcbmltcG9ydCB7IENsckRyb3Bkb3duSXRlbSB9IGZyb20gJy4vZHJvcGRvd24taXRlbSc7XG5pbXBvcnQgeyBDbHJEcm9wZG93bk1lbnUgfSBmcm9tICcuL2Ryb3Bkb3duLW1lbnUnO1xuaW1wb3J0IHsgQ2xyRHJvcGRvd25UcmlnZ2VyIH0gZnJvbSAnLi9kcm9wZG93bi10cmlnZ2VyJztcblxuZXhwb3J0IGNvbnN0IENMUl9EUk9QRE9XTl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJEcm9wZG93biwgQ2xyRHJvcGRvd25NZW51LCBDbHJEcm9wZG93blRyaWdnZXIsIENsckRyb3Bkb3duSXRlbV07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckNvbW1vblBvcG92ZXJNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfRFJPUERPV05fRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfRFJPUERPV05fRElSRUNUSVZFUywgQ2xyQ29uZGl0aW9uYWxNb2R1bGUsIENsckljb25Nb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93bk1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vLyBAVE9ETyBNYWtlIHRoaXMgYW4gZW51bVxuZXhwb3J0IGNvbnN0IEFMRVJUX1RZUEVTOiBzdHJpbmdbXSA9IFsnaW5mbycsICd3YXJuaW5nJywgJ2RhbmdlcicsICdzdWNjZXNzJ107XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWxlcnRJbmZvT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMvYWxlcnQtaW5mby1vYmplY3QnO1xuaW1wb3J0IHsgQUxFUlRfVFlQRVMgfSBmcm9tICcuLi91dGlscy9hbGVydC10eXBlcyc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbGVydEljb25BbmRUeXBlc1NlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlKSB7fVxuXG4gIHByaXZhdGUgZGVmYXVsdEljb25TaGFwZSA9ICdpbmZvLWNpcmNsZSc7XG4gIHByaXZhdGUgX2FsZXJ0SWNvblNoYXBlID0gJyc7XG4gIHByaXZhdGUgX2FsZXJ0VHlwZSA9ICdpbmZvJztcblxuICBnZXQgYWxlcnRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2FsZXJ0VHlwZTtcbiAgfVxuICBzZXQgYWxlcnRUeXBlKHZhbDogc3RyaW5nKSB7XG4gICAgaWYgKEFMRVJUX1RZUEVTLmluZGV4T2YodmFsKSA+IC0xKSB7XG4gICAgICB0aGlzLl9hbGVydFR5cGUgPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFsZXJ0SWNvblNoYXBlKCk6IHN0cmluZyB7XG4gICAgaWYgKCcnID09PSB0aGlzLl9hbGVydEljb25TaGFwZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaWNvbkluZm9Gcm9tVHlwZSh0aGlzLl9hbGVydFR5cGUpLnNoYXBlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWxlcnRJY29uU2hhcGU7XG4gIH1cbiAgc2V0IGFsZXJ0SWNvblNoYXBlKHZhbDogc3RyaW5nKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHRoaXMuX2FsZXJ0SWNvblNoYXBlID0gJyc7XG4gICAgfSBlbHNlIGlmICh2YWwgIT09IHRoaXMuX2FsZXJ0SWNvblNoYXBlKSB7XG4gICAgICB0aGlzLl9hbGVydEljb25TaGFwZSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBnZXQgYWxlcnRJY29uVGl0bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW5mb0Zyb21UeXBlKHRoaXMuX2FsZXJ0VHlwZSkudGl0bGU7XG4gIH1cblxuICBwdWJsaWMgaWNvbkluZm9Gcm9tVHlwZSh0eXBlOiBzdHJpbmcpOiBBbGVydEluZm9PYmplY3Qge1xuICAgIGNvbnN0IHJldHVybk9iaiA9IHsgc2hhcGU6ICcnLCBjc3NDbGFzczogJycsIHRpdGxlOiAnJyB9O1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgcmV0dXJuT2JqLnNoYXBlID0gJ2V4Y2xhbWF0aW9uLXRyaWFuZ2xlJztcbiAgICAgICAgcmV0dXJuT2JqLmNzc0NsYXNzID0gJ2FsZXJ0LXdhcm5pbmcnO1xuICAgICAgICByZXR1cm5PYmoudGl0bGUgPSB0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy53YXJuaW5nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rhbmdlcic6XG4gICAgICAgIHJldHVybk9iai5zaGFwZSA9ICdleGNsYW1hdGlvbi1jaXJjbGUnO1xuICAgICAgICByZXR1cm5PYmouY3NzQ2xhc3MgPSAnYWxlcnQtZGFuZ2VyJztcbiAgICAgICAgcmV0dXJuT2JqLnRpdGxlID0gdGhpcy5jb21tb25TdHJpbmdzLmtleXMuZGFuZ2VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICByZXR1cm5PYmouc2hhcGUgPSAnY2hlY2stY2lyY2xlJztcbiAgICAgICAgcmV0dXJuT2JqLmNzc0NsYXNzID0gJ2FsZXJ0LXN1Y2Nlc3MnO1xuICAgICAgICByZXR1cm5PYmoudGl0bGUgPSB0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy5zdWNjZXNzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybk9iai5zaGFwZSA9IHRoaXMuZGVmYXVsdEljb25TaGFwZTtcbiAgICAgICAgcmV0dXJuT2JqLmNzc0NsYXNzID0gJ2FsZXJ0LWluZm8nO1xuICAgICAgICByZXR1cm5PYmoudGl0bGUgPSB0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy5pbmZvO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuT2JqO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJBbGVydCB9IGZyb20gJy4uL2FsZXJ0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE11bHRpQWxlcnRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBhbGxBbGVydHM6IFF1ZXJ5TGlzdDxDbHJBbGVydD4gPSBuZXcgUXVlcnlMaXN0PENsckFsZXJ0PigpO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIF9jdXJyZW50ID0gMDtcblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgcHVibGljIGdldCBjaGFuZ2VzKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICB9XG4gIHNldCBjdXJyZW50KGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoaW5kZXggIT09IHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbmRleDtcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBnZXQgYWN0aXZlQWxlcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmFsbEFsZXJ0cy5maWx0ZXIoYWxlcnQgPT4gIWFsZXJ0Ll9jbG9zZWQpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRBbGVydCgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVBbGVydHNbdGhpcy5jdXJyZW50XTtcbiAgfVxuXG4gIHNldCBjdXJyZW50QWxlcnQoYWxlcnQ6IENsckFsZXJ0KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5hY3RpdmVBbGVydHMuaW5kZXhPZihhbGVydCk7XG4gIH1cblxuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlQWxlcnRzLmxlbmd0aDtcbiAgfVxuXG4gIG1hbmFnZShhbGVydHM6IFF1ZXJ5TGlzdDxDbHJBbGVydD4pIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuYWxsQWxlcnRzID0gYWxlcnRzO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5hbGxBbGVydHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY3VycmVudCA+PSB0aGlzLmFsbEFsZXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gTWF0aC5tYXgoMCwgdGhpcy5hbGxBbGVydHMubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZXh0KCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudCA9PT0gdGhpcy5hY3RpdmVBbGVydHMubGVuZ3RoIC0gMSA/IDAgOiB0aGlzLmN1cnJlbnQgKyAxO1xuICB9XG5cbiAgcHJldmlvdXMoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlQWxlcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQgPT09IDAgPyB0aGlzLmFjdGl2ZUFsZXJ0cy5sZW5ndGggLSAxIDogdGhpcy5jdXJyZW50IC0gMTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucHJldmlvdXMoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3B0aW9uYWwsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vLyBwcm92aWRlcnNcbmltcG9ydCB7IEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2ljb24tYW5kLXR5cGVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTXVsdGlBbGVydFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9tdWx0aS1hbGVydC5zZXJ2aWNlJztcbmltcG9ydCB7IGlzQm9vbGVhbkF0dHJpYnV0ZVNldCB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbXBvbmVudC9pcy1ib29sZWFuLWF0dHJpYnV0ZS1zZXQnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYWxlcnQnLFxuICBwcm92aWRlcnM6IFtBbGVydEljb25BbmRUeXBlc1NlcnZpY2VdLFxuICB0ZW1wbGF0ZVVybDogJy4vYWxlcnQuaHRtbCcsXG4gIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9J10sXG59KVxuZXhwb3J0IGNsYXNzIENsckFsZXJ0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGljb25TZXJ2aWNlOiBBbGVydEljb25BbmRUeXBlc1NlcnZpY2UsXG4gICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHVibGljIG11bHRpQWxlcnRTZXJ2aWNlOiBNdWx0aUFsZXJ0U2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2VcbiAgKSB7fVxuXG4gIEBJbnB1dCgnY2xyQWxlcnRTaXplU21hbGwnKSBpc1NtYWxsOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgnY2xyQWxlcnRDbG9zYWJsZScpIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCdjbHJBbGVydEFwcExldmVsJykgaXNBcHBMZXZlbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIEFyaWFcbiAgQElucHV0KCkgY2xyQ2xvc2VCdXR0b25BcmlhTGFiZWw6IHN0cmluZyA9IHRoaXMuY29tbW9uU3RyaW5ncy5rZXlzLmFsZXJ0Q2xvc2VCdXR0b25BcmlhTGFiZWw7XG5cbiAgQElucHV0KCdjbHJBbGVydENsb3NlZCcpIF9jbG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQE91dHB1dCgnY2xyQWxlcnRDbG9zZWRDaGFuZ2UnKSBfY2xvc2VkQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgQElucHV0KCdjbHJBbGVydFR5cGUnKVxuICBzZXQgYWxlcnRUeXBlKHZhbDogc3RyaW5nKSB7XG4gICAgdGhpcy5pY29uU2VydmljZS5hbGVydFR5cGUgPSB2YWw7XG4gIH1cbiAgZ2V0IGFsZXJ0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmljb25TZXJ2aWNlLmFsZXJ0VHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjbHJQb2xpdGUgaXMgbm90IHVzZWQgaW4gdGhlIGNvZGUuIElzIGhlcmUganVzdCB0byBwcm92aWRlXG4gICAqIGNvZGUgY29tcGxpdGlvbiBhbmQgYWxzbyBtYXJrIGNvbXBvbmVudCB3aGF0IHR5cGUgQXJpYUxpdmVcbiAgICogd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgQElucHV0KCdjbHJQb2xpdGUnKSBwb2xpdGU6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoJ2NsckFzc2VydGl2ZScpIGFzc2VydGl2ZTogYm9vbGVhbjtcbiAgQElucHV0KCdjbHJPZmYnKSBvZmY6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGVyZSBpcyBhbiBvcmRlciBvbiBob3cgdGhlIGF0dHJpYnV0ZXMgd2lsbCB0YWtlIGVmZmVjdC5cbiAgICogQXNzZXJ0aXZlLCBPZmYsIFBvbGl0ZS5cbiAgICpcbiAgICogUG9saXRlIGlzIGRlZmF1bHQgaWYgbm9uIGlzIHBhc3NlZC5cbiAgICpcbiAgICogSW4gdGhlIGNhc2Ugb2Ygc2V0dGluZyBhbGwgb2YgdGhlbSB0byB0cnVlLiBBc3NlcnRpdmUgd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKi9cbiAgZ2V0IHNldEFyaWFMaXZlKCk6IHN0cmluZyB7XG4gICAgaWYgKGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh0aGlzLmFzc2VydGl2ZSkpIHtcbiAgICAgIHJldHVybiAnYXNzZXJ0aXZlJztcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh0aGlzLm9mZikpIHtcbiAgICAgIHJldHVybiAnb2ZmJztcbiAgICB9XG4gICAgcmV0dXJuICdwb2xpdGUnO1xuICB9XG5cbiAgQElucHV0KCdjbHJBbGVydEljb24nKVxuICBzZXQgYWxlcnRJY29uU2hhcGUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuaWNvblNlcnZpY2UuYWxlcnRJY29uU2hhcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBhbGVydENsYXNzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaWNvblNlcnZpY2UuaWNvbkluZm9Gcm9tVHlwZSh0aGlzLmljb25TZXJ2aWNlLmFsZXJ0VHlwZSkuY3NzQ2xhc3M7XG4gIH1cblxuICBwcml2YXRlIHByZXZpb3VzbHlIaWRkZW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBoaWRkZW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGRldGVjdENoYW5nZXNJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5SGlkZGVuICE9PSB0aGlzLmhpZGRlbikge1xuICAgICAgdGhpcy5wcmV2aW91c2x5SGlkZGVuID0gdGhpcy5oaWRkZW47XG4gICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlzSGlkZGVuKCkge1xuICAgIGlmICh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlKSB7XG4gICAgICAvLyBjaGFuZ2UgZGV0ZWN0aW9uIGlzc3VlIGluIHByb2R1Y3Rpb24gbW9kZSBjYXVzZXMgY3VycmVudEFsZXJ0IHRvIGJlIHVuZGVmaW5lZCB3aGVuIG9ubHkgdGhlIGZpcnN0IGFsZXJ0IGV4aXN0c1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS9jbGFyaXR5L2lzc3Vlcy8yNDMwXG4gICAgICBpZiAodGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQgPT09IHRoaXMgfHwgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jb3VudCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5oaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzbHlIaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNseUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmRldGVjdENoYW5nZXNJZk5lZWRlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhpZGRlbjtcbiAgfVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jbG9zYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlKSB7XG4gICAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlZENoYW5nZWQuZW1pdCh0cnVlKTtcbiAgfVxuXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VkQ2hhbmdlZC5lbWl0KGZhbHNlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2ljb24tYW5kLXR5cGVzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYWxlcnQtaXRlbScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1pY29uLXdyYXBwZXJcIj5cbiAgICAgICAgICAgIDxjbHItaWNvbiBjbGFzcz1cImFsZXJ0LWljb25cIiBcbiAgICAgICAgICAgICAgW2F0dHIuc2hhcGVdPVwiaWNvblNlcnZpY2UuYWxlcnRJY29uU2hhcGVcIiBcbiAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiaWNvblNlcnZpY2UuYWxlcnRJY29uVGl0bGVcIj48L2Nsci1pY29uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHsgY2xhc3M6ICdhbGVydC1pdGVtJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydEl0ZW0ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaWNvblNlcnZpY2U6IEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSkge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckFsZXJ0IH0gZnJvbSAnLi9hbGVydCc7XG5pbXBvcnQgeyBNdWx0aUFsZXJ0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL211bHRpLWFsZXJ0LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYWxlcnRzJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2FsZXJ0cy5odG1sJyxcbiAgcHJvdmlkZXJzOiBbTXVsdGlBbGVydFNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5hbGVydHNdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuYWxlcnQtZGFuZ2VyXSc6IFwidGhpcy5jdXJyZW50QWxlcnRUeXBlID09ICdkYW5nZXInXCIsXG4gICAgJ1tjbGFzcy5hbGVydC1pbmZvXSc6IFwidGhpcy5jdXJyZW50QWxlcnRUeXBlID09ICdpbmZvJ1wiLFxuICAgICdbY2xhc3MuYWxlcnQtc3VjY2Vzc10nOiBcInRoaXMuY3VycmVudEFsZXJ0VHlwZSA9PSAnc3VjY2VzcydcIixcbiAgICAnW2NsYXNzLmFsZXJ0LXdhcm5pbmddJzogXCJ0aGlzLmN1cnJlbnRBbGVydFR5cGUgPT0gJ3dhcm5pbmcnXCIsXG4gIH0sXG4gIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrIH0nXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQWxlcnRzIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJBbGVydCkgYWxsQWxlcnRzOiBRdWVyeUxpc3Q8Q2xyQWxlcnQ+O1xuXG4gIC8qKlxuICAgKiBJbnB1dC9PdXRwdXQgdG8gc3VwcG9ydCB0d28gd2F5IGJpbmRpbmcgb24gY3VycmVudCBhbGVydCBpbmRleFxuICAgKi9cbiAgQElucHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleCcpXG4gIHB1YmxpYyBzZXQgX2lucHV0Q3VycmVudEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbmRleCkgJiYgaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50ID0gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyQ3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UnKSBwdWJsaWMgY3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oZmFsc2UpO1xuXG4gIHNldCBjdXJyZW50QWxlcnRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50ID0gaW5kZXg7XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbGVydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQ7XG4gIH1cblxuICAvKipcbiAgICogSW5wdXQvT3V0cHV0IHRvIHN1cHBvcnQgdHdvIHdheSBiaW5kaW5nIG9uIGN1cnJlbnQgYWxlcnQgaW5zdGFuY2VcbiAgICovXG4gIEBJbnB1dCgnY2xyQ3VycmVudEFsZXJ0JylcbiAgc2V0IGN1cnJlbnRBbGVydChhbGVydDogQ2xyQWxlcnQpIHtcbiAgICBpZiAoYWxlcnQpIHtcbiAgICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0ID0gYWxlcnQ7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50QWxlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0O1xuICB9XG4gIEBPdXRwdXQoJ2NsckN1cnJlbnRBbGVydENoYW5nZScpIHB1YmxpYyBjdXJyZW50QWxlcnRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENsckFsZXJ0PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVuc3VyZSB3ZSBhcmUgb25seSBkZWFsaW5nIHdpdGggYWxlcnRzIHRoYXQgaGF2ZSBub3QgYmVlbiBjbG9zZWQgeWV0XG4gICAqL1xuICBnZXQgYWxlcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmFsbEFsZXJ0cy5maWx0ZXIoYWxlcnQgPT4ge1xuICAgICAgcmV0dXJuIGFsZXJ0LmlzSGlkZGVuID09PSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBjdXJyZW50QWxlcnRUeXBlKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0KSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQuYWxlcnRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbXVsdGlBbGVydFNlcnZpY2U6IE11bHRpQWxlcnRTZXJ2aWNlKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLm1hbmFnZSh0aGlzLmFsbEFsZXJ0cyk7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZShpbmRleCA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRBbGVydEluZGV4Q2hhbmdlLm5leHQoaW5kZXgpO1xuICAgICAgdGhpcy5jdXJyZW50QWxlcnRDaGFuZ2UubmV4dCh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyQWxlcnQgfSBmcm9tICcuL2FsZXJ0JztcbmltcG9ydCB7IE11bHRpQWxlcnRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbXVsdGktYWxlcnQuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1hbGVydHMtcGFnZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vYWxlcnRzLXBhZ2VyLmh0bWwnLFxuICBob3N0OiB7ICdbY2xhc3MuYWxlcnRzLXBhZ2VyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydHNQYWdlciBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBtdWx0aUFsZXJ0U2VydmljZUNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSW5wdXQvT3V0cHV0IHRvIHN1cHBvcnQgdHdvIHdheSBiaW5kaW5nIG9uIGN1cnJlbnQgYWxlcnQgaW5zdGFuY2VcbiAgICovXG4gIEBJbnB1dCgnY2xyQ3VycmVudEFsZXJ0JylcbiAgc2V0IGN1cnJlbnRBbGVydChhbGVydDogQ2xyQWxlcnQpIHtcbiAgICBpZiAoYWxlcnQpIHtcbiAgICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0ID0gYWxlcnQ7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50QWxlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0O1xuICB9XG5cbiAgQE91dHB1dCgnY2xyQ3VycmVudEFsZXJ0Q2hhbmdlJykgY3VycmVudEFsZXJ0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJBbGVydD4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBJbnB1dC9PdXRwdXQgdG8gc3VwcG9ydCB0d28gd2F5IGJpbmRpbmcgb24gY3VycmVudCBhbGVydCBpbmRleFxuICAgKi9cbiAgQElucHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleCcpXG4gIHNldCBjdXJyZW50QWxlcnRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50ID0gaW5kZXg7XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbGVydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQ7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleENoYW5nZScpIGN1cnJlbnRBbGVydEluZGV4Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG11bHRpQWxlcnRTZXJ2aWNlOiBNdWx0aUFsZXJ0U2VydmljZSwgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2VDaGFuZ2VzID0gdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZShpbmRleCA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRBbGVydEluZGV4Q2hhbmdlLmVtaXQoaW5kZXgpO1xuICAgICAgdGhpcy5jdXJyZW50QWxlcnRDaGFuZ2UuZW1pdCh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmFjdGl2ZUFsZXJ0c1tpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgcGFnZVVwKCkge1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UubmV4dCgpO1xuICB9XG5cbiAgcGFnZURvd24oKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5wcmV2aW91cygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZUNoYW5nZXMudW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRHJvcGRvd25Nb2R1bGUgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckFsZXJ0IH0gZnJvbSAnLi9hbGVydCc7XG5pbXBvcnQgeyBDbHJBbGVydEl0ZW0gfSBmcm9tICcuL2FsZXJ0LWl0ZW0nO1xuaW1wb3J0IHsgQ2xyQWxlcnRzIH0gZnJvbSAnLi9hbGVydHMnO1xuaW1wb3J0IHsgQ2xyQWxlcnRzUGFnZXIgfSBmcm9tICcuL2FsZXJ0cy1wYWdlcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfQUxFUlRfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyQWxlcnQsIENsckFsZXJ0SXRlbSwgQ2xyQWxlcnRzLCBDbHJBbGVydHNQYWdlcl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGUsIENsckRyb3Bkb3duTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0FMRVJUX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX0FMRVJUX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckFsZXJ0TW9kdWxlIH0gZnJvbSAnLi9hbGVydC9hbGVydC5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoeyBleHBvcnRzOiBbQ2xyQWxlcnRNb2R1bGVdIH0pXG5leHBvcnQgY2xhc3MgQ2xyRW1waGFzaXNNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJlc3BvbnNpdmVOYXZDb2RlcyB7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0xFVkVMXzE6IG51bWJlciA9IDE7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0xFVkVMXzI6IG51bWJlciA9IDI7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMT1NFX0FMTDogc3RyaW5nID0gJ05BVl9DTE9TRV9BTEwnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9PUEVOOiBzdHJpbmcgPSAnTkFWX09QRU4nO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTE9TRTogc3RyaW5nID0gJ05BVl9DTE9TRSc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX1RPR0dMRTogc3RyaW5nID0gJ05BVl9UT0dHTEUnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19IQU1CVVJHRVJfTUVOVTogc3RyaW5nID0gJ29wZW4taGFtYnVyZ2VyLW1lbnUnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19PVkVSRkxPV19NRU5VOiBzdHJpbmcgPSAnb3Blbi1vdmVyZmxvdy1tZW51JztcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xBU1NfVFJJR0dFUl8xOiBzdHJpbmcgPSAnaGVhZGVyLWhhbWJ1cmdlci10cmlnZ2VyJztcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xBU1NfVFJJR0dFUl8yOiBzdHJpbmcgPSAnaGVhZGVyLW92ZXJmbG93LXRyaWdnZXInO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19MRVZFTF8xOiBzdHJpbmcgPSAnY2xyLW5hdi1sZXZlbC0xJztcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xBU1NfTEVWRUxfMjogc3RyaW5nID0gJ2Nsci1uYXYtbGV2ZWwtMic7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBjbGFzcyBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb250cm9sQ29kZTogc3RyaW5nLCBwcml2YXRlIF9uYXZMZXZlbDogbnVtYmVyKSB7fVxuXG4gIGdldCBjb250cm9sQ29kZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sQ29kZTtcbiAgfVxuXG4gIGdldCBuYXZMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9uYXZMZXZlbDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29kZXMgfSBmcm9tICcuLi9yZXNwb25zaXZlLW5hdi1jb2Rlcyc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UgfSBmcm9tICcuLi9yZXNwb25zaXZlLW5hdi1jb250cm9sLW1lc3NhZ2UnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSB7XG4gIHB1YmxpYyByZXNwb25zaXZlTmF2TGlzdDogbnVtYmVyW10gPSBbXTtcbiAgcHJpdmF0ZSByZWdpc3Rlck5hdlN1YmplY3QgPSBuZXcgUmVwbGF5U3ViamVjdDxudW1iZXJbXT4oKTtcbiAgcHJpdmF0ZSBjb250cm9sTmF2U3ViamVjdCA9IG5ldyBTdWJqZWN0PFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZT4oKTtcblxuICBnZXQgcmVnaXN0ZXJlZE5hdnMoKTogT2JzZXJ2YWJsZTxudW1iZXJbXT4ge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyTmF2U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBuYXZDb250cm9sKCk6IE9ic2VydmFibGU8UmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlPiB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbE5hdlN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsb3NlQWxsTmF2cygpOyAvLyBXZSBzdGFydCB3aXRoIGFsbCBuYXZzIGNsb3NlZFxuICB9XG5cbiAgcmVnaXN0ZXJOYXYobmF2TGV2ZWw6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghbmF2TGV2ZWwgfHwgdGhpcy5pc05hdlJlZ2lzdGVyZWQobmF2TGV2ZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2l2ZU5hdkxpc3QucHVzaChuYXZMZXZlbCk7XG4gICAgdGhpcy5yZWdpc3Rlck5hdlN1YmplY3QubmV4dCh0aGlzLnJlc3BvbnNpdmVOYXZMaXN0KTtcbiAgfVxuXG4gIGlzTmF2UmVnaXN0ZXJlZChuYXZMZXZlbDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2l2ZU5hdkxpc3QuaW5kZXhPZihuYXZMZXZlbCkgPiAtMSkge1xuICAgICAgY29uc29sZS5lcnJvcignTXVsdGlwbGUgY2xyLW5hdi1sZXZlbCAnICsgbmF2TGV2ZWwgKyAnIGF0dHJpYnV0ZXMgZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdCBvbmx5IG9uZSBleGlzdHMnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB1bnJlZ2lzdGVyTmF2KG5hdkxldmVsOiBudW1iZXIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVzcG9uc2l2ZU5hdkxpc3QuaW5kZXhPZihuYXZMZXZlbCk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZU5hdkxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJOYXZTdWJqZWN0Lm5leHQodGhpcy5yZXNwb25zaXZlTmF2TGlzdCk7XG4gICAgfVxuICB9XG5cbiAgc2VuZENvbnRyb2xNZXNzYWdlKGNvbnRyb2xDb2RlOiBzdHJpbmcsIG5hdkxldmVsOiBudW1iZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlOiBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UgPSBuZXcgUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlKGNvbnRyb2xDb2RlLCBuYXZMZXZlbCk7XG4gICAgdGhpcy5jb250cm9sTmF2U3ViamVjdC5uZXh0KG1lc3NhZ2UpO1xuICB9XG5cbiAgY2xvc2VBbGxOYXZzKCkge1xuICAgIGNvbnN0IG1lc3NhZ2U6IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSA9IG5ldyBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UoXG4gICAgICBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMT1NFX0FMTCxcbiAgICAgIC05OTlcbiAgICApO1xuICAgIHRoaXMuY29udHJvbE5hdlN1YmplY3QubmV4dChtZXNzYWdlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL25hdi9wcm92aWRlcnMvcmVzcG9uc2l2ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdkNvZGVzIH0gZnJvbSAnLi4vbmF2L3Jlc3BvbnNpdmUtbmF2LWNvZGVzJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSB9IGZyb20gJy4uL25hdi9yZXNwb25zaXZlLW5hdi1jb250cm9sLW1lc3NhZ2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItbWFpbi1jb250YWluZXInLCBob3N0OiB7ICdbY2xhc3MubWFpbi1jb250YWluZXJdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJNYWluQ29udGFpbmVyIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQge1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfY2xhc3NMaXN0OiBET01Ub2tlbkxpc3Q7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSByZXNwb25zaXZlTmF2U2VydmljZTogUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX2NsYXNzTGlzdCA9IHRoaXMuZWxSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3Q7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5uYXZDb250cm9sLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAobWVzc2FnZTogUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvY2Vzc01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHJvY2Vzc01lc3NhZ2UobWVzc2FnZTogUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlKTogdm9pZCB7XG4gICAgbGV0IG5hdkNsYXNzOiBzdHJpbmcgPSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX0hBTUJVUkdFUl9NRU5VO1xuICAgIGlmIChtZXNzYWdlLmNvbnRyb2xDb2RlID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMT1NFX0FMTCkge1xuICAgICAgdGhpcy5fY2xhc3NMaXN0LnJlbW92ZShSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX0hBTUJVUkdFUl9NRU5VKTtcbiAgICAgIHRoaXMuX2NsYXNzTGlzdC5yZW1vdmUoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTEFTU19PVkVSRkxPV19NRU5VKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubmF2TGV2ZWwgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMSkge1xuICAgICAgdGhpcy5jb250cm9sTmF2KG1lc3NhZ2UuY29udHJvbENvZGUsIG5hdkNsYXNzKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubmF2TGV2ZWwgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMikge1xuICAgICAgbmF2Q2xhc3MgPSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX09WRVJGTE9XX01FTlU7XG4gICAgICB0aGlzLmNvbnRyb2xOYXYobWVzc2FnZS5jb250cm9sQ29kZSwgbmF2Q2xhc3MpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRyb2xOYXYoY29udHJvbENvZGU6IHN0cmluZywgbmF2Q2xhc3M6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChjb250cm9sQ29kZSA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9PUEVOKSB7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QuYWRkKG5hdkNsYXNzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xDb2RlID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMT1NFKSB7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QucmVtb3ZlKG5hdkNsYXNzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xDb2RlID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX1RPR0dMRSkge1xuICAgICAgdGhpcy5fY2xhc3NMaXN0LnRvZ2dsZShuYXZDbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsck1haW5Db250YWluZXIgfSBmcm9tICcuL21haW4tY29udGFpbmVyJztcblxuZXhwb3J0IGNvbnN0IENMUl9MQVlPVVRfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyTWFpbkNvbnRhaW5lcl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfTEFZT1VUX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX0xBWU9VVF9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTWFpbkNvbnRhaW5lck1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaWxseVdvbmthIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL3dpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLW1haW4tY29udGFpbmVyJyB9KVxuZXhwb3J0IGNsYXNzIE1haW5Db250YWluZXJXaWxseVdvbmthIGV4dGVuZHMgV2lsbHlXb25rYSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9vbXBhTG9vbXBhIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL29vbXBhLWxvb21wYSc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvcmVzcG9uc2l2ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFpbkNvbnRhaW5lcldpbGx5V29ua2EgfSBmcm9tICcuL21haW4tY29udGFpbmVyLXdpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWhlYWRlcicgfSlcbmV4cG9ydCBjbGFzcyBOYXZEZXRlY3Rpb25Pb21wYUxvb21wYSBleHRlbmRzIE9vbXBhTG9vbXBhIHtcbiAgcHJpdmF0ZSByZXNwb25zaXZlTmF2U2VydmljZTogUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQE9wdGlvbmFsKCkgd2lsbHlXb25rYTogTWFpbkNvbnRhaW5lcldpbGx5V29ua2EsXG4gICAgcmVzcG9uc2l2ZU5hdlNlcnZpY2U6IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZVxuICApIHtcbiAgICBpZiAoIXdpbGx5V29ua2EpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyLWhlYWRlciBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsci1tYWluLWNvbnRhaW5lcicpO1xuICAgIH1cbiAgICBzdXBlcihjZHIsIHdpbGx5V29ua2EpO1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UgPSByZXNwb25zaXZlTmF2U2VydmljZTtcbiAgfVxuXG4gIC8vIE5hdkRldGVjdGlvbk9vbXBhTG9vbXBhIGlzIHRoZSBhZGRpdGlvbiBvZiB0aGUgbmF2IGxldmVsc1xuICAvLyBTaW5jZSB3ZSBzdXBwb3J0IDIgbGV2ZWxzLCB0aGUgcG9zc2liaWxpdGllcyBhcmUgMCwgMSBvciAzICgxICsgMilcbiAgZ2V0IGZsYXZvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5yZXNwb25zaXZlTmF2TGlzdC5yZWR1Y2UoKHN1bSwgbmF2TGV2ZWwpID0+IHN1bSArIG5hdkxldmVsLCAwKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29kZXMgfSBmcm9tICcuL3Jlc3BvbnNpdmUtbmF2LWNvZGVzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWhlYWRlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgKm5nSWY9XCJpc05hdkxldmVsMU9uUGFnZVwiXG4gICAgICAgICAgICBjbGFzcz1cImhlYWRlci1oYW1idXJnZXItdHJpZ2dlclwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlTmF2KHJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMSlcIj5cbiAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAqbmdJZj1cImlzTmF2TGV2ZWwyT25QYWdlXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaGVhZGVyLW92ZXJmbG93LXRyaWdnZXJcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZU5hdihyZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzIpXCI+XG4gICAgICAgICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyLWJhY2tkcm9wXCIgKGNsaWNrKT1cImNsb3NlT3Blbk5hdigpXCI+PC9kaXY+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmhlYWRlcl0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xySGVhZGVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHB1YmxpYyBpc05hdkxldmVsMU9uUGFnZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgaXNOYXZMZXZlbDJPblBhZ2U6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHJlc3BvbnNpdmVOYXZDb2RlcyA9IFJlc3BvbnNpdmVOYXZDb2RlcztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlc3BvbnNpdmVOYXZTZXJ2aWNlOiBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnJlZ2lzdGVyZWROYXZzLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAobmF2TGV2ZWxMaXN0OiBudW1iZXJbXSkgPT4ge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVOYXZUcmlnZ2VycyhuYXZMZXZlbExpc3QpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHJlc2V0IHRyaWdnZXJzLiBoYW5kbGVzIGNhc2VzIHdoZW4gYW4gYXBwbGljYXRpb24gaGFzIGRpZmZlcmVudCBuYXYgbGV2ZWxzIG9uIGRpZmZlcmVudCBwYWdlcy5cbiAgcmVzZXROYXZUcmlnZ2VycygpIHtcbiAgICB0aGlzLmlzTmF2TGV2ZWwxT25QYWdlID0gZmFsc2U7XG4gICAgdGhpcy5pc05hdkxldmVsMk9uUGFnZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gZGVjaWRlcyB3aGljaCB0cmlnZ2VycyB0byBzaG93IG9uIHRoZSBoZWFkZXJcbiAgaW5pdGlhbGl6ZU5hdlRyaWdnZXJzKG5hdkxpc3Q6IG51bWJlcltdKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldE5hdlRyaWdnZXJzKCk7XG4gICAgaWYgKG5hdkxpc3QubGVuZ3RoID4gMikge1xuICAgICAgY29uc29sZS5lcnJvcignTW9yZSB0aGFuIDIgTmF2IExldmVscyBkZXRlY3RlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmF2TGlzdC5mb3JFYWNoKG5hdkxldmVsID0+IHtcbiAgICAgIGlmIChuYXZMZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8xKSB7XG4gICAgICAgIHRoaXMuaXNOYXZMZXZlbDFPblBhZ2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChuYXZMZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8yKSB7XG4gICAgICAgIHRoaXMuaXNOYXZMZXZlbDJPblBhZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gY2xvc2VzIHRoZSBuYXYgdGhhdCBpcyBvcGVuXG4gIGNsb3NlT3Blbk5hdigpIHtcbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLmNsb3NlQWxsTmF2cygpO1xuICB9XG5cbiAgLy8gdG9nZ2xlcyB0aGUgbmF2IHRoYXQgaXMgb3BlblxuICB0b2dnbGVOYXYobmF2TGV2ZWw6IG51bWJlcikge1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2Uuc2VuZENvbnRyb2xNZXNzYWdlKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfVE9HR0xFLCBuYXZMZXZlbCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcmVzcG9uc2l2ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdkNvZGVzIH0gZnJvbSAnLi9yZXNwb25zaXZlLW5hdi1jb2Rlcyc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHItbmF2LWxldmVsXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJOYXZMZXZlbCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgnY2xyLW5hdi1sZXZlbCcpIF9sZXZlbDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVzcG9uc2l2ZU5hdlNlcnZpY2U6IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSwgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICh0aGlzLmxldmVsICE9PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzEgJiYgdGhpcy5sZXZlbCAhPT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdOYXYgTGV2ZWwgY2FuIG9ubHkgYmUgMSBvciAyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UucmVnaXN0ZXJOYXYodGhpcy5sZXZlbCk7XG4gICAgdGhpcy5hZGROYXZDbGFzcyh0aGlzLmxldmVsKTtcbiAgfVxuXG4gIGFkZE5hdkNsYXNzKGxldmVsOiBudW1iZXIpIHtcbiAgICBjb25zdCBuYXZIb3N0Q2xhc3NMaXN0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0O1xuICAgIGlmIChsZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8xKSB7XG4gICAgICBuYXZIb3N0Q2xhc3NMaXN0LmFkZChSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX0xFVkVMXzEpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWwgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMikge1xuICAgICAgbmF2SG9zdENsYXNzTGlzdC5hZGQoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTEFTU19MRVZFTF8yKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gIH1cblxuICAvLyBnZXR0ZXIgdG8gYWNjZXNzIHRoZSByZXNwb25zaXZlIG5hdmlnYXRpb24gY29kZXMgZnJvbSB0aGUgdGVtcGxhdGVcbiAgZ2V0IHJlc3BvbnNpdmVOYXZDb2RlcygpOiBSZXNwb25zaXZlTmF2Q29kZXMge1xuICAgIHJldHVybiBSZXNwb25zaXZlTmF2Q29kZXM7XG4gIH1cblxuICBvcGVuKCk6IHZvaWQge1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2Uuc2VuZENvbnRyb2xNZXNzYWdlKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfT1BFTiwgdGhpcy5sZXZlbCk7XG4gIH1cblxuICBjbG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnNlbmRDb250cm9sTWVzc2FnZShSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMT1NFLCB0aGlzLmxldmVsKTtcbiAgfVxuXG4gIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdHMgdGhlIGJlc3Qgd2F5IHRvIGRvIHRoaXMuIFBvc3NpYmxlIG1ldGhvZHNcbiAgLy8gMS4gSG9zdExpc3RlbmVyIChjdXJyZW50IHNvbHV0aW9uKVxuICAvLyAyLiBEaXJlY3RpdmVzIG9uIHRoZSAubmF2LWxpbmsgY2xhc3MuIFdlIGRpc2N1c3NlZCBvbiBtb3ZpbmcgYXdheSBmcm9tIGNsYXNzIHNlbGVjdG9ycyBidXQgSSBmb3JnZXQgdGhlIHJlYXNvblxuICAvLyB3aHlcbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcbiAgb25Nb3VzZUNsaWNrKHRhcmdldDogYW55KSB7XG4gICAgbGV0IGN1cnJlbnQ6IGFueSA9IHRhcmdldDsgLy8gR2V0IHRoZSBlbGVtZW50IGluIHRoZSBET00gb24gd2hpY2ggdGhlIG1vdXNlIHdhcyBjbGlja2VkXG4gICAgY29uc3QgbmF2SG9zdDogYW55ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7IC8vIEdldCB0aGUgY3VycmVudCBuYXYgbmF0aXZlIEhUTUwgZWxlbWVudFxuXG4gICAgLy8gU3RhcnQgY2hlY2tpbmcgaWYgY3VycmVudCBhbmQgbmF2SG9zdCBhcmUgZXF1YWwuXG4gICAgLy8gSWYgbm90IHRyYXZlcnNlIHRvIHRoZSBwYXJlbnROb2RlIGFuZCBjaGVjayBhZ2Fpbi5cbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IG5hdkhvc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50LmNsYXNzTGlzdC5jb250YWlucygnbmF2LWxpbmsnKSkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS51bnJlZ2lzdGVyTmF2KHRoaXMubGV2ZWwpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJEcm9wZG93bk1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcblxuaW1wb3J0IHsgTWFpbkNvbnRhaW5lcldpbGx5V29ua2EgfSBmcm9tICcuL2Nob2NvbGF0ZS9tYWluLWNvbnRhaW5lci13aWxseS13b25rYSc7XG5pbXBvcnQgeyBOYXZEZXRlY3Rpb25Pb21wYUxvb21wYSB9IGZyb20gJy4vY2hvY29sYXRlL25hdi1kZXRlY3Rpb24tb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IENsckhlYWRlciB9IGZyb20gJy4vaGVhZGVyJztcbmltcG9ydCB7IENsck5hdkxldmVsIH0gZnJvbSAnLi9uYXYtbGV2ZWwnO1xuXG5leHBvcnQgY29uc3QgQ0xSX05BVklHQVRJT05fRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbXG4gIENsckhlYWRlcixcbiAgQ2xyTmF2TGV2ZWwsXG4gIE5hdkRldGVjdGlvbk9vbXBhTG9vbXBhLFxuICBNYWluQ29udGFpbmVyV2lsbHlXb25rYSxcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGUsIENsckRyb3Bkb3duTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX05BVklHQVRJT05fRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfTkFWSUdBVElPTl9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTmF2aWdhdGlvbk1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICB0ZW1wbGF0ZTogYFxuICAgICAgPG5nLXRlbXBsYXRlPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUmVmQ29udGFpbmVyIHtcbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZikgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUZW1wbGF0ZVJlZkNvbnRhaW5lciB9IGZyb20gJy4vdGVtcGxhdGUtcmVmLWNvbnRhaW5lcic7XG5cbmV4cG9ydCAqIGZyb20gJy4vdGVtcGxhdGUtcmVmLWNvbnRhaW5lcic7XG5cbmV4cG9ydCBjb25zdCBURU1QTEFURV9SRUZfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbVGVtcGxhdGVSZWZDb250YWluZXJdO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFRFTVBMQVRFX1JFRl9ESVJFQ1RJVkVTIH0gZnJvbSAnLi9pbmRleCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtURU1QTEFURV9SRUZfRElSRUNUSVZFU10sXG4gIGVudHJ5Q29tcG9uZW50czogW1RFTVBMQVRFX1JFRl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW1RFTVBMQVRFX1JFRl9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGVtcGxhdGVSZWZNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2lsbHlXb25rYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS93aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci10YWJzJyB9KVxuZXhwb3J0IGNsYXNzIFRhYnNXaWxseVdvbmthIGV4dGVuZHMgV2lsbHlXb25rYSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgSW5qZWN0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBPb21wYUxvb21wYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS9vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgSUZfQUNUSVZFX0lELCBJZkFjdGl2ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuc2VydmljZSc7XG5cbmltcG9ydCB7IFRhYnNXaWxseVdvbmthIH0gZnJvbSAnLi90YWJzLXdpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclRhYkxpbmtdLCBjbHItdGFiLWNvbnRlbnQnIH0pXG5leHBvcnQgY2xhc3MgQWN0aXZlT29tcGFMb29tcGEgZXh0ZW5kcyBPb21wYUxvb21wYSB7XG4gIHByaXZhdGUgaWZBY3RpdmU6IElmQWN0aXZlU2VydmljZTtcbiAgcHJpdmF0ZSBpZDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQE9wdGlvbmFsKCkgd2lsbHlXb25rYTogVGFic1dpbGx5V29ua2EsXG4gICAgQEluamVjdChJRl9BQ1RJVkVfSUQpIGlkOiBudW1iZXIsXG4gICAgaWZBY3RpdmU6IElmQWN0aXZlU2VydmljZVxuICApIHtcbiAgICBpZiAoIXdpbGx5V29ua2EpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyVGFiTGluayBhbmQgY2xyLXRhYi1jb250ZW50IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLXRhYnMnKTtcbiAgICB9XG4gICAgc3VwZXIoY2RyLCB3aWxseVdvbmthKTtcbiAgICB0aGlzLmlmQWN0aXZlID0gaWZBY3RpdmU7XG4gICAgdGhpcy5pZCA9IGlkO1xuICB9XG5cbiAgZ2V0IGZsYXZvcigpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZS5jdXJyZW50ID09PSB0aGlzLmlkO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8vIFRPRE86IGlmIHdlIGZpbmQgbW9yZSBjb21wb25lbnRzIHRoYXQgY291bGQgdXNlIHRoaXMsIGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIHV0aWxzXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQXJpYVNlcnZpY2Uge1xuICBwdWJsaWMgYXJpYUxhYmVsbGVkQnk6IHN0cmluZztcbiAgcHVibGljIGFyaWFDb250cm9sczogc3RyaW5nO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyVGFiIH0gZnJvbSAnLi4vdGFiJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRhYnNTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfY2hpbGRyZW46IENsclRhYltdID0gW107XG5cbiAgcmVnaXN0ZXIodGFiOiBDbHJUYWIpIHtcbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKHRhYik7XG4gIH1cblxuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZVRhYigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maW5kKCh0YWI6IENsclRhYikgPT4ge1xuICAgICAgcmV0dXJuIHRhYi5hY3RpdmU7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgb3ZlcmZsb3dUYWJzKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmZpbHRlcigodGFiOiBDbHJUYWIpID0+IHtcbiAgICAgIHJldHVybiB0YWIudGFiTGluay5pbk92ZXJmbG93ID09PSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgdW5yZWdpc3Rlcih0YWI6IENsclRhYikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKHRhYik7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICB0YWJDb250ZW50Vmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRW1iZWRkZWRWaWV3UmVmLCBJbmplY3QsIElucHV0LCBPbkRlc3Ryb3ksIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElGX0FDVElWRV9JRCwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UnO1xuaW1wb3J0IHsgQXJpYVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9hcmlhLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFic1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJzLnNlcnZpY2UnO1xuXG5sZXQgbmJUYWJDb250ZW50Q29tcG9uZW50czogbnVtYmVyID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRhYi1jb250ZW50JyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctdGVtcGxhdGUgI3RhYkNvbnRlbnRQcm9qZWN0ZWRSZWY+XG4gICAgICA8c2VjdGlvbiBbaWRdPVwidGFiQ29udGVudElkXCIgcm9sZT1cInRhYnBhbmVsXCIgY2xhc3M9XCJ0YWItY29udGVudFwiIFtjbGFzcy5hY3RpdmVdPVwiYWN0aXZlXCJcbiAgICAgICAgICAgICAgIFtoaWRkZW5dPVwiIWFjdGl2ZVwiXG4gICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiYXJpYUxhYmVsbGVkQnlcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJhY3RpdmVcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIWFjdGl2ZVwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUYWJDb250ZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSB2aWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8Q2xyVGFiQ29udGVudD47XG5cbiAgLy8gVGhlIHRlbXBsYXRlIG11c3QgYmUgYXBwbGllZCBvbiB0aGUgdG9wLWRvd24gcGhhc2Ugb2Ygdmlldy1jaGlsZCBpbml0aWFsaXphdGlvbiB0byBwcmV2ZW50XG4gIC8vIGNvbXBvbmVudHMgaW4gdGhlIGNvbnRlbnQgZnJvbSBpbml0aWFsaXppbmcgYmVmb3JlIGEgY29udGVudCBjb250YWluZXIgZXhpc3RzLlxuICAvLyBTb21lIGNoaWxkIGNvbXBvbmVudHMgbmVlZCB0aGVpciBjb250YWluZXIgZm9yIHNpemluZyBjYWxjdWxhdGlvbnMuXG4gIC8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xuICBAVmlld0NoaWxkKCd0YWJDb250ZW50UHJvamVjdGVkUmVmJylcbiAgcHJpdmF0ZSBzZXQgdGVtcGxhdGVSZWYodmFsdWU6IFRlbXBsYXRlUmVmPENsclRhYkNvbnRlbnQ+KSB7XG4gICAgdGhpcy52aWV3UmVmID0gdGhpcy50YWJzU2VydmljZS50YWJDb250ZW50Vmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodmFsdWUpO1xuICB9XG4gIC8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIEBJbmplY3QoSUZfQUNUSVZFX0lEKSBwdWJsaWMgaWQ6IG51bWJlcixcbiAgICBwcml2YXRlIGFyaWFTZXJ2aWNlOiBBcmlhU2VydmljZSxcbiAgICBwcml2YXRlIHRhYnNTZXJ2aWNlOiBUYWJzU2VydmljZVxuICApIHtcbiAgICBpZiAoIXRoaXMudGFiQ29udGVudElkKSB7XG4gICAgICB0aGlzLnRhYkNvbnRlbnRJZCA9ICdjbHItdGFiLWNvbnRlbnQtJyArIG5iVGFiQ29udGVudENvbXBvbmVudHMrKztcbiAgICB9XG4gIH1cblxuICBnZXQgYXJpYUxhYmVsbGVkQnkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmlhU2VydmljZS5hcmlhTGFiZWxsZWRCeTtcbiAgfVxuXG4gIGdldCB0YWJDb250ZW50SWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmlhU2VydmljZS5hcmlhQ29udHJvbHM7XG4gIH1cblxuICBASW5wdXQoJ2lkJylcbiAgc2V0IHRhYkNvbnRlbnRJZChpZDogc3RyaW5nKSB7XG4gICAgdGhpcy5hcmlhU2VydmljZS5hcmlhQ29udHJvbHMgPSBpZDtcbiAgfVxuXG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPT09IHRoaXMuaWQ7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMudGFic1NlcnZpY2UudGFiQ29udGVudFZpZXdDb250YWluZXIuaW5kZXhPZih0aGlzLnZpZXdSZWYpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnRhYnNTZXJ2aWNlLnRhYkNvbnRlbnRWaWV3Q29udGFpbmVyLnJlbW92ZShpbmRleCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5sZXQgbmJUYWJzQ29tcG9uZW50ID0gMDtcblxuZXhwb3J0IGNvbnN0IFRBQlNfSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW48bnVtYmVyPignVEFCU19JRCcpO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5GYWN0b3J5KCkge1xuICByZXR1cm4gJ2Nsci10YWJzLScgKyBuYlRhYnNDb21wb25lbnQrKztcbn1cblxuZXhwb3J0IGNvbnN0IFRBQlNfSURfUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IFRBQlNfSUQsXG4gIHVzZUZhY3Rvcnk6IHRva2VuRmFjdG9yeSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSUZfQUNUSVZFX0lELCBJZkFjdGl2ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuc2VydmljZSc7XG5pbXBvcnQgeyBUZW1wbGF0ZVJlZkNvbnRhaW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL3RlbXBsYXRlLXJlZi90ZW1wbGF0ZS1yZWYtY29udGFpbmVyJztcblxuaW1wb3J0IHsgQXJpYVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9hcmlhLnNlcnZpY2UnO1xuaW1wb3J0IHsgVEFCU19JRCB9IGZyb20gJy4vdGFicy1pZC5wcm92aWRlcic7XG5cbmxldCBuYlRhYkxpbmtDb21wb25lbnRzOiBudW1iZXIgPSAwO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyVGFiTGlua10nLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAndGFiTGlua0lkJyxcbiAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnYWN0aXZlJyxcbiAgICAnW2F0dHIuYXJpYS1oaWRkZW5dJzogJ2ZhbHNlJyxcbiAgICAnW2F0dHIuYXJpYS1jb250cm9sc10nOiAnYXJpYUNvbnRyb2xzJyxcbiAgICAnW2NsYXNzLmJ0bl0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5idG4tbGlua10nOiAnIWluT3ZlcmZsb3cnLFxuICAgICdbY2xhc3MubmF2LWxpbmtdJzogJyFpbk92ZXJmbG93JyxcbiAgICAnW2NsYXNzLm5hdi1pdGVtXSc6ICchaW5PdmVyZmxvdycsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgcm9sZTogJ3RhYicsXG4gICAgdHlwZTogJ2J1dHRvbicsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYkxpbmsge1xuICBASW5wdXQoJ2NsclRhYkxpbmtJbk92ZXJmbG93JykgaW5PdmVyZmxvdzogYm9vbGVhbjtcbiAgdGVtcGxhdGVSZWZDb250YWluZXI6IFRlbXBsYXRlUmVmQ29udGFpbmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBpZkFjdGl2ZVNlcnZpY2U6IElmQWN0aXZlU2VydmljZSxcbiAgICBASW5qZWN0KElGX0FDVElWRV9JRCkgcHJpdmF0ZSBpZDogbnVtYmVyLFxuICAgIHByaXZhdGUgYXJpYVNlcnZpY2U6IEFyaWFTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgQEluamVjdChUQUJTX0lEKSBwdWJsaWMgdGFic0lkOiBudW1iZXJcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnRhYkxpbmtJZCkge1xuICAgICAgdGhpcy50YWJMaW5rSWQgPSAnY2xyLXRhYi1saW5rLScgKyBuYlRhYkxpbmtDb21wb25lbnRzKys7XG4gICAgfVxuXG4gICAgLy8gVGFiIGxpbmtzIGNhbiBiZSByZW5kZXJlZCBpbiBvbmUgb2YgdHdvIHBsYWNlczogaW4gdGhlIG1haW4gYXJlYSBvciBpbnNpZGUgdGhlIG92ZXJmbG93IGRyb3Bkb3duIG1lbnUuXG4gICAgLy8gSGVyZSwgd2UgY3JlYXRlIGEgY29udGFpbmVyIHNvIHRoYXQgaXRzIHRlbXBsYXRlIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBlbWJlZGRlZFZpZXcgb24gdGhlIGZseS5cbiAgICAvLyBTZWUgVGFic1NlcnZpY2UncyByZW5kZXJWaWV3KCkgbWV0aG9kIGFuZCBob3cgaXQncyB1c2VkIGluIFRhYnMgY2xhc3MgZm9yIGFuIGV4YW1wbGUuXG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFRlbXBsYXRlUmVmQ29udGFpbmVyKTtcbiAgICB0aGlzLnRlbXBsYXRlUmVmQ29udGFpbmVyID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5LCAxLCB1bmRlZmluZWQsIFtcbiAgICAgIFt0aGlzLmVsLm5hdGl2ZUVsZW1lbnRdLFxuICAgIF0pLmluc3RhbmNlO1xuICB9XG5cbiAgZ2V0IGFyaWFDb250cm9scygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFDb250cm9scztcbiAgfVxuXG4gIGdldCB0YWJMaW5rSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmlhU2VydmljZS5hcmlhTGFiZWxsZWRCeTtcbiAgfVxuXG4gIEBJbnB1dCgnaWQnKVxuICBzZXQgdGFiTGlua0lkKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFMYWJlbGxlZEJ5ID0gaWQ7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPSB0aGlzLmlkO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElGX0FDVElWRV9JRF9QUk9WSURFUiwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBBcmlhU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2FyaWEuc2VydmljZSc7XG5pbXBvcnQgeyBUYWJzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RhYnMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUYWJDb250ZW50IH0gZnJvbSAnLi90YWItY29udGVudCc7XG5pbXBvcnQgeyBDbHJUYWJMaW5rIH0gZnJvbSAnLi90YWItbGluay5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGFiJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIHByb3ZpZGVyczogW0lGX0FDVElWRV9JRF9QUk9WSURFUiwgQXJpYVNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUYWIge1xuICBAQ29udGVudENoaWxkKENsclRhYkxpbmspIHRhYkxpbms6IENsclRhYkxpbms7XG4gIEBDb250ZW50Q2hpbGQoQ2xyVGFiQ29udGVudCkgdGFiQ29udGVudDogQ2xyVGFiQ29udGVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgQEluamVjdChJRl9BQ1RJVkVfSUQpIHB1YmxpYyBpZDogbnVtYmVyLFxuICAgIHByaXZhdGUgdGFic1NlcnZpY2U6IFRhYnNTZXJ2aWNlXG4gICkge1xuICAgIHRhYnNTZXJ2aWNlLnJlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy50YWJzU2VydmljZS51bnJlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3RvciwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGFiLW92ZXJmbG93LWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZHJvcGRvd24tbWVudV0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYk92ZXJmbG93Q29udGVudCBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKGluamVjdG9yOiBJbmplY3RvciwgQFNraXBTZWxmKCkgcGFyZW50SG9zdDogRWxlbWVudFJlZikge1xuICAgIHN1cGVyKGluamVjdG9yLCBwYXJlbnRIb3N0KTtcbiAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX1JJR0hUO1xuICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgIHRoaXMuY2xvc2VPbk91dHNpZGVDbGljayA9IHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBJbmplY3QsXG4gIFF1ZXJ5TGlzdCxcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5cbmltcG9ydCB7IFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdGFicy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRhYkxpbmsgfSBmcm9tICcuL3RhYi1saW5rLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJUYWJDb250ZW50IH0gZnJvbSAnLi90YWItY29udGVudCc7XG5pbXBvcnQgeyBUQUJTX0lELCBUQUJTX0lEX1BST1ZJREVSIH0gZnJvbSAnLi90YWJzLWlkLnByb3ZpZGVyJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRhYnMnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8dWwgY2xhc3M9XCJuYXZcIiByb2xlPVwidGFibGlzdFwiIFthdHRyLmFyaWEtb3duc109XCJ0YWJJZHNcIj5cbiAgICAgICAgICAgIDwhLS10YWIgbGlua3MtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGxpbmsgb2YgdGFiTGlua0RpcmVjdGl2ZXNcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibGluay50YWJzSWQgPT09IHRhYnNJZCAmJiAhbGluay5pbk92ZXJmbG93XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxpbmsudGVtcGxhdGVSZWZDb250YWluZXIudGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInRhYnNTZXJ2aWNlLm92ZXJmbG93VGFicy5sZW5ndGggPiAwXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYnMtb3ZlcmZsb3cgYm90dG9tLXJpZ2h0XCIgW2NsYXNzLm9wZW5dPVwiaWZPcGVuU2VydmljZS5vcGVuXCJcbiAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVPdmVyZmxvdygkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tbGluayBuYXYtbGluayBkcm9wZG93bi10b2dnbGVcIiB0eXBlPVwiYnV0dG9uXCIgW2NsYXNzLmFjdGl2ZV09XCJhY3RpdmVUYWJJbk92ZXJmbG93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZWxsaXBzaXMtaG9yaXpvbnRhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MuaXMtaW5mb109XCJpZk9wZW5TZXJ2aWNlLm9wZW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLm1vcmVcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDwhLS10YWIgbGlua3MgaW4gb3ZlcmZsb3cgbWVudS0tPlxuICAgICAgICAgICAgICAgICAgICA8Y2xyLXRhYi1vdmVyZmxvdy1jb250ZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgbGluayBvZiB0YWJMaW5rRGlyZWN0aXZlc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJsaW5rLnRhYnNJZCA9PT0gdGFic0lkICYmIGxpbmsuaW5PdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJsaW5rLnRlbXBsYXRlUmVmQ29udGFpbmVyLnRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9jbHItdGFiLW92ZXJmbG93LWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC91bD5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjdGFiQ29udGVudFZpZXdDb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gICAgYCxcbiAgcHJvdmlkZXJzOiBbSWZBY3RpdmVTZXJ2aWNlLCBJZk9wZW5TZXJ2aWNlLCBUYWJzU2VydmljZSwgVEFCU19JRF9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYnMgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJUYWJMaW5rLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gIHRhYkxpbmtEaXJlY3RpdmVzOiBRdWVyeUxpc3Q8Q2xyVGFiTGluaz47XG5cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJUYWJDb250ZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gIHRhYkNvbnRlbnRzOiBRdWVyeUxpc3Q8Q2xyVGFiQ29udGVudD47XG5cbiAgLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG4gIEBWaWV3Q2hpbGQoJ3RhYkNvbnRlbnRWaWV3Q29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIHByaXZhdGUgc2V0IHRhYkNvbnRlbnRWaWV3Q29udGFpbmVyKHZhbHVlOiBWaWV3Q29udGFpbmVyUmVmKSB7XG4gICAgdGhpcy50YWJzU2VydmljZS50YWJDb250ZW50Vmlld0NvbnRhaW5lciA9IHZhbHVlO1xuICB9XG4gIC8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIHB1YmxpYyBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHB1YmxpYyB0YWJzU2VydmljZTogVGFic1NlcnZpY2UsXG4gICAgQEluamVjdChUQUJTX0lEKSBwdWJsaWMgdGFic0lkOiBudW1iZXIsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlXG4gICkge31cblxuICBnZXQgYWN0aXZlVGFiSW5PdmVyZmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy50YWJzU2VydmljZS5vdmVyZmxvd1RhYnMuaW5kZXhPZih0aGlzLnRhYnNTZXJ2aWNlLmFjdGl2ZVRhYikgPiAtMTtcbiAgfVxuXG4gIGdldCB0YWJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFic1NlcnZpY2UuY2hpbGRyZW4ubWFwKHRhYiA9PiB0YWIudGFiTGluay50YWJMaW5rSWQpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnRhYkxpbmtEaXJlY3RpdmVzLmZpcnN0LmFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlT3ZlcmZsb3coZXZlbnQ6IGFueSkge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVGVtcGxhdGVSZWZNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy90ZW1wbGF0ZS1yZWYvdGVtcGxhdGUtcmVmLm1vZHVsZSc7XG5cbmltcG9ydCB7IEFjdGl2ZU9vbXBhTG9vbXBhIH0gZnJvbSAnLi9jaG9jb2xhdGUvYWN0aXZlLW9vbXBhLWxvb21wYSc7XG5pbXBvcnQgeyBUYWJzV2lsbHlXb25rYSB9IGZyb20gJy4vY2hvY29sYXRlL3RhYnMtd2lsbHktd29ua2EnO1xuaW1wb3J0IHsgQ2xyVGFiIH0gZnJvbSAnLi90YWInO1xuaW1wb3J0IHsgQ2xyVGFiQ29udGVudCB9IGZyb20gJy4vdGFiLWNvbnRlbnQnO1xuaW1wb3J0IHsgQ2xyVGFiTGluayB9IGZyb20gJy4vdGFiLWxpbmsuZGlyZWN0aXZlJztcbmltcG9ydCB7IENsclRhYk92ZXJmbG93Q29udGVudCB9IGZyb20gJy4vdGFiLW92ZXJmbG93LWNvbnRlbnQnO1xuaW1wb3J0IHsgQ2xyVGFicyB9IGZyb20gJy4vdGFicyc7XG5cbmV4cG9ydCBjb25zdCBDTFJfVEFCU19ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyVGFiQ29udGVudCxcbiAgQ2xyVGFiLFxuICBDbHJUYWJzLFxuICBDbHJUYWJPdmVyZmxvd0NvbnRlbnQsXG4gIENsclRhYkxpbmssXG4gIFRhYnNXaWxseVdvbmthLFxuICBBY3RpdmVPb21wYUxvb21wYSxcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckNvbW1vblBvcG92ZXJNb2R1bGUsIENsckNvbmRpdGlvbmFsTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJUZW1wbGF0ZVJlZk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9UQUJTX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1RBQlNfRElSRUNUSVZFUywgQ2xyQ29uZGl0aW9uYWxNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUYWJzTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlIHtcbiAgcHVibGljIG5hdkdyb3VwQ291bnQ6IG51bWJlciA9IDA7XG5cbiAgcmVnaXN0ZXJOYXZHcm91cCgpIHtcbiAgICB0aGlzLm5hdkdyb3VwQ291bnQrKztcbiAgfVxuXG4gIHVucmVnaXN0ZXJOYXZHcm91cCgpOiB2b2lkIHtcbiAgICB0aGlzLm5hdkdyb3VwQ291bnQtLTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfaWNvbnM6IG51bWJlciA9IDA7XG5cbiAgZ2V0IGhhc0ljb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pY29ucyA+IDA7XG4gIH1cblxuICByZWdpc3Rlckljb24oKTogdm9pZCB7XG4gICAgdGhpcy5faWNvbnMrKztcbiAgfVxuXG4gIHVucmVnaXN0ZXJJY29uKCk6IHZvaWQge1xuICAgIHRoaXMuX2ljb25zLS07XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmVydGljYWxOYXZTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfYW5pbWF0ZU9uQ29sbGFwc2VkOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBnZXQgYW5pbWF0ZU9uQ29sbGFwc2VkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRlT25Db2xsYXBzZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9jb2xsYXBzZWRDaGFuZ2VkOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBnZXQgY29sbGFwc2VkQ2hhbmdlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VkQ2hhbmdlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvbGxhcHNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBjb2xsYXBzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlZDtcbiAgfVxuXG4gIHNldCBjb2xsYXBzZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMuY29sbGFwc2libGUgJiYgdGhpcy5fY29sbGFwc2VkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy51cGRhdGVDb2xsYXBzZUJlaGF2aW9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jb2xsYXBzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBjb2xsYXBzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2libGU7XG4gIH1cblxuICBzZXQgY29sbGFwc2libGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMuX2NvbGxhcHNpYmxlICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSAmJiB0aGlzLmNvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbGxhcHNlQmVoYXZpb3IoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29sbGFwc2libGUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUNvbGxhcHNlQmVoYXZpb3IodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLl9hbmltYXRlT25Db2xsYXBzZWQubmV4dCh2YWx1ZSk7XG4gICAgdGhpcy5fY29sbGFwc2VkID0gdmFsdWU7XG4gICAgdGhpcy5fY29sbGFwc2VkQ2hhbmdlZC5uZXh0KHZhbHVlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgVmVydGljYWxOYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtZ3JvdXAtcmVnaXN0cmF0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZJY29uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1pY29uLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdmVydGljYWwtbmF2JyxcbiAgdGVtcGxhdGVVcmw6ICcuL3ZlcnRpY2FsLW5hdi5odG1sJyxcbiAgcHJvdmlkZXJzOiBbVmVydGljYWxOYXZTZXJ2aWNlLCBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlLCBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZV0sXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ2Nsci12ZXJ0aWNhbC1uYXYnLFxuICAgICdbY2xhc3MuaXMtY29sbGFwc2VkXSc6ICdjb2xsYXBzZWQnLFxuICAgICdbY2xhc3MuaGFzLW5hdi1ncm91cHNdJzogJ2hhc05hdkdyb3VwcycsXG4gICAgJ1tjbGFzcy5oYXMtaWNvbnNdJzogJ2hhc0ljb25zJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXYgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBnZXQgY29sbGFwc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2libGU7XG4gIH1cblxuICBASW5wdXQoJ2NsclZlcnRpY2FsTmF2Q29sbGFwc2libGUnKVxuICBzZXQgY29sbGFwc2libGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNpYmxlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyVmVydGljYWxOYXZDb2xsYXBzZWQnKVxuICBzZXQgY29sbGFwc2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsclZlcnRpY2FsTmF2Q29sbGFwc2VkQ2hhbmdlJylcbiAgcHJpdmF0ZSBfY29sbGFwc2VkQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBnZXQgaGFzTmF2R3JvdXBzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UubmF2R3JvdXBDb3VudCA+IDA7XG4gIH1cblxuICBnZXQgaGFzSWNvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdkljb25TZXJ2aWNlLmhhc0ljb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3ViOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfbmF2U2VydmljZTogVmVydGljYWxOYXZTZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdkljb25TZXJ2aWNlOiBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZTogVmVydGljYWxOYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuX3N1YiA9IHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkQ2hhbmdlZC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgdGhpcy5fY29sbGFwc2VkQ2hhbmdlZC5lbWl0KHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRvZ2dsZUJ5QnV0dG9uKCkge1xuICAgIHRoaXMuY29sbGFwc2VkID0gIXRoaXMuY29sbGFwc2VkO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3ViLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmVydGljYWxOYXZHcm91cFNlcnZpY2Uge1xuICBwcml2YXRlIF9leHBhbmRDaGFuZ2U6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGdldCBleHBhbmRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGFuZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGV4cGFuZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9leHBhbmRDaGFuZ2UubmV4dCh0cnVlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25FdmVudCwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kJztcblxuaW1wb3J0IHsgVmVydGljYWxOYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtZ3JvdXAtcmVnaXN0cmF0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZHcm91cFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtZ3JvdXAuc2VydmljZSc7XG5pbXBvcnQgeyBWZXJ0aWNhbE5hdlNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5cbmNvbnN0IEVYUEFOREVEX1NUQVRFOiBzdHJpbmcgPSAnZXhwYW5kZWQnO1xuY29uc3QgQ09MTEFQU0VEX1NUQVRFOiBzdHJpbmcgPSAnY29sbGFwc2VkJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXZlcnRpY2FsLW5hdi1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAnLi92ZXJ0aWNhbC1uYXYtZ3JvdXAuaHRtbCcsXG4gIHByb3ZpZGVyczogW0V4cGFuZCwgVmVydGljYWxOYXZHcm91cFNlcnZpY2VdLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignY2xyRXhwYW5kJywgW1xuICAgICAgc3RhdGUoRVhQQU5ERURfU1RBVEUsIHN0eWxlKHsgaGVpZ2h0OiAnKicgfSkpLFxuICAgICAgc3RhdGUoQ09MTEFQU0VEX1NUQVRFLCBzdHlsZSh7IGhlaWdodDogMCwgJ292ZXJmbG93LXknOiAnaGlkZGVuJywgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSkpLFxuICAgICAgdHJhbnNpdGlvbihgJHtFWFBBTkRFRF9TVEFURX0gPD0+ICR7Q09MTEFQU0VEX1NUQVRFfWAsIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKSksXG4gICAgXSksXG4gIF0sXG4gIGhvc3Q6IHsgY2xhc3M6ICduYXYtZ3JvdXAnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclZlcnRpY2FsTmF2R3JvdXAgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9pdGVtRXhwYW5kOiBFeHBhbmQsXG4gICAgcHJpdmF0ZSBfbmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlOiBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9uYXZHcm91cFNlcnZpY2U6IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdlNlcnZpY2U6IFZlcnRpY2FsTmF2U2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5fbmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlLnJlZ2lzdGVyTmF2R3JvdXAoKTtcblxuICAgIC8vIEZJWE1FOiBUaGlzIHN1YnNjcmlwdGlvbiBoYW5kbGVzIGEgY29ybmVyIGNhc2VcbiAgICAvLyBWZXJ0aWNhbCBOYXYgY29sbGFwc2UgcmVxdWlyZXMgdGhlIGFuaW1hdGlvbiB0byBydW4gZmlyc3QgYW5kIHRoZW5cbiAgICAvLyByZW1vdmUgdGhlIG5vZGVzIGZyb20gdGhlIERPTS4gSWYgdGhlIHVzZXIgZGlyZWN0bHkgc2V0cyB0aGUgaW5wdXRcbiAgICAvLyBvbiB0aGUgY2xySWZFeHBhbmRlZCBkaXJlY3RpdmUsIHdlIGhhdmUgbm8gY2hhbmNlIHRvIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgLy8gYW5kIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlLiBUaGlzIHN1YnNjcmlwdGlvbiBtYWtlcyBzdXJlIHRoYXQgdGhlXG4gICAgLy8gYW5pbWF0aW9uIHN0YXRlcyBhcmUgY29ycmVjdCBmb3IgdGhhdCBlZGdlIGNhc2UuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5faXRlbUV4cGFuZC5leHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPT09IENPTExBUFNFRF9TVEFURSkge1xuICAgICAgICAgIGlmICh0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9IEVYUEFOREVEX1NUQVRFO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID09PSBFWFBBTkRFRF9TVEFURSkge1xuICAgICAgICAgIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSBDT0xMQVBTRURfU1RBVEU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIDEuIElmIHRoZSBuYXYgaXMgY29sbGFwc2luZywgY2xvc2UgdGhlIG9wZW4gbmF2IGdyb3VwICsgc2F2ZSBpdHMgc3RhdGVcbiAgICAvLyAyLiBJZiB0aGUgbmF2IGlzIGV4cGFuZGluZywgZXhwYW5kIHRoZSBuYXYgZ3JvdXAgaWYgdGhlIHByZXZpb3VzIHN0YXRlIHdhcyBleHBhbmRlZFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX25hdlNlcnZpY2UuYW5pbWF0ZU9uQ29sbGFwc2VkLnN1YnNjcmliZSgoZ29pbmdUb0NvbGxhcHNlOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChnb2luZ1RvQ29sbGFwc2UgJiYgdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgIHRoaXMud2FzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSBDT0xMQVBTRURfU1RBVEU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWdvaW5nVG9Db2xsYXBzZSAmJiB0aGlzLndhc0V4cGFuZGVkKSB7XG4gICAgICAgICAgdGhpcy5leHBhbmRHcm91cCgpO1xuICAgICAgICAgIHRoaXMud2FzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gSWYgYSBsaW5rIGlzIGNsaWNrZWQsIGV4cGFuZCB0aGUgbmF2IGdyb3VwXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5fbmF2R3JvdXBTZXJ2aWNlLmV4cGFuZENoYW5nZS5zdWJzY3JpYmUoKGV4cGFuZDogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoZXhwYW5kICYmICF0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgdGhpcy5leHBhbmRHcm91cCgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHdhc0V4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pcy1leHBhbmRlZCcpXG4gIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbUV4cGFuZC5leHBhbmRlZDtcbiAgfVxuXG4gIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLl9pdGVtRXhwYW5kLmV4cGFuZGVkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5faXRlbUV4cGFuZC5leHBhbmRlZCA9IHZhbHVlO1xuICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoJ2NsclZlcnRpY2FsTmF2R3JvdXBFeHBhbmRlZCcpXG4gIHNldCB1c2VyRXhwYW5kZWRJbnB1dCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5leHBhbmRlZCAhPT0gdmFsdWUpIHtcbiAgICAgIC8vIFdlIGhhdmUgdG8gY2FsbCB0b2dnbGVFeHBhbmQgYmVjYXVzZSBzb21lIGNhc2VzIHJlcXVpcmUgYW5pbWF0aW9ucyB0byBvY2N1ciBmaXJzdFxuICAgICAgLy8gRGlyZWN0bHkgc2V0dGluZyB0aGUgRXhwYW5kIHNlcnZpY2UgdmFsdWUgc2tpcHMgdGhlIGFuaW1hdGlvbiBhbmQgY2FuIHJlc3VsdCBpblxuICAgICAgLy8gbm9kZXMgaW4gdGhlIERPTSBidXQgdGhlIG5hdiBncm91cCBzdGlsbCBiZWluZyBjb2xsYXBzZWRcbiAgICAgIHRoaXMudG9nZ2xlRXhwYW5kKCk7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyVmVydGljYWxOYXZHcm91cEV4cGFuZGVkQ2hhbmdlJykgZXhwYW5kZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4odHJ1ZSk7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBwcml2YXRlIF9leHBhbmRBbmltYXRpb25TdGF0ZTogc3RyaW5nID0gQ09MTEFQU0VEX1NUQVRFO1xuXG4gIGV4cGFuZEdyb3VwKCk6IHZvaWQge1xuICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgIC8vIEV4cGFuZGVkIGFuaW1hdGlvbiBvY2N1cnMgYWZ0ZXIgRXhwYW5kLmV4cGFuZCBpcyBzZXQgdG8gdHJ1ZVxuICAgIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSBFWFBBTkRFRF9TVEFURTtcbiAgfVxuXG4gIGNvbGxhcHNlR3JvdXAoKTogdm9pZCB7XG4gICAgLy8gSWYgYSBWZXJ0aWNhbCBOYXYgR3JvdXAgdG9nZ2xlIGJ1dHRvbiBpcyBjbGlja2VkIHdoaWxlIHRoZSBWZXJ0aWNhbCBOYXYgaXMgaW4gQ29sbGFwc2VkIHN0YXRlLFxuICAgIC8vIHRoZSBWZXJ0aWNhbCBOYXYgc2hvdWxkIGJlIGV4cGFuZGVkIGZpcnN0LlxuICAgIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSBDT0xMQVBTRURfU1RBVEU7XG4gIH1cblxuICAvLyBjbG9zZXMgYSBncm91cCBhZnRlciB0aGUgY29sbGFwc2UgYW5pbWF0aW9uXG4gIGV4cGFuZEFuaW1hdGlvbkRvbmUoJGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgIGlmICgkZXZlbnQudG9TdGF0ZSA9PT0gQ09MTEFQU0VEX1NUQVRFKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGV4cGFuZEFuaW1hdGlvblN0YXRlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGFuZEFuaW1hdGlvblN0YXRlO1xuICB9XG5cbiAgc2V0IGV4cGFuZEFuaW1hdGlvblN0YXRlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2V4cGFuZEFuaW1hdGlvblN0YXRlKSB7XG4gICAgICB0aGlzLl9leHBhbmRBbmltYXRpb25TdGF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUV4cGFuZCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgdGhpcy5jb2xsYXBzZUdyb3VwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5hdiBpcyBjb2xsYXNwZWQsIGZpcnN0IG9wZW4gdGhlIG5hdlxuICAgICAgaWYgKHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyB0aGVuIGV4cGFuZCB0aGUgbmF2IGdyb3VwXG4gICAgICB0aGlzLmV4cGFuZEdyb3VwKCk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IGlmIHNvbWVvbmUgbWFya3MgYSBuYXYgZ3JvdXAgZXhwYW5kZWQgaW4gYSBjb2xsYXBzZWQgbmF2XG4gICAgLy8gdGhlIGV4cGFuZGVkIHByb3BlcnR5IGlzIHN3aXRjaGVkIGJhY2sgdG8gY29sbGFwc2VkIHN0YXRlLlxuICAgIGlmICh0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCAmJiB0aGlzLmV4cGFuZGVkKSB7XG4gICAgICB0aGlzLndhc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSBDT0xMQVBTRURfU1RBVEU7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX25hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZS51bnJlZ2lzdGVyTmF2R3JvdXAoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXZlcnRpY2FsLW5hdi1ncm91cC1jaGlsZHJlbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJWZXJ0aWNhbE5hdkdyb3VwQ2hpbGRyZW4ge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWljb24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJWZXJ0aWNhbE5hdkljb25dJywgaG9zdDogeyBjbGFzczogJ25hdi1pY29uJyB9IH0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZJY29uIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfdmVydGljYWxOYXZJY29uU2VydmljZTogVmVydGljYWxOYXZJY29uU2VydmljZSkge1xuICAgIHRoaXMuX3ZlcnRpY2FsTmF2SWNvblNlcnZpY2UucmVnaXN0ZXJJY29uKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl92ZXJ0aWNhbE5hdkljb25TZXJ2aWNlLnVucmVnaXN0ZXJJY29uKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgSG9zdExpc3RlbmVyLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZHcm91cFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtZ3JvdXAuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1tjbHJWZXJ0aWNhbE5hdkxpbmtdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclZlcnRpY2FsTmF2SWNvbl1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibmF2LXRleHRcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD4gICAgXG4gICAgICAgIDwvc3Bhbj5cbiAgICBgLFxuICBob3N0OiB7IGNsYXNzOiAnbmF2LWxpbmsnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclZlcnRpY2FsTmF2TGluayB7XG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgX25hdkdyb3VwU2VydmljZTogVmVydGljYWxOYXZHcm91cFNlcnZpY2UpIHt9XG5cbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICBwdWJsaWMgZXhwYW5kUGFyZW50TmF2R3JvdXAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX25hdkdyb3VwU2VydmljZSkge1xuICAgICAgdGhpcy5fbmF2R3JvdXBTZXJ2aWNlLmV4cGFuZCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWZFeHBhbmRNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsclZlcnRpY2FsTmF2IH0gZnJvbSAnLi92ZXJ0aWNhbC1uYXYnO1xuaW1wb3J0IHsgQ2xyVmVydGljYWxOYXZHcm91cCB9IGZyb20gJy4vdmVydGljYWwtbmF2LWdyb3VwJztcbmltcG9ydCB7IENsclZlcnRpY2FsTmF2R3JvdXBDaGlsZHJlbiB9IGZyb20gJy4vdmVydGljYWwtbmF2LWdyb3VwLWNoaWxkcmVuJztcbmltcG9ydCB7IENsclZlcnRpY2FsTmF2SWNvbiB9IGZyb20gJy4vdmVydGljYWwtbmF2LWljb24nO1xuaW1wb3J0IHsgQ2xyVmVydGljYWxOYXZMaW5rIH0gZnJvbSAnLi92ZXJ0aWNhbC1uYXYtbGluayc7XG5cbmV4cG9ydCBjb25zdCBDTFJfVkVSVElDQUxfTkFWX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICBDbHJWZXJ0aWNhbE5hdixcbiAgQ2xyVmVydGljYWxOYXZMaW5rLFxuICBDbHJWZXJ0aWNhbE5hdkdyb3VwLFxuICBDbHJWZXJ0aWNhbE5hdkdyb3VwQ2hpbGRyZW4sXG4gIENsclZlcnRpY2FsTmF2SWNvbixcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGUsIENscklmRXhwYW5kTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX1ZFUlRJQ0FMX05BVl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9WRVJUSUNBTF9OQVZfRElSRUNUSVZFUywgQ2xySWZFeHBhbmRNb2R1bGUsIENsckljb25Nb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJWZXJ0aWNhbE5hdk1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyTWFpbkNvbnRhaW5lck1vZHVsZSB9IGZyb20gJy4vbWFpbi1jb250YWluZXIvbWFpbi1jb250YWluZXIubW9kdWxlJztcbmltcG9ydCB7IENsck5hdmlnYXRpb25Nb2R1bGUgfSBmcm9tICcuL25hdi9uYXZpZ2F0aW9uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJUYWJzTW9kdWxlIH0gZnJvbSAnLi90YWJzL3RhYnMubW9kdWxlJztcbmltcG9ydCB7IENsclZlcnRpY2FsTmF2TW9kdWxlIH0gZnJvbSAnLi92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2Lm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7IGV4cG9ydHM6IFtDbHJNYWluQ29udGFpbmVyTW9kdWxlLCBDbHJOYXZpZ2F0aW9uTW9kdWxlLCBDbHJUYWJzTW9kdWxlLCBDbHJWZXJ0aWNhbE5hdk1vZHVsZV0gfSlcbmV4cG9ydCBjbGFzcyBDbHJMYXlvdXRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2Nyb2xsaW5nU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnkpIHt9XG5cbiAgc3RvcFNjcm9sbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ25vLXNjcm9sbGluZycpO1xuICB9XG5cbiAgcmVzdW1lU2Nyb2xsaW5nKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnbm8tc2Nyb2xsaW5nJykpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbm8tc2Nyb2xsaW5nJyk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25FdmVudCwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgU2ltcGxlQ2hhbmdlLFxuICBWaWV3Q2hpbGQsXG4gIEluamVjdCxcbiAgRWxlbWVudFJlZixcbiAgUExBVEZPUk1fSUQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGb2N1c1RyYXBEaXJlY3RpdmUgfSBmcm9tICcuLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNjcm9sbGluZ1NlcnZpY2UgfSBmcm9tICcuLi91dGlscy9zY3JvbGxpbmcvc2Nyb2xsaW5nLXNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVU5JUVVFX0lELCBVTklRVUVfSURfUFJPVklERVIgfSBmcm9tICcuLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItbW9kYWwnLFxuICB2aWV3UHJvdmlkZXJzOiBbU2Nyb2xsaW5nU2VydmljZV0sXG4gIHRlbXBsYXRlVXJsOiAnLi9tb2RhbC5odG1sJyxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgICA6aG9zdCB7IGRpc3BsYXk6IG5vbmU7IH1cbiAgICAgICAgOmhvc3Qub3BlbiB7IGRpc3BsYXk6IGlubGluZTsgfVxuICAgIGAsXG4gIF0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdmYWRlRG93bicsIFtcbiAgICAgIHRyYW5zaXRpb24oJyogPT4gZmFsc2UnLCBbc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgLTI1JSknIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0JyldKSxcbiAgICAgIHRyYW5zaXRpb24oJ2ZhbHNlID0+IConLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIC0yNSUpJyB9KSldKSxcbiAgICBdKSxcbiAgICB0cmlnZ2VyKCdmYWRlJywgW1xuICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW3N0eWxlKHsgb3BhY2l0eTogMCB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMC44NSB9KSldKSxcbiAgICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFthbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKV0pLFxuICAgIF0pLFxuICBdLFxuICBwcm92aWRlcnM6IFtVTklRVUVfSURfUFJPVklERVJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJNb2RhbCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgQFZpZXdDaGlsZChGb2N1c1RyYXBEaXJlY3RpdmUpIGZvY3VzVHJhcDogRm9jdXNUcmFwRGlyZWN0aXZlO1xuICBAVmlld0NoaWxkKCdtb2RhbFRpdGxlJykgbW9kYWxUaXRsZTogRWxlbWVudFJlZjxIVE1MRGl2RWxlbWVudD47XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5vcGVuJylcbiAgQElucHV0KCdjbHJNb2RhbE9wZW4nKVxuICBfb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICBAT3V0cHV0KCdjbHJNb2RhbE9wZW5DaGFuZ2UnKSBfb3BlbkNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIEBJbnB1dCgnY2xyTW9kYWxDbG9zYWJsZScpIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCdjbHJNb2RhbFNpemUnKSBzaXplOiBzdHJpbmc7XG4gIEBJbnB1dCgnY2xyTW9kYWxTdGF0aWNCYWNrZHJvcCcpIHN0YXRpY0JhY2tkcm9wOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCdjbHJNb2RhbFNraXBBbmltYXRpb24nKSBza2lwQW5pbWF0aW9uOiBzdHJpbmcgPSAnZmFsc2UnO1xuXG4gIC8vIHByZXNlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCBieSB3aXphcmRzXG4gIEBJbnB1dCgnY2xyTW9kYWxPdmVycmlkZVNjcm9sbFNlcnZpY2UnKSBieXBhc3NTY3JvbGxTZXJ2aWNlOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgnY2xyTW9kYWxQcmV2ZW50Q2xvc2UnKSBzdG9wQ2xvc2U6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQE91dHB1dCgnY2xyTW9kYWxBbHRlcm5hdGVDbG9zZScpIGFsdENsb3NlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9zY3JvbGxpbmdTZXJ2aWNlOiBTY3JvbGxpbmdTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzU2VydmljZSxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCxcbiAgICBASW5qZWN0KFVOSVFVRV9JRCkgcHVibGljIG1vZGFsSWQ6IHN0cmluZ1xuICApIHt9XG5cbiAgLy8gRGV0ZWN0IHdoZW4gX29wZW4gaXMgc2V0IHRvIHRydWUgYW5kIHNldCBuby1zY3JvbGxpbmcgdG8gdHJ1ZVxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtwcm9wTmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlIH0pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYnlwYXNzU2Nyb2xsU2VydmljZSAmJiBjaGFuZ2VzICYmIGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ19vcGVuJykpIHtcbiAgICAgIGlmIChjaGFuZ2VzLl9vcGVuLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxpbmdTZXJ2aWNlLnN0b3BTY3JvbGxpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbGluZ1NlcnZpY2UucmVzdW1lU2Nyb2xsaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc2Nyb2xsaW5nU2VydmljZS5yZXN1bWVTY3JvbGxpbmcoKTtcbiAgfVxuXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgdGhpcy5fb3BlbkNoYW5nZWQuZW1pdCh0cnVlKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JvZHk6a2V5dXAuZXNjYXBlJylcbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RvcENsb3NlKSB7XG4gICAgICB0aGlzLmFsdENsb3NlLmVtaXQoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2xvc2FibGUgfHwgIXRoaXMuX29wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgIC8vIHRvZG86IHJlbW92ZSB0aGlzIGFmdGVyIGFuaW1hdGlvbiBidWcgaXMgZml4ZWQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU3OThcbiAgICAvLyB0aGlzIHdhcyBoYW5kbGVkIGJ5IHRoZSBmYWRlRG9uZSBldmVudCBiZWxvdywgYnV0IHRoYXQgQW5pbWF0aW9uRXZlbnQgaXMgbm90IGZpcmluZyBpbiBBbmd1bGFyIDQuMC5cbiAgICB0aGlzLl9vcGVuQ2hhbmdlZC5lbWl0KGZhbHNlKTtcbiAgICAvLyBTUEVDTUVcbiAgICB0aGlzLmZvY3VzVHJhcC5zZXRQcmV2aW91c0ZvY3VzKCk7IC8vIEhhbmRsZXMgbW92aW5nIGZvY3VzIGJhY2sgdG8gdGhlIGVsZW1lbnQgdGhhdCBoYWQgaXQgYmVmb3JlLlxuICB9XG5cbiAgLy8gVE9ETyBJbnZlc3RpZ2F0ZSBpZiB3ZSBjYW4gZGVjb3VwbGUgZnJvbSBhbmltYXRpb24gZXZlbnRzXG4gIGZhZGVEb25lKGU6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgaWYgKGUudG9TdGF0ZSA9PT0gJ3ZvaWQnKSB7XG4gICAgICB0aGlzLl9vcGVuQ2hhbmdlZC5lbWl0KGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGUudG9TdGF0ZSA9PT0gJ2ZhbHNlJyAmJiBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIHRoaXMubW9kYWxUaXRsZSkge1xuICAgICAgdGhpcy5tb2RhbFRpdGxlLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbGxvd3MgbW9kYWwgb3ZlcmZsb3cgYXJlYSB0byBiZSBzY3JvbGxhYmxlIHZpYSBrZXlib2FyZC5cbiAqIFRoZSBtb2RhbCBib2R5IHdpbGwgZm9jdXMgd2l0aCBrZXlib2FyZCBuYXZpZ2F0aW9uIG9ubHkuXG4gKiBUaGlzIGFsbG93cyBpbm5lciBmb2N1c2FibGUgaXRlbXMgdG8gYmUgZm9jdXNlZCB3aXRob3V0XG4gKiB0aGUgb3ZlcmZsb3cgc2Nyb2xsIGJlaW5nIGZvY3VzZWQuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJy5tb2RhbC1ib2R5JyxcbiAgaG9zdDoge1xuICAgICdbYXR0ci50YWJpbmRleF0nOiAnXCIwXCInLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJNb2RhbEJvZHkge1xuICBwcml2YXRlIF9tb3VzZURvd24gPSBmYWxzZTtcblxuICBASG9zdExpc3RlbmVyKCdmb2N1cycsIFsnJGV2ZW50J10pXG4gIGZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX21vdXNlRG93bikge1xuICAgICAgZXZlbnQudGFyZ2V0LmJsdXIoKTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nKVxuICBtb3VzZURvd24oKSB7XG4gICAgdGhpcy5fbW91c2VEb3duID0gdHJ1ZTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNldXAnKVxuICBtb3VzZVVwKCkge1xuICAgIHRoaXMuX21vdXNlRG93biA9IGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJGb2N1c1RyYXBNb2R1bGUgfSBmcm9tICcuLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAubW9kdWxlJztcbmltcG9ydCB7IENsck1vZGFsIH0gZnJvbSAnLi9tb2RhbCc7XG5pbXBvcnQgeyBDbHJNb2RhbEJvZHkgfSBmcm9tICcuL21vZGFsLWJvZHknO1xuXG5leHBvcnQgY29uc3QgQ0xSX01PREFMX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0Nsck1vZGFsLCBDbHJNb2RhbEJvZHldO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJGb2N1c1RyYXBNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfTU9EQUxfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfTU9EQUxfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsck1vZGFsTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyJztcblxuZXhwb3J0IGludGVyZmFjZSBQb3NpdGlvbiB7XG4gIGFuY2hvclBvaW50OiBQb2ludDtcbiAgcG9wb3ZlclBvaW50OiBQb2ludDtcbiAgb2Zmc2V0WTogbnVtYmVyO1xuICBvZmZzZXRYOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBTSUdOUE9TVF9QT1NJVElPTlM6IHsgW2lucHV0OiBzdHJpbmddOiBQb3NpdGlvbiB9ID0ge1xuICAndG9wLWxlZnQnOiB7IGFuY2hvclBvaW50OiBQb2ludC5UT1BfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkJPVFRPTV9SSUdIVCwgb2Zmc2V0WTogLTEwLCBvZmZzZXRYOiAwIH0sXG4gICd0b3AtbWlkZGxlJzogeyBhbmNob3JQb2ludDogUG9pbnQuVE9QX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5CT1RUT01fQ0VOVEVSLCBvZmZzZXRZOiAtMTAsIG9mZnNldFg6IDAgfSxcbiAgJ3RvcC1yaWdodCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlRPUF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuQk9UVE9NX0xFRlQsIG9mZnNldFk6IC0xMCwgb2Zmc2V0WDogMCB9LFxuICAncmlnaHQtdG9wJzogeyBhbmNob3JQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkxFRlRfQk9UVE9NLCBvZmZzZXRZOiAyLCBvZmZzZXRYOiAxNCB9LFxuICAncmlnaHQtbWlkZGxlJzogeyBhbmNob3JQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkxFRlRfQ0VOVEVSLCBvZmZzZXRZOiA2LCBvZmZzZXRYOiAxNCB9LFxuICAncmlnaHQtYm90dG9tJzogeyBhbmNob3JQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkxFRlRfVE9QLCBvZmZzZXRZOiAtMSwgb2Zmc2V0WDogMTQgfSxcbiAgJ2JvdHRvbS1yaWdodCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LkJPVFRPTV9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuVE9QX0xFRlQsIG9mZnNldFk6IDksIG9mZnNldFg6IC0xIH0sXG4gICdib3R0b20tbWlkZGxlJzogeyBhbmNob3JQb2ludDogUG9pbnQuQk9UVE9NX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5UT1BfQ0VOVEVSLCBvZmZzZXRZOiA5LCBvZmZzZXRYOiAxMiB9LFxuICAnYm90dG9tLWxlZnQnOiB7IGFuY2hvclBvaW50OiBQb2ludC5CT1RUT01fQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LlRPUF9SSUdIVCwgb2Zmc2V0WTogOSwgb2Zmc2V0WDogMCB9LFxuICAnbGVmdC1ib3R0b20nOiB7IGFuY2hvclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5SSUdIVF9UT1AsIG9mZnNldFk6IDAsIG9mZnNldFg6IC0xNCB9LFxuICAnbGVmdC1taWRkbGUnOiB7IGFuY2hvclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5SSUdIVF9DRU5URVIsIG9mZnNldFk6IDQsIG9mZnNldFg6IC0xNCB9LFxuICAnbGVmdC10b3AnOiB7IGFuY2hvclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5SSUdIVF9CT1RUT00sIG9mZnNldFk6IDAsIG9mZnNldFg6IC0xNCB9LFxuICBkZWZhdWx0OiB7IGFuY2hvclBvaW50OiBQb2ludC5SSUdIVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuTEVGVF9DRU5URVIsIG9mZnNldFk6IDYsIG9mZnNldFg6IDE0IH0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdG9yLCBJbnB1dCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vY29tbW9uL2Fic3RyYWN0LXBvcG92ZXInO1xuaW1wb3J0IHsgUE9QT1ZFUl9IT1NUX0FOQ0hPUiB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuJztcblxuaW1wb3J0IHsgU0lHTlBPU1RfUE9TSVRJT05TIH0gZnJvbSAnLi9zaWducG9zdC1wb3NpdGlvbnMnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVU5JUVVFX0lELCBVTklRVUVfSURfUFJPVklERVIgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2lnbnBvc3RJZFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9zaWducG9zdC1pZC5zZXJ2aWNlJztcblxuLy8gYWthIHdoZXJlIHRoZSBhcnJvdyAvIHBvaW50ZXIgaXMgYXQgaW4gcmVsYXRpb24gdG8gdGhlIGFuY2hvclxuY29uc3QgUE9TSVRJT05TOiBzdHJpbmdbXSA9IFtcbiAgJ3RvcC1sZWZ0JyxcbiAgJ3RvcC1taWRkbGUnLFxuICAndG9wLXJpZ2h0JyxcbiAgJ3JpZ2h0LXRvcCcsXG4gICdyaWdodC1taWRkbGUnLCAvLyBkZWZhdWx0XG4gICdyaWdodC1ib3R0b20nLFxuICAnYm90dG9tLXJpZ2h0JyxcbiAgJ2JvdHRvbS1taWRkbGUnLFxuICAnYm90dG9tLWxlZnQnLFxuICAnbGVmdC1ib3R0b20nLFxuICAnbGVmdC1taWRkbGUnLFxuICAnbGVmdC10b3AnLFxuXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXNpZ25wb3N0LWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgPGRpdiBjbGFzcz1cInNpZ25wb3N0LXdyYXBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlci1wb2ludGVyXCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNpZ25wb3N0LWNvbnRlbnQtYm9keVwiPlxuICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNpZ25wb3N0LWNvbnRlbnQtaGVhZGVyXCI+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLnNpZ25wb3N0Q2xvc2VcIiBjbGFzcz1cInNpZ25wb3N0LWFjdGlvbiBjbG9zZVwiXG4gICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNsb3NlKClcIiBbYXR0ci5hcmlhLWNvbnRyb2xzXT1cInNpZ25wb3N0Q29udGVudElkXCI+XG4gICAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJjbG9zZVwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mua2V5cy5jbG9zZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5zaWducG9zdC1jb250ZW50XSc6ICd0cnVlJywgJ1tpZF0nOiAnc2lnbnBvc3RDb250ZW50SWQnIH0sXG4gIHByb3ZpZGVyczogW1VOSVFVRV9JRF9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclNpZ25wb3N0Q29udGVudCBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoUE9QT1ZFUl9IT1NUX0FOQ0hPUilcbiAgICBwYXJlbnRIb3N0OiBFbGVtZW50UmVmLFxuICAgIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgc2lnbnBvc3RDb250ZW50SWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHNpZ25wb3N0SWRTZXJ2aWNlOiBTaWducG9zdElkU2VydmljZVxuICApIHtcbiAgICBzdXBlcihpbmplY3RvciwgcGFyZW50SG9zdCk7XG4gICAgaWYgKCFwYXJlbnRIb3N0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1zaWducG9zdC1jb250ZW50IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLXNpZ25wb3N0Jyk7XG4gICAgfVxuICAgIHRoaXMuY29tbW9uU3RyaW5ncyA9IGNvbW1vblN0cmluZ3M7XG4gICAgLy8gRGVmYXVsdHNcbiAgICB0aGlzLnBvc2l0aW9uID0gJ3JpZ2h0LW1pZGRsZSc7XG4gICAgdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgICB0aGlzLnNpZ25wb3N0SWRTZXJ2aWNlLnNldElkKHNpZ25wb3N0Q29udGVudElkKTtcbiAgfVxuXG4gIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlO1xuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDbG9zZSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIHNpZ25wb3N0IGluc3RhbmNlIHRvIHRvZ2dsZSB0aGUgc3RhdGUgb2YgdGhlIGNvbnRlbnQgcG9wb3Zlci5cbiAgICpcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIF9wb3NpdGlvbjogc3RyaW5nO1xuXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHNldHRlciBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSBDbHJTaWducG9zdENvbnRlbnQgcG9wb3Zlci4gVGhpcyBpcyBhIGNvbWJpbmF0aW9uIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqIC0gYW5jaG9yUG9pbnQgLSB3aGVyZSBvbiB0aGUgdHJpZ2dlciB0byBhbmNob3IgdGhlIENsclNpZ25wb3N0Q29udGVudFxuICAgKiAtIHBvcG92ZXJQb2ludCAtIHdoZXJlIG9uIHRoZSBDbHJTaWducG9zdENvbnRlbnQgY29udGFpbmVyIHRvIGFsaWduIHdpdGggdGhlIGFuY2hvclBvaW50XG4gICAqIC0gb2Zmc2V0WSAtIHdoZXJlIG9uIHRoZSBZIGF4aXMgdG8gYWxpZ24gdGhlIENsclNpZ25wb3N0Q29udGVudCBzbyBpdCBtZWV0cyBzcGVjc1xuICAgKiAtIG9mZnNldFggLSB3aGVyZSBvbiB0aGUgWCBheGlzIHRvIGFsaWduIHRoZSBDbHJTaWducG9zdENvbnRlbnQgc28gaXQgbWVldHMgc3BlY3NcbiAgICogVGhlcmUgYXJlIDEyIHBvc3NpYmxlIHBvc2l0aW9ucyB0byBwbGFjZSBhIENsclNpZ25wb3N0Q29udGVudCBjb250YWluZXI6XG4gICAqIC0gdG9wLWxlZnRcbiAgICogLSB0b3AtbWlkZGxlXG4gICAqIC0gdG9wLXJpZ2h0XG4gICAqIC0gcmlnaHQtdG9wXG4gICAqIC0gcmlnaHQtbWlkZGxlXG4gICAqIC0gcmlnaHQtYm90dG9tXG4gICAqIC0gYm90dG9tLXJpZ2h0XG4gICAqIC0gYm90dG9tLW1pZGRsZVxuICAgKiAtIGJvdHRvbS1sZWZ0XG4gICAqIC0gbGVmdC1ib3R0b21cbiAgICogLSBsZWZ0LW1pZGRsZVxuICAgKiAtIGxlZnQtdG9wXG4gICAqXG4gICAqIEkgdGhpbmsgb2YgaXQgYXMgZm9sbG93cyBmb3IgJ3RvcC1sZWZ0JyAtPiBDT05UQUlORVJfU0lERS1TSURFX1BPU0lUSU9OLiBJbiB0aGlzIGNhc2UgQ09OVEFJTkVSX1NJREUgaXMgJ3RvcCdcbiAgICogbWVhbmluZyB0aGUgdG9wIG9mIHRoZSB0cmlnZ2VyIGljb24gKGFib3ZlIHRoZSBpY29uIHRoYXQgaGlkZXMvc2hvd3MpIHRoZSBDbHJTaWducG9zdENvbnRlbnQuIEFuZCwgU0lERV9QT1NJVElPTlxuICAgKiBpcyAnbGVmdCcgbWVhbmluZyB0d28gdGhpbmdzOiAxKSB0aGUgQ2xyU2lnbnBvc3RDb250ZW50IGNvbnRhaW5lciBleHRlbmRzIHRvIHRoZSBsZWZ0IGFuZCAyKSB0aGUgJ2Fycm93L3BvaW50ZXInXG4gICAqIGxpbmtpbmcgdGhlIFNpbmdwb3N0Q29udGVudCB0byB0aGUgdHJpZ2dlciBwb2ludHMgZG93biBhdCB0aGUgaG9yaXpvbnRhbCBjZW50ZXIgb2YgdGhlIHRyaWdnZXIgaWNvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld1Bvc2l0aW9uXG4gICAqL1xuICBASW5wdXQoJ2NsclBvc2l0aW9uJylcbiAgc2V0IHBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpIHtcbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5wb3NpdGlvbik7XG4gICAgaWYgKHBvc2l0aW9uICYmIFBPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA+IC0xKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9ICdyaWdodC1taWRkbGUnO1xuICAgIH1cbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICBjb25zdCBzZXRQb3NpdGlvbiA9IFNJR05QT1NUX1BPU0lUSU9OU1t0aGlzLnBvc2l0aW9uXTtcbiAgICB0aGlzLmFuY2hvclBvaW50ID0gc2V0UG9zaXRpb24uYW5jaG9yUG9pbnQ7XG4gICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBzZXRQb3NpdGlvbi5wb3BvdmVyUG9pbnQ7XG4gICAgdGhpcy5wb3BvdmVyT3B0aW9ucy5vZmZzZXRZID0gc2V0UG9zaXRpb24ub2Zmc2V0WTtcbiAgICB0aGlzLnBvcG92ZXJPcHRpb25zLm9mZnNldFggPSBzZXRQb3NpdGlvbi5vZmZzZXRYO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXIubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyU2lnbnBvc3QgfSBmcm9tICcuL3NpZ25wb3N0JztcbmltcG9ydCB7IENsclNpZ25wb3N0Q29udGVudCB9IGZyb20gJy4vc2lnbnBvc3QtY29udGVudCc7XG5pbXBvcnQgeyBDbHJTaWducG9zdFRyaWdnZXIgfSBmcm9tICcuL3NpZ25wb3N0LXRyaWdnZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX1NJR05QT1NUX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsclNpZ25wb3N0LCBDbHJTaWducG9zdENvbnRlbnQsIENsclNpZ25wb3N0VHJpZ2dlcl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckNvbW1vblBvcG92ZXJNb2R1bGUsIENsckljb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfU0lHTlBPU1RfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfU0lHTlBPU1RfRElSRUNUSVZFUywgQ2xyQ29uZGl0aW9uYWxNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTaWducG9zdE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUb29sdGlwSWRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfaWQ6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuICB1cGRhdGVJZChpZDogc3RyaW5nKSB7XG4gICAgdGhpcy5faWQubmV4dChpZCk7XG4gIH1cblxuICBnZXQgaWQoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5faWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5pbXBvcnQgeyBQT1BPVkVSX0hPU1RfQU5DSE9SIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4nO1xuaW1wb3J0IHsgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7IFRvb2x0aXBJZFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90b29sdGlwLWlkLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdG9vbHRpcCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy50b29sdGlwXSc6ICd0cnVlJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbXG4gICAgSWZPcGVuU2VydmljZSxcbiAgICB7IHByb3ZpZGU6IFBPUE9WRVJfSE9TVF9BTkNIT1IsIHVzZUV4aXN0aW5nOiBFbGVtZW50UmVmIH0sXG4gICAgLy8gVE9ETzogY29uc2lkZXIgY2VudHJhbGl6aW5nIHRoZSB1bmlxdWUgaWQgc3RyaW5nIG9uIGEgc2VydmljZSB0aGF0IHByb3ZpZGVzIGFyaWFBdHRyaWJ1dGVzIHRoYXQgbmVlZCBpdFxuICAgIC8vIEFyaWFTZXJ2aWNlIGluIGxheW91dC90YWJzL3Byb3ZpZGVycyBtaWdodCBiZSBhIGdvb2Qgc3RhcnRpbmcgcG9pbnQuXG4gICAgVU5JUVVFX0lEX1BST1ZJREVSLFxuICAgIFRvb2x0aXBJZFNlcnZpY2UsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRvb2x0aXAge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RvciwgSW5wdXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFBvcG92ZXIgfSBmcm9tICcuLi9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5pbXBvcnQgeyBVTklRVUVfSUQgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgVG9vbHRpcElkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Rvb2x0aXAtaWQuc2VydmljZSc7XG5cbmNvbnN0IFBPU0lUSU9OUzogc3RyaW5nW10gPSBbJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAncmlnaHQnLCAnbGVmdCddO1xuXG5jb25zdCBTSVpFUzogc3RyaW5nW10gPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJ107XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10b29sdGlwLWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MudG9vbHRpcC1jb250ZW50XSc6ICd0cnVlJyxcbiAgICAnW3N0eWxlLm9wYWNpdHldJzogJzEnLFxuICAgICdbYXR0ci5yb2xlXSc6ICdcInRvb2x0aXBcIicsXG4gICAgJ1tpZF0nOiAnaWQnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUb29sdGlwQ29udGVudCBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoUE9QT1ZFUl9IT1NUX0FOQ0hPUilcbiAgICBwYXJlbnRIb3N0OiBFbGVtZW50UmVmLFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgdW5pcXVlSWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHRvb2x0aXBJZFNlcnZpY2U6IFRvb2x0aXBJZFNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoaW5qZWN0b3IsIHBhcmVudEhvc3QpO1xuXG4gICAgaWYgKCFwYXJlbnRIb3N0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci10b29sdGlwLWNvbnRlbnQgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItdG9vbHRpcCcpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHRzXG4gICAgdGhpcy5wb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgdGhpcy5zaXplID0gJ3NtJztcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBpZCBpbiBjYXNlIGNvbnN1bWVyIGRvZXMgbm90IHN1cHBseSBhIGN1c3RvbSBpZC5cbiAgICB0aGlzLnVwZGF0ZUlkKHVuaXF1ZUlkKTtcbiAgfVxuXG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBzdHJpbmc7XG5cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdmFsdWUgPyB0aGlzLnVwZGF0ZUlkKHZhbHVlKSA6IHRoaXMudXBkYXRlSWQoJycpO1xuICB9XG4gIHByaXZhdGUgX2lkO1xuXG4gIHByaXZhdGUgdXBkYXRlSWQoaWQ6IHN0cmluZykge1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy50b29sdGlwSWRTZXJ2aWNlLnVwZGF0ZUlkKGlkKTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9zaXRpb24nKVxuICBzZXQgcG9zaXRpb24ocG9zaXRpb246IHN0cmluZykge1xuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndG9vbHRpcC0nICsgdGhpcy5wb3NpdGlvbik7XG4gICAgaWYgKHBvc2l0aW9uICYmIFBPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA+IC0xKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndG9vbHRpcC0nICsgdGhpcy5wb3NpdGlvbik7XG5cbiAgICAvLyBzZXQgdGhlIHBvcG92ZXIgdmFsdWVzIGJhc2VkIG9uIGRpcmVjdGlvblxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkxFRlRfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zaXplOiBzdHJpbmc7XG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBASW5wdXQoJ2NsclNpemUnKVxuICBzZXQgc2l6ZShzaXplOiBzdHJpbmcpIHtcbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3Rvb2x0aXAtJyArIHRoaXMuc2l6ZSk7XG4gICAgaWYgKHNpemUgJiYgU0laRVMuaW5kZXhPZihzaXplKSA+IC0xKSB7XG4gICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2l6ZSA9ICdzbSc7XG4gICAgfVxuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndG9vbHRpcC0nICsgdGhpcy5zaXplKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5pbXBvcnQgeyBUb29sdGlwSWRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdG9vbHRpcC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyVG9vbHRpcFRyaWdnZXJdJyxcbiAgaG9zdDoge1xuICAgIHRhYmluZGV4OiAnMCcsXG4gICAgJ1tjbGFzcy50b29sdGlwLXRyaWdnZXJdJzogJ3RydWUnLFxuICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdhcmlhRGVzY3JpYmVkQnknLFxuICAgICdbYXR0ci5yb2xlXSc6ICdcImJ1dHRvblwiJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVG9vbHRpcFRyaWdnZXIge1xuICBwdWJsaWMgYXJpYURlc2NyaWJlZEJ5O1xuICBwcml2YXRlIHN1YnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSwgcHJpdmF0ZSB0b29sdGlwSWRTZXJ2aWNlOiBUb29sdGlwSWRTZXJ2aWNlKSB7XG4gICAgLy8gVGhlIGFyaWEtZGVzY3JpYmVkIGJ5IGNvbWVzIGZyb20gdGhlIGlkIG9mIGNvbnRlbnQuIEl0XG4gICAgdGhpcy5zdWJzLnB1c2godGhpcy50b29sdGlwSWRTZXJ2aWNlLmlkLnN1YnNjcmliZSh0b29sdGlwSWQgPT4gKHRoaXMuYXJpYURlc2NyaWJlZEJ5ID0gdG9vbHRpcElkKSkpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgc2hvd1Rvb2x0aXAoKTogdm9pZCB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSB0cnVlO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICBoaWRlVG9vbHRpcCgpOiB2b2lkIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsclRvb2x0aXAgfSBmcm9tICcuL3Rvb2x0aXAnO1xuaW1wb3J0IHsgQ2xyVG9vbHRpcENvbnRlbnQgfSBmcm9tICcuL3Rvb2x0aXAtY29udGVudCc7XG5pbXBvcnQgeyBDbHJUb29sdGlwVHJpZ2dlciB9IGZyb20gJy4vdG9vbHRpcC10cmlnZ2VyJztcblxuZXhwb3J0IGNvbnN0IENMUl9UT09MVElQX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsclRvb2x0aXAsIENsclRvb2x0aXBUcmlnZ2VyLCBDbHJUb29sdGlwQ29udGVudF07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckNvbW1vblBvcG92ZXJNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfVE9PTFRJUF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9UT09MVElQX0RJUkVDVElWRVMsIENsckNvbmRpdGlvbmFsTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVG9vbHRpcE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRHJvcGRvd25Nb2R1bGUgfSBmcm9tICcuL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTaWducG9zdE1vZHVsZSB9IGZyb20gJy4vc2lnbnBvc3Qvc2lnbnBvc3QubW9kdWxlJztcbmltcG9ydCB7IENsclRvb2x0aXBNb2R1bGUgfSBmcm9tICcuL3Rvb2x0aXAvdG9vbHRpcC5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoeyBleHBvcnRzOiBbQ2xyRHJvcGRvd25Nb2R1bGUsIENsclNpZ25wb3N0TW9kdWxlLCBDbHJUb29sdGlwTW9kdWxlXSB9KVxuZXhwb3J0IGNsYXNzIENsclBvcG92ZXJNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQnV0dG9uSHViU2VydmljZSB7XG4gIHB1YmxpYyBidXR0b25zUmVhZHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9wcmV2aW91c0J0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgcHJldmlvdXNCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX25leHRCdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IG5leHRCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRCdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGFuZ2VyQnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBkYW5nZXJCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhbmdlckJ0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9jYW5jZWxCdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IGNhbmNlbEJ0bkNsaWNrZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fY2FuY2VsQnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZpbmlzaEJ0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgZmluaXNoQnRuQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hCdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY3VzdG9tQnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBjdXN0b21CdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1c3RvbUJ0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgYnV0dG9uQ2xpY2tlZChidXR0b25UeXBlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoJ3ByZXZpb3VzJyA9PT0gYnV0dG9uVHlwZSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNCdG5DbGlja2VkLm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKCduZXh0JyA9PT0gYnV0dG9uVHlwZSkge1xuICAgICAgdGhpcy5fbmV4dEJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJ2ZpbmlzaCcgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaEJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJ2RhbmdlcicgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX2RhbmdlckJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJ2NhbmNlbCcgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX2NhbmNlbEJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jdXN0b21CdG5DbGlja2VkLm5leHQoYnV0dG9uVHlwZSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi4vd2l6YXJkLXBhZ2UnO1xuXG4vKipcbiAqIFBhZ2VDb2xsZWN0aW9uU2VydmljZSBtYW5hZ2VzIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzIGFzc2lnbmVkIHRvIHRoZSB3aXphcmQgYW5kIG9mZmVyc1xuICogYSBudW1iZXIgb2YgZnVuY3Rpb25zIHVzZWZ1bCBhY3Jvc3MgdGhlIHdpemFyZHMgcHJvdmlkZXJzIGFuZCBzdWJjb21wb25lbnRzIC0tIGFsbCByZWxhdGVkXG4gKiB0byBlc3NlbnRpYWxseSBsb29rdXBzIG9uIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzLlxuICpcbiAqIFRoZSBlYXNpZXN0IHdheSB0byBhY2Nlc3MgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIGlzIHZpYSB0aGUgd2l6YXJkLiBUaGVcbiAqIGZvbGxvd2luZyBleGFtcGxlIHdvdWxkIGFsbG93IHlvdSB0byBhY2Nlc3MgeW91ciBpbnN0YW5jZSBvZiB0aGUgd2l6YXJkIGZyb20geW91ciBob3N0XG4gKiBjb21wb25lbnQgYW5kIHRoZXJlYnkgYWNjZXNzIHRoZSBwYWdlIGNvbGxlY3Rpb24gdmlhIFlvdXJIb3N0Q29tcG9uZW50LndpemFyZC5wYWdlQ29sbGVjdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGNsci13aXphcmQgI3dpemFyZCAuLi4+XG4gKlxuICogQGV4YW1wbGVcbiAqIGV4cG9ydCBjbGFzcyBZb3VySG9zdENvbXBvbmVudCB7XG4gKiAgIEBWaWV3Q2hpbGQoXCJ3aXphcmRcIikgd2l6YXJkOiBXaXphcmQ7XG4gKiAgIC4uLlxuICogfVxuICpcbiAqIFRoZSBoZWFydCBvZiB0aGUgcGFnZSBjb2xsZWN0aW9uIGlzIHRoZSBxdWVyeSBsaXN0IG9mIHBhZ2VzLCB3aGljaCBpdCBpcyBhc3NpZ25lZCBhcyBhXG4gKiByZWZlcmVuY2UgdG8gdGhlIFdpemFyZC5wYWdlcyBRdWVyeUxpc3Qgd2hlbiB0aGUgd2l6YXJkIGlzIGNyZWF0ZWQuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIHtcbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBXaXphcmQucGFnZXMgUXVlcnlMaXN0LlxuICAgKlxuICAgKiBQb3B1bGF0ZWQgd2hlbiB0aGUgd2l6YXJkIGlzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwYWdlczogUXVlcnlMaXN0PENscldpemFyZFBhZ2U+O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLnBhZ2VzIFF1ZXJ5TGlzdCB0byBhbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogVXNlZnVsIGZvciBtYW55IGluc3RhbmNlcyB3aGVuIHlvdSB3b3VsZCBwcmVmZXIgYSBRdWVyeUxpc3QgdG8gYWN0IGxpa2UgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFnZXNBc0FycmF5KCk6IENscldpemFyZFBhZ2VbXSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZXMgPyB0aGlzLnBhZ2VzLnRvQXJyYXkoKSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFnZXMgcXVlcnkgbGlzdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBwYWdlc0NvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZXMgPyB0aGlzLnBhZ2VzLmxlbmd0aCA6IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dC10by1sYXN0IHBhZ2UgaW4gdGhlIHF1ZXJ5IGxpc3Qgb2YgcGFnZXMuIE9wZXJhdGVzIGFzIGEgZ2V0dGVyXG4gICAqIHNvIHRoYXQgaXQgaXNuJ3Qgd29ya2luZyB3aXRoIHN0YWxlIGRhdGEuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgcGVudWx0aW1hdGVQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRoaXMucGFnZXNDb3VudDtcblxuICAgIGlmIChwYWdlQ291bnQgPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFnZXNBc0FycmF5W3BhZ2VDb3VudCAtIDJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgcGFnZSBpbiB0aGUgcXVlcnkgbGlzdCBvZiBwYWdlcy4gT3BlcmF0ZXMgYXMgYSBnZXR0ZXJcbiAgICogc28gdGhhdCBpdCBpc24ndCB3b3JraW5nIHdpdGggc3RhbGUgZGF0YS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBsYXN0UGFnZSgpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBjb25zdCBwYWdlQ291bnQgPSB0aGlzLnBhZ2VzQ291bnQ7XG5cbiAgICBpZiAocGFnZUNvdW50IDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhZ2VzQXNBcnJheVtwYWdlQ291bnQgLSAxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBxdWVyeSBsaXN0IG9mIHBhZ2VzLiBPcGVyYXRlcyBhcyBhIGdldHRlclxuICAgKiBzbyB0aGF0IGl0IGlzbid0IHdvcmtpbmcgd2l0aCBzdGFsZSBkYXRhLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpcnN0UGFnZSgpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBpZiAoIXRoaXMucGFnZXNDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhZ2VzQXNBcnJheVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIG1vc3RseSBpbnRlcm5hbGx5LCBidXQgYWNjZXB0cyBhIHN0cmluZyBJRCBhbmQgcmV0dXJucyBhIENscldpemFyZFBhZ2VcbiAgICogb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgSUQgcGFzc2VkLiBOb3RlIHRoYXQgSURzIGhlcmUgc2hvdWxkIGluY2x1ZGUgdGhlIHByZWZpeFxuICAgKiBcImNsci13aXphcmQtcGFnZS1cIi5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgbmV4dC10by1sYXN0IHBhZ2UgaW4gdGhlIHF1ZXJ5IGxpc3Qgb2YgcGFnZXMuIE9wZXJhdGVzIGFzIGEgZ2V0dGVyXG4gICAqIHNvIHRoYXQgaXQgaXNuJ3Qgd29ya2luZyB3aXRoIHN0YWxlIGRhdGEuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRQYWdlQnlJZChpZDogc3RyaW5nKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgZm91bmRQYWdlczogQ2xyV2l6YXJkUGFnZVtdID0gdGhpcy5wYWdlcy5maWx0ZXIoKHBhZ2U6IENscldpemFyZFBhZ2UpID0+IGlkID09PSBwYWdlLmlkKTtcbiAgICByZXR1cm4gdGhpcy5jaGVja1Jlc3VsdHMoZm91bmRQYWdlcywgaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgcyBudW1iZXIgYXMgYSBwYXJhbWV0ZXIgYW5kIHRyZWF0cyB0aGF0IG51bWJlciBhcyB0aGUgaW5kZXggb2YgdGhlIHBhZ2VcbiAgICogeW91J3JlIGxvb2tpbmcgZm9yIGluIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzLiBSZXR1cm5zIGEgIHdpemFyZCBwYWdlIG9iamVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFBhZ2VCeUluZGV4KGluZGV4OiBudW1iZXIpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBjb25zdCBwYWdlQ291bnQgPSB0aGlzLnBhZ2VzQ291bnQ7XG4gICAgY29uc3QgcGFnZXNMYXN0SW5kZXg6IG51bWJlciA9IHBhZ2VDb3VudCA+IDEgPyBwYWdlQ291bnQgLSAxIDogMDtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJldHJpZXZlIHBhZ2Ugd2l0aCBpbmRleCBvZiAnICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+IHBhZ2VzTGFzdEluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgaW5kZXggaXMgZ3JlYXRlciB0aGFuIGxlbmd0aCBvZiBwYWdlcyBhcnJheS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgd2l6YXJkIHBhZ2Ugb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0cyBpbmRleCBpbiB0aGVcbiAgICogY29sbGVjdGlvbiBvZiBwYWdlcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFBhZ2VJbmRleChwYWdlOiBDbHJXaXphcmRQYWdlKTogbnVtYmVyIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFnZXNBc0FycmF5LmluZGV4T2YocGFnZSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCBwYWdlIGNhbm5vdCBiZSBmb3VuZCBpbiBjb2xsZWN0aW9uIG9mIHBhZ2VzLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZXMgZ3VhcmQgbG9naWMgdGhhdCBwcmV2ZW50cyBhIGNvdXBsZSBvZiB1bmZvcnR1bmF0ZSBlZGdlIGNhc2VzIHdpdGhcbiAgICogbG9vayB1cHMgb24gdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgY2hlY2tSZXN1bHRzKHJlc3VsdHM6IENscldpemFyZFBhZ2VbXSwgcmVxdWVzdGVkUGFnZUlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmb3VuZFBhZ2VzQ291bnQ6IG51bWJlciA9IHJlc3VsdHMubGVuZ3RoIHx8IDA7XG5cbiAgICBpZiAoZm91bmRQYWdlc0NvdW50ID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb3JlIHRoYW4gb25lIHBhZ2UgaGFzIHRoZSByZXF1ZXN0ZWQgaWQgJyArIHJlcXVlc3RlZFBhZ2VJZCArICcuJyk7XG4gICAgfSBlbHNlIGlmIChmb3VuZFBhZ2VzQ291bnQgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhZ2UgY2FuIGJlIGZvdW5kIHdpdGggdGhlIGlkICcgKyByZXF1ZXN0ZWRQYWdlSWQgKyAnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyB0d28gbnVtZXJpYyBpbmRleGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHdpemFyZCBwYWdlIG9iamVjdHMgdGhhdCBpbmNsdWRlXG4gICAqIGFsbCB3aXphcmQgcGFnZXMgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbiBmcm9tIHRoZSBmaXJzdCBpbmRleCB0byB0aGUgc2Vjb25kLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcGFnZVJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogQ2xyV2l6YXJkUGFnZVtdIHtcbiAgICBsZXQgcGFnZXM6IENscldpemFyZFBhZ2VbXSA9IFtdO1xuXG4gICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IHR5cGVvZiBzdGFydCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNOYU4oc3RhcnQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gbnVsbCB8fCB0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJyB8fCBpc05hTihlbmQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IHRoaXMucGFnZXNDb3VudCkge1xuICAgICAgZW5kID0gdGhpcy5wYWdlc0NvdW50O1xuICAgIH1cblxuICAgIHBhZ2VzID0gdGhpcy5wYWdlc0FzQXJyYXk7XG5cbiAgICBpZiAoZW5kIC0gc3RhcnQgPT09IDApIHtcbiAgICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBvbmUgcGFnZSB0aGV5IHdhbnRcbiAgICAgIHJldHVybiBbdGhpcy5nZXRQYWdlQnlJbmRleChzdGFydCldO1xuICAgIH1cblxuICAgIC8vIHNsaWNlIGVuZCBkb2VzIG5vdCBpbmNsdWRlIGl0ZW0gcmVmZXJlbmNlZCBieSBlbmQgaW5kZXgsIHdoaWNoIGlzIHdlaXJkIGZvciB1c2Vyc1xuICAgIC8vIGluY3JlbWVudGluZyBlbmQgaW5kZXggaGVyZSB0byBjb3JyZWN0IHRoYXQgc28gdXNlcnMgYW5kIG90aGVyIG1ldGhvZHNcbiAgICAvLyBkb24ndCBoYXZlIHRvIHRoaW5rIGFib3V0IGl0XG4gICAgZW5kID0gZW5kICsgMTtcblxuICAgIC8vIHNsaWNlIGRvZXMgbm90IHJldHVybiB0aGUgbGFzdCBvbmUgaW4gdGhlIHJhbmdlIGJ1dCBpdCBkb2VzIGluY2x1ZGUgdGhlIGZpcnN0IG9uZVxuICAgIC8vIGRvZXMgbm90IG1vZGlmeSBvcmlnaW5hbCBhcnJheVxuICAgIHJldHVybiBwYWdlcy5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIHR3byB3aXphcmQgcGFnZSBvYmplY3RzIGFuZCByZXR1cm5zIHRob3NlIHBhZ2Ugb2JqZWN0cyB3aXRoIGFsbCBvdGhlciBwYWdlXG4gICAqIG9iamVjdHMgYmV0d2VlbiB0aGVtIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24uIEl0IGRvZXNuJ3QgY2FyZSB3aGljaCBwYWdlIGlzIGFoZWFkIG9mIHRoZVxuICAgKiBvdGhlciBpbiB0aGUgcGFyYW1ldGVycy4gSXQgd2lsbCBiZSBzbWFydCBlbm91Z2ggdG8gZmlndXJlIHRoYXQgb3V0ICBvbiBpdHMgb3duLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFnZVJhbmdlRnJvbVBhZ2VzKHBhZ2U6IENscldpemFyZFBhZ2UsIG90aGVyUGFnZTogQ2xyV2l6YXJkUGFnZSk6IENscldpemFyZFBhZ2VbXSB7XG4gICAgY29uc3QgcGFnZUluZGV4ID0gdGhpcy5nZXRQYWdlSW5kZXgocGFnZSk7XG4gICAgY29uc3Qgb3RoZXJQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChvdGhlclBhZ2UpO1xuICAgIGxldCBzdGFydEluZGV4OiBudW1iZXI7XG4gICAgbGV0IGVuZEluZGV4OiBudW1iZXI7XG5cbiAgICBpZiAocGFnZUluZGV4IDw9IG90aGVyUGFnZUluZGV4KSB7XG4gICAgICBzdGFydEluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgZW5kSW5kZXggPSBvdGhlclBhZ2VJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJbmRleCA9IG90aGVyUGFnZUluZGV4O1xuICAgICAgZW5kSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhZ2VSYW5nZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdGhlIHdpemFyZCBwYWdlIG9iamVjdCBvZlxuICAgKiB0aGUgcGFnZSBpbW1lZGlhdGVseSBiZWZvcmUgaXQgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbi4gUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzXG4gICAqIG5vIHBhZ2UgYmVmb3JlIHRoZSBwYWdlIGl0IGlzIHBhc3NlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFByZXZpb3VzUGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgbXlQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChwYWdlKTtcbiAgICBjb25zdCBwcmV2aW91c1BhZ2VJbmRleCA9IG15UGFnZUluZGV4IC0gMTtcbiAgICBpZiAocHJldmlvdXNQYWdlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUJ5SW5kZXgocHJldmlvdXNQYWdlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSBCb29sZWFuIHRoYXQgc2F5cyBpZlxuICAgKiB0aGUgcGFnZSB5b3Ugc2VudCBpdCBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzUGFnZUlzQ29tcGxldGVkKHBhZ2U6IENscldpemFyZFBhZ2UpIHtcbiAgICBsZXQgcHJldmlvdXNQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJldmlvdXNQYWdlID0gdGhpcy5nZXRQcmV2aW91c1BhZ2UocGFnZSk7XG5cbiAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNQYWdlKSB7XG4gICAgICAvLyBwYWdlIGlzIHRoZSBmaXJzdCBwYWdlLiBubyBwcmV2aW91cyBwYWdlLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZpb3VzUGFnZS5jb21wbGV0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdGhlIHdpemFyZCBwYWdlIG9iamVjdCBvZlxuICAgKiB0aGUgcGFnZSBpbW1lZGlhdGVseSBhZnRlciBpdCBpbiB0aGUgcGFnZSBjb2xsZWN0aW9uLiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXNcbiAgICogbm8gcGFnZSBhZnRlciB0aGUgcGFnZSBpdCBpcyBwYXNzZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXROZXh0UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgbXlQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChwYWdlKTtcbiAgICBjb25zdCBuZXh0UGFnZUluZGV4ID0gbXlQYWdlSW5kZXggKyAxO1xuXG4gICAgaWYgKG5leHRQYWdlSW5kZXggPj0gdGhpcy5wYWdlc0FzQXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUJ5SW5kZXgobmV4dFBhZ2VJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIGdlbmVyYXRlcyBhIHN0ZXAgaXRlbSBpZCBmcm9tIHRoZVxuICAgKiBwYWdlIElELiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgc3RlcCBpdGVtIElEIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RlcEl0ZW1JZEZvclBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIGNvbnN0IHBhZ2VJZCA9IHBhZ2UuaWQ7XG4gICAgY29uc3QgcGFnZUlkUGFydHMgPSBwYWdlSWQuc3BsaXQoJy0nKS5yZXZlcnNlKCk7XG5cbiAgICBwYWdlSWRQYXJ0c1sxXSA9ICdzdGVwJztcbiAgICByZXR1cm4gcGFnZUlkUGFydHMucmV2ZXJzZSgpLmpvaW4oJy0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmFsbHkgb25seSB1c2VkIGludGVybmFsbHkgdG8gbWFyayB0aGF0IGEgc3BlY2lmaWMgcGFnZSBoYXMgYmVlbiBcImNvbW1pdHRlZFwiLlxuICAgKiBUaGlzIGludm9sdmVzIG1hcmtpbmcgdGhlIHBhZ2UgY29tcGxldGUgYW5kIGZpcmluZyB0aGUgQ2xyV2l6YXJkUGFnZS5vbkNvbW1pdFxuICAgKiAoY2xyV2l6YXJkUGFnZU9uQ29tbWl0KSBvdXRwdXQuIFRha2VzIHRoZSB3aXphcmQgcGFnZSBvYmplY3QgdGhhdCB5b3UgaW50ZW5kIHRvXG4gICAqIG1hcmsgY29tcGxldGVkIGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY29tbWl0UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgcGFnZUhhc092ZXJyaWRlcyA9IHBhZ2Uuc3RvcE5leHQgfHwgcGFnZS5wcmV2ZW50RGVmYXVsdDtcbiAgICBwYWdlLmNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICBpZiAoIXBhZ2VIYXNPdmVycmlkZXMpIHtcbiAgICAgIC8vIHByZXZlbnQgbG9vcCBvZiBldmVudCBlbWlzc2lvbjsgYWx0ZXJuYXRlIGZsb3dzIHdvcmsgb2ZmXG4gICAgICAvLyBvZiBldmVudCBlbWl0dGVycyB0aGlzIGlzIGhvdyB0aGV5IGJyZWFrIHRoYXQgY3ljbGUuXG4gICAgICBwYWdlLm9uQ29tbWl0LmVtaXQocGFnZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlZCBieSB0aGUgbmF2U2VydmljZSB0byBuYXZpZ2F0ZSBiYWNrIHRvIGZpcnN0IHBvc3NpYmxlIHN0ZXAgYWZ0ZXJcbiAgLy8gcGFnZXMgYXJlIHJlc2V0XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX3BhZ2VzUmVzZXQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHRoYXQgdGhlIG5hdmlnYXRpb24gc2VydmljZSBsaXN0ZW5zIHRvIGluIG9yZGVyIHRvIGtub3cgd2hlblxuICAgKiB0aGUgcGFnZSBjb2xsZWN0aW9uIGNvbXBsZXRlZCBzdGF0ZXMgaGF2ZSBiZWVuIHJlc2V0IHRvIGZhbHNlIHNvIHRoYXQgd2F5IGl0XG4gICAqIGNhbiBhbHNvIHJlc2V0IHRoZSBuYXZpZ2F0aW9uIHRvIG1ha2UgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIHBhZ2UgY29sbGVjdGlvblxuICAgKiBjdXJyZW50L2FjdGl2ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBwYWdlc1Jlc2V0KCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9wYWdlc1Jlc2V0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYWxsIGNvbXBsZXRlZCBzdGF0ZXMgb2YgdGhlIHBhZ2VzIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24gdG8gZmFsc2UgYW5kXG4gICAqIG5vdGlmaWVzIHRoZSBuYXZpZ2F0aW9uIHNlcnZpY2UgdG8gbGlrZXdpc2UgcmVzZXQgdGhlIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICB0aGlzLnBhZ2VzQXNBcnJheS5mb3JFYWNoKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiB7XG4gICAgICBwYWdlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuX3BhZ2VzUmVzZXQubmV4dCh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xscyB0aHJvdWdoIGFsbCB0aGUgcGFnZXMgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbiB0byBtYWtlIHN1cmUgdGhlcmUgYXJlIG5vXG4gICAqIGluY29tcGxldGUgcGFnZXMgc2FuZHdpY2hlZCBiZXR3ZWVuIGNvbXBsZXRlZCBwYWdlcyBpbiB0aGUgd29ya2Zsb3cuIElkZW50aWZpZXNcbiAgICogdGhlIGZpcnN0IGluY29tcGxldGUgcGFnZSBpbmRleCBhbmQgc2V0cyBhbGwgcGFnZXMgYmVoaW5kIGl0IHRvIGEgY29tcGxldGVkXG4gICAqIHN0YXRlIG9mIGZhbHNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29tcGxldGVkU3RhdGVzKCk6IHZvaWQge1xuICAgIGNvbnN0IGZpcnN0SW5jb21wbGV0ZUluZGV4ID0gdGhpcy5maW5kRmlyc3RJbmNvbXBsZXRlUGFnZUluZGV4KCk7XG5cbiAgICBpZiAoZmlyc3RJbmNvbXBsZXRlSW5kZXggPT09IHRoaXMucGFnZXNBc0FycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGFsbCBjb21wbGV0ZSBubyBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wYWdlc0FzQXJyYXkuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKGluZGV4ID4gZmlyc3RJbmNvbXBsZXRlSW5kZXgpIHtcbiAgICAgICAgcGFnZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpbmNvbXBsZXRlIHBhZ2UgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZpbmRGaXJzdEluY29tcGxldGVQYWdlSW5kZXgoKTogbnVtYmVyIHtcbiAgICBsZXQgcmV0dXJuSW5kZXg6IG51bWJlciA9IG51bGw7XG4gICAgdGhpcy5wYWdlc0FzQXJyYXkuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKG51bGwgPT09IHJldHVybkluZGV4ICYmIGZhbHNlID09PSBwYWdlLmNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm5JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmFsbHRocm91Z2gsIGFsbCBjb21wbGV0ZWQsIHJldHVybiBsYXN0IHBhZ2VcbiAgICBpZiAobnVsbCA9PT0gcmV0dXJuSW5kZXgpIHtcbiAgICAgIHJldHVybkluZGV4ID0gdGhpcy5wYWdlc0NvdW50IC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuSW5kZXg7XG4gIH1cblxuICBwdWJsaWMgZmluZEZpcnN0SW5jb21wbGV0ZVBhZ2UoKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgbXlJbmNvbXBsZXRlSW5kZXggPSB0aGlzLmZpbmRGaXJzdEluY29tcGxldGVQYWdlSW5kZXgoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbbXlJbmNvbXBsZXRlSW5kZXhdO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi4vd2l6YXJkLXBhZ2UnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9idXR0b24taHViLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5cbi8qKlxuICogUGVyZm9ybXMgbmF2aWdhdGlvbiBmdW5jdGlvbnMgZm9yIGEgd2l6YXJkIGFuZCBtYW5hZ2VzIHRoZSBjdXJyZW50IHBhZ2UuIFByZXNlbnRlZCBhcyBhXG4gKiBzZXBhcmF0ZSBzZXJ2aWNlIHRvIGVuY2Fwc3VsYXRlIHRoZSBiZWhhdmlvciBvZiBuYXZpZ2F0aW5nIGFuZCBjb21wbGV0aW5nIHRoZSB3aXphcmQgc29cbiAqIHRoYXQgaXQgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgdGhlIHdpemFyZCBhbmQgaXRzIHN1Yi1jb21wb25lbnRzLlxuICpcbiAqIFRoZSBlYXNpZXN0IHdheSB0byBhY2Nlc3MgdGhlIG5hdmlnYXRpb24gc2VydmljZSBpcyB0aGVyZSBhIHJlZmVyZW5jZSBvbiB5b3VyIHdpemFyZC4gVGhlXG4gKiBGb2xsb3dpbmcgZXhhbXBsZSB3b3VsZCBhbGxvdyB5b3UgdG8gYWNjZXNzIHlvdXIgaW5zdGFuY2Ugb2YgdGhlIHdpemFyZCBmcm9tIHlvdXIgaG9zdFxuICogY29tcG9uZW50IGFuZCB0aGVyZWJ5IGFjY2VzcyB0aGUgbmF2aWdhdGlvbiBzZXJ2aWNlIHZpYSBZb3VySG9zdENvbXBvbmVudC53aXphcmQubmF2U2VydmljZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGNsci13aXphcmQgI3dpemFyZCAuLi4+XG4gKlxuICogQGV4YW1wbGVcbiAqIGV4cG9ydCBjbGFzcyBZb3VySG9zdENvbXBvbmVudCB7XG4gKiAgIEBWaWV3Q2hpbGQoXCJ3aXphcmRcIikgd2l6YXJkOiBXaXphcmQ7XG4gKiAgIC4uLlxuICogfVxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBwcmV2aW91cyBidXR0b24gaXMgY2xpY2tlZCBpbiB0aGUgd2l6YXJkLiBQZXJmb3JtcyBjaGVja3NcbiAgICogYmVmb3JlIGFsZXJ0aW5nIHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhlIGJ1dHRvbiBjbGljay4gRW5hY3RzIG5hdmlnYXRpb24gdG9cbiAgICogdGhlIHByZXZpb3VzIHBhZ2UgaWYgbm90IG92ZXJyaWRkZW4gYXQgdGhlIHBhZ2UgbGV2ZWwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBOZXh0IGJ1dHRvbiBpcyBjbGlja2VkIGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIG5leHRCdXR0b25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSXMgbm90aWZpZWQgd2hlbiBhIGRhbmdlciBidXR0b24gaXMgY2xpY2tlZCBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkYW5nZXJCdXR0b25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSXMgbm90aWZpZWQgd2hlbiBhICBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZmluaXNoQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBDdXN0b20gYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY3VzdG9tQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBDYW5jZWwgYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC4gTm90aWZpZXMgdGhlIHdpemFyZCxcbiAgICogd2hpY2ggaGFuZGxlcyBhbGwgY2FuY2VsIGZ1bmN0aW9uYWxpdHksIGlmIGNhbmNlbCBpcyBub3Qgb3ZlcnJpZGRlbiBhdCB0aGUgcGFnZVxuICAgKiBsZXZlbC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBuYXZpZ2F0aW9uIHRvIG1ha2UgdGhlIGZpcnN0IHBhZ2UgY3VycmVudCB3aGVuIHRoZSBwYWdlIGNvbGxlY3Rpb24gc2VydmljZVxuICAgKiBlbWl0cyBhbiBldmVudCBub3RpZnlpbmcgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgdGhhdCBpdCBoYXMgcmVzZXQgYWxsIHBhZ2VzXG4gICAqIHRvIHRoZWlyIHByaXN0aW5lLCBpbmNvbXBsZXRlIHN0YXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwYWdlc1Jlc2V0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UuIEFsc28gc2V0cyB1cCBzdWJzY3JpcHRpb25zXG4gICAqIHRoYXQgbGlzdGVuIHRvIHRoZSBidXR0b24gc2VydmljZSB0byBkZXRlcm1pbmUgd2hlbiBhIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIGluIHRoZSB3aXphcmQuIElzIGFsc28gcmVzcG9uc2libGUgZm9yIHRha2luZyBhY3Rpb24gd2hlbiB0aGUgcGFnZSBjb2xsZWN0aW9uXG4gICAqIHJlcXVlc3RzIHRoYXQgbmF2aWdhdGlvbiBiZSByZXNldCB0byBpdHMgcHJpc3RpbmUgc3RhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VDb2xsZWN0aW9uOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UsIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlKSB7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5wcmV2aW91c0J0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlSXNGaXJzdCB8fCBjdXJyZW50UGFnZS5wcmV2aW91c1N0ZXBEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFnZS5wcmV2aW91c0J1dHRvbkNsaWNrZWQuZW1pdChjdXJyZW50UGFnZSk7XG4gICAgICBpZiAoIWN1cnJlbnRQYWdlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV4dEJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5uZXh0QnRuQ2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCduZXh0Jyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRhbmdlckJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5kYW5nZXJCdG5DbGlja2VkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQW5kQ29tbWl0Q3VycmVudFBhZ2UoJ2RhbmdlcicpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5maW5pc2hCdXR0b25TdWJzY3JpcHRpb24gPSB0aGlzLmJ1dHRvblNlcnZpY2UuZmluaXNoQnRuQ2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCdmaW5pc2gnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY3VzdG9tQnV0dG9uU3Vic2NyaXB0aW9uID0gdGhpcy5idXR0b25TZXJ2aWNlLmN1c3RvbUJ0bkNsaWNrZWQuc3Vic2NyaWJlKCh0eXBlOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICghdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlLmN1c3RvbUJ1dHRvbkNsaWNrZWQuZW1pdCh0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uID0gdGhpcy5idXR0b25TZXJ2aWNlLmNhbmNlbEJ0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZS5wYWdlT25DYW5jZWwuZW1pdCh0aGlzLmN1cnJlbnRQYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhZ2VzUmVzZXRTdWJzY3JpcHRpb24gPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzUmVzZXQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0Rmlyc3RQYWdlQ3VycmVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMubmV4dEJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuZGFuZ2VyQnV0dG9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5maW5pc2hCdXR0b25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLmN1c3RvbUJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5wYWdlc1Jlc2V0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9jdXJyZW50Q2hhbmdlZCA9IG5ldyBTdWJqZWN0PENscldpemFyZFBhZ2U+KCk7XG5cbiAgLyoqXG4gICAqIEFuIE9ic2VydmFibGUgdGhhdCBpcyBwcmVkb21pbmFudGx5IHVzZWQgYW1vbmdzdCB0aGUgc3ViY29tcG9uZW50cyBhbmQgc2VydmljZXNcbiAgICogb2YgdGhlIHdpemFyZC4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB1c2VycyBsaXN0ZW4gdG8gdGhlIENscldpemFyZFBhZ2Uub25Mb2FkXG4gICAqIChjbHJXaXphcmRQYWdlT25Mb2FkKSBvdXRwdXQgaW5zdGVhZCBvZiB0aGlzIE9ic2VydmFibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUNoYW5nZWQoKTogT2JzZXJ2YWJsZTxDbHJXaXphcmRQYWdlPiB7XG4gICAgLy8gVE9ETzogTUFLRSBTVVJFIEVYVEVSTkFMIE9VVFBVVFMgU0FZICdDSEFOR0UnIE5PVCAnQ0hBTkdFRCdcbiAgICAvLyBBIEJSRUFLSU5HIENIQU5HRSBTTyBBV0FJVElORyBNSU5PUiBSRUxFQVNFXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgQm9vbGVhbiBmbGFnIHVzZWQgYnkgdGhlIENscldpemFyZFBhZ2UgdG8gYXZvaWQgYSByYWNlIGNvbmRpdGlvbiB3aGVuIHBhZ2VzIGFyZVxuICAgKiBsb2FkaW5nIGFuZCB0aGVyZSBpcyBubyBjdXJyZW50IHBhZ2UgZGVmaW5lZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgbmF2U2VydmljZUxvYWRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuZm9yY2VGb3J3YXJkIChjbHJXaXphcmRGb3JjZUZvcndhcmROYXZpZ2F0aW9uKSBpbnB1dC4gV2hlbiB0cnVlLFxuICAgKiBuYXZpZ2F0aW5nIGJhY2t3YXJkcyBpbiB0aGUgc3RlcG5hdiBtZW51IHdpbGwgcmVzZXQgYW55IHNraXBwZWQgcGFnZXMnIGNvbXBsZXRlZFxuICAgKiBzdGF0ZSB0byBmYWxzZS5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBhIHdpemFyZCBleGVjdXRlcyB2YWxpZGF0aW9uIG9uIGEgcGFnZS1ieS1wYWdlIGJhc2lzIHdoZW5cbiAgICogdGhlIG5leHQgYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZvcmNlRm9yd2FyZE5hdmlnYXRpb24gPSBmYWxzZTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlVGl0bGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgLy8gd2hlbiB0aGUgcXVlcnlsaXN0IG9mIHBhZ2VzIGlzIGVtcHR5LiB0aGlzIGlzIHRoZSBmaXJzdCBwbGFjZSBpdCBmYWlscy4uLlxuICAgIGlmICghdGhpcy5jdXJyZW50UGFnZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlLnRpdGxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCb29sZWFuIHRoYXQgdGVsbHMgeW91IHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlIGZpcnN0XG4gICAqIHBhZ2UgaW4gdGhlIFdpemFyZC5cbiAgICpcbiAgICogVGhpcyBpcyBoZWxwZnVsIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIGEgcGFnZSBpcyBuYXZpZ2FibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUlzRmlyc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGFnZUNvbGxlY3Rpb24uZmlyc3RQYWdlID09PSB0aGlzLmN1cnJlbnRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCb29sZWFuIHRoYXQgdGVsbHMgeW91IHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlXG4gICAqIGxhc3QgcGFnZSBpbiB0aGUgV2l6YXJkLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGJ1dHRvbnMgc2hvdWxkIGRpc3BsYXkgaW4gdGhlIHdpemFyZCBmb290ZXIuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUlzTGFzdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5sYXN0UGFnZSA9PT0gdGhpcy5jdXJyZW50UGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDbHJXaXphcmRQYWdlIG9iamVjdCBvZiB0aGUgY3VycmVudCBwYWdlIG9yIG51bGwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGlmICghdGhpcy5fY3VycmVudFBhZ2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIENscldpemFyZFBhZ2Ugb2JqZWN0LCBzaW5jZSB0aGF0IG9iamVjdCB0byBiZSB0aGUgY3VycmVudC9hY3RpdmVcbiAgICogcGFnZSBpbiB0aGUgd2l6YXJkLCBhbmQgZW1pdHMgdGhlIENscldpemFyZFBhZ2Uub25Mb2FkIChjbHJXaXphcmRQYWdlT25Mb2FkKVxuICAgKiBldmVudCBmb3IgdGhhdCBwYWdlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYWxsIG9mIHRoaXMgd29yayBpcyBieXBhc3NlZCBpZiB0aGUgQ2xyV2l6YXJkUGFnZSBvYmplY3QgaXMgYWxyZWFkeVxuICAgKiB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHNldCBjdXJyZW50UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYWdlICE9PSBwYWdlICYmICF0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICB0aGlzLl9jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICBwYWdlLm9uTG9hZC5lbWl0KHBhZ2UuaWQpO1xuICAgICAgdGhpcy5fY3VycmVudENoYW5nZWQubmV4dChwYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9tb3ZlZFRvTmV4dFBhZ2UgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHVzZWQgaW50ZXJuYWxseSB0byBhbGVydCB0aGUgd2l6YXJkIHRoYXQgZm9yd2FyZCBuYXZpZ2F0aW9uXG4gICAqIGhhcyBvY2N1cnJlZC4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHRoZSBXaXphcmQub25Nb3ZlTmV4dFxuICAgKiAoY2xyV2l6YXJkT25OZXh0KSBvdXRwdXQgaW5zdGVhZCBvZiB0aGlzIG9uZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1vdmVkVG9OZXh0UGFnZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZWRUb05leHRQYWdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBfd2l6YXJkRmluaXNoZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHVzZWQgaW50ZXJuYWxseSB0byBhbGVydCB0aGUgd2l6YXJkIHRoYXQgdGhlIG5hdiBzZXJ2aWNlXG4gICAqIGhhcyBhcHByb3ZlZCBjb21wbGV0aW9uIG9mIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSB0aGUgV2l6YXJkLndpemFyZEZpbmlzaGVkIChjbHJXaXphcmRPbkZpbmlzaClcbiAgICogb3V0cHV0IGluc3RlYWQgb2YgdGhpcyBvbmUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCB3aXphcmRGaW5pc2hlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fd2l6YXJkRmluaXNoZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgYWR2YW5jZVxuICAgKiB0aGUgdXNlciB0byB0aGUgbmV4dCBwYWdlLlxuICAgKlxuICAgKiBXaGVuIGludm9rZWQsIHRoaXMgbWV0aG9kIHdpbGwgbW92ZSB0aGUgd2l6YXJkIHRvIHRoZSBuZXh0IHBhZ2UgYWZ0ZXJcbiAgICogc3VjY2Vzc2Z1bCB2YWxpZGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZ29lcyB0aHJvdWdoIGFsbCBjaGVja3NcbiAgICogYW5kIGV2ZW50IGVtaXNzaW9ucyBhcyBpZiBXaXphcmQubmV4dChmYWxzZSkgaGFkIGJlZW4gY2FsbGVkLlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHVzZSBXaXphcmQubmV4dChmYWxzZSkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIG5leHQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2VJc0xhc3QpIHtcbiAgICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnbmV4dCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCeXBhc3NlcyBjaGVja3MgYW5kIG1vc3QgZXZlbnQgZW1pc3Npb25zIHRvIGZvcmNlIGEgcGFnZSB0byBuYXZpZ2F0ZSBmb3J3YXJkLlxuICAgKlxuICAgKiBDb21wYXJhYmxlIHRvIGNhbGxpbmcgV2l6YXJkLm5leHQoKSBvciBXaXphcmQuZm9yY2VOZXh0KCkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZvcmNlTmV4dCgpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50UGFnZTogQ2xyV2l6YXJkUGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG4gICAgY29uc3QgbmV4dFBhZ2U6IENscldpemFyZFBhZ2UgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLmdldE5leHRQYWdlKGN1cnJlbnRQYWdlKTtcblxuICAgIC8vIGNhdGNoIGVycmFudCBudWxsIG9yIHVuZGVmaW5lZHMgdGhhdCBjcmVlcCBpblxuICAgIGlmICghbmV4dFBhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHdpemFyZCBoYXMgbm8gbmV4dCBwYWdlIHRvIGdvIHRvLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjdXJyZW50UGFnZS5jb21wbGV0ZWQpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBzdGF0ZSB0aGF0IGFsdCBuZXh0IGZsb3dzIGNhbiBnZXQgdGhlbXNlbHZlcyBpbi4uLlxuICAgICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5jb21taXRQYWdlKGN1cnJlbnRQYWdlKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IG5leHRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBidXR0b24vYWN0aW9uIHR5cGUgYXMgYSBwYXJhbWV0ZXIuIEVuY2Fwc3VsYXRlcyBhbGwgbG9naWMgZm9yXG4gICAqIGV2ZW50IGVtaXNzaW9ucywgc3RhdGUgb2YgdGhlIGN1cnJlbnQgcGFnZSwgYW5kIHdpemFyZCBhbmQgcGFnZSBsZXZlbCBvdmVycmlkZXMuXG4gICAqXG4gICAqIEF2b2lkIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSB1bmxlc3MgeW91IHJlYWxseSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKGJ1dHRvblR5cGU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICBsZXQgaUFtVGhlTGFzdFBhZ2U6IGJvb2xlYW47XG5cbiAgICBsZXQgaXNOZXh0OiBib29sZWFuO1xuICAgIGxldCBpc0RhbmdlcjogYm9vbGVhbjtcbiAgICBsZXQgaXNEYW5nZXJOZXh0OiBib29sZWFuO1xuICAgIGxldCBpc0RhbmdlckZpbmlzaDogYm9vbGVhbjtcbiAgICBsZXQgaXNGaW5pc2g6IGJvb2xlYW47XG5cbiAgICBpZiAoIWN1cnJlbnRQYWdlLnJlYWR5VG9Db21wbGV0ZSB8fCB0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaUFtVGhlTGFzdFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlSXNMYXN0O1xuXG4gICAgaXNOZXh0ID0gYnV0dG9uVHlwZSA9PT0gJ25leHQnO1xuICAgIGlzRGFuZ2VyID0gYnV0dG9uVHlwZSA9PT0gJ2Rhbmdlcic7XG4gICAgaXNEYW5nZXJOZXh0ID0gaXNEYW5nZXIgJiYgIWlBbVRoZUxhc3RQYWdlO1xuICAgIGlzRGFuZ2VyRmluaXNoID0gaXNEYW5nZXIgJiYgaUFtVGhlTGFzdFBhZ2U7XG4gICAgaXNGaW5pc2ggPSBidXR0b25UeXBlID09PSAnZmluaXNoJyB8fCBpc0RhbmdlckZpbmlzaDtcblxuICAgIGlmIChpc0ZpbmlzaCAmJiAhaUFtVGhlTGFzdFBhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50UGFnZS5wcmltYXJ5QnV0dG9uQ2xpY2tlZC5lbWl0KGJ1dHRvblR5cGUpO1xuXG4gICAgaWYgKGlzRmluaXNoKSB7XG4gICAgICBjdXJyZW50UGFnZS5maW5pc2hCdXR0b25DbGlja2VkLmVtaXQoY3VycmVudFBhZ2UpO1xuICAgIH0gZWxzZSBpZiAoaXNEYW5nZXIpIHtcbiAgICAgIGN1cnJlbnRQYWdlLmRhbmdlckJ1dHRvbkNsaWNrZWQuZW1pdCgpO1xuICAgIH0gZWxzZSBpZiAoaXNOZXh0KSB7XG4gICAgICBjdXJyZW50UGFnZS5uZXh0QnV0dG9uQ2xpY2tlZC5lbWl0KCk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQYWdlLnN0b3BOZXh0IHx8IGN1cnJlbnRQYWdlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBjdXJyZW50UGFnZS5vbkNvbW1pdC5lbWl0KGN1cnJlbnRQYWdlLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvcmRlciBpcyB2ZXJ5IGltcG9ydGFudCB3aXRoIHRoZXNlIGVtaXR0ZXJzIVxuICAgIGlmIChpc0ZpbmlzaCkge1xuICAgICAgLy8gbWFyayBwYWdlIGFzIGNvbXBsZXRlXG4gICAgICBpZiAoIXRoaXMud2l6YXJkSGFzQWx0TmV4dCkge1xuICAgICAgICB0aGlzLnBhZ2VDb2xsZWN0aW9uLmNvbW1pdFBhZ2UoY3VycmVudFBhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5fd2l6YXJkRmluaXNoZWQubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpemFyZEhhc0FsdE5leHQpIHtcbiAgICAgIHRoaXMucGFnZUNvbGxlY3Rpb24uY29tbWl0UGFnZShjdXJyZW50UGFnZSk7XG5cbiAgICAgIGlmIChpc05leHQgfHwgaXNEYW5nZXJOZXh0KSB7XG4gICAgICAgIHRoaXMuX21vdmVkVG9OZXh0UGFnZS5uZXh0KHRydWUpO1xuICAgICAgfVxuICAgICAgLy8ganVtcCBvdXQgaGVyZSwgbm8gbWF0dGVyIHdoYXQgdHlwZSB3ZSdyZSBsb29raW5nIGF0XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTmV4dCB8fCBpc0Rhbmdlck5leHQpIHtcbiAgICAgIHRoaXMuZm9yY2VOZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndpemFyZEhhc0FsdE5leHQgJiYgIXRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHRoaXMuX21vdmVkVG9OZXh0UGFnZS5uZXh0KHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgcHVibGljIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBjb25jbHVkZVxuICAgKiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBXaGVuIGludm9rZWQsIHRoaXMgbWV0aG9kIHdpbGwgIGluaXRpYXRlIHRoZSB3b3JrIGludm9sdmVkIHdpdGggZmluYWxpemluZ1xuICAgKiBhbmQgZmluaXNoaW5nIHRoZSB3aXphcmQgd29ya2Zsb3cuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBnb2VzIHRocm91Z2ggYWxsXG4gICAqIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zIGFzIGlmIFdpemFyZC5maW5pc2goZmFsc2UpIGhhZCBiZWVuIGNhbGxlZC5cbiAgICpcbiAgICogSW4gbW9zdCBjYXNlcywgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byB1c2UgV2l6YXJkLmZpbmlzaChmYWxzZSkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZpbmlzaCgpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrQW5kQ29tbWl0Q3VycmVudFBhZ2UoJ2ZpbmlzaCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBfbW92ZWRUb1ByZXZpb3VzUGFnZSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSB3aXphcmQgd2hlbiBiYWNrd2FyZHMgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWQgdmlhIHRoZVxuICAgKiBwcmV2aW91cyBidXR0b24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBtb3ZlZFRvUHJldmlvdXNQYWdlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlZFRvUHJldmlvdXNQYWdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2dyYW1tYXRpY2FsbHkgbW92ZXMgdGhlIHdpemFyZCB0byB0aGUgcGFnZSBiZWZvcmUgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogSW4gbW9zdCBpbnN0YW5jZXMsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gY2FsbCBXaXphcmQucHJldmlvdXMoKVxuICAgKiB3aGljaCBkb2VzIHRoZSBzYW1lIHRoaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwcmV2aW91cygpOiB2b2lkIHtcbiAgICBsZXQgcHJldmlvdXNQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2VJc0ZpcnN0IHx8IHRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2aW91c1BhZ2UgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLmdldFByZXZpb3VzUGFnZSh0aGlzLmN1cnJlbnRQYWdlKTtcblxuICAgIGlmICghcHJldmlvdXNQYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbW92ZWRUb1ByZXZpb3VzUGFnZS5uZXh0KHRydWUpO1xuXG4gICAgaWYgKHRoaXMuZm9yY2VGb3J3YXJkTmF2aWdhdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gcHJldmlvdXNQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBfY2FuY2VsV2l6YXJkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGUgd2l6YXJkIHRoYXQgYSB1c2VyIGlzIHRyeWluZyB0byBjYW5jZWwgaXQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBub3RpZnlXaXphcmRDYW5jZWwoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fY2FuY2VsV2l6YXJkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBhIGhvb2sgaW50byB0aGUgY2FuY2VsIHdvcmtmbG93IG9mIHRoZSB3aXphcmQgZnJvbSB0aGUgbmF2IHNlcnZpY2UuIE5vdGUgdGhhdFxuICAgKiB0aGlzIHJvdXRlIGdvZXMgdGhyb3VnaCBhbGwgY2hlY2tzIGFuZCBldmVudCBlbWlzc2lvbnMgYXMgaWYgYSBjYW5jZWwgYnV0dG9uIGhhZFxuICAgKiBiZWVuIGNsaWNrZWQuXG4gICAqXG4gICAqIEluIG1vc3QgY2FzZXMsIHVzZXJzIGxvb2tpbmcgZm9yIGEgaG9vayBpbnRvIHRoZSBjYW5jZWwgcm91dGluZSBhcmUgYWN0dWFsbHkgbG9va2luZ1xuICAgKiBmb3IgYSB3YXkgdG8gY2xvc2UgdGhlIHdpemFyZCBmcm9tIHRoZWlyIGhvc3QgY29tcG9uZW50IGJlY2F1c2UgdGhleSBoYXZlIHByZXZlbnRlZFxuICAgKiB0aGUgZGVmYXVsdCBjYW5jZWwgYWN0aW9uLlxuICAgKlxuICAgKiBJbiB0aGlzIGluc3RhbmNlLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgV2l6YXJkLmNsb3NlKCkgdG8gYXZvaWQgYW55IGV2ZW50XG4gICAqIGVtaXNzaW9uIGxvb3AgcmVzdWx0aW5nIGZyb20gYW4gZXZlbnQgaGFuZGxlciBjYWxsaW5nIGJhY2sgaW50byByb3V0aW5lIHRoYXQgd2lsbFxuICAgKiBhZ2FpbiBldm9rZSB0aGUgZXZlbnRzIGl0IGhhbmRsZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLl9jYW5jZWxXaXphcmQubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBmbGFnIHNoYXJlZCBhY3Jvc3MgdGhlIFdpemFyZCBzdWJjb21wb25lbnRzIHRoYXQgZm9sbG93cyB0aGUgdmFsdWVcbiAgICogb2YgdGhlIFdpemFyZC5zdG9wQ2FuY2VsIChjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbCkgaW5wdXQuIFdoZW4gdHJ1ZSwgdGhlIGNhbmNlbFxuICAgKiByb3V0aW5lIGlzIHN1YnZlcnRlZCBhbmQgbXVzdCBiZSByZWluc3RhdGVkIGluIHRoZSBob3N0IGNvbXBvbmVudCBjYWxsaW5nIFdpemFyZC5jbG9zZSgpXG4gICAqIGF0IHNvbWUgcG9pbnQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHdpemFyZEhhc0FsdENhbmNlbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuc3RvcE5leHQgKGNscldpemFyZFByZXZlbnREZWZhdWx0TmV4dCkgaW5wdXQuIFdoZW4gdHJ1ZSwgdGhlIG5leHQgYW5kIGZpbmlzaFxuICAgKiByb3V0aW5lcyBhcmUgc3VidmVydGVkIGFuZCBtdXN0IGJlIHJlaW5zdGF0ZWQgaW4gdGhlIGhvc3QgY29tcG9uZW50IGNhbGxpbmcgV2l6YXJkLm5leHQoKSxcbiAgICogV2l6YXJkLmZvcmNlTmV4dCgpLCBXaXphcmQuZmluaXNoKCksIG9yIFdpemFyZC5mb3JjZUZpbmlzaCgpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB3aXphcmRIYXNBbHROZXh0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBmbGFnIHNoYXJlZCBhY3Jvc3MgdGhlIFdpemFyZCBzdWJjb21wb25lbnRzIHRoYXQgZm9sbG93cyB0aGUgdmFsdWVcbiAgICogb2YgdGhlIFdpemFyZC5zdG9wTmF2aWdhdGlvbiAoY2xyV2l6YXJkUHJldmVudE5hdmlnYXRpb24pIGlucHV0LiBXaGVuIHRydWUsIGFsbFxuICAgKiBuYXZpZ2F0aW9uYWwgZWxlbWVudHMgaW4gdGhlIHdpemFyZCBhcmUgZGlzYWJsZWQuXG4gICAqXG4gICAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gZnJlZXplIHRoZSB3aXphcmQgaW4gcGxhY2UuIEV2ZW50cyBhcmUgbm90IGZpcmVkIHNvIHRoaXMgaXNcbiAgICogbm90IGEgd2F5IHRvIGltcGxlbWVudCBhbHRlcm5hdGUgZnVuY3Rpb25hbGl0eSBmb3IgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgd2l6YXJkU3RvcE5hdmlnYXRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBib29sZWFuIGZsYWcgc2hhcmVkIHdpdGggdGhlIHN0ZXBuYXYgaXRlbXMgdGhhdCBwcmV2ZW50cyB1c2VyIGNsaWNrcyBvblxuICAgKiBzdGVwbmF2IGl0ZW1zIGZyb20gbmF2aWdhdGluZyB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB3aXphcmREaXNhYmxlU3RlcG5hdjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhbGwgcmVxdWlyZWQgY2hlY2tzIHRvIGRldGVybWluZSBpZiBhIHVzZXIgY2FuIG5hdmlnYXRlIHRvIGEgcGFnZS4gQ2hlY2tpbmcgYXQgZWFjaFxuICAgKiBwb2ludCBpZiBhIHBhZ2UgaXMgbmF2aWdhYmxlIC0tIGNvbXBsZXRlZCB3aGVyZSB0aGUgcGFnZSBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBjb21wbGV0ZWRcbiAgICogcGFnZS5cbiAgICpcbiAgICogVGFrZXMgdHdvIHBhcmFtZXRlcnMuIFRoZSBmaXJzdCBvbmUgbXVzdCBiZSBlaXRoZXIgdGhlIENscldpemFyZFBhZ2Ugb2JqZWN0IG9yIHRoZSBJRCBvZiB0aGVcbiAgICogQ2xyV2l6YXJkUGFnZSBvYmplY3QgdGhhdCB5b3Ugd2FudCB0byBtYWtlIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIG9wdGlvbmFsIGFuZCBpcyBhIEJvb2xlYW4gZmxhZyBmb3IgXCJsYXp5IGNvbXBsZXRpb25cIi4gV2hhdCB0aGlzIG1lYW5zXG4gICAqIGlzIHRoZSBXaXphcmQgd2lsbCBtYXJrIGFsbCBwYWdlcyBiZXR3ZWVuIHRoZSBjdXJyZW50IHBhZ2UgYW5kIHRoZSBwYWdlIHlvdSB3YW50IHRvIG5hdmlnYXRlXG4gICAqIHRvIGFzIGNvbXBsZXRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGluZm9ybWF0aW9uYWwgd2l6YXJkcyB0aGF0IGRvIG5vdCByZXF1aXJlIHVzZXIgYWN0aW9uLFxuICAgKiBhbGxvd2luZyBhbiBlYXN5IG1lYW5zIGZvciB1c2VycyB0byBqdW1wIGFoZWFkLlxuICAgKlxuICAgKiBUbyBhdm9pZCBjaGVja3Mgb24gbmF2aWdhdGlvbiwgdXNlIENscldpemFyZFBhZ2UubWFrZUN1cnJlbnQoKSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnb1RvKHBhZ2VUb0dvVG9PcklkOiBhbnksIGxhenlDb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgbGV0IHBhZ2VUb0dvVG86IENscldpemFyZFBhZ2U7XG4gICAgbGV0IGN1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlO1xuICAgIGxldCBteVBhZ2VzOiBQYWdlQ29sbGVjdGlvblNlcnZpY2U7XG4gICAgbGV0IHBhZ2VzVG9DaGVjazogQ2xyV2l6YXJkUGFnZVtdO1xuICAgIGxldCBva2F5VG9Nb3ZlOiBib29sZWFuO1xuICAgIGxldCBnb2luZ0ZvcndhcmQ6IGJvb2xlYW47XG4gICAgbGV0IGN1cnJlbnRQYWdlSW5kZXg6IG51bWJlcjtcbiAgICBsZXQgZ29Ub1BhZ2VJbmRleDogbnVtYmVyO1xuXG4gICAgbXlQYWdlcyA9IHRoaXMucGFnZUNvbGxlY3Rpb247XG4gICAgcGFnZVRvR29UbyA9IHR5cGVvZiBwYWdlVG9Hb1RvT3JJZCA9PT0gJ3N0cmluZycgPyBteVBhZ2VzLmdldFBhZ2VCeUlkKHBhZ2VUb0dvVG9PcklkKSA6IHBhZ2VUb0dvVG9PcklkO1xuICAgIGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcblxuICAgIC8vIG5vIHBvaW50IGluIGdvaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UuIHlvdSdyZSB0aGVyZSBhbHJlYWR5IVxuICAgIC8vIGFsc28gaGFyZCBibG9jayBvbiBhbnkgbmF2aWdhdGlvbiB3aGVuIHN0b3BOYXZpZ2F0aW9uIGlzIHRydWVcbiAgICBpZiAocGFnZVRvR29UbyA9PT0gY3VycmVudFBhZ2UgfHwgdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRQYWdlSW5kZXggPSBteVBhZ2VzLmdldFBhZ2VJbmRleChjdXJyZW50UGFnZSk7XG4gICAgZ29Ub1BhZ2VJbmRleCA9IG15UGFnZXMuZ2V0UGFnZUluZGV4KHBhZ2VUb0dvVG8pO1xuICAgIGdvaW5nRm9yd2FyZCA9IGdvVG9QYWdlSW5kZXggPiBjdXJyZW50UGFnZUluZGV4O1xuICAgIHBhZ2VzVG9DaGVjayA9IG15UGFnZXMuZ2V0UGFnZVJhbmdlRnJvbVBhZ2VzKHRoaXMuY3VycmVudFBhZ2UsIHBhZ2VUb0dvVG8pO1xuXG4gICAgb2theVRvTW92ZSA9IGxhenlDb21wbGV0ZSB8fCB0aGlzLmNhbkdvVG8ocGFnZXNUb0NoZWNrKTtcblxuICAgIGlmICghb2theVRvTW92ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChnb2luZ0ZvcndhcmQgJiYgbGF6eUNvbXBsZXRlKSB7XG4gICAgICBwYWdlc1RvQ2hlY2suZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4ge1xuICAgICAgICBpZiAocGFnZSAhPT0gcGFnZVRvR29Ubykge1xuICAgICAgICAgIHBhZ2UuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghZ29pbmdGb3J3YXJkICYmIHRoaXMuZm9yY2VGb3J3YXJkTmF2aWdhdGlvbikge1xuICAgICAgcGFnZXNUb0NoZWNrLmZvckVhY2goKHBhZ2U6IENscldpemFyZFBhZ2UpID0+IHtcbiAgICAgICAgcGFnZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlVG9Hb1RvO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSByYW5nZSBvZiBDbHJXaXphcmRQYWdlIG9iamVjdHMgYXMgYSBwYXJhbWV0ZXIuIFBlcmZvcm1zIHRoZSB3b3JrIG9mIGNoZWNraW5nXG4gICAqIHRob3NlIG9iamVjdHMgdG8gZGV0ZXJtaW5lIGlmIG5hdmlnYXRpb24gY2FuIGJlIGFjY29tcGxpc2hlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2FuR29UbyhwYWdlc1RvQ2hlY2s6IENscldpemFyZFBhZ2VbXSk6IGJvb2xlYW4ge1xuICAgIGxldCBva2F5VG9Nb3ZlID0gdHJ1ZTtcbiAgICBjb25zdCBteVBhZ2VzID0gdGhpcy5wYWdlQ29sbGVjdGlvbjtcblxuICAgIC8vIHByZXZpb3VzIHBhZ2UgY2FuIGJlIGltcG9ydGFudCB3aGVuIG1vdmluZyBiZWNhdXNlIGlmIGl0J3MgY29tcGxldGVkIGl0XG4gICAgLy8gYWxsb3dzIHVzIHRvIG1vdmUgdG8gdGhlIHBhZ2UgZXZlbiBpZiBpdCdzIGluY29tcGxldGUuLi5cbiAgICBsZXQgcHJldmlvdXNQYWdlUGFzc2VzOiBib29sZWFuO1xuXG4gICAgaWYgKCFwYWdlc1RvQ2hlY2sgfHwgcGFnZXNUb0NoZWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYWdlc1RvQ2hlY2suZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4ge1xuICAgICAgbGV0IHByZXZpb3VzUGFnZTogQ2xyV2l6YXJkUGFnZTtcblxuICAgICAgaWYgKCFva2F5VG9Nb3ZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2UuY29tcGxldGVkKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgaXMgdHJ1ZS4ganVzdCBqdW1wIG91dCBpbnN0ZWFkIG9mIGNvbXBsaWNhdGluZyBpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzbyB3ZSBrbm93IG91ciBwYWdlIGlzIG5vdCBjb21wbGV0ZWQuLi5cbiAgICAgIHByZXZpb3VzUGFnZSA9IG15UGFnZXMuZ2V0UGFnZUluZGV4KHBhZ2UpID4gMCA/IG15UGFnZXMuZ2V0UHJldmlvdXNQYWdlKHBhZ2UpIDogbnVsbDtcbiAgICAgIHByZXZpb3VzUGFnZVBhc3NlcyA9IHByZXZpb3VzUGFnZSA9PT0gbnVsbCB8fCBwcmV2aW91c1BhZ2UuY29tcGxldGVkID09PSB0cnVlO1xuXG4gICAgICAvLyB3ZSBhcmUgZmFsc2UgaWYgbm90IHRoZSBjdXJyZW50IHBhZ2UgQU5EIHByZXZpb3VzIHBhZ2UgaXMgbm90IGNvbXBsZXRlZFxuICAgICAgLy8gKGJ1dCBtdXN0IGhhdmUgYSBwcmV2aW91cyBwYWdlKVxuICAgICAgaWYgKCFwYWdlLmN1cnJlbnQgJiYgIXByZXZpb3VzUGFnZVBhc3Nlcykge1xuICAgICAgICBva2F5VG9Nb3ZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoIHRvIHRydWUgYXMgZGVmYXVsdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9rYXlUb01vdmU7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgdGhyb3VnaCB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcyB0byBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBpbmNvbXBsZXRlXG4gICAqIGFuZCBtYWtlcyB0aGF0IHBhZ2UgdGhlIGN1cnJlbnQvYWN0aXZlIHBhZ2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNldExhc3RFbmFibGVkUGFnZUN1cnJlbnQoKTogdm9pZCB7XG4gICAgY29uc3QgYWxsUGFnZXM6IENscldpemFyZFBhZ2VbXSA9IHRoaXMucGFnZUNvbGxlY3Rpb24ucGFnZXNBc0FycmF5O1xuICAgIGxldCBsYXN0Q29tcGxldGVkUGFnZUluZGV4OiBudW1iZXIgPSBudWxsO1xuXG4gICAgYWxsUGFnZXMuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKHBhZ2UuY29tcGxldGVkKSB7XG4gICAgICAgIGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChsYXN0Q29tcGxldGVkUGFnZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAvLyBhbHdheXMgaXMgYXQgbGVhc3QgdGhlIGZpcnN0IGl0ZW0uLi5cbiAgICAgIGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAobGFzdENvbXBsZXRlZFBhZ2VJbmRleCArIDEgPCBhbGxQYWdlcy5sZW5ndGgpIHtcbiAgICAgIGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggPSBsYXN0Q29tcGxldGVkUGFnZUluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gYWxsUGFnZXNbbGFzdENvbXBsZXRlZFBhZ2VJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMgYW5kIG1ha2VzIHRoYXQgcGFnZSB0aGVcbiAgICogY3VycmVudC9hY3RpdmUgcGFnZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc2V0Rmlyc3RQYWdlQ3VycmVudCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5wYWdlc0FzQXJyYXlbMF07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RlcG5hdiBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB3aXphcmQgd2hlbiBwYWdlcyBhcmUgZHluYW1pY2FsbHlcbiAgICogYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVOYXZpZ2F0aW9uKCk6IHZvaWQge1xuICAgIGxldCB0b1NldEN1cnJlbnQ6IENscldpemFyZFBhZ2U7XG4gICAgbGV0IGN1cnJlbnRQYWdlUmVtb3ZlZDogYm9vbGVhbjtcblxuICAgIHRoaXMucGFnZUNvbGxlY3Rpb24udXBkYXRlQ29tcGxldGVkU3RhdGVzKCk7XG5cbiAgICBjdXJyZW50UGFnZVJlbW92ZWQgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzQXNBcnJheS5pbmRleE9mKHRoaXMuY3VycmVudFBhZ2UpIDwgMDtcbiAgICBpZiAoY3VycmVudFBhZ2VSZW1vdmVkKSB7XG4gICAgICB0b1NldEN1cnJlbnQgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLmZpbmRGaXJzdEluY29tcGxldGVQYWdlKCk7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlID0gdG9TZXRDdXJyZW50O1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENscldpemFyZEhlYWRlckFjdGlvbiB9IGZyb20gJy4uL3dpemFyZC1oZWFkZXItYWN0aW9uJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhlYWRlckFjdGlvblNlcnZpY2Uge1xuICAvLyB0aGlzIHNlcnZpY2UgY29tbXVuaWNhdGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcmVzZW5jZS9kaXNwbGF5IG9mIGhlYWRlciBhY3Rpb25zXG4gIC8vIGFjcm9zcyB0aGUgd2l6YXJkXG5cbiAgY29uc3RydWN0b3IocHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlKSB7fVxuXG4gIHB1YmxpYyB3aXphcmRIZWFkZXJBY3Rpb25zOiBRdWVyeUxpc3Q8Q2xyV2l6YXJkSGVhZGVyQWN0aW9uPjtcblxuICBwdWJsaWMgZ2V0IHdpemFyZEhhc0hlYWRlckFjdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgd2l6YXJkSGRyQWN0aW9ucyA9IHRoaXMud2l6YXJkSGVhZGVyQWN0aW9ucztcbiAgICBpZiAoIXdpemFyZEhkckFjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpemFyZEhkckFjdGlvbnMudG9BcnJheSgpLmxlbmd0aCA+IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlSGFzSGVhZGVyQWN0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlID8gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlLmhhc0hlYWRlckFjdGlvbnMgOiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2hvd1dpemFyZEhlYWRlckFjdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmN1cnJlbnRQYWdlSGFzSGVhZGVyQWN0aW9ucyAmJiB0aGlzLndpemFyZEhhc0hlYWRlckFjdGlvbnM7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGRpc3BsYXlIZWFkZXJBY3Rpb25zV3JhcHBlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFnZUhhc0hlYWRlckFjdGlvbnMgfHwgdGhpcy53aXphcmRIYXNIZWFkZXJBY3Rpb25zO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmxldCB3aXphcmRIZWFkZXJBY3Rpb25JbmRleCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQtaGVhZGVyLWFjdGlvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiYnRuIGNsci13aXphcmQtaGVhZGVyLWFjdGlvbiBidG4tbGlua1wiXG4gICAgICAgICAgICBbaWRdPVwiaWRcIlxuICAgICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjbGljaygpXCJcbiAgICAgICAgICAgIFt0aXRsZV09XCJ0aXRsZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgLFxuICBob3N0OiB7IGNsYXNzOiAnY2xyLXdpemFyZC1oZWFkZXItYWN0aW9uLXdyYXBwZXInIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZEhlYWRlckFjdGlvbiB7XG4gIC8vIHRpdGxlIGlzIGV4cGxhbmF0b3J5IHRleHQgYWRkZWQgdG8gdGhlIGhlYWRlciBhY3Rpb25cbiAgQElucHV0KCd0aXRsZScpIHRpdGxlOiBzdHJpbmcgPSAnJztcblxuICAvLyBJZiBvdXIgaG9zdCBoYXMgYW4gSUQgYXR0cmlidXRlLCB3ZSB1c2UgdGhpcyBpbnN0ZWFkIG9mIG91ciBpbmRleC5cbiAgQElucHV0KCdpZCcpIF9pZDogc3RyaW5nID0gKHdpemFyZEhlYWRlckFjdGlvbkluZGV4KyspLnRvU3RyaW5nKCk7XG5cbiAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2xyLXdpemFyZC1oZWFkZXItYWN0aW9uLSR7dGhpcy5faWR9YDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyV2l6YXJkSGVhZGVyQWN0aW9uRGlzYWJsZWQnKSBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBAT3V0cHV0KCdhY3Rpb25DbGlja2VkJykgaGVhZGVyQWN0aW9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcblxuICBjbGljaygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHBhc3NpbmcgdGhlIGhlYWRlciBhY3Rpb24gaWQgYWxsb3dzIHVzZXJzIHRvIGhhdmUgb25lIG1ldGhvZCB0aGF0XG4gICAgLy8gcm91dGVzIHRvIG1hbnkgZGlmZmVyZW50IGFjdGlvbnMgYmFzZWQgb24gdGhlIHR5cGUgb2YgaGVhZGVyIGFjdGlvblxuICAgIC8vIGNsaWNrZWQuIHRoaXMgaXMgZnVydGhlciBhaWRlZCBieSB1c2VycyBiZWluZyBhYmxlIHRvIHNwZWNpZnkgaWRzXG4gICAgLy8gZm9yIHRoZWlyIGhlYWRlciBhY3Rpb25zLlxuICAgIHRoaXMuaGVhZGVyQWN0aW9uQ2xpY2tlZC5lbWl0KHRoaXMuX2lkKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQYWdlQnV0dG9uc10nIH0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZUJ1dHRvbnMge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZUJ1dHRvbnNUZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUGFnZUhlYWRlckFjdGlvbnNdJyB9KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFBhZ2VIZWFkZXJBY3Rpb25zIHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VIZWFkZXJBY3Rpb25zVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhZ2VOYXZUaXRsZV0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZU5hdlRpdGxlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VOYXZUaXRsZVRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQYWdlVGl0bGVdJyB9KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFBhZ2VUaXRsZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlVGl0bGVUZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYnV0dG9uLWh1Yi5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VDb2xsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UtY29sbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlQnV0dG9ucyB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtYnV0dG9ucyc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucyB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtaGVhZGVyLWFjdGlvbnMnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZU5hdlRpdGxlIH0gZnJvbSAnLi93aXphcmQtcGFnZS1uYXZ0aXRsZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlVGl0bGUgfSBmcm9tICcuL3dpemFyZC1wYWdlLXRpdGxlJztcblxubGV0IHdpemFyZFBhZ2VJbmRleCA9IDA7XG5cbi8qKlxuICogVGhlIENscldpemFyZFBhZ2UgY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwbGF5aW5nIHRoZSBjb250ZW50IG9mIGVhY2ggc3RlcFxuICogaW4gdGhlIHdpemFyZCB3b3JrZmxvdy5cbiAqXG4gKiBDbHJXaXphcmRQYWdlIGNvbXBvbmVudCBoYXMgaG9va3MgaW50byB0aGUgbmF2aWdhdGlvbiBzZXJ2aWNlIChDbHJXaXphcmRQYWdlLm5hdlNlcnZpY2UpLFxuICogcGFnZSBjb2xsZWN0aW9uIChDbHJXaXphcmRQYWdlLnBhZ2VDb2xsZWN0aW9uKSwgYW5kIGJ1dHRvbiBzZXJ2aWNlXG4gKiAoQ2xyV2l6YXJkUGFnZS5idXR0b25TZXJ2aWNlKS4gVGhlc2UgdGhyZWUgcHJvdmlkZXJzIGFyZSBzaGFyZWQgYWNyb3NzIHRoZSBjb21wb25lbnRzXG4gKiB3aXRoaW4gZWFjaCBpbnN0YW5jZSBvZiBhIFdpemFyZC5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQtcGFnZScsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICdpZCcsXG4gICAgJ1thdHRyLmFyaWEtaGlkZGVuXSc6ICchY3VycmVudCcsXG4gICAgJ1thdHRyLmFyaWEtbGFiZWxsZWRieV0nOiAnc3RlcEl0ZW1JZCcsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ2N1cnJlbnQnLFxuICAgICdbY2xhc3MuY2xyLXdpemFyZC1wYWdlXSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENscldpemFyZFBhZ2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBwYWdlQ29sbGVjdGlvbjogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIHBhZ2UgdGl0bGUgd2hpY2ggaXMgdXNlZCBmb3IgYSBudW1iZXJcbiAgICogb2YgZGlmZmVyZW50IHRhc2tzIGZvciBkaXNwbGF5IGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkKENscldpemFyZFBhZ2VUaXRsZSkgcHVibGljIHBhZ2VUaXRsZTogQ2xyV2l6YXJkUGFnZVRpdGxlO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgZGVzaXJlZCB0aXRsZSBmb3IgdGhlIHBhZ2UncyBzdGVwIGluIHRoZVxuICAgKiBuYXZpZ2F0aW9uIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHdpemFyZC4gQ2FuIGJlIHByb2plY3RlZCB0byBjaGFuZ2UgdGhlXG4gICAqIG5hdmlnYXRpb24gbGluaydzIHRleHQuXG4gICAqXG4gICAqIElmIG5vdCBkZWZpbmVkLCB0aGVuIENscldpemFyZFBhZ2UucGFnZVRpdGxlIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBzdGVwbmF2LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJXaXphcmRQYWdlTmF2VGl0bGUpIHB1YmxpYyBwYWdlTmF2VGl0bGU6IENscldpemFyZFBhZ2VOYXZUaXRsZTtcblxuICAvKipcbiAgICogQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGJ1dHRvbnMgZGVmaW5lZCB3aXRoaW4gdGhlIHBhZ2UuIElmIG5vdCBkZWZpbmVkLFxuICAgKiB0aGUgd2l6YXJkIGRlZmF1bHRzIHRvIHRoZSBzZXQgb2YgYnV0dG9ucyBkZWZpbmVkIGFzIGEgZGlyZWN0IGNoaWxkIG9mIHRoZVxuICAgKiB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkKENscldpemFyZFBhZ2VCdXR0b25zKSBwdWJsaWMgX2J1dHRvbnM6IENscldpemFyZFBhZ2VCdXR0b25zO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgaGVhZGVyIGFjdGlvbnMgZGVmaW5lZCB3aXRoaW4gdGhlIHBhZ2UuIElmIG5vdCBkZWZpbmVkLFxuICAgKiB0aGUgd2l6YXJkIGRlZmF1bHRzIHRvIHRoZSBzZXQgb2YgaGVhZGVyIGFjdGlvbnMgZGVmaW5lZCBhcyBhIGRpcmVjdCBjaGlsZCBvZiB0aGVcbiAgICogd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucykgcHVibGljIF9oZWFkZXJBY3Rpb25zOiBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucztcblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHByaXZhdGUgX25leHRTdGVwRGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIgdGhhdCB0ZWxscyB3aGV0aGVyIG9yIG5vdCB0aGUgd2l6YXJkIHNob3VsZCBiZSBhbGxvd2VkXG4gICAqIHRvIG1vdmUgdG8gdGhlIG5leHQgcGFnZS5cbiAgICpcbiAgICogVXNlZnVsIGZvciBpbi1wYWdlIHZhbGlkYXRpb24gYmVjYXVzZSBpdCBwcmV2ZW50cyBmb3J3YXJkIG5hdmlnYXRpb25cbiAgICogYW5kIHZpc2libHkgZGlzYWJsZXMgdGhlIG5leHQgYnV0dG9uLlxuICAgKlxuICAgKiBEb2VzIG5vdCByZXF1aXJlIHRoYXQgeW91IHJlLWltcGxlbWVudCBuYXZpZ2F0aW9uIHJvdXRpbmVzIGxpa2UgeW91XG4gICAqIHdvdWxkIGlmIHlvdSB3ZXJlIHVzaW5nIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHQgb3JcbiAgICogV2l6YXJkLnByZXZlbnREZWZhdWx0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBuZXh0U3RlcERpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uZXh0U3RlcERpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgcGFnZSBzaG91bGQgYWxsb3cgZm9yd2FyZCBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQYWdlTmV4dERpc2FibGVkJylcbiAgcHVibGljIHNldCBuZXh0U3RlcERpc2FibGVkKHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhbEJvb2wgPSAhIXZhbDtcbiAgICBpZiAodmFsQm9vbCAhPT0gdGhpcy5fbmV4dFN0ZXBEaXNhYmxlZCkge1xuICAgICAgdGhpcy5fbmV4dFN0ZXBEaXNhYmxlZCA9IHZhbEJvb2w7XG4gICAgICB0aGlzLm5leHRTdGVwRGlzYWJsZWRDaGFuZ2UuZW1pdCh2YWxCb29sKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgdmFsdWUgb2YgQ2xyV2l6YXJkUGFnZS5uZXh0U3RlcERpc2FibGVkIGNoYW5nZXMuXG4gICAqIFNob3VsZCBlbWl0IHRoZSBuZXcgdmFsdWUgb2YgbmV4dFN0ZXBEaXNhYmxlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VOZXh0RGlzYWJsZWRDaGFuZ2UnKSBuZXh0U3RlcERpc2FibGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9wcmV2aW91c1N0ZXBEaXNhYmxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGdldHRlciB0aGF0IHRlbGxzIHdoZXRoZXIgb3Igbm90IHRoZSB3aXphcmQgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICogdG8gbW92ZSB0byB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICpcbiAgICogVXNlZnVsIGZvciBpbi1wYWdlIHZhbGlkYXRpb24gYmVjYXVzZSBpdCBwcmV2ZW50cyBiYWNrd2FyZCBuYXZpZ2F0aW9uXG4gICAqIGFuZCB2aXNpYmx5IGRpc2FibGVzIHRoZSBwcmV2aW91cyBidXR0b24uXG4gICAqXG4gICAqIERvZXMgbm90IHJlcXVpcmUgdGhhdCB5b3UgcmUtaW1wbGVtZW50IG5hdmlnYXRpb24gcm91dGluZXMgbGlrZSB5b3VcbiAgICogd291bGQgaWYgeW91IHdlcmUgdXNpbmcgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdCBvclxuICAgKiBXaXphcmQucHJldmVudERlZmF1bHQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHByZXZpb3VzU3RlcERpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c1N0ZXBEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBhZ2Ugc2hvdWxkIGFsbG93IGJhY2t3YXJkIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VQcmV2aW91c0Rpc2FibGVkJylcbiAgcHVibGljIHNldCBwcmV2aW91c1N0ZXBEaXNhYmxlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX3ByZXZpb3VzU3RlcERpc2FibGVkKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c1N0ZXBEaXNhYmxlZCA9IHZhbEJvb2w7XG4gICAgICB0aGlzLnByZXZpb3VzU3RlcERpc2FibGVkQ2hhbmdlLmVtaXQodmFsQm9vbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHZhbHVlIG9mIENscldpemFyZFBhZ2UucHJldmlvdXNTdGVwRGlzYWJsZWQgY2hhbmdlcy5cbiAgICogU2hvdWxkIGVtaXQgdGhlIG5ldyB2YWx1ZSBvZiBwcmV2aW91c1N0ZXBEaXNhYmxlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VQcmV2aW91c0Rpc2FibGVkQ2hhbmdlJylcbiAgcHVibGljIHByZXZpb3VzU3RlcERpc2FibGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBhbGwgYWN0aW9ucyBmcm9tIHRoZSBwYWdlIGxldmVsLCBzbyB5b3UgY2FuIHVzZSBhbiBhbHRlcm5hdGUgZnVuY3Rpb24gZm9yXG4gICAqIHZhbGlkYXRpb24gb3IgZGF0YS1tdW5naW5nIHdpdGggYSBDbHJXaXphcmRQYWdlLm9uQ29tbWl0IChjbHJXaXphcmRQYWdlT25Db21taXQgb3V0cHV0KSxcbiAgICogQ2xyV2l6YXJkUGFnZS5vbkNhbmNlbCAoY2xyV2l6YXJkUGFnZU9uQ2FuY2VsIG91dHB1dCksIG9yIG9uZVxuICAgKiBvZiB0aGUgZ3JhbnVsYXIgcGFnZS1sZXZlbCBidXR0b24gY2xpY2sgZXZlbnQgZW1pdHRlcnMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdCcpIHB1YmxpYyBwcmV2ZW50RGVmYXVsdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfc3RvcENhbmNlbCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGdldHRlciB0aGF0IHJldHJpZXZlcyB3aGV0aGVyIHRoZSBwYWdlIGlzIHByZXZlbnRpbmcgdGhlIGNhbmNlbCBhY3Rpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0b3BDYW5jZWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BDYW5jZWw7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBjYW5jZWwgYWN0aW9uIGZyb20gdGhlIHBhZ2UgbGV2ZWwuIEFsbG93cyB5b3UgdG8gdXNlIGFuXG4gICAqIGFsdGVybmF0ZSBmdW5jdGlvbiBmb3IgdmFsaWRhdGlvbiBvciBkYXRhLW11bmdpbmcgYmVmb3JlIGNhbmNlbGxpbmcgdGhlXG4gICAqIHdpemFyZCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIENscldpemFyZFBhZ2Uub25DYW5jZWxcbiAgICogKHRoZSBjbHJXaXphcmRQYWdlT25DYW5jZWwgb3V0cHV0KS5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhhdCB5b3UgbWFudWFsbHkgY2xvc2UgdGhlIHdpemFyZCBmcm9tIHlvdXIgaG9zdCBjb21wb25lbnQsXG4gICAqIHVzdWFsbHkgd2l0aCBhIGNhbGwgdG8gV2l6YXJkLmZvcmNlTmV4dCgpIG9yIHdpemFyZC5uZXh0KCk7XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRQYWdlXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdENhbmNlbCcpXG4gIHB1YmxpYyBzZXQgc3RvcENhbmNlbCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX3N0b3BDYW5jZWwpIHtcbiAgICAgIHRoaXMuX3N0b3BDYW5jZWwgPSB2YWxCb29sO1xuICAgICAgdGhpcy5zdG9wQ2FuY2VsQ2hhbmdlLmVtaXQodmFsQm9vbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHRDYW5jZWxDaGFuZ2UnKSBzdG9wQ2FuY2VsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9zdG9wTmV4dCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGdldHRlciB0aGF0IHRlbGxzIHlvdSB3aGV0aGVyIHRoZSBwYWdlIGlzIHByZXZlbnRpbmcgdGhlIG5leHQgYWN0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBzdG9wTmV4dCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcE5leHQ7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGZvcndhcmQgbmF2aWdhdGlvbiBmcm9tIHRoZSBwYWdlIGxldmVsLiBBbGxvd3MgeW91IHRvIHVzZSBhblxuICAgKiBhbHRlcm5hdGUgZnVuY3Rpb24gZm9yIHZhbGlkYXRpb24gb3IgZGF0YS1tdW5naW5nIGJlZm9yZSBtb3ZpbmcgdGhlXG4gICAqIHdpemFyZCB0byB0aGUgbmV4dCBwYWdld2hlbiBjb21iaW5lZCB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLm9uQ29tbWl0XG4gICAqIChjbHJXaXphcmRQYWdlT25Db21taXQpIG9yIENscldpemFyZFBhZ2UubmV4dEJ1dHRvbkNsaWNrZWRcbiAgICogKGNscldpemFyZFBhZ2VOZXh0KSBvdXRwdXRzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGF0IHlvdSBtYW51YWxseSB0ZWxsIHRoZSB3aXphcmQgdG8gbmF2aWdhdGUgZm9yd2FyZCBmcm9tXG4gICAqIHRoZSBob3N0Q29tcG9uZW50LCB1c3VhbGx5IHdpdGggYSBjYWxsIHRvIFdpemFyZC5mb3JjZU5leHQoKSBvclxuICAgKiB3aXphcmQubmV4dCgpO1xuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkUGFnZVxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHROZXh0JylcbiAgcHVibGljIHNldCBzdG9wTmV4dCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX3N0b3BOZXh0KSB7XG4gICAgICB0aGlzLl9zdG9wTmV4dCA9IHZhbEJvb2w7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGVtaXR0ZXIgY2FycmllZCBvdmVyIGZyb20gYSBsZWdhY3kgdmVyc2lvbiBvZiBDbHJXaXphcmRQYWdlLlxuICAgKiBGaXJlcyBhbiBldmVudCBvbiBDbHJXaXphcmRQYWdlIHdoZW5ldmVyIHRoZSBuZXh0IG9yIGZpbmlzaCBidXR0b25zXG4gICAqIGFyZSBjbGlja2VkIGFuZCB0aGUgcGFnZSBpcyB0aGUgY3VycmVudCBwYWdlIG9mIHRoZSBXaXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGF1dG9tYXRpY2FsbHkgZW1pdCBhbiBldmVudCB3aGVuIGEgY3VzdG9tXG4gICAqIGJ1dHRvbiBpcyB1c2VkIGluIHBsYWNlIG9mIGEgbmV4dCBvciBmaW5pc2ggYnV0dG9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZU9uQ29tbWl0Jykgb25Db21taXQ6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiBDbHJXaXphcmRQYWdlIGJlY29tZXMgdGhlIGN1cnJlbnQgcGFnZSBvZiB0aGVcbiAgICogV2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZU9uTG9hZCcpIG9uTG9hZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIENscldpemFyZFBhZ2UgaW52b2tlcyB0aGUgY2FuY2VsIHJvdXRpbmUgZm9yIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2Uuc3RvcENhbmNlbFxuICAgKiAoY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0Q2FuY2VsKSBvciBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0XG4gICAqIChjbHJXaXphcmRQYWdlUGFnZVByZXZlbnREZWZhdWx0KSBpbnB1dHMgdG8gaW1wbGVtZW50IGN1c3RvbSBjYW5jZWxcbiAgICogZnVuY3Rpb25hbGl0eSBhdCB0aGUgcGFnZSBsZXZlbC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG9cbiAgICogdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuIHVzZXJzIGJlZm9yZSBjYW5jZWxsaW5nIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHlvdSB0byBjYWxsIFdpemFyZC5jbG9zZSgpIGZyb20gdGhlIGhvc3QgY29tcG9uZW50LlxuICAgKiBUaGlzIGNvbnN0aXR1ZXMgYSBmdWxsIHJlcGxhY2VtZW50IG9mIHRoZSBjYW5jZWwgZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VPbkNhbmNlbCcpIHBhZ2VPbkNhbmNlbDogRXZlbnRFbWl0dGVyPENscldpemFyZFBhZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZSBDbHJXaXphcmRQYWdlIGlzXG4gICAqIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gZmluaXNoXG4gICAqIGZ1bmN0aW9uYWxpdHkgYXQgdGhlIHBhZ2UgbGV2ZWwuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvXG4gICAqIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FybiB1c2VycyBiZWZvcmUgYWxsb3dpbmcgdGhlbSB0byBjb21wbGV0ZVxuICAgKiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuZmluaXNoKCkgb3IgV2l6YXJkLmZvcmNlRmluaXNoKClcbiAgICogZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXMgY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2ZcbiAgICogdGhlIGZpbmlzaCBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZUZpbmlzaCcpIGZpbmlzaEJ1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxDbHJXaXphcmRQYWdlPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgcHJldmlvdXMgYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZSBDbHJXaXphcmRQYWdlIGlzXG4gICAqIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gYmFja3dhcmRzXG4gICAqIG5hdmlnYXRpb24gYXQgdGhlIHBhZ2UgbGV2ZWwuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvXG4gICAqIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FybiB1c2VycyBiZWZvcmUgYWxsb3dpbmcgdGhlbSB0byBnb1xuICAgKiBiYWNrd2FyZHMgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLnByZXZpb3VzKClcbiAgICogZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXMgY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2ZcbiAgICogdGhlIGJhY2t3YXJkcyBuYXZpZ2F0aW9uIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlUHJldmlvdXMnKSBwcmV2aW91c0J1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxDbHJXaXphcmRQYWdlPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbmV4dCBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIENscldpemFyZFBhZ2UgaXNcbiAgICogdGhlIHdpemFyZCdzIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXQgdG8gaW1wbGVtZW50IGN1c3RvbSBmb3J3YXJkc1xuICAgKiBuYXZpZ2F0aW9uIGF0IHRoZSBwYWdlIGxldmVsLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkb1xuICAgKiB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm4gdXNlcnMgYmVmb3JlIGFsbG93aW5nIHRoZW0gdG8gZ29cbiAgICogdG8gdGhlIG5leHQgcGFnZSBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuZm9yY2VOZXh0KCkgb3IgV2l6YXJkLm5leHQoKVxuICAgKiBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC4gVGhpcyBjb21iaW5hdGlvbiBjcmVhdGVzIGEgZnVsbCByZXBsYWNlbWVudCBvZlxuICAgKiB0aGUgZm9yd2FyZCBuYXZpZ2F0aW9uIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlTmV4dCcpIG5leHRCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8Q2xyV2l6YXJkUGFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gYSBkYW5nZXIgYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZSBDbHJXaXphcmRQYWdlIGlzXG4gICAqIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuIEJ5IGRlZmF1bHQsIGEgZGFuZ2VyIGJ1dHRvbiB3aWxsIGFjdCBhc1xuICAgKiBlaXRoZXIgYSBcIm5leHRcIiBvciBcImZpbmlzaFwiIGJ1dHRvbiBkZXBlbmRpbmcgb24gaWYgdGhlIENscldpemFyZFBhZ2UgaXMgdGhlXG4gICAqIGxhc3QgcGFnZSBvciBub3QuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gZm9yd2FyZHNcbiAgICogb3IgZmluaXNoIG5hdmlnYXRpb24gYXQgdGhlIHBhZ2UgbGV2ZWwgd2hlbiB0aGUgZGFuZ2VyIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkbyB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm5cbiAgICogdXNlcnMgYmVmb3JlIGFsbG93aW5nIHRoZW0gdG8gZ28gdG8gdGhlIG5leHQgcGFnZSBpbiB0aGUgd2l6YXJkIG9yXG4gICAqIGZpbmlzaCB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuZmluaXNoKCksIFdpemFyZC5mb3JjZUZpbmlzaCgpLFxuICAgKiBXaXphcmQuZm9yY2VOZXh0KCkgb3IgV2l6YXJkLm5leHQoKSBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC4gVGhpc1xuICAgKiBjb21iaW5hdGlvbiBjcmVhdGVzIGEgZnVsbCByZXBsYWNlbWVudCBvZiB0aGUgZm9yd2FyZCBuYXZpZ2F0aW9uIGFuZFxuICAgKiBmaW5pc2ggZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VEYW5nZXInKSBkYW5nZXJCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8Q2xyV2l6YXJkUGFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gYSBuZXh0LCBmaW5pc2gsIG9yIGRhbmdlciBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlXG4gICAqIENscldpemFyZFBhZ2UgaXMgdGhlIHdpemFyZCdzIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXQgdG8gaW1wbGVtZW50IGN1c3RvbSBmb3J3YXJkc1xuICAgKiBvciBmaW5pc2ggbmF2aWdhdGlvbiBhdCB0aGUgcGFnZSBsZXZlbCwgcmVnYXJkbGVzcyBvZiB0aGUgdHlwZSBvZlxuICAgKiBwcmltYXJ5IGJ1dHRvbi5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG8gdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuXG4gICAqIHVzZXJzIGJlZm9yZSBhbGxvd2luZyB0aGVtIHRvIGdvIHRvIHRoZSBuZXh0IHBhZ2UgaW4gdGhlIHdpemFyZCBvclxuICAgKiBmaW5pc2ggdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLmZpbmlzaCgpLCBXaXphcmQuZm9yY2VGaW5pc2goKSxcbiAgICogV2l6YXJkLmZvcmNlTmV4dCgpIG9yIFdpemFyZC5uZXh0KCkgZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXNcbiAgICogY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2YgdGhlIGZvcndhcmQgbmF2aWdhdGlvbiBhbmRcbiAgICogZmluaXNoIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlUHJpbWFyeScpIHByaW1hcnlCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlQ3VzdG9tQnV0dG9uJykgY3VzdG9tQnV0dG9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEFuIGlucHV0IHZhbHVlIHRoYXQgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGdlbmVyYXRlIHRoZSBDbHJXaXphcmRQYWdlIElEIGFzXG4gICAqIHdlbGwgYXMgdGhlIHN0ZXAgbmF2IGl0ZW0gSUQuXG4gICAqXG4gICAqIFR5cGVkIGFzIGFueSBiZWNhdXNlIGl0IHNob3VsZCBiZSBhYmxlIHRvIGFjY2VwdCBudW1iZXJzIGFzIHdlbGwgYXNcbiAgICogc3RyaW5ncy4gUGFzc2luZyBhbiBpbmRleCBmb3Igd2l6YXJkIHdob3NlIHBhZ2VzIGFyZSBjcmVhdGVkIHdpdGggYW5cbiAgICogbmdGb3IgbG9vcCBpcyBhIGNvbW1vbiB1c2UgY2FzZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnaWQnKSBfaWQ6IGFueSA9ICh3aXphcmRQYWdlSW5kZXgrKykudG9TdHJpbmcoKTtcblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgZ2VuZXJhdGVzIGFuIElEIHN0cmluZyBmb3IgdGhlIHdpemFyZCBwYWdlIGZyb21cbiAgICogZWl0aGVyIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIENscldpemFyZFBhZ2UgXCJpZFwiIGlucHV0IG9yIGEgd2l6YXJkIHBhZ2VcbiAgICogY291bnRlciBzaGFyZWQgYWNyb3NzIGFsbCB3aXphcmQgcGFnZXMgaW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCBpbnRvIHRoZSBJRCBpbnB1dCBXaWxsIGJlIHByZWZpeGVkIHdpdGhcbiAgICogXCJjbHItd2l6YXJkLXBhZ2UtXCIuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkUGFnZVxuICAgKi9cbiAgcHVibGljIGdldCBpZCgpIHtcbiAgICAvLyBjb3ZlcnMgdGhpbmdzIGxpa2UgbnVsbCwgdW5kZWZpbmVkLCBmYWxzZSwgYW5kIGVtcHR5IHN0cmluZ1xuICAgIC8vIHdoaWxlIGFsbG93aW5nIHplcm8gdG8gcGFzc1xuICAgIGNvbnN0IGlkSXNOb25aZXJvRmFsc3kgPSAhdGhpcy5faWQgJiYgdGhpcy5faWQgIT09IDA7XG5cbiAgICAvLyBpbiBhZGRpdGlvbiB0byBub24temVybyBmYWxzeSB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIF9pZCBpcyBub3QgYSBuZWdhdGl2ZVxuICAgIC8vIG51bWJlci5cbiAgICBpZiAoaWRJc05vblplcm9GYWxzeSB8fCB0aGlzLl9pZCA8IDApIHtcbiAgICAgIC8vIGd1YXJkIGhlcmUgaW4gdGhlIGV2ZW50IHRoYXQgaW5wdXQgYmVjb21lcyB1bmRlZmluZWQgb3IgbnVsbCBieSBhY2NpZGVudFxuICAgICAgdGhpcy5faWQgPSAod2l6YXJkUGFnZUluZGV4KyspLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBgY2xyLXdpemFyZC1wYWdlLSR7dGhpcy5faWR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCBzZXJ2ZXMgYXMgYSBjb252ZW5pZW5jZSBmb3IgdGhvc2Ugd2hvIHdvdWxkIHJhdGhlclxuICAgKiBub3QgdGhpbmsgaW4gdGhlIHRlcm1zIG9mICFDbHJXaXphcmRQYWdlLm5leHRTdGVwRGlzYWJsZWQuIEZvciBzb21lIHVzZSBjYXNlcyxcbiAgICogQ2xyV2l6YXJkUGFnZS5yZWFkeVRvQ29tcGxldGUgaXMgbW9yZSBsb2dpY2FsIGFuZCBkZWNsYXJhdGl2ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgcmVhZHlUb0NvbXBsZXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5uZXh0U3RlcERpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9jb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIHBhZ2UgaXMgbWFya2VkIGFzIGNvbXBsZXRlZCBpZiBpdCBpcyBib3RoIHJlYWR5VG9Db21wbGV0ZSBhbmQgY29tcGxldGVkLFxuICAgKiBhcyBpbiB0aGUgbmV4dCBvciBmaW5pc2ggYWN0aW9uIGhhcyBiZWVuIGV4ZWN1dGVkIHdoaWxlIHRoaXMgcGFnZSB3YXMgY3VycmVudC5cbiAgICpcbiAgICogTm90ZSB0aGVyZSBpcyBhbmQgb3BlbiBxdWVzdGlvbiBhYm91dCBob3cgdG8gaGFuZGxlIHBhZ2VzIHRoYXQgYXJlIG1hcmtlZFxuICAgKiBjb21wbGV0ZSBidXQgd2hvIGFyZSBubyBsb25nZXIgcmVhZHlUb0NvbXBsZXRlLiBUaGlzIG1pZ2h0IGluZGljYXRlIGFuIGVycm9yXG4gICAqIHN0YXRlIGZvciB0aGUgQ2xyV2l6YXJkUGFnZS4gQ3VycmVudGx5LCB0aGUgd2l6YXJkIGRvZXMgbm90IGFja25vd2xlZGdlIHRoaXMgc3RhdGVcbiAgICogYW5kIG9ubHkgcmV0dXJucyB0aGF0IHRoZSBwYWdlIGlzIGluY29tcGxldGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbXBsZXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGxldGUgJiYgdGhpcy5yZWFkeVRvQ29tcGxldGU7XG5cbiAgICAvLyBGT1IgVjI6IFVOV0lORCBDT01QTEVURUQsIFJFQURZVE9DT01QTEVURSwgQU5EIEVSUk9SU1xuICAgIC8vIFNVQ0ggVEhBVCBFUlJPUlMgSVMgSVRTIE9XTiBJTlBVVC4gSUYgQSBTVEVQIElTXG4gICAgLy8gSU5DT01QTEVURSBBTkQgRVJST1JFRCwgRVJST1JFRCBXSUxMIE5PVCBTSE9XLlxuICAgIC8vIEZJUlNUIFFVRVNUSU9OOiBBTSBJIEdSRVkgT1IgQ09MT1JFRD9cbiAgICAvLyBTRUNPTkQgUVVFU1RJT046IEFNIEkgR1JFRU4gT1IgUkVEP1xuICB9XG5cbiAgLyoqXG4gICAqIEEgQ2xyV2l6YXJkUGFnZSBjYW4gYmUgbWFudWFsbHkgc2V0IHRvIGNvbXBsZXRlZCB1c2luZyB0aGlzIGJvb2xlYW4gc2V0dGVyLlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHVzZXJzIHJlbHkgb24gdGhlIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyBpbiB0aGUgd2l6YXJkXG4gICAqIGFuZCBuYXZpZ2F0aW9uIHNlcnZpY2UgaW5zdGVhZCBvZiBtYW51YWxseSBzZXR0aW5nIHBhZ2Vzw6LCgMKZIGNvbXBsZXRpb24gc3RhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRQYWdlXG4gICAqL1xuICBwdWJsaWMgc2V0IGNvbXBsZXRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2NvbXBsZXRlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdpdGggdGhlIG5hdmlnYXRpb24gc2VydmljZSB0byBzZWUgaWYgaXQgaXMgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlID09PSB0aGlzO1xuICB9XG5cbiAgcHVibGljIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuZW5hYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwYWdlIGlzIG5hdmlnYWJsZVxuICAgKiBpbiB0aGUgd2l6YXJkLiBBIHdpemFyZCBwYWdlIGNhbiBiZSBuYXZpZ2F0ZWQgdG8gaWYgaXQgaXMgY29tcGxldGVkXG4gICAqIG9yIHRoZSBwYWdlIGJlZm9yZSBpdCBpcyBjb21wbGV0ZWQuXG4gICAqXG4gICAqIFRoaXMgZ2V0dGVyIGhhbmRsZXMgdGhlIGxvZ2ljIGZvciBlbmFibGluZyBvciBkaXNhYmxpbmcgdGhlIGxpbmtzIGluXG4gICAqIHRoZSBzdGVwIG5hdiBvbiB0aGUgbGVmdCBTaWRlIG9mIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCB8fCB0aGlzLmNvbXBsZXRlZCB8fCB0aGlzLnByZXZpb3VzQ29tcGxldGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBhZ2UgYmVmb3JlIHRoaXNcbiAgICogQ2xyV2l6YXJkUGFnZSBpcyBjb21wbGV0ZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIG9yIG5vdFxuICAgKiBhIHBhZ2UgaXMgbmF2aWdhYmxlIGlmIGl0IGlzIG5vdCBjdXJyZW50IG9yIGFscmVhZHkgY29tcGxldGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBwcmV2aW91c0NvbXBsZXRlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBwcmV2aW91c1BhZ2UgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLmdldFByZXZpb3VzUGFnZSh0aGlzKTtcblxuICAgIGlmICghcHJldmlvdXNQYWdlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldmlvdXNQYWdlLmNvbXBsZXRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCB0aXRsZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wYWdlVGl0bGUucGFnZVRpdGxlVGVtcGxhdGVSZWY7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgbmF2VGl0bGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgaWYgKHRoaXMucGFnZU5hdlRpdGxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWdlTmF2VGl0bGUucGFnZU5hdlRpdGxlVGVtcGxhdGVSZWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhZ2VUaXRsZS5wYWdlVGl0bGVUZW1wbGF0ZVJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBoZWFkZXJBY3Rpb25zKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIGlmICghdGhpcy5faGVhZGVyQWN0aW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faGVhZGVyQWN0aW9ucy5wYWdlSGVhZGVyQWN0aW9uc1RlbXBsYXRlUmVmO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhhc0hlYWRlckFjdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5faGVhZGVyQWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBidXR0b25zKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIGlmICghdGhpcy5fYnV0dG9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnV0dG9ucy5wYWdlQnV0dG9uc1RlbXBsYXRlUmVmO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IHJldHVybnMgYSBib29sZWFuIHRoYXQgc2F5cyB3aGV0aGVyIG9yXG4gICAqIG5vdCB0aGUgQ2xyV2l6YXJkUGFnZSBpbmNsdWRlcyBidXR0b25zLiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVcbiAgICogV2l6YXJkIHNob3VsZCBvdmVycmlkZSB0aGUgZGVmYXVsdCBidXR0b24gc2V0IGRlZmluZWQgYXNcbiAgICogaXRzIGRpcmVjdCBjaGlsZHJlbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzQnV0dG9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9idXR0b25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZXMgdGhlIG5hdiBzZXJ2aWNlIHRvIG1ha2UgdGhlIENscldpemFyZFBhZ2UgdGhlIGN1cnJlbnQgcGFnZSBpbiB0aGVcbiAgICogd2l6YXJkLiBCeXBhc3NlcyBhbGwgY2hlY2tzIGJ1dCBzdGlsbCBlbWl0cyB0aGUgQ2xyV2l6YXJkUGFnZS5vbkxvYWRcbiAgICogKGNscldpemFyZFBhZ2VPbkxvYWQpIG91dHB1dC5cbiAgICpcbiAgICogSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSB0aGUgZGVmYXVsdCBuYXZpZ2F0aW9uIGZ1bmN0aW9uc1xuICAgKiBpbiBXaXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgbWFrZUN1cnJlbnQoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5rcyB0aGUgbmF2IHNlcnZpY2UgYW5kIGVzdGFibGlzaGVzIHRoZSBjdXJyZW50IHBhZ2UgaWYgb25lIGlzIG5vdCBkZWZpbmVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGNvbnN0IG5hdlNlcnZpY2UgPSB0aGlzLm5hdlNlcnZpY2U7XG4gICAgaWYgKCFuYXZTZXJ2aWNlLmN1cnJlbnRQYWdlICYmICFuYXZTZXJ2aWNlLm5hdlNlcnZpY2VMb2FkZWQpIHtcbiAgICAgIHRoaXMubWFrZUN1cnJlbnQoKTtcbiAgICAgIHRoaXMubmF2U2VydmljZS5uYXZTZXJ2aWNlTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgaWQgdXNlZCBieSB0aGUgc3RlcCBuYXYgaXRlbSBhc3NvY2lhdGVkIHdpdGggdGhlIHBhZ2UuXG4gICAqXG4gICAqIENscldpemFyZFBhZ2UgbmVlZHMgdGhpcyBJRCBzdHJpbmcgZm9yIGFyaWEgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0ZXBJdGVtSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5nZXRTdGVwSXRlbUlkRm9yUGFnZSh0aGlzKTtcbiAgfVxufVxuIiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4qIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4qIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiovXG5cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBEb0NoZWNrLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFZpZXdDaGlsZCxcbiAgUExBVEZPUk1fSUQsXG4gIEluamVjdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQnV0dG9uSHViU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2J1dHRvbi1odWIuc2VydmljZSc7XG5pbXBvcnQgeyBIZWFkZXJBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGVhZGVyLWFjdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkSGVhZGVyQWN0aW9uIH0gZnJvbSAnLi93aXphcmQtaGVhZGVyLWFjdGlvbic7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi93aXphcmQtcGFnZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQnLFxuICBwcm92aWRlcnM6IFtXaXphcmROYXZpZ2F0aW9uU2VydmljZSwgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLCBCdXR0b25IdWJTZXJ2aWNlLCBIZWFkZXJBY3Rpb25TZXJ2aWNlXSxcbiAgdGVtcGxhdGVVcmw6ICcuL3dpemFyZC5odG1sJyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLXdpemFyZF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy53aXphcmQtbWRdJzogXCJzaXplID09ICdtZCdcIixcbiAgICAnW2NsYXNzLndpemFyZC1sZ10nOiBcInNpemUgPT0gJ2xnJ1wiLFxuICAgICdbY2xhc3Mud2l6YXJkLXhsXSc6IFwic2l6ZSA9PSAneGwnXCIsXG4gICAgJ1tjbGFzcy5sYXN0UGFnZV0nOiAnbmF2U2VydmljZS5jdXJyZW50UGFnZUlzTGFzdCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZCBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCwgRG9DaGVjayB7XG4gIC8qKlxuICAgKiBTZXQgdGhlIG1vZGFsIHNpemUgb2YgdGhlIHdpemFyZC4gU2V0IHVzaW5nIGBbY2xyV2l6YXJkU2l6ZV1gIGlucHV0LlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRTaXplJykgc2l6ZSA9ICd4bCc7XG5cbiAgLyoqXG4gICAqIFRlbGxzIHRoZSBtb2RhbCBwYXJ0IG9mIHRoZSB3aXphcmQgd2hldGhlciBpdCBzaG91bGQgaGF2ZSBhIGNsb3NlIFwiWFwiXG4gICAqIGluIHRoZSB0b3AgcmlnaHQgY29ybmVyLiBTZXQgdXNpbmcgYFtjbHJXaXphcmRDbG9zYWJsZV1gIGlucHV0LlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRDbG9zYWJsZScpIGNsb3NhYmxlID0gdHJ1ZTtcblxuICAvKipcbiAgICogUmVzZXRzIHBhZ2UgY29tcGxldGVkIHN0YXRlcyB3aGVuIG5hdmlnYXRpbmcgYmFja3dhcmRzLlxuICAgKiBTZXQgdXNpbmcgYFtjbHJXaXphcmRGb3JjZUZvcndhcmROYXZpZ2F0aW9uXWAgaW5wdXQuXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZEZvcmNlRm9yd2FyZE5hdmlnYXRpb24nKVxuICBzZXQgZm9yY2VGb3J3YXJkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZm9yY2VGb3J3YXJkID0gISF2YWx1ZTtcbiAgICB0aGlzLm5hdlNlcnZpY2UuZm9yY2VGb3J3YXJkTmF2aWdhdGlvbiA9IHZhbHVlO1xuICB9XG4gIHByaXZhdGUgX2ZvcmNlRm9yd2FyZDogYm9vbGVhbiA9IGZhbHNlO1xuICBnZXQgZm9yY2VGb3J3YXJkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZUZvcndhcmQ7XG4gIH1cblxuICBfb3BlbiA9IGZhbHNlO1xuICAvKipcbiAgICogVG9nZ2xlcyBvcGVuL2Nsb3NlIG9mIHRoZSB3aXphcmQgY29tcG9uZW50LlxuICAgKiBTZXQgdXNpbmcgdGhlIGBbY2xyV2l6YXJkT3Blbl1gIGlucHV0LlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRPcGVuJylcbiAgc2V0IGNscldpemFyZE9wZW4ob3BlbjogYm9vbGVhbikge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fb3BlbiA9IG9wZW47XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgQ2xyV2l6YXJkIGZyb20gbW92aW5nIHRvIHRoZSBuZXh0IHBhZ2Ugb3IgY2xvc2luZyBpdHNlbGYgb24gZmluaXNoaW5nLlxuICAgKiBTZXQgdXNpbmcgdGhlIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0XWAgaW5wdXQuIE5vdGUgdGhhdCB1c2luZyBzdG9wTmV4dFxuICAgKiB3aWxsIHJlcXVpcmUgeW91IHRvIGNyZWF0ZSB5b3VyIG93biBjYWxscyB0byAubmV4dCgpIGFuZCAuZmluaXNoKCkgaW4geW91clxuICAgKiBob3N0IGNvbXBvbmVudCB0byBtYWtlIHRoZSBDbHJXaXphcmQgd29yayBhcyBleHBlY3RlZC5cbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0JylcbiAgc2V0IHN0b3BOZXh0KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc3RvcE5leHQgPSAhIXZhbHVlO1xuICAgIHRoaXMubmF2U2VydmljZS53aXphcmRIYXNBbHROZXh0ID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfc3RvcE5leHQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IHN0b3BOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9wTmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBDbHJXaXphcmQgZnJvbSBjbG9zaW5nIHdoZW4gdGhlIGNhbmNlbCBidXR0b24gb3IgY2xvc2UgXCJYXCIgaXMgY2xpY2tlZC5cbiAgICogU2V0IHVzaW5nIHRoZSBgW2NscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsXWAgaW5wdXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB1c2luZyBzdG9wQ2FuY2VsIHdpbGwgcmVxdWlyZSB5b3UgdG8gY3JlYXRlIHlvdXIgb3duIGNhbGxzIHRvIGBjbG9zZSgpYCBpbiB5b3VyIGhvc3QgY29tcG9uZWBudFxuICAgKiB0byBtYWtlIHRoZSBDbHJXaXphcmQgd29yayBhcyBleHBlY3RlZC4gVXNlZnVsIGZvciBkb2luZyBjaGVja3Mgb3IgcHJvbXB0c1xuICAgKiBiZWZvcmUgY2xvc2luZyBhIENscldpemFyZC5cbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWwnKVxuICBzZXQgc3RvcENhbmNlbCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3N0b3BDYW5jZWwgPSAhIXZhbHVlO1xuICAgIHRoaXMubmF2U2VydmljZS53aXphcmRIYXNBbHRDYW5jZWwgPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9zdG9wQ2FuY2VsOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBzdG9wQ2FuY2VsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdG9wQ2FuY2VsO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIENscldpemFyZCBmcm9tIHBlcmZvcm1pbmcgYW55IGZvcm0gb2YgbmF2aWdhdGlvbiBhd2F5IGZyb20gdGhlIGN1cnJlbnRcbiAgICogcGFnZS4gU2V0IHVzaW5nIHRoZSBgW2NscldpemFyZFByZXZlbnROYXZpZ2F0aW9uXWAgaW5wdXQuXG4gICAqIE5vdGUgdGhhdCBzdG9wTmF2aWdhdGlvbiBpcyBtZWFudCB0byBmcmVlemUgdGhlIHdpemFyZCBpbiBwbGFjZSwgdHlwaWNhbGx5XG4gICAqIGR1cmluZyBhIGxvbmcgdmFsaWRhdGlvbiBvciBiYWNrZ3JvdW5kIGFjdGlvbiB3aGVyZSB5b3Ugd2FudCB0aGUgd2l6YXJkIHRvXG4gICAqIGRpc3BsYXkgbG9hZGluZyBjb250ZW50IGJ1dCBub3QgYWxsb3cgdGhlIHVzZXIgdG8gZXhlY3V0ZSBuYXZpZ2F0aW9uIGluXG4gICAqIHRoZSBzdGVwbmF2LCBjbG9zZSBYLCBvciB0aGUgIGJhY2ssIGZpbmlzaCwgb3IgbmV4dCBidXR0b25zLlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQcmV2ZW50TmF2aWdhdGlvbicpXG4gIHNldCBzdG9wTmF2aWdhdGlvbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3N0b3BOYXZpZ2F0aW9uID0gISF2YWx1ZTtcbiAgICB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkU3RvcE5hdmlnYXRpb24gPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9zdG9wTmF2aWdhdGlvbiA9IGZhbHNlO1xuICBnZXQgc3RvcE5hdmlnYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BOYXZpZ2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIGNsaWNrcyBvbiB0aGUgbGlua3MgaW4gdGhlIHN0ZXBuYXYgZnJvbSB3b3JraW5nLlxuICAgKiBTZXQgdXNpbmcgYFtjbHJXaXphcmREaXNhYmxlU3RlcG5hdl1gIGlucHV0LlxuICAgKiBBIG1vcmUgZ3JhbnVsYXIgYnlwYXNzaW5nIG9mIG5hdmlnYXRpb24gd2hpY2ggY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdXJcbiAgICogQ2xyV2l6YXJkIGlzIGluIGEgc3RhdGUgb2YgY29tcGxldGlvbiBhbmQgeW91IGRvbid0IHdhbnQgdXNlcnMgdG8gYmVcbiAgICogYWJsZSB0byBqdW1wIGJhY2t3YXJkcyBhbmQgY2hhbmdlIHRoaW5ncy5cbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkRGlzYWJsZVN0ZXBuYXYnKVxuICBzZXQgZGlzYWJsZVN0ZXBuYXYodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kaXNhYmxlU3RlcG5hdiA9ICEhdmFsdWU7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLndpemFyZERpc2FibGVTdGVwbmF2ID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfZGlzYWJsZVN0ZXBuYXY6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IGRpc2FibGVTdGVwbmF2KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlU3RlcG5hdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNvbW11bmljYXRlIHRvIHRoZSB1bmRlcmx5aW5nIG1vZGFsIHRoYXQgYW5pbWF0aW9ucyBhcmUgbm90XG4gICAqIHdhbnRlZC4gUHJpbWFyeSB1c2UgaXMgZm9yIHRoZSBkaXNwbGF5IG9mIHN0YXRpYy9pbmxpbmUgd2l6YXJkcy5cbiAgICogU2V0IHVzaW5nIGBbY2xyV2l6YXJkUHJldmVudE1vZGFsQW5pbWF0aW9uXWAgaW5wdXQuXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFByZXZlbnRNb2RhbEFuaW1hdGlvbicpIF9zdG9wTW9kYWxBbmltYXRpb25zOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBzdG9wTW9kYWxBbmltYXRpb25zKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BNb2RhbEFuaW1hdGlvbnMgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyBvcGVuZWQgb3IgY2xvc2VkLlxuICAgKiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT3BlbkNoYW5nZSlgIGV2ZW50LlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT3BlbkNoYW5nZScpIF9vcGVuQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyBjYW5jZWxlZC4gTGlzdGVuIHZpYSBgKGNscldpemFyZE9uQ2FuY2VsKWAgZXZlbnQuXG4gICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgW2NscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsXWAgaW5wdXQgdG8gY3JlYXRlXG4gICAqIHdpemFyZC1sZXZlbCBjdXN0b20gY2FuY2VsIHJvdXRpbmVzLlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25DYW5jZWwnKSBvbkNhbmNlbDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgaXMgY29tcGxldGVkLiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT25GaW5pc2gpYCBldmVudC5cbiAgICogQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0XWAgaW5wdXQgdG8gY3JlYXRlXG4gICAqIHdpemFyZC1sZXZlbCBjdXN0b20gY29tcGxldGlvbiByb3V0aW5lcy5cbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZE9uRmluaXNoJykgd2l6YXJkRmluaXNoZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIHJlc2V0LiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT25SZXNldClgIGV2ZW50LlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25SZXNldCcpIG9uUmVzZXQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgY3VycmVudCBwYWdlIGhhcyBjaGFuZ2VkLiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkQ3VycmVudFBhZ2VDaGFuZ2VkKWAgZXZlbnQuXG4gICAqIG91dHB1dC4gVXNlZnVsIGZvciBub24tYmxvY2tpbmcgdmFsaWRhdGlvbi5cbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZEN1cnJlbnRQYWdlQ2hhbmdlZCcpIGN1cnJlbnRQYWdlQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgbW92ZXMgdG8gdGhlIG5leHQgcGFnZS4gTGlzdGVuIHZpYSBgKGNscldpemFyZE9uTmV4dClgIGV2ZW50LlxuICAgKiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYFtjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHRdYCBpbnB1dCB0byBjcmVhdGVcbiAgICogd2l6YXJkLWxldmVsIGN1c3RvbSBuYXZpZ2F0aW9uIHJvdXRpbmVzLCB3aGljaCBhcmUgdXNlZnVsIGZvciB2YWxpZGF0aW9uLlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25OZXh0Jykgb25Nb3ZlTmV4dDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgbW92ZXMgdG8gdGhlIHByZXZpb3VzIHBhZ2UuIENhbiBiZSB1c2VmdWwgZm9yIHZhbGlkYXRpb24uXG4gICAqIExpc3RlbiB2aWEgYChjbHJXaXphcmRPblByZXZpb3VzKWAgZXZlbnQuXG4gICAqL1xuXG4gIEBPdXRwdXQoJ2NscldpemFyZE9uUHJldmlvdXMnKSBvbk1vdmVQcmV2aW91czogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyV2l6YXJkUGFnZSkgcGFnZXM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRQYWdlPjtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJXaXphcmRIZWFkZXJBY3Rpb24pIGhlYWRlckFjdGlvbnM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRIZWFkZXJBY3Rpb24+O1xuICBAVmlld0NoaWxkKCd3aXphcmRUaXRsZScpIHdpemFyZFRpdGxlOiBFbGVtZW50UmVmO1xuXG4gIHB1YmxpYyBnZXQgY3VycmVudFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgY3VycmVudFBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIHRoaXMubmF2U2VydmljZS5nb1RvKHBhZ2UsIHRydWUpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0xhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZUlzTGFzdDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNGaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlSXNGaXJzdDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuICh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuY2xhc3NMaXN0LmNvbnRhaW5zKCdjbHItd2l6YXJkLS1pbmxpbmUnKTtcbiAgfVxuXG4gIHByaXZhdGUgZGlmZmVyOiBhbnk7IC8vIGZvciBtYXJraW5nIHdoZW4gdGhlIGNvbGxlY3Rpb24gb2Ygd2l6YXJkIHBhZ2VzIGhhcyBiZWVuIGFkZGVkIHRvIG9yIGRlbGV0ZWQgZnJvbVxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QsXG4gICAgcHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBwYWdlQ29sbGVjdGlvbjogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlLFxuICAgIHB1YmxpYyBoZWFkZXJBY3Rpb25TZXJ2aWNlOiBIZWFkZXJBY3Rpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnNcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmxpc3RlbkZvck5leHRQYWdlQ2hhbmdlcygpLFxuICAgICAgdGhpcy5saXN0ZW5Gb3JQcmV2aW91c1BhZ2VDaGFuZ2VzKCksXG4gICAgICB0aGlzLmxpc3RlbkZvckNhbmNlbENoYW5nZXMoKSxcbiAgICAgIHRoaXMubGlzdGVuRm9yRmluaXNoZWRDaGFuZ2VzKCksXG4gICAgICB0aGlzLmxpc3RlbkZvclBhZ2VDaGFuZ2VzKClcbiAgICApO1xuXG4gICAgdGhpcy5kaWZmZXIgPSBkaWZmZXJzLmZpbmQoW10pLmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5wYWdlcyA9IHRoaXMucGFnZXM7XG4gICAgdGhpcy5oZWFkZXJBY3Rpb25TZXJ2aWNlLndpemFyZEhlYWRlckFjdGlvbnMgPSB0aGlzLmhlYWRlckFjdGlvbnM7XG4gICAgdGhpcy5pbml0aWFsaXplQnV0dG9ucygpO1xuICB9XG5cbiAgcHVibGljIG5nRG9DaGVjaygpIHtcbiAgICB0aGlzLnVwZGF0ZU5hdk9uUGFnZUNoYW5nZXMoKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgV2l6YXJkIGFzIGZpbmlzaGVkLiBCeSBkZWZhdWx0IGl0IGRvZXMgbm90IGV4ZWN1dGUgZXZlbnRcbiAgICogZW1pc3Npb25zIG9yIGNoZWNrcyBiZWZvcmUgY29tcGxldGluZyBhbmQgY2xvc2luZy4gVGhpcyBtZXRob2QgaXMgY29tbW9ubHlcbiAgICogdXNlZCBhcyBwYXJ0IG9mIGFuIGFsdGVybmF0aXZlIG5hdmlnYXRpb24gd2l0aCBgW2NscldpemFyZFByZXZlbnREZWZhdWx0TmV4dF1gLlxuICAgKlxuICAgKiBJZiBgc2tpcENoZWNrc0FuZEVtaXRzYCBpcyB0cnVlLCB0aGUgd2l6YXJkIHdpbGwgY29tcGxldGUgYW5kIGNsb3NlXG4gICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mIGl0cyBjdXJyZW50IHBhZ2UuIFRoaXMgaXMgdXNlZnVsIGZvciBhbHRlcm5hdGl2ZVxuICAgKiBuYXZpZ2F0aW9uIHdoZXJlIGV2ZW50IGVtaXNzaW9ucyBoYXZlIGFscmVhZHkgYmVlbiBkb25lIGFuZCBmaXJpbmcgdGhlbSBhZ2FpblxuICAgKiBtYXkgY2F1c2UgYW4gZXZlbnQgbG9vcC5cbiAgICovXG4gIHB1YmxpYyBmaW5pc2goc2tpcENoZWNrc0FuZEVtaXRzID0gdHJ1ZSkge1xuICAgIGlmIChza2lwQ2hlY2tzQW5kRW1pdHMpIHtcbiAgICAgIHRoaXMuZm9yY2VGaW5pc2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYXZTZXJ2aWNlLmZpbmlzaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrcyB0aGUgd2l6YXJkIGFzIGZpbmlzaGVkIGJ1dCBkb2VzIHJ1biBjaGVja3MgYW5kIGVtaXNzaW9ucy5cbiAgICogR29vZCBmb3IgYSBsYXN0IHN0ZXAgaW4gYW4gYWx0ZXJuYXRlIHdvcmtmbG93LiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzXG4gICAqIGNhbGxpbmcgYENscldpemFyZC5maW5pc2godHJ1ZSlgIG9yIGBDbHJXaXphcmQuZmluaXNoKClgIHdpdGhvdXQgYSBwYXJhbWV0ZXIuXG4gICAqL1xuICBwdWJsaWMgZm9yY2VGaW5pc2goKSB7XG4gICAgaWYgKHRoaXMuc3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHdpemFyZC4gSWYgdGhlcmUgaXMgbm8gY3VycmVudCBwYWdlIGRlZmluZWQsIHNldHMgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIHdpemFyZCB0byBiZSBjdXJyZW50LlxuICAgKi9cbiAgcHVibGljIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5fb3BlbiA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuY3VycmVudFBhZ2UpIHtcbiAgICAgIHRoaXMubmF2U2VydmljZS5zZXRGaXJzdFBhZ2VDdXJyZW50KCk7XG4gICAgfVxuXG4gICAgLy8gT25seSByZW5kZXIgYnV0dG9ucyB3aGVuIHdpemFyZCBpcyBvcGVuZWQsIHRvIGF2b2lkIGNob2NvbGF0ZSBlcnJvcnNcbiAgICB0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuX29wZW5DaGFuZ2VkLmVtaXQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSB3aXphcmQuIENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkIG9mIGBjYW5jZWwoKWAgdG8gaW1wbGVtZW50IGFsdGVybmF0aXZlIGNhbmNlbCBmdW5jdGlvbmFsaXR5LlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wZW5DaGFuZ2VkLmVtaXQoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gb3BlbiBhbmQgY2xvc2UgdGhlIHdpemFyZC4gQnkgZGVmYXVsdCB0aGUgd2l6YXJkIHdpbGxcbiAgICogY2xvc2UgaWYgaW52b2tlZCB3aXRoIG5vIHBhcmFtZXRlci4gSWYgcGFyYW1ldGVyIGlzIHRydWUgd2l6YXJkIHdpbGwgb3BlblxuICAgKiBlbHNlIGlmIGZhbHNlIHdpbGwgY2xvc2UuXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKG9wZW46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHdpemFyZCB0byB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICovXG4gIHB1YmxpYyBwcmV2aW91cygpOiB2b2lkIHtcbiAgICB0aGlzLm5hdlNlcnZpY2UucHJldmlvdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBgbmV4dCgpYCBkb2VzIG5vdCBleGVjdXRlIGV2ZW50IGVtaXNzaW9ucy5cbiAgICogVGhpcyBtZXRob2QgaXMgY29tbW9ubHkgY2FsbGVkIGFzIHBhcnQgb2YgYW4gYWx0ZXJuYXRpdmUgbmF2aWdhdGlvblxuICAgKiB3aXRoIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0XWAuIFRoZSB3aXphcmQgd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IHBhZ2VcbiAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2YgaXRzIGN1cnJlbnQgcGFnZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsdGVybmF0aXZlXG4gICAqIG5hdmlnYXRpb24gd2hlcmUgZXZlbnQgZW1pc3Npb25zIGhhdmUgYWxyZWFkeSBiZWVuIGRvbmUgYW5kIGZpcmluZyB0aGVtIGFnYWluXG4gICAqIG1heSBjYXVzZSBhbiBldmVudCBsb29wLlxuICAgKlxuICAgKiBJZiBgc2tpcENoZWNrc0FuZEVtaXRzYCBpcyBmYWxzZSwgdGhlIHdpemFyZCB3aWxsIGV4ZWN1dGUgZGVmYXVsdCBjaGVja3NcbiAgICogYW5kIGVtaXQgZXZlbnRzIGFzIG5vcm1hbC4gVGhpcyBpcyB1c2VmdWwgZm9yIGN1c3RvbSBidXR0b25zIG9yIHByb2dyYW1tYXRpY1xuICAgKiB3b3JrZmxvd3MgdGhhdCBhcmUgbm90IGV4ZWN1dGluZyB0aGUgd2l6YXJkcyBkZWZhdWx0IGNoZWNrcyBhbmQgZW1pc3Npb25zLlxuICAgKiBJdCBpcyBhbm90aGVyIHdheSB0byBuYXZpZ2F0ZSB3aXRob3V0IGhhdmluZyB0byByZXdyaXRlIHRoZSB3aXphcmTDosKAwplzIGRlZmF1bHRcbiAgICogZnVuY3Rpb25hbGl0eSBmcm9tIHNjcmF0Y2guXG4gICAqL1xuICBwdWJsaWMgbmV4dChza2lwQ2hlY2tzQW5kRW1pdHM6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKHNraXBDaGVja3NBbmRFbWl0cykge1xuICAgICAgdGhpcy5mb3JjZU5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYXZTZXJ2aWNlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHdpemFyZCB0byB0aGUgbmV4dCBwYWdlIHdpdGhvdXQgdGhlIGNoZWNrcyBhbmQgZW1pc3Npb25zLlxuICAgKiBHb29kIGZvciBhIGxhc3Qgc3RlcCBpbiBhbiBhbHRlcm5hdGUgd29ya2Zsb3cuXG4gICAqIEFsaWFzIGZvciBgQ2xyV2l6YXJkLm5leHQodHJ1ZSlgIG9yIGBDbHJXaXphcmQubmV4dCgpYFxuICAgKi9cbiAgcHVibGljIGZvcmNlTmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLm5hdlNlcnZpY2UuZm9yY2VOZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbmQgY2xvc2VzIHRoZSB3aXphcmQuIERvIG5vdCB1c2UgdGhpcyBmb3IgYW4gb3ZlcnJpZGUgb2YgdGhlIGNhbmNlbFxuICAgKiB0aGUgZnVuY3Rpb25hbGl0eSB3aXRoIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWxdYCwgYFtjbHJXaXphcmRQcmV2ZW50UGFnZURlZmF1bHRDYW5jZWxdYCxcbiAgICogb3IgYFtjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHRdYCBiZWNhdXNlIGl0IHdpbGwgaW5pdGlhdGUgdGhlIHNhbWUgY2hlY2tzXG4gICAqIGFuZCBldmVudCBlbWlzc2lvbnMgdGhhdCBpbnZva2VkIHlvdXIgZXZlbnQgaGFuZGxlci4gVXNlIGBDbHJXaXphcmQuY2xvc2UoKWAgaW5zdGVhZC5cbiAgICovXG4gIHB1YmxpYyBjYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLmNhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBiZWhhdmlvciBvZiB0aGUgdW5kZXJseWluZyBtb2RhbCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGhcbiAgICogYWx0ZXJuYXRpdmUgY2FuY2VsIGZ1bmN0aW9uYWxpdHkuIEluIG1vc3QgY2FzZXMsIHVzZSBgQ2xyV2l6YXJkLmNhbmNlbCgpYCBpbnN0ZWFkLlxuICAgKi9cbiAgcHVibGljIG1vZGFsQ2FuY2VsKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsb3NhYmxlKSB7XG4gICAgICB0aGlzLmNoZWNrQW5kQ2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgYWx0ZXJuYXRpdmUgY2FuY2VsIGZsb3dzIGRlZmluZWQgYXQgdGhlIGN1cnJlbnQgcGFnZSBvclxuICAgKiB3aXphcmQgbGV2ZWwuIFBlcmZvcm1zIGEgY2FuY2VsZWQgaWYgbm90LiBFbWl0cyBldmVudHMgdGhhdCBpbml0aWF0ZVxuICAgKiB0aGUgYWx0ZXJuYXRpdmUgY2FuY2VsIG91dHB1dHMgYChjbHJXaXphcmRQYWdlT25DYW5jZWwpYCBhbmQgYChjbHJXaXphcmRPbkNhbmNlbClgLlxuICAgKi9cbiAgcHVibGljIGNoZWNrQW5kQ2FuY2VsKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICBjb25zdCBjdXJyZW50UGFnZUhhc092ZXJyaWRlcyA9IGN1cnJlbnRQYWdlLnN0b3BDYW5jZWwgfHwgY3VycmVudFBhZ2UucHJldmVudERlZmF1bHQ7XG5cbiAgICBpZiAodGhpcy5zdG9wTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRQYWdlLnBhZ2VPbkNhbmNlbC5lbWl0KCk7XG4gICAgaWYgKCFjdXJyZW50UGFnZUhhc092ZXJyaWRlcykge1xuICAgICAgdGhpcy5vbkNhbmNlbC5lbWl0KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0b3BDYW5jZWwgJiYgIWN1cnJlbnRQYWdlSGFzT3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlcyB0byBhIGdpdmVuIHBhZ2UgaW4gdGhlIFdpemFyZC4gTmF2aWdhdGlvbiB3aWxsIGludm9rZSB0aGUgd2l6YXJkw6LCgMKZcyBkZWZhdWx0XG4gICAqIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zLlxuICAgKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBleHBlY3RlZCBJRCBwYXJhbWV0ZXIgY2FuIGJlIGZvdW5kIGluIHRoZSByZXR1cm4gb2YgdGhlXG4gICAqIENscldpemFyZFBhZ2UuaWQgZ2V0dGVyLCB1c3VhbGx5IHByZWZpeGVkIHdpdGggYGNsci13aXphcmQtcGFnZS1gIGFuZCB0aGVuIGVpdGhlciBhXG4gICAqIG51bWVyaWMgSUQgb3IgdGhlIElEIHNwZWNpZmllZCBmb3IgdGhlIGBDbHJXaXphcmRQYWdlYCBjb21wb25lbnTDosKAwplzIGBpZGAgaW5wdXQuXG4gICAqL1xuICBwdWJsaWMgZ29UbyhwYWdlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghcGFnZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5uYXZTZXJ2aWNlLmdvVG8ocGFnZUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBzZXRzIGFsbCBXaXphcmRQYWdlcyB0byBpbmNvbXBsZXRlIGFuZCBzZXRzIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBgQ2xyV2l6YXJkYCB0b1xuICAgKiBiZSB0aGUgY3VycmVudCBwYWdlLCByZXNldHRpbmcgdGhlIHdpemFyZCBuYXZpZ2F0aW9uLlxuICAgKiBVc2UgYChjbHJXaXphcmRPblJlc2V0KWAgZXZlbnQgdG8gcmVzZXQgdGhlIGRhdGEgb3IgbW9kZWwgb2YgeW91ciB3aXphcmQuXG4gICAqL1xuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5yZXNldCgpO1xuICAgIHRoaXMub25SZXNldC5uZXh0KCk7XG4gIH1cblxuICBwcml2YXRlIGxpc3RlbkZvck5leHRQYWdlQ2hhbmdlcygpOiBTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2UubW92ZWRUb05leHRQYWdlLnBpcGUoZmlsdGVyKCgpID0+IGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5vbk1vdmVOZXh0LmVtaXQoKTtcbiAgICAgIHRoaXMud2l6YXJkVGl0bGUubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBsaXN0ZW5Gb3JQcmV2aW91c1BhZ2VDaGFuZ2VzKCk6IFN1YnNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5tb3ZlZFRvUHJldmlvdXNQYWdlLnBpcGUoZmlsdGVyKCgpID0+IGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5vbk1vdmVQcmV2aW91cy5lbWl0KCk7XG4gICAgICB0aGlzLndpemFyZFRpdGxlLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbGlzdGVuRm9yQ2FuY2VsQ2hhbmdlcygpOiBTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2Uubm90aWZ5V2l6YXJkQ2FuY2VsLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNoZWNrQW5kQ2FuY2VsKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBsaXN0ZW5Gb3JGaW5pc2hlZENoYW5nZXMoKTogU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLndpemFyZEZpbmlzaGVkLnN1YnNjcmliZSgoKSA9PiB0aGlzLmVtaXRXaXphcmRGaW5pc2hlZCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgbGlzdGVuRm9yUGFnZUNoYW5nZXMoKTogU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlQ2hhbmdlZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jdXJyZW50UGFnZUNoYW5nZWQuZW1pdCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTmF2T25QYWdlQ2hhbmdlcygpOiB2b2lkIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kaWZmZXIuZGlmZih0aGlzLnBhZ2VzKTtcbiAgICBpZiAoY2hhbmdlcykge1xuICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKCgpID0+IHRoaXMubmF2U2VydmljZS51cGRhdGVOYXZpZ2F0aW9uKCkpO1xuICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKCkgPT4gdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZU5hdmlnYXRpb24oKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplQnV0dG9ucygpOiB2b2lkIHtcbiAgICAvLyBPbmx5IHRyaWdnZXIgYnV0dG9ucyByZWFkeSBpZiBkZWZhdWx0IGlzIG9wZW4gKGlubGluZWQpXG4gICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgIHRoaXMuYnV0dG9uU2VydmljZS5idXR0b25zUmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdFdpemFyZEZpbmlzaGVkKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5zdG9wTmV4dCkge1xuICAgICAgdGhpcy5mb3JjZUZpbmlzaCgpO1xuICAgIH1cbiAgICB0aGlzLndpemFyZEZpbmlzaGVkLmVtaXQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYnV0dG9uLWh1Yi5zZXJ2aWNlJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0JVVFRPTl9UWVBFUzogYW55ID0ge1xuICBjYW5jZWw6ICdjYW5jZWwnLFxuICBwcmV2aW91czogJ3ByZXZpb3VzJyxcbiAgbmV4dDogJ25leHQnLFxuICBmaW5pc2g6ICdmaW5pc2gnLFxuICBkYW5nZXI6ICdkYW5nZXInLFxufTtcblxuZXhwb3J0IGNvbnN0IENVU1RPTV9CVVRUT05fVFlQRVM6IGFueSA9IHtcbiAgY2FuY2VsOiAnY3VzdG9tLWNhbmNlbCcsXG4gIHByZXZpb3VzOiAnY3VzdG9tLXByZXZpb3VzJyxcbiAgbmV4dDogJ2N1c3RvbS1uZXh0JyxcbiAgZmluaXNoOiAnY3VzdG9tLWZpbmlzaCcsXG4gIGRhbmdlcjogJ2N1c3RvbS1kYW5nZXInLFxufTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXdpemFyZC1idXR0b24nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiYnRuIGNsci13aXphcmQtYnRuXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tbGlua109XCJpc0NhbmNlbFwiXG4gICAgICAgICAgICBbY2xhc3MuY2xyLXdpemFyZC1idG4tLXRlcnRpYXJ5XT1cImlzQ2FuY2VsXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tb3V0bGluZV09XCJpc1ByZXZpb3VzXCJcbiAgICAgICAgICAgIFtjbGFzcy5jbHItd2l6YXJkLWJ0bi0tc2Vjb25kYXJ5XT1cImlzUHJldmlvdXNcIlxuICAgICAgICAgICAgW2NsYXNzLmJ0bi1wcmltYXJ5XT1cImlzUHJpbWFyeUFjdGlvblwiXG4gICAgICAgICAgICBbY2xhc3MuY2xyLXdpemFyZC1idG4tLXByaW1hcnldPVwiaXNQcmltYXJ5QWN0aW9uXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tc3VjY2Vzc109XCJpc0ZpbmlzaFwiXG4gICAgICAgICAgICBbY2xhc3MuYnRuLWRhbmdlcl09XCJpc0RhbmdlclwiXG4gICAgICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwiaXNEaXNhYmxlZFwiXG4gICAgICAgICAgICBbYXR0ci5kaXNhYmxlZF09XCJfZGlzYWJsZWRBdHRyaWJ1dGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImNsaWNrKClcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgaG9zdDogeyBjbGFzczogJ2Nsci13aXphcmQtYnRuLXdyYXBwZXInLCAnW2F0dHIuYXJpYS1oaWRkZW5dJzogJ2lzSGlkZGVuJyB9LFxuICBzdHlsZXM6IFsnW2FyaWEtaGlkZGVuPVwidHJ1ZVwiXSB7IGRpc3BsYXk6IG5vbmU7IH0nXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkQnV0dG9uIHtcbiAgQElucHV0KCd0eXBlJykgcHVibGljIHR5cGU6IHN0cmluZyA9ICcnO1xuXG4gIEBJbnB1dCgnY2xyV2l6YXJkQnV0dG9uRGlzYWJsZWQnKSBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASW5wdXQoJ2NscldpemFyZEJ1dHRvbkhpZGRlbicpIHB1YmxpYyBoaWRkZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBFdmVudEVtaXR0ZXIgd2hpY2ggaXMgZW1pdHRlZCB3aGVuIGEgYnV0dG9uIGlzIGNsaWNrZWQuXG4gIEBPdXRwdXQoJ2NscldpemFyZEJ1dHRvbkNsaWNrZWQnKSB3YXNDbGlja2VkOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLCBwdWJsaWMgYnV0dG9uU2VydmljZTogQnV0dG9uSHViU2VydmljZSkge31cblxuICBwcml2YXRlIGNoZWNrRGVmYXVsdEFuZEN1c3RvbVR5cGUodmFsdWVUb0NoZWNrOiBzdHJpbmcgPSAnJywgdHlwZVRvTG9va1VwOiBzdHJpbmcpIHtcbiAgICBpZiAoREVGQVVMVF9CVVRUT05fVFlQRVNbdHlwZVRvTG9va1VwXSA9PT0gdmFsdWVUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENVU1RPTV9CVVRUT05fVFlQRVNbdHlwZVRvTG9va1VwXSA9PT0gdmFsdWVUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0NhbmNlbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ2NhbmNlbCcpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc05leHQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh0aGlzLnR5cGUsICduZXh0Jyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzUHJldmlvdXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh0aGlzLnR5cGUsICdwcmV2aW91cycpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0ZpbmlzaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ2ZpbmlzaCcpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0RhbmdlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ2RhbmdlcicpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc1ByaW1hcnlBY3Rpb24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNOZXh0IHx8IHRoaXMuaXNEYW5nZXIgfHwgdGhpcy5pc0ZpbmlzaDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgX2Rpc2FibGVkQXR0cmlidXRlKCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgLy8gZGVhbGluZyB3aXRoIG5lZ2F0aXZlcyBoZXJlLiBjb2duaXRpdmVseSBlYXNpZXIgdG8gdGhpbmsgb2YgaXQgbGlrZSB0aGlzLi4uXG4gICAgY29uc3QgZGlzYWJsZWQgPSB0cnVlO1xuICAgIGNvbnN0IG5hdiA9IHRoaXMubmF2U2VydmljZTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlO1xuXG4gICAgLy8gRW5zdXJlIHdlIGRvbid0IGNoYW5nZSB0aGUgcmVzcG9uc2UgdW50aWwgYnV0dG9ucyBhcmUgcmVhZHkgdG8gYXZvaWQgY2hvY29sYXRlXG4gICAgaWYgKCF0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5KSB7XG4gICAgICByZXR1cm4gIWRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IG5hdi53aXphcmRTdG9wTmF2aWdhdGlvbiB8fCAhcGFnZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDYW5jZWwpIHtcbiAgICAgIHJldHVybiAhZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQcmV2aW91cyAmJiAobmF2LmN1cnJlbnRQYWdlSXNGaXJzdCB8fCBwYWdlLnByZXZpb3VzU3RlcERpc2FibGVkKSkge1xuICAgICAgcmV0dXJuIGRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGFuZ2VyICYmICFwYWdlLnJlYWR5VG9Db21wbGV0ZSkge1xuICAgICAgcmV0dXJuIGRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTmV4dCAmJiAobmF2LmN1cnJlbnRQYWdlSXNMYXN0IHx8ICFwYWdlLnJlYWR5VG9Db21wbGV0ZSkpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0ZpbmlzaCAmJiAoIW5hdi5jdXJyZW50UGFnZUlzTGFzdCB8fCAhcGFnZS5yZWFkeVRvQ29tcGxldGUpKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICFkaXNhYmxlZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNIaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgLy8gZGVhbGluZyB3aXRoIG5lZ2F0aXZlcyBoZXJlLiBjb2duaXRpdmVseSBlYXNpZXIgdG8gdGhpbmsgb2YgaXQgbGlrZSB0aGlzLi4uXG4gICAgY29uc3QgaGlkZGVuID0gdHJ1ZTtcbiAgICBjb25zdCBuYXYgPSB0aGlzLm5hdlNlcnZpY2U7XG5cbiAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgY2hhbmdlIHRoZSByZXNwb25zZSB1bnRpbCBidXR0b25zIGFyZSByZWFkeSB0byBhdm9pZCBjaG9jb2xhdGVcbiAgICBpZiAoIXRoaXMuYnV0dG9uU2VydmljZS5idXR0b25zUmVhZHkpIHtcbiAgICAgIHJldHVybiAhaGlkZGVuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhpZGRlbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDYW5jZWwpIHtcbiAgICAgIHJldHVybiAhaGlkZGVuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUHJldmlvdXMgJiYgbmF2LmN1cnJlbnRQYWdlSXNGaXJzdCkge1xuICAgICAgcmV0dXJuIGhpZGRlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc05leHQgJiYgbmF2LmN1cnJlbnRQYWdlSXNMYXN0KSB7XG4gICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRmluaXNoICYmICFuYXYuY3VycmVudFBhZ2VJc0xhc3QpIHtcbiAgICAgIHJldHVybiBoaWRkZW47XG4gICAgfVxuXG4gICAgcmV0dXJuICFoaWRkZW47XG4gIH1cblxuICBjbGljaygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53YXNDbGlja2VkLmVtaXQodGhpcy50eXBlKTtcbiAgICB0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uQ2xpY2tlZCh0aGlzLnR5cGUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItd2l6YXJkLXRpdGxlLCBjbHItd2l6YXJkLXBhZ2V0aXRsZScgfSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRDdXN0b21UYWdzIHtcbiAgLy8gTm8gYmVoYXZpb3JcbiAgLy8gVGhlIG9ubHkgcHVycG9zZSBpcyB0byBcImRlY2xhcmVcIiB0aGUgdGFnIGluIEFuZ3VsYXJcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQtc3RlcG5hdicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNsci13aXphcmQtc3RlcG5hdi1saXN0XCI+XG4gICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBwYWdlIG9mIHBhZ2VTZXJ2aWNlLnBhZ2VzXCIgY2xyLXdpemFyZC1zdGVwbmF2LWl0ZW0gW3BhZ2VdPVwicGFnZVwiIGNsYXNzPVwiY2xyLXdpemFyZC1zdGVwbmF2LWl0ZW1cIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgaG9zdDogeyBjbGFzczogJ2Nsci13aXphcmQtc3RlcG5hdicgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkU3RlcG5hdiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlU2VydmljZTogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBhZ2VDb2xsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UtY29sbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi93aXphcmQtcGFnZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1tjbHItd2l6YXJkLXN0ZXBuYXYtaXRlbV0nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGluayBjbHItd2l6YXJkLXN0ZXBuYXYtbGlua1wiIChjbGljayk9XCJjbGljaygpXCIgW2F0dHIuZGlzYWJsZWRdPVwiaXNEaXNhYmxlZCA/ICcnIDogbnVsbFwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInBhZ2UubmF2VGl0bGVcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAnaWQnLFxuICAgICdbYXR0ci5hcmlhLXNlbGVjdGVkXSc6ICdpc0N1cnJlbnQnLFxuICAgICdbYXR0ci5hcmlhLWNvbnRyb2xzXSc6ICdpZCcsXG4gICAgJ1tjbGFzcy5jbHItbmF2LWxpbmtdJzogJ3RydWUnLFxuICAgICdbY2xhc3MubmF2LWl0ZW1dJzogJ3RydWUnLFxuICAgICdbY2xhc3MuYWN0aXZlXSc6ICdpc0N1cnJlbnQnLFxuICAgICdbY2xhc3MuZGlzYWJsZWRdJzogJ2lzRGlzYWJsZWQnLFxuICAgICdbY2xhc3Mubm8tY2xpY2tdJzogJyFjYW5OYXZpZ2F0ZScsXG4gICAgJ1tjbGFzcy5jb21wbGV0ZV0nOiAnaXNDb21wbGV0ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFN0ZXBuYXZJdGVtIHtcbiAgQElucHV0KCdwYWdlJykgcHVibGljIHBhZ2U6IENscldpemFyZFBhZ2U7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLCBwdWJsaWMgcGFnZUNvbGxlY3Rpb246IFBhZ2VDb2xsZWN0aW9uU2VydmljZSkge31cblxuICBwcml2YXRlIHBhZ2VHdWFyZCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXphcmQgc3RlcG5hdiBpdGVtIGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYSB3aXphcmQgcGFnZS4nKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5nZXRTdGVwSXRlbUlkRm9yUGFnZSh0aGlzLnBhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0Rpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHRoaXMucGFnZUd1YXJkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5kaXNhYmxlZCB8fCB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkU3RvcE5hdmlnYXRpb24gfHwgdGhpcy5uYXZTZXJ2aWNlLndpemFyZERpc2FibGVTdGVwbmF2O1xuICB9XG5cbiAgcHVibGljIGdldCBpc0N1cnJlbnQoKTogYm9vbGVhbiB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmN1cnJlbnQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmNvbXBsZXRlZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY2FuTmF2aWdhdGUoKTogYm9vbGVhbiB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5wcmV2aW91c1BhZ2VJc0NvbXBsZXRlZCh0aGlzLnBhZ2UpO1xuICB9XG5cbiAgY2xpY2soKTogdm9pZCB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcblxuICAgIC8vIGlmIHdlIGNsaWNrIG9uIG91ciBvd24gc3RlcG5hdiBvciBhIGRpc2FibGVkIHN0ZXBuYXYsIHdlIGRvbid0IHdhbnQgdG8gZG8gYW55dGhpbmdcbiAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8IHRoaXMuaXNDdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5uYXZTZXJ2aWNlLmdvVG8odGhpcy5wYWdlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQWxlcnRNb2R1bGUgfSBmcm9tICcuLi9lbXBoYXNpcy9hbGVydC9hbGVydC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTW9kYWxNb2R1bGUgfSBmcm9tICcuLi9tb2RhbC9tb2RhbC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJXaXphcmQgfSBmcm9tICcuL3dpemFyZCc7XG5pbXBvcnQgeyBDbHJXaXphcmRCdXR0b24gfSBmcm9tICcuL3dpemFyZC1idXR0b24nO1xuaW1wb3J0IHsgQ2xyV2l6YXJkQ3VzdG9tVGFncyB9IGZyb20gJy4vd2l6YXJkLWN1c3RvbS10YWdzJztcbmltcG9ydCB7IENscldpemFyZEhlYWRlckFjdGlvbiB9IGZyb20gJy4vd2l6YXJkLWhlYWRlci1hY3Rpb24nO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZUJ1dHRvbnMgfSBmcm9tICcuL3dpemFyZC1wYWdlLWJ1dHRvbnMnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZUhlYWRlckFjdGlvbnMgfSBmcm9tICcuL3dpemFyZC1wYWdlLWhlYWRlci1hY3Rpb25zJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VOYXZUaXRsZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtbmF2dGl0bGUnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZVRpdGxlIH0gZnJvbSAnLi93aXphcmQtcGFnZS10aXRsZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRTdGVwbmF2IH0gZnJvbSAnLi93aXphcmQtc3RlcG5hdic7XG5pbXBvcnQgeyBDbHJXaXphcmRTdGVwbmF2SXRlbSB9IGZyb20gJy4vd2l6YXJkLXN0ZXBuYXYtaXRlbSc7XG5cbmV4cG9ydCBjb25zdCBDTFJfV0laQVJEX0RJUkVDVElWRVM6IGFueVtdID0gW1xuICBDbHJXaXphcmQsXG4gIENscldpemFyZFBhZ2UsXG4gIENscldpemFyZFN0ZXBuYXYsXG4gIENscldpemFyZFN0ZXBuYXZJdGVtLFxuICBDbHJXaXphcmRCdXR0b24sXG4gIENscldpemFyZEhlYWRlckFjdGlvbixcbiAgQ2xyV2l6YXJkQ3VzdG9tVGFncyxcbiAgQ2xyV2l6YXJkUGFnZVRpdGxlLFxuICBDbHJXaXphcmRQYWdlTmF2VGl0bGUsXG4gIENscldpemFyZFBhZ2VCdXR0b25zLFxuICBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucyxcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsck1vZGFsTW9kdWxlLCBDbHJBbGVydE1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9XSVpBUkRfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfV0laQVJEX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEhvc3RCaW5kaW5nIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc0Jvb2xlYW5BdHRyaWJ1dGVTZXQgfSBmcm9tICcuLi8uLi91dGlscy9jb21wb25lbnQvaXMtYm9vbGVhbi1hdHRyaWJ1dGUtc2V0JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXByb2dyZXNzLWJhcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHByb2dyZXNzIFtpZF09XCJpZFwiIFthdHRyLm1heF09XCJtYXhcIiBbYXR0ci52YWx1ZV09XCJ2YWx1ZVwiIFthdHRyLmRhdGEtZGlzcGxheXZhbF09XCJkaXNwbGF5VmFsdWVcIj48L3Byb2dyZXNzPlxuICAgIDxzcGFuICpuZ0lmPVwiZGlzcGxheUFyaWFMaXZlKClcIiBbYXR0ci5hcmlhLWxpdmVdPVwiYXJpYUxpdmVcIj57eyBkaXNwbGF5VmFsdWUgfX08L3NwYW4+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsclByb2dyZXNzQmFyIHtcbiAgLyoqXG4gICAqIEhhbmRsZSBjb21wb25lbnQgSURcbiAgICovXG4gIHByaXZhdGUgX0lEOiBzdHJpbmc7XG4gIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGV4dGVybmFsSWQ6IHN0cmluZyA9ICcnO1xuICBASW5wdXQoKVxuICBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX0lEID0gdmFsdWU7XG4gICAgdGhpcy5leHRlcm5hbElkID0gbnVsbDtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX0lEO1xuICB9XG5cbiAgLy8gUHJvZ3Jlc3NcbiAgQElucHV0KCdjbHJNYXgnKSBtYXg6IG51bWJlciA9IDEwMDtcbiAgQElucHV0KCdjbHJWYWx1ZScpIHZhbHVlOiBudW1iZXIgPSAwO1xuICBASW5wdXQoJ2NsckRpc3BsYXl2YWwnKSBkaXNwbGF5dmFsOiBzdHJpbmc7XG5cbiAgLy8gU3R5bGVzXG4gIEBIb3N0QmluZGluZygnY2xhc3MucHJvZ3Jlc3MnKVxuICBnZXQgcHJvZ3Jlc3NDbGFzcygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX2xhYmVsZWQ6IGJvb2xlYW47XG4gIEBIb3N0QmluZGluZygnY2xhc3MubGFiZWxlZCcpXG4gIGdldCBsYWJlbGVkQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhYmVsZWQ7XG4gIH1cblxuICBASW5wdXQoJ2NsckxhYmVsZWQnKVxuICBzZXQgY2xyTGFiZWxlZCh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIHRoaXMuX2xhYmVsZWQgPSBpc0Jvb2xlYW5BdHRyaWJ1dGVTZXQodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZmFkZTogYm9vbGVhbjtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5wcm9ncmVzcy1mYWRlJylcbiAgZ2V0IGZhZGVDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFkZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRmFkZScpXG4gIHNldCBjbHJGYWRlKHZhbHVlOiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgdGhpcy5fZmFkZSA9IGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9sb29wOiBib29sZWFuO1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmxvb3AnKVxuICBnZXQgbG9vcENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9sb29wO1xuICB9XG5cbiAgQElucHV0KCdjbHJMb29wJylcbiAgc2V0IGNsckxvb3AodmFsdWU6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgICB0aGlzLl9sb29wID0gaXNCb29sZWFuQXR0cmlidXRlU2V0KHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgX3N1Y2Nlc3M6IGJvb2xlYW47XG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3VjY2VzcycpXG4gIGdldCBzdWNjZXNzQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1Y2Nlc3M7XG4gIH1cblxuICBASW5wdXQoJ2NsclN1Y2Nlc3MnKVxuICBzZXQgY2xyU3VjY2Vzcyh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIHRoaXMuX3N1Y2Nlc3MgPSBpc0Jvb2xlYW5BdHRyaWJ1dGVTZXQodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGFuZ2VyOiBib29sZWFuO1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmRhbmdlcicpXG4gIGdldCBkYW5nZXJDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGFuZ2VyO1xuICB9XG5cbiAgQElucHV0KCdjbHJEYW5nZXInKVxuICBzZXQgY2xyRGFuZ2VyKHZhbHVlOiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgdGhpcy5fZGFuZ2VyID0gaXNCb29sZWFuQXR0cmlidXRlU2V0KHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZsYXNoOiBib29sZWFuO1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmZsYXNoJylcbiAgZ2V0IGZsYXNoQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZsYXNoO1xuICB9XG5cbiAgQElucHV0KCdjbHJGbGFzaCcpXG4gIHNldCBjbHJGbGFzaCh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIHRoaXMuX2ZsYXNoID0gaXNCb29sZWFuQXR0cmlidXRlU2V0KHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZsYXNoRGFuZ2VyOiBib29sZWFuO1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmZsYXNoLWRhbmdlcicpXG4gIGdldCBmbGFzaERhbmdlckNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9mbGFzaERhbmdlcjtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRmxhc2hEYW5nZXInKVxuICBzZXQgY2xyRmxhc2hEYW5nZXIodmFsdWU6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgICB0aGlzLl9mbGFzaERhbmdlciA9IGlzQm9vbGVhbkF0dHJpYnV0ZVNldCh2YWx1ZSk7XG4gIH1cblxuICAvLyBBcmlhIExpdmVcbiAgQElucHV0KCdjbHJBc3NlcnRpdmUnKSBhc3NlcnRpdmU6IGJvb2xlYW47XG4gIEBJbnB1dCgnY2xyT2ZmJykgb2ZmOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgd2lsbCBoYXZlIHNvbWV0aGluZyB0aGF0IGlzIHJlYWRhYmxlXG4gICAqIGZvciB0aGUgc2NyZWVuIHJlYWRlclxuICAgKi9cbiAgZ2V0IGRpc3BsYXlWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5dmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwbGF5dmFsO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy52YWx1ZX0lYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IGFyaWEtbGl2ZSBvbmx5IHdoZW4gdGhlcmUgaXMgdmFsdWUgYW5kIGl0J3Mgbm90IDAgb3IgZXF1YWwgdG8gdGhlIG1heCB2YWx1ZVxuICAgKi9cbiAgZGlzcGxheUFyaWFMaXZlKCkge1xuICAgIHJldHVybiAodGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMudmFsdWUgIT09IDApICYmIHRoaXMudmFsdWUgIT09IHRoaXMubWF4O1xuICB9XG5cbiAgZ2V0IGFyaWFMaXZlKCkge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyaWJ1dGVTZXQodGhpcy5hc3NlcnRpdmUpKSB7XG4gICAgICByZXR1cm4gJ2Fzc2VydGl2ZSc7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW5BdHRyaWJ1dGVTZXQodGhpcy5vZmYpKSB7XG4gICAgICByZXR1cm4gJ29mZic7XG4gICAgfVxuICAgIHJldHVybiAncG9saXRlJztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJQcm9ncmVzc0JhciB9IGZyb20gJy4vcHJvZ3Jlc3MtYmFyJztcblxuZXhwb3J0IGNvbnN0IENMUl9QUk9HUkVTU19CQVJfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyUHJvZ3Jlc3NCYXJdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX1BST0dSRVNTX0JBUl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9QUk9HUkVTU19CQVJfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsclByb2dyZXNzQmFyTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJCdXR0b25Nb2R1bGUgfSBmcm9tICcuL2J1dHRvbi9idXR0b24ubW9kdWxlJztcbmltcG9ydCB7IENsckRhdGFNb2R1bGUgfSBmcm9tICcuL2RhdGEvZGF0YS5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRHJhZ0FuZERyb3BNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1hbmQtZHJvcC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRW1waGFzaXNNb2R1bGUgfSBmcm9tICcuL2VtcGhhc2lzL2VtcGhhc2lzLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJGb3Jtc01vZHVsZSB9IGZyb20gJy4vZm9ybXMvZm9ybXMubW9kdWxlJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTGF5b3V0TW9kdWxlIH0gZnJvbSAnLi9sYXlvdXQvbGF5b3V0Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJNb2RhbE1vZHVsZSB9IGZyb20gJy4vbW9kYWwvbW9kYWwubW9kdWxlJztcbmltcG9ydCB7IENsclBvcG92ZXJNb2R1bGUgfSBmcm9tICcuL3BvcG92ZXIvcG9wb3Zlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJZkV4cGFuZE1vZHVsZSB9IGZyb20gJy4vdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRm9jdXNUcmFwTW9kdWxlIH0gZnJvbSAnLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAubW9kdWxlJztcbmltcG9ydCB7IENsckxvYWRpbmdNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkTW9kdWxlIH0gZnJvbSAnLi93aXphcmQvd2l6YXJkLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTcGlubmVyTW9kdWxlIH0gZnJvbSAnLi9wcm9ncmVzcy9zcGlubmVyL3NwaW5uZXIubW9kdWxlJztcbmltcG9ydCB7IENsclByb2dyZXNzQmFyTW9kdWxlIH0gZnJvbSAnLi9wcm9ncmVzcy9wcm9ncmVzcy1iYXJzL3Byb2dyZXNzLWJhci5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBleHBvcnRzOiBbXG4gICAgQ2xyRW1waGFzaXNNb2R1bGUsXG4gICAgQ2xyRGF0YU1vZHVsZSxcbiAgICBDbHJJY29uTW9kdWxlLFxuICAgIENsck1vZGFsTW9kdWxlLFxuICAgIENsckxvYWRpbmdNb2R1bGUsXG4gICAgQ2xySWZFeHBhbmRNb2R1bGUsXG4gICAgQ2xyQ29uZGl0aW9uYWxNb2R1bGUsXG4gICAgQ2xyRm9jdXNUcmFwTW9kdWxlLFxuICAgIENsckJ1dHRvbk1vZHVsZSxcbiAgICBDbHJGb3Jtc01vZHVsZSxcbiAgICBDbHJMYXlvdXRNb2R1bGUsXG4gICAgQ2xyUG9wb3Zlck1vZHVsZSxcbiAgICBDbHJXaXphcmRNb2R1bGUsXG4gICAgQ2xyRHJhZ0FuZERyb3BNb2R1bGUsXG4gICAgQ2xyU3Bpbm5lck1vZHVsZSxcbiAgICBDbHJQcm9ncmVzc0Jhck1vZHVsZSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xhcml0eU1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuLyoqXG4gKiBQcml2YXRlIGNvdW50ZXIgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyBmb3IgdGhlIGNoZWNrYm94ZXMsIHRvIGJpbmQgdGhlIGxhYmVscyB0byB0aGVtLlxuICovXG5sZXQgbGF0ZXN0SWQgPSAwO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIENsckNoZWNrYm94IHdpbGwgYmUgcmVuYW1lZCB0byBDbHJDaGVja2JveERlcHJlY2F0ZWQgaW4gMC4xMiwgYW5kIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIG5ld1xuICogaW1wbGVtZW50YXRpb24gaW4gMC4xMywgc28gaWYgeW91IGltcG9ydCBpdCB5b3Ugd2lsbCBuZWVkIHRvIHVwZGF0ZSB5b3VyIHJlZmVyZW5jZXMuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jaGVja2JveCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDwhLS1cbiAgICAgICAgICAgIEZJWE1FOiBXZSBhcmUgbm90IHN1YnNjcmliZWQgdG8gdGhlIGNoYW5nZSBldmVudCBidXQgdGhlIGNsaWNrIGV2ZW50IGhlcmUuXG4gICAgICAgICAgICBUaGUgcmVhc29uIGZvciB0aGF0IGlzIGJlY2F1c2UgY2hlY2tib3hlcyBiZWhhdmUgZGlmZmVyZW50bHkgb24gSUUgJiBFZGdlLlxuICAgICAgICAgICAgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NDQ3OTM5XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFRvIGZpeCB0aGF0LCB3ZSBsaXN0ZW4gdG8gZXZlcnkgY2xpY2sgZXZlbnQgYW5kIHRoZW4gdG9nZ2xlIHRoZSBjaGVja2JveCBtYW51YWxseVxuICAgICAgICAgICAgdG8gbWFrZSBpdCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFjcm9zcyB0aGUgYnJvd3NlcnMgd2Ugc3VwcG9ydC5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgVGhpcyB3b3JrcyBmb3IgY2FzZXMgd2hlbiB1c2VycyB0b2dnbGUgdGhlIGNoZWNrYm94IHVzaW5nIHRoZSBrZXlib2FyZCB0b286XG4gICAgICAgICAgICBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzg3ODk0MC9zcGFjZWJhci10cmlnZ2VyaW5nLWNsaWNrLWV2ZW50LW9uLWNoZWNrYm94XG4gICAgICAgIC0tPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImNsckFyaWFMYWJlbGVkQnlcIlxuICAgICAgICAgICAgICAgW2lkXT1cImlkXCIgW25hbWVdPVwibmFtZVwiIFtjaGVja2VkXT1cImNoZWNrZWRcIlxuICAgICAgICAgICAgICAgW2luZGV0ZXJtaW5hdGVdPVwiaW5kZXRlcm1pbmF0ZVwiIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAoYmx1cik9XCJ0b3VjaCgpXCIgKGNsaWNrKT1cImNoZWNrSW5kZXRlcm1pbmF0ZVN0YXRlKClcIj5cbiAgICAgICAgPGxhYmVsIFthdHRyLmZvcl09XCJpZFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2xhYmVsPlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5jaGVja2JveF0nOiAnIWlubGluZScsICdbY2xhc3MuY2hlY2tib3gtaW5saW5lXSc6ICdpbmxpbmUnLCAnW2NsYXNzLmRpc2FibGVkXSc6ICdkaXNhYmxlZCcgfSxcbiAgLypcbiAgICAgKiBUaGlzIHByb3ZpZGVyIGxldHMgdXMgZGVjbGFyZSBvdXIgY2hlY2tib3ggYXMgYSBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgKiB3aGljaCBhbGxvd3MgdXMgdG8gdXNlIFsobmdNb2RlbCldIGRpcmVjdGx5IG9uIG91ciBjb21wb25lbnQsXG4gICAgICogd2l0aCBhbGwgdGhlIGF1dG9tYXRpYyBmZWF0dXJlcyB3aXJpbmcgdGhhdCBjb21lIHdpdGggaXQuXG4gICAgICovXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENsckNoZWNrYm94RGVwcmVjYXRlZCksIG11bHRpOiB0cnVlIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDaGVja2JveERlcHJlY2F0ZWQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gIC8vIElmIG91ciBob3N0IGhhcyBhbiBJRCBhdHRyaWJ1dGUsIHdlIHVzZSB0aGlzIGluc3RlYWQgb2Ygb3VyIGluZGV4LlxuICBASW5wdXQoJ2lkJykgX2lkOiBzdHJpbmcgPSAobGF0ZXN0SWQrKykudG9TdHJpbmcoKTtcblxuICBwdWJsaWMgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgY2xyLWNoZWNrYm94LSR7dGhpcy5faWR9YDtcbiAgfVxuXG4gIC8vIElmIGhvc3QgcHJvdmlkZXMgYW4gY2xyQXJpYUxhYmVsZWRCeSBpbnB1dCwgd2UgYXBwbHkgaXQgdG8gdGhlIGNoZWNrYm94XG4gIEBJbnB1dCgnY2xyQXJpYUxhYmVsZWRCeScpIHB1YmxpYyBjbHJBcmlhTGFiZWxlZEJ5OiBzdHJpbmcgPSBudWxsO1xuXG4gIC8vIElmIG91ciBob3N0IGhhcyBhIG5hbWUgYXR0cmlidXRlLCB3ZSBhcHBseSBpdCB0byB0aGUgY2hlY2tib3guXG4gIEBJbnB1dCgnbmFtZScpIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBudWxsO1xuXG4gIC8vIElmIHRoZSBob3N0IGlzIGRpc2FibGVkIHdlIGFwcGx5IGl0IHRvIHRoZSBjaGVja2JveFxuICBASW5wdXQoJ2NsckRpc2FibGVkJykgcHVibGljIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gU3VwcG9ydCBmb3IgaW5saW5lIGNoZWNrYm94ZXMsIGFkZHMgdGhlIG5lY2Vzc2FyeSBjbGFzcyB0byB0aGUgaG9zdFxuICBASW5wdXQoJ2NscklubGluZScpIHB1YmxpYyBpbmxpbmUgPSBmYWxzZTtcblxuICBwcml2YXRlIF9jaGVja2VkID0gZmFsc2U7XG5cbiAgcHVibGljIGdldCBjaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICB9XG5cbiAgQElucHV0KCdjbHJDaGVja2VkJylcbiAgcHVibGljIHNldCBjaGVja2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9jaGVja2VkKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGVja2VkKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pbmRldGVybWluYXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHVibGljIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuICB9XG5cbiAgQElucHV0KCdjbHJJbmRldGVybWluYXRlJylcbiAgcHVibGljIHNldCBpbmRldGVybWluYXRlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fY2hlY2tlZCkge1xuICAgICAgICB0aGlzLnNldENoZWNrZWQoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRJbmRldGVybWluYXRlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJJbmRldGVybWluYXRlQ2hhbmdlJylcbiAgcHVibGljIGluZGV0ZXJtaW5hdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHByaXZhdGUgc2V0SW5kZXRlcm1pbmF0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSB2YWx1ZTtcbiAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UuZW1pdCh0aGlzLl9pbmRldGVybWluYXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Q2hlY2tlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2NoZWNrZWQgPSB2YWx1ZTtcbiAgICB0aGlzLmNoYW5nZS5lbWl0KHRoaXMuX2NoZWNrZWQpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyQ2hlY2tlZENoYW5nZScpIHB1YmxpYyBjaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMuY2hlY2tlZCk7XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5jaGVja2VkKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgICAqIFRoZXNlIGNhbGxiYWNrcyB3aWxsIGJlIGdpdmVuIHRvIHVzIHRocm91Z2ggdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSxcbiAgICAgKiBhbmQgd2UgbmVlZCB0byBjYWxsIHRoZW0gd2hlbiB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgY2hlY2tib3guXG4gICAgICovXG4gIHByaXZhdGUgb25DaGFuZ2VDYWxsYmFjayA9IChfOiBhbnkpID0+IHt9O1xuXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IG9uQ2hhbmdlO1xuICB9XG5cbiAgcHJpdmF0ZSBvblRvdWNoZWRDYWxsYmFjayA9ICgpID0+IHt9O1xuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IG9uVG91Y2hlZDtcbiAgfVxuXG4gIHB1YmxpYyB0b3VjaCgpIHtcbiAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gIH1cblxuICBjaGVja0luZGV0ZXJtaW5hdGVTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQ2hlY2tib3hEZXByZWNhdGVkIH0gZnJvbSAnLi9jaGVja2JveCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfQ0hFQ0tCT1hfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyQ2hlY2tib3hEZXByZWNhdGVkXTtcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0NMUl9DSEVDS0JPWF9ESVJFQ1RJVkVTXSwgZXhwb3J0czogW0NMUl9DSEVDS0JPWF9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94RGVwcmVjYXRlZE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRGF0ZXBpY2tlck1vZHVsZSB9IGZyb20gJy4uL2Zvcm1zL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ2hlY2tib3hEZXByZWNhdGVkTW9kdWxlIH0gZnJvbSAnLi9jaGVja2JveC9jaGVja2JveC5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW0NsckNoZWNrYm94RGVwcmVjYXRlZE1vZHVsZSwgQ2xyRGF0ZXBpY2tlck1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckZvcm1zRGVwcmVjYXRlZE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uTWV0YWRhdGEsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29sbGFwc2UoKTogQW5pbWF0aW9uTWV0YWRhdGFbXSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgcmV0dXJuIFtcbiAgICBzdGF0ZSgndHJ1ZScsIHN0eWxlKHsgaGVpZ2h0OiAwLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nIH0pKSxcbiAgICB0cmFuc2l0aW9uKCd0cnVlID0+IGZhbHNlJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IGhlaWdodDogJyonLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nIH0pKV0pLFxuICAgIHRyYW5zaXRpb24oJ2ZhbHNlID0+IHRydWUnLCBbc3R5bGUoeyBoZWlnaHQ6ICcqJywgJ292ZXJmbG93LXknOiAnaGlkZGVuJyB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gIF07XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25NZXRhZGF0YSwgc3R5bGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZhZGUob3BhY2l0eTogbnVtYmVyID0gMSk6IEFuaW1hdGlvbk1ldGFkYXRhW10ge1xuICByZXR1cm4gW1xuICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IG9wYWNpdHkgfSkpXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXSksXG4gIF07XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25NZXRhZGF0YSwgc3R5bGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZhZGVTbGlkZShkaXJlY3Rpb246IHN0cmluZyk6IEFuaW1hdGlvbk1ldGFkYXRhW10ge1xuICBsZXQgdHJhbnNmb3JtOiBzdHJpbmcgPSBudWxsO1xuICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCAyNSUpJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgLTI1JSknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgyNSUsIDApJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yNSUsIDApJztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGlyZWN0aW9uICcgKyBkaXJlY3Rpb24gKyAnIGZvciBzbGlkZSBhbmltYXRpb24uJyk7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogdHJhbnNmb3JtIH0pKV0pLFxuICBdO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uTWV0YWRhdGEsIHN0eWxlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzbGlkZShkaXJlY3Rpb246IHN0cmluZyk6IEFuaW1hdGlvbk1ldGFkYXRhW10ge1xuICBsZXQgdHJhbnNmb3JtOiBzdHJpbmcgPSBudWxsO1xuICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCAyNSUpJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgLTI1JSknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgyNSUsIDApJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yNSUsIDApJztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGlyZWN0aW9uICcgKyBkaXJlY3Rpb24gKyAnIGZvciBzbGlkZSBhbmltYXRpb24uJyk7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbc3R5bGUoeyB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IHRyYW5zZm9ybTogdHJhbnNmb3JtIH0pKV0pLFxuICBdO1xufVxuIl0sIm5hbWVzIjpbIkRpcmVjdGl2ZSIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIiwiU3ViamVjdCIsInRzbGliXzEuX192YWx1ZXMiLCJFdmVudEVtaXR0ZXIiLCJUZW1wbGF0ZVJlZiIsIlZpZXdDb250YWluZXJSZWYiLCJJbnB1dCIsIk91dHB1dCIsIk9wdGlvbmFsIiwiSW5qZWN0YWJsZSIsIkNvbXBvbmVudCIsIlNraXBTZWxmIiwiVmlld0NoaWxkIiwiRWxlbWVudFJlZiIsIkNvbnRlbnRDaGlsZHJlbiIsIkhvc3RMaXN0ZW5lciIsInRyaWdnZXIiLCJ0cmFuc2l0aW9uIiwic3R5bGUiLCJhbmltYXRlIiwia2V5ZnJhbWVzIiwiUmVuZGVyZXIyIiwiQmVoYXZpb3JTdWJqZWN0IiwiSG9zdEJpbmRpbmciLCJJbmplY3Rpb25Ub2tlbiIsIkluamVjdCIsIkNvbnRlbnRDaGlsZCIsIkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciIsInRzbGliXzEuX19leHRlbmRzIiwiSW5qZWN0b3IiLCJOZ0NvbnRyb2wiLCJTZWxmIiwiQXR0cmlidXRlIiwiRE9DVU1FTlQiLCJpc1BsYXRmb3JtQnJvd3NlciIsIlBMQVRGT1JNX0lEIiwiZmlyc3QiLCJmaWx0ZXIiLCJOZ1pvbmUiLCJnZXRMb2NhbGVEYXlOYW1lcyIsIkZvcm1TdHlsZSIsIlRyYW5zbGF0aW9uV2lkdGgiLCJnZXRMb2NhbGVNb250aE5hbWVzIiwiZ2V0TG9jYWxlRmlyc3REYXlPZldlZWsiLCJnZXRMb2NhbGVEYXRlRm9ybWF0IiwiRm9ybWF0V2lkdGgiLCJMT0NBTEVfSUQiLCJvZiIsInN3aXRjaE1hcCIsIkZvcm1zTW9kdWxlIiwiU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciIsIkNoYW5nZURldGVjdG9yUmVmIiwiTmdGb3JPZiIsIkl0ZXJhYmxlRGlmZmVycyIsImNvbWJpbmVMYXRlc3QiLCJtYXAiLCJzdGF0ZSIsImlzT2JzZXJ2YWJsZSIsIkZvY3VzU2VydmljZSIsIk9ic2VydmFibGUiLCJ0YWtlIiwiUmVwbGF5U3ViamVjdCIsIlF1ZXJ5TGlzdCIsInRva2VuRmFjdG9yeSIsIlBP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QUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7UUFDN0csY0FBYyxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7UUFDM0csY0FBYyxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUU7UUFDM0csZUFBZSxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFO1FBQzlHLGFBQWEsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRTtRQUMxRyxhQUFhLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMxRyxhQUFhLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUM3RyxVQUFVLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMxRyxPQUFPLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7S0FDdkc7Ozs7Ozs7O1FDWkssU0FBUyxHQUFhO1FBQzFCLFVBQVU7UUFDVixZQUFZO1FBQ1osV0FBVztRQUNYLFdBQVc7UUFDWCxjQUFjO1FBQ2QsY0FBYztRQUNkLGNBQWM7UUFDZCxlQUFlO1FBQ2YsYUFBYTtRQUNiLGFBQWE7UUFDYixhQUFhO1FBQ2IsVUFBVTtLQUNYO0FBRUQ7UUFtQndDNEIsc0NBQWU7UUFDckQsNEJBQ0UsUUFBa0IsRUFHbEIsVUFBc0IsRUFDdEIsYUFBc0MsRUFDWixpQkFBeUIsRUFDM0MsaUJBQW9DO1lBUDlDLFlBU0Usa0JBQU0sUUFBUSxFQUFFLFVBQVUsQ0FBQyxTQVM1QjtZQVoyQix1QkFBaUIsR0FBakIsaUJBQWlCLENBQVE7WUFDM0MsdUJBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtZQUc1QyxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsbUVBQW1FLENBQUMsQ0FBQzthQUN0RjtZQUNELEtBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDOztZQUVuQyxLQUFJLENBQUMsUUFBUSxHQUFHLGNBQWMsQ0FBQztZQUMvQixLQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDO1lBQ2hDLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQzs7U0FDakQ7Ozs7Ozs7Ozs7Ozs7OztRQVVELGtDQUFLOzs7Ozs7OztZQUFMO2dCQUNFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQzthQUNqQztRQUlELHNCQUFJLHdDQUFROzs7Z0JBQVo7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO2FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBK0JELFVBQ2EsUUFBZ0I7O2dCQUUzQixJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ2hFLElBQUksUUFBUSxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7b0JBQ2hELElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO2lCQUMzQjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsU0FBUyxHQUFHLGNBQWMsQ0FBQztpQkFDakM7O2dCQUVELElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7b0JBRXZELFdBQVcsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUNyRCxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUM7Z0JBQzNDLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDLFlBQVksQ0FBQztnQkFDN0MsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQztnQkFDbEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQzthQUNuRDs7O1dBaERBOztvQkF4REZsQixZQUFTLFNBQUM7d0JBQ1QsUUFBUSxFQUFFLHNCQUFzQjt3QkFDaEMsUUFBUSxFQUFFLDRtQkFhVDt3QkFDRCxJQUFJLEVBQUUsRUFBRSwwQkFBMEIsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLG1CQUFtQixFQUFFO3dCQUN6RSxTQUFTLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztxQkFDaEM7Ozs7O3dCQTVDdUNtQixXQUFRO3dCQUE1QmhCLGFBQVUsdUJBZ0R6QkwsV0FBUSxZQUNSaUIsU0FBTSxTQUFDLG1CQUFtQjt3QkEzQ3RCLHVCQUF1QjtxREE4QzNCQSxTQUFNLFNBQUMsU0FBUzt3QkE1Q1osaUJBQWlCOzs7OytCQXlHdkJuQixRQUFLLFNBQUMsYUFBYTs7UUFrQnRCLHlCQUFDO0tBQUEsQ0F0RnVDLGVBQWU7Ozs7Ozs7QUNqQ3ZELFFBQWEsdUJBQXVCLEdBQWdCLENBQUMsV0FBVyxFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixDQUFDO0FBRXpHO1FBQUE7U0FLaUM7O29CQUxoQ1AsV0FBUSxTQUFDO3dCQUNSLE9BQU8sRUFBRSxDQUFDQyxtQkFBWSxFQUFFLHNCQUFzQixFQUFFLGFBQWEsQ0FBQzt3QkFDOUQsWUFBWSxFQUFFLENBQUMsdUJBQXVCLENBQUM7d0JBQ3ZDLE9BQU8sRUFBRSxDQUFDLHVCQUF1QixFQUFFLG9CQUFvQixDQUFDO3FCQUN6RDs7UUFDK0Isd0JBQUM7S0FMakM7Ozs7Ozs7UUNWQTtZQUVVLFFBQUcsR0FBb0IsSUFBSUMsWUFBTyxFQUFVLENBQUM7U0FTdEQ7Ozs7O1FBUEMsbUNBQVE7Ozs7WUFBUixVQUFTLEVBQVU7Z0JBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ25CO1FBRUQsc0JBQUksZ0NBQUU7OztnQkFBTjtnQkFDRSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDaEM7OztXQUFBOztvQkFWRlEsYUFBVTs7UUFXWCx1QkFBQztLQVhEOzs7Ozs7O1FDRUE7U0FpQjBCOztvQkFqQnpCQyxZQUFTLFNBQUM7d0JBQ1QsUUFBUSxFQUFFLGFBQWE7d0JBQ3ZCLFFBQVEsRUFBRSwyQ0FFUDt3QkFDSCxJQUFJLEVBQUU7NEJBQ0osaUJBQWlCLEVBQUUsTUFBTTt5QkFDMUI7d0JBQ0QsU0FBUyxFQUFFOzRCQUNULGFBQWE7NEJBQ2IsRUFBRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFRyxhQUFVLEVBQUU7Ozs0QkFHekQsa0JBQWtCOzRCQUNsQixnQkFBZ0I7eUJBQ2pCO3FCQUNGOztRQUN3QixpQkFBQztLQWpCMUI7Ozs7Ozs7UUNDTW1ELFdBQVMsR0FBYSxDQUFDLGFBQWEsRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDOztRQUUvRixLQUFLLEdBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7QUFFaEQ7UUFZdUNwQyxxQ0FBZTtRQUNwRCwyQkFDRSxRQUFrQixFQUdsQixVQUFzQixFQUNJLFFBQWdCLEVBQ2xDLGdCQUFrQztZQU41QyxZQVFFLGtCQUFNLFFBQVEsRUFBRSxVQUFVLENBQUMsU0FZNUI7WUFmMkIsY0FBUSxHQUFSLFFBQVEsQ0FBUTtZQUNsQyxzQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1lBSTFDLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQyxDQUFDO2FBQ3BGOztZQUdELEtBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1lBQ3hCLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOztZQUdqQixLQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztTQUN6QjtRQUlELHNCQUFJLHVDQUFROzs7Z0JBQVo7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO2FBQ3ZCOzs7O2dCQWlCRCxVQUNhLFFBQWdCOztnQkFFM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDN0UsSUFBSSxRQUFRLElBQUlvQyxXQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO29CQUNoRCxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztpQkFDM0I7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7aUJBQzFCOztnQkFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztnQkFHMUUsUUFBUSxRQUFRO29CQUNkLEtBQUssV0FBVzt3QkFDZCxJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7d0JBQ3BDLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQzt3QkFDdEMsTUFBTTtvQkFDUixLQUFLLFVBQVU7d0JBQ2IsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDO3dCQUNwQyxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUM7d0JBQ3ZDLE1BQU07b0JBQ1IsS0FBSyxjQUFjO3dCQUNqQixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUM7d0JBQ3ZDLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQzt3QkFDbkMsTUFBTTtvQkFDUixLQUFLLGFBQWE7d0JBQ2hCLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQzt3QkFDdkMsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO3dCQUNwQyxNQUFNO29CQUNSLEtBQUssT0FBTzt3QkFDVixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUM7d0JBQ3RDLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQzt3QkFDbkMsTUFBTTtvQkFDUixLQUFLLE1BQU07d0JBQ1QsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO3dCQUNyQyxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7d0JBQ3BDLE1BQU07b0JBQ1I7d0JBQ0UsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDO3dCQUN0QyxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUM7d0JBQ25DLE1BQU07aUJBQ1Q7YUFDRjs7O1dBNURBO1FBRUQsc0JBQUksaUNBQUU7OztnQkFBTjtnQkFDRSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7YUFDakI7Ozs7Z0JBRUQsVUFDTyxLQUFhO2dCQUNsQixLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2xEOzs7V0FMQTs7Ozs7UUFRTyxvQ0FBUTs7OztZQUFoQixVQUFpQixFQUFVO2dCQUN6QixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztnQkFDZCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3BDO1FBaURELHNCQUFJLG1DQUFJOzs7Z0JBQVI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO2FBQ25COzs7O2dCQUVELFVBQ1MsSUFBWTs7Z0JBRW5CLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3pFLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7b0JBQ3BDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO2lCQUNuQjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztpQkFDbkI7O2dCQUVELElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdkU7OztXQWJBOztvQkF6R0Z0RCxZQUFTLFNBQUM7d0JBQ1QsUUFBUSxFQUFFLHFCQUFxQjt3QkFDL0IsUUFBUSxFQUFFLDJDQUVQO3dCQUNILElBQUksRUFBRTs0QkFDSix5QkFBeUIsRUFBRSxNQUFNOzRCQUNqQyxpQkFBaUIsRUFBRSxHQUFHOzRCQUN0QixhQUFhLEVBQUUsV0FBVzs0QkFDMUIsTUFBTSxFQUFFLElBQUk7eUJBQ2I7cUJBQ0Y7Ozs7O3dCQXRCdUNtQixXQUFRO3dCQUE1QmhCLGFBQVUsdUJBMEJ6QkwsV0FBUSxZQUNSaUIsU0FBTSxTQUFDLG1CQUFtQjtxREFFMUJBLFNBQU0sU0FBQyxTQUFTO3dCQXhCWixnQkFBZ0I7Ozs7eUJBbUR0Qm5CLFFBQUs7K0JBV0xBLFFBQUssU0FBQyxhQUFhOzJCQW1EbkJBLFFBQUssU0FBQyxTQUFTOztRQVlsQix3QkFBQztLQUFBLENBM0dzQyxlQUFlOzs7Ozs7O1FDTHBELDJCQUFvQixhQUE0QixFQUFVLGdCQUFrQztZQUE1RixpQkFHQztZQUhtQixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtZQUFVLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7WUFEcEYsU0FBSSxHQUFtQixFQUFFLENBQUM7O1lBR2hDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFVBQUEsU0FBUyxJQUFJLFFBQUMsS0FBSSxDQUFDLGVBQWUsR0FBRyxTQUFTLElBQUMsQ0FBQyxDQUFDLENBQUM7U0FDckc7Ozs7UUFJRCx1Q0FBVzs7O1lBRlg7Z0JBR0UsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO2FBQ2hDOzs7O1FBSUQsdUNBQVc7OztZQUZYO2dCQUdFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQzthQUNqQzs7OztRQUVELHVDQUFXOzs7WUFBWDtnQkFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsQ0FBQyxXQUFXLEVBQUUsR0FBQSxDQUFDLENBQUM7YUFDN0M7O29CQS9CRlIsWUFBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSxxQkFBcUI7d0JBQy9CLElBQUksRUFBRTs0QkFDSixRQUFRLEVBQUUsR0FBRzs0QkFDYix5QkFBeUIsRUFBRSxNQUFNOzRCQUNqQyx5QkFBeUIsRUFBRSxpQkFBaUI7NEJBQzVDLGFBQWEsRUFBRSxVQUFVO3lCQUMxQjtxQkFDRjs7Ozs7d0JBWlEsYUFBYTt3QkFDYixnQkFBZ0I7Ozs7a0NBb0J0QmlCLGVBQVksU0FBQyxZQUFZLGNBQ3pCQSxlQUFZLFNBQUMsT0FBTztrQ0FLcEJBLGVBQVksU0FBQyxZQUFZLGNBQ3pCQSxlQUFZLFNBQUMsTUFBTTs7UUFRdEIsd0JBQUM7S0FoQ0Q7Ozs7Ozs7QUNNQSxRQUFhLHNCQUFzQixHQUFnQixDQUFDLFVBQVUsRUFBRSxpQkFBaUIsRUFBRSxpQkFBaUIsQ0FBQztBQUVyRztRQUFBO1NBS2dDOztvQkFML0JoQixXQUFRLFNBQUM7d0JBQ1IsT0FBTyxFQUFFLENBQUNDLG1CQUFZLEVBQUUsc0JBQXNCLENBQUM7d0JBQy9DLFlBQVksRUFBRSxDQUFDLHNCQUFzQixDQUFDO3dCQUN0QyxPQUFPLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSxhQUFhLENBQUM7cUJBQ3ZFOztRQUM4Qix1QkFBQztLQUxoQzs7Ozs7OztRQ1JBO1NBQ2dDOztvQkFEL0JELFdBQVEsU0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixDQUFDLEVBQUU7O1FBQ2hELHVCQUFDO0tBRGhDOzs7Ozs7O1FDREE7WUFFUyxpQkFBWSxHQUFZLEtBQUssQ0FBQztZQUU3Qix3QkFBbUIsR0FBRyxJQUFJRSxZQUFPLEVBQU8sQ0FBQztZQUt6QyxvQkFBZSxHQUFHLElBQUlBLFlBQU8sRUFBTyxDQUFDO1lBS3JDLHNCQUFpQixHQUFHLElBQUlBLFlBQU8sRUFBTyxDQUFDO1lBS3ZDLHNCQUFpQixHQUFHLElBQUlBLFlBQU8sRUFBTyxDQUFDO1lBS3ZDLHNCQUFpQixHQUFHLElBQUlBLFlBQU8sRUFBTyxDQUFDO1lBS3ZDLHNCQUFpQixHQUFHLElBQUlBLFlBQU8sRUFBTyxDQUFDO1NBb0JoRDtRQTVDQyxzQkFBVyxnREFBa0I7OztnQkFBN0I7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDaEQ7OztXQUFBO1FBR0Qsc0JBQVcsNENBQWM7OztnQkFBekI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQzVDOzs7V0FBQTtRQUdELHNCQUFXLDhDQUFnQjs7O2dCQUEzQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUM5Qzs7O1dBQUE7UUFHRCxzQkFBVyw4Q0FBZ0I7OztnQkFBM0I7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDOUM7OztXQUFBO1FBR0Qsc0JBQVcsOENBQWdCOzs7Z0JBQTNCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO2FBQzlDOzs7V0FBQTtRQUdELHNCQUFXLDhDQUFnQjs7O2dCQUEzQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUM5Qzs7O1dBQUE7Ozs7O1FBRU0sd0NBQWE7Ozs7WUFBcEIsVUFBcUIsVUFBa0I7Z0JBQ3JDLElBQUksVUFBVSxLQUFLLFVBQVUsRUFBRTtvQkFDN0IsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxDQUFDO2lCQUNqQztxQkFBTSxJQUFJLE1BQU0sS0FBSyxVQUFVLEVBQUU7b0JBQ2hDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQzdCO3FCQUFNLElBQUksUUFBUSxLQUFLLFVBQVUsRUFBRTtvQkFDbEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxDQUFDO2lCQUMvQjtxQkFBTSxJQUFJLFFBQVEsS0FBSyxVQUFVLEVBQUU7b0JBQ2xDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQztpQkFDL0I7cUJBQU0sSUFBSSxRQUFRLEtBQUssVUFBVSxFQUFFO29CQUNsQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQy9CO3FCQUFNO29CQUNMLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQ3pDO2FBQ0Y7O29CQWhERlEsYUFBVTs7UUFpRFgsdUJBQUM7S0FqREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN3QkE7UUFBQTs7Ozs7OztZQW9UVSxnQkFBVyxHQUFHLElBQUlSLFlBQU8sRUFBVyxDQUFDO1NBMkU5QztRQTdXQyxzQkFBVywrQ0FBWTs7Ozs7Ozs7Ozs7Ozs7O2dCQUF2QjtnQkFDRSxPQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUM7YUFDL0M7OztXQUFBO1FBT0Qsc0JBQVcsNkNBQVU7Ozs7Ozs7Ozs7O2dCQUFyQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQzNDOzs7V0FBQTtRQVFELHNCQUFXLGtEQUFlOzs7Ozs7Ozs7Ozs7O2dCQUExQjs7b0JBQ1EsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVO2dCQUVqQyxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7b0JBQ2pCLE9BQU87aUJBQ1I7Z0JBRUQsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUN6Qzs7O1dBQUE7UUFRRCxzQkFBVywyQ0FBUTs7Ozs7Ozs7Ozs7OztnQkFBbkI7O29CQUNRLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVTtnQkFFakMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxFQUFFO29CQUNqQixPQUFPO2lCQUNSO2dCQUVELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDekM7OztXQUFBO1FBUUQsc0JBQVcsNENBQVM7Ozs7Ozs7Ozs7Ozs7Z0JBQXBCO2dCQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNwQixPQUFPO2lCQUNSO2dCQUVELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM3Qjs7O1dBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBWU0sMkNBQVc7Ozs7Ozs7Ozs7OztZQUFsQixVQUFtQixFQUFVOztvQkFDckIsVUFBVSxHQUFvQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFDLElBQW1CLElBQUssT0FBQSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsR0FBQSxDQUFDO2dCQUM5RixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQzFDOzs7Ozs7Ozs7Ozs7Ozs7UUFRTSw4Q0FBYzs7Ozs7Ozs7WUFBckIsVUFBc0IsS0FBYTs7b0JBQzNCLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVTs7b0JBQzNCLGNBQWMsR0FBVyxTQUFTLEdBQUcsQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLEdBQUcsQ0FBQztnQkFFaEUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO29CQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLEdBQUcsS0FBSyxDQUFDLENBQUM7aUJBQ2hFO2dCQUVELElBQUksS0FBSyxHQUFHLGNBQWMsRUFBRTtvQkFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO2lCQUN0RTtnQkFFRCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDakM7Ozs7Ozs7Ozs7Ozs7OztRQVFNLDRDQUFZOzs7Ozs7OztZQUFuQixVQUFvQixJQUFtQjs7b0JBQy9CLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7Z0JBRTdDLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtvQkFDYixNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7aUJBQzNFO2dCQUVELE9BQU8sS0FBSyxDQUFDO2FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7UUFRTyw0Q0FBWTs7Ozs7Ozs7O1lBQXBCLFVBQXFCLE9BQXdCLEVBQUUsZUFBdUI7O29CQUM5RCxlQUFlLEdBQVcsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDO2dCQUVuRCxJQUFJLGVBQWUsR0FBRyxDQUFDLEVBQUU7b0JBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLEdBQUcsZUFBZSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2lCQUNyRjtxQkFBTSxJQUFJLGVBQWUsR0FBRyxDQUFDLEVBQUU7b0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLEdBQUcsZUFBZSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2lCQUM5RTtxQkFBTTtvQkFDTCxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbkI7YUFDRjs7Ozs7Ozs7Ozs7Ozs7OztRQVFNLHlDQUFTOzs7Ozs7Ozs7WUFBaEIsVUFBaUIsS0FBYSxFQUFFLEdBQVc7O29CQUNyQyxLQUFLLEdBQW9CLEVBQUU7Z0JBRS9CLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO29CQUN4QixPQUFPLEVBQUUsQ0FBQztpQkFDWDtnQkFFRCxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksT0FBTyxLQUFLLEtBQUssV0FBVyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDbEUsT0FBTyxFQUFFLENBQUM7aUJBQ1g7Z0JBRUQsSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJLE9BQU8sR0FBRyxLQUFLLFdBQVcsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQzVELE9BQU8sRUFBRSxDQUFDO2lCQUNYO2dCQUVELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQ3pCLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO2lCQUN2QjtnQkFFRCxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztnQkFFMUIsSUFBSSxHQUFHLEdBQUcsS0FBSyxLQUFLLENBQUMsRUFBRTs7b0JBRXJCLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7aUJBQ3JDOzs7O2dCQUtELEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDOzs7Z0JBSWQsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQzthQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBU00scURBQXFCOzs7Ozs7Ozs7O1lBQTVCLFVBQTZCLElBQW1CLEVBQUUsU0FBd0I7O29CQUNsRSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7O29CQUNuQyxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUM7O29CQUMvQyxVQUFrQjs7b0JBQ2xCLFFBQWdCO2dCQUVwQixJQUFJLFNBQVMsSUFBSSxjQUFjLEVBQUU7b0JBQy9CLFVBQVUsR0FBRyxTQUFTLENBQUM7b0JBQ3ZCLFFBQVEsR0FBRyxjQUFjLENBQUM7aUJBQzNCO3FCQUFNO29CQUNMLFVBQVUsR0FBRyxjQUFjLENBQUM7b0JBQzVCLFFBQVEsR0FBRyxTQUFTLENBQUM7aUJBQ3RCO2dCQUNELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDN0M7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBU00sK0NBQWU7Ozs7Ozs7OztZQUF0QixVQUF1QixJQUFtQjs7b0JBQ2xDLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQzs7b0JBQ3JDLGlCQUFpQixHQUFHLFdBQVcsR0FBRyxDQUFDO2dCQUN6QyxJQUFJLGlCQUFpQixHQUFHLENBQUMsRUFBRTtvQkFDekIsT0FBTyxJQUFJLENBQUM7aUJBQ2I7Z0JBQ0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFDLENBQUM7YUFDL0M7Ozs7Ozs7Ozs7Ozs7OztRQVFNLHVEQUF1Qjs7Ozs7Ozs7WUFBOUIsVUFBK0IsSUFBbUI7O29CQUM1QyxZQUEyQjtnQkFFL0IsSUFBSSxDQUFDLElBQUksRUFBRTtvQkFDVCxPQUFPLEtBQUssQ0FBQztpQkFDZDtnQkFFRCxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFFMUMsSUFBSSxJQUFJLEtBQUssWUFBWSxFQUFFOztvQkFFekIsT0FBTyxJQUFJLENBQUM7aUJBQ2I7Z0JBRUQsT0FBTyxZQUFZLENBQUMsU0FBUyxDQUFDO2FBQy9COzs7Ozs7Ozs7Ozs7Ozs7OztRQVNNLDJDQUFXOzs7Ozs7Ozs7WUFBbEIsVUFBbUIsSUFBbUI7O29CQUM5QixXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7O29CQUNyQyxhQUFhLEdBQUcsV0FBVyxHQUFHLENBQUM7Z0JBRXJDLElBQUksYUFBYSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFO29CQUM3QyxPQUFPLElBQUksQ0FBQztpQkFDYjtnQkFDRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDM0M7Ozs7Ozs7Ozs7Ozs7OztRQVFNLG9EQUFvQjs7Ozs7Ozs7WUFBM0IsVUFBNEIsSUFBbUI7O29CQUN2QyxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUU7O29CQUNoQixXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUU7Z0JBRS9DLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7Z0JBQ3hCLE9BQU8sV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUN4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQVVNLDBDQUFVOzs7Ozs7Ozs7O1lBQWpCLFVBQWtCLElBQW1COztvQkFDN0IsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYztnQkFDN0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBRXRCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTs7O29CQUdyQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7aUJBQzdCO2FBQ0Y7UUFtQkQsc0JBQVcsNkNBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUFyQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDeEM7OztXQUFBOzs7Ozs7Ozs7Ozs7OztRQVFNLHFDQUFLOzs7Ozs7O1lBQVo7Z0JBQ0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFtQjtvQkFDNUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7aUJBQ3hCLENBQUMsQ0FBQztnQkFDSCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBVU0scURBQXFCOzs7Ozs7Ozs7WUFBNUI7O29CQUNRLG9CQUFvQixHQUFHLElBQUksQ0FBQyw0QkFBNEIsRUFBRTtnQkFFaEUsSUFBSSxvQkFBb0IsS0FBSyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O29CQUV6RCxPQUFPO2lCQUNSO2dCQUVELElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBbUIsRUFBRSxLQUFhO29CQUMzRCxJQUFJLEtBQUssR0FBRyxvQkFBb0IsRUFBRTt3QkFDaEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7cUJBQ3hCO2lCQUNGLENBQUMsQ0FBQzthQUNKOzs7Ozs7Ozs7Ozs7UUFPTSw0REFBNEI7Ozs7OztZQUFuQzs7b0JBQ00sV0FBVyxHQUFXLElBQUk7Z0JBQzlCLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBbUIsRUFBRSxLQUFhO29CQUMzRCxJQUFJLElBQUksS0FBSyxXQUFXLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxTQUFTLEVBQUU7d0JBQ3BELFdBQVcsR0FBRyxLQUFLLENBQUM7cUJBQ3JCO2lCQUNGLENBQUMsQ0FBQzs7Z0JBR0gsSUFBSSxJQUFJLEtBQUssV0FBVyxFQUFFO29CQUN4QixXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7aUJBQ25DO2dCQUVELE9BQU8sV0FBVyxDQUFDO2FBQ3BCOzs7O1FBRU0sdURBQXVCOzs7WUFBOUI7O29CQUNRLGlCQUFpQixHQUFHLElBQUksQ0FBQyw0QkFBNEIsRUFBRTtnQkFDN0QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLENBQUM7YUFDN0M7O29CQTlYRlEsYUFBVTs7UUErWFgsNEJBQUM7S0EvWEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNDQTs7Ozs7Ozs7O1FBaUVFLGlDQUFtQixjQUFxQyxFQUFTLGFBQStCO1lBQWhHLGlCQTZDQztZQTdDa0IsbUJBQWMsR0FBZCxjQUFjLENBQXVCO1lBQVMsa0JBQWEsR0FBYixhQUFhLENBQWtCOzs7OztZQWlFeEYsb0JBQWUsR0FBRyxJQUFJUixZQUFPLEVBQWlCLENBQUM7Ozs7Ozs7WUFxQmhELHFCQUFnQixHQUFHLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7O1lBYXpCLDJCQUFzQixHQUFHLEtBQUssQ0FBQzs7OztZQTJFOUIscUJBQWdCLEdBQUcsSUFBSUEsWUFBTyxFQUFXLENBQUM7Ozs7WUFnQjFDLG9CQUFlLEdBQUcsSUFBSUEsWUFBTyxFQUFXLENBQUM7Ozs7WUE4SnpDLHlCQUFvQixHQUFHLElBQUlBLFlBQU8sRUFBVyxDQUFDOzs7O1lBNkM5QyxrQkFBYSxHQUFHLElBQUlBLFlBQU8sRUFBTyxDQUFDOzs7Ozs7Ozs7WUFzQ3BDLHVCQUFrQixHQUFZLEtBQUssQ0FBQzs7Ozs7Ozs7O1lBVXBDLHFCQUFnQixHQUFZLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7WUFZbEMseUJBQW9CLEdBQVksS0FBSyxDQUFDOzs7Ozs7O1lBUXRDLHlCQUFvQixHQUFZLEtBQUssQ0FBQztZQTVjM0MsSUFBSSxDQUFDLDBCQUEwQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDOztvQkFDMUUsV0FBVyxHQUFHLEtBQUksQ0FBQyxXQUFXO2dCQUNwQyxJQUFJLEtBQUksQ0FBQyxrQkFBa0IsSUFBSSxXQUFXLENBQUMsb0JBQW9CLEVBQUU7b0JBQy9ELE9BQU87aUJBQ1I7Z0JBQ0QsV0FBVyxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLEVBQUU7b0JBQy9CLEtBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztpQkFDakI7YUFDRixDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO2dCQUN4RSxLQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDeEMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDO2dCQUM1RSxLQUFJLENBQUMseUJBQXlCLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDO2dCQUM1RSxLQUFJLENBQUMseUJBQXlCLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLFVBQUMsSUFBWTtnQkFDekYsSUFBSSxDQUFDLEtBQUksQ0FBQyxvQkFBb0IsRUFBRTtvQkFDOUIsS0FBSSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ2pEO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDO2dCQUM1RSxJQUFJLEtBQUksQ0FBQyxvQkFBb0IsRUFBRTtvQkFDN0IsT0FBTztpQkFDUjtnQkFFRCxJQUFJLEtBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxFQUFFO29CQUNuQyxLQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUN0RDtxQkFBTTtvQkFDTCxLQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7aUJBQ2Y7YUFDRixDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO2dCQUNyRSxLQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQzthQUM1QixDQUFDLENBQUM7U0FDSjs7Ozs7Ozs7OztRQU1ELDZDQUFXOzs7OztZQUFYO2dCQUNFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDOUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUMxQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQzVDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDNUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUM1QyxJQUFJLENBQUMsd0JBQXdCLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQzVDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUMzQztRQWVELHNCQUFXLHVEQUFrQjs7Ozs7Ozs7Ozs7Ozs7O2dCQUE3Qjs7O2dCQUdFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUM1Qzs7O1dBQUE7UUEwQkQsc0JBQVcscURBQWdCOzs7Ozs7O2dCQUEzQjs7Z0JBRUUsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7b0JBQ3JCLE9BQU8sSUFBSSxDQUFDO2lCQUNiO2dCQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUM7YUFDL0I7OztXQUFBO1FBVUQsc0JBQVcsdURBQWtCOzs7Ozs7Ozs7Ozs7Ozs7OztnQkFBN0I7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsS0FBSyxJQUFJLENBQUMsV0FBVyxDQUFDO2FBQzNEOzs7V0FBQTtRQVVELHNCQUFXLHNEQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBQTVCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLFdBQVcsQ0FBQzthQUMxRDs7O1dBQUE7UUFZRCxzQkFBSSxnREFBVzs7Ozs7Ozs7Ozs7Z0JBQWY7Z0JBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7b0JBQ3RCLE9BQU8sSUFBSSxDQUFDO2lCQUNiO2dCQUNELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQzthQUMxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFZRCxVQUFnQixJQUFtQjtnQkFDakMsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtvQkFDNUQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7b0JBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDMUIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ2pDO2FBQ0Y7OztXQWxCQTtRQWdDRCxzQkFBVyxvREFBZTs7Ozs7Ozs7Ozs7Ozs7O2dCQUExQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUM3Qzs7O1dBQUE7UUFnQkQsc0JBQVcsbURBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBQXpCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUM1Qzs7O1dBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBY00sc0NBQUk7Ozs7Ozs7Ozs7Ozs7WUFBWDtnQkFDRSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtvQkFDMUIsSUFBSSxDQUFDLHlCQUF5QixDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUMxQztxQkFBTTtvQkFDTCxJQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ3hDO2FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7UUFTTSwyQ0FBUzs7Ozs7Ozs7WUFBaEI7O29CQUNRLFdBQVcsR0FBa0IsSUFBSSxDQUFDLFdBQVc7O29CQUM3QyxRQUFRLEdBQWtCLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQzs7Z0JBRzVFLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO2lCQUMxRDtnQkFFRCxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtvQkFDN0IsT0FBTztpQkFDUjtnQkFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRTs7b0JBRTFCLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUM3QztnQkFDRCxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQzthQUM3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQVVNLDJEQUF5Qjs7Ozs7Ozs7OztZQUFoQyxVQUFpQyxVQUFrQjs7b0JBQzNDLFdBQVcsR0FBa0IsSUFBSSxDQUFDLFdBQVc7O29CQUMvQyxjQUF1Qjs7b0JBRXZCLE1BQWU7O29CQUNmLFFBQWlCOztvQkFDakIsWUFBcUI7O29CQUNyQixjQUF1Qjs7b0JBQ3ZCLFFBQWlCO2dCQUVyQixJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUU7b0JBQzdELE9BQU87aUJBQ1I7Z0JBRUQsY0FBYyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztnQkFFeEMsTUFBTSxHQUFHLFVBQVUsS0FBSyxNQUFNLENBQUM7Z0JBQy9CLFFBQVEsR0FBRyxVQUFVLEtBQUssUUFBUSxDQUFDO2dCQUNuQyxZQUFZLEdBQUcsUUFBUSxJQUFJLENBQUMsY0FBYyxDQUFDO2dCQUMzQyxjQUFjLEdBQUcsUUFBUSxJQUFJLGNBQWMsQ0FBQztnQkFDNUMsUUFBUSxHQUFHLFVBQVUsS0FBSyxRQUFRLElBQUksY0FBYyxDQUFDO2dCQUVyRCxJQUFJLFFBQVEsSUFBSSxDQUFDLGNBQWMsRUFBRTtvQkFDL0IsT0FBTztpQkFDUjtnQkFFRCxXQUFXLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUVsRCxJQUFJLFFBQVEsRUFBRTtvQkFDWixXQUFXLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUNuRDtxQkFBTSxJQUFJLFFBQVEsRUFBRTtvQkFDbkIsV0FBVyxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxDQUFDO2lCQUN4QztxQkFBTSxJQUFJLE1BQU0sRUFBRTtvQkFDakIsV0FBVyxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxDQUFDO2lCQUN0QztnQkFFRCxJQUFJLFdBQVcsQ0FBQyxRQUFRLElBQUksV0FBVyxDQUFDLGNBQWMsRUFBRTtvQkFDdEQsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUMxQyxPQUFPO2lCQUNSOztnQkFHRCxJQUFJLFFBQVEsRUFBRTs7b0JBRVosSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTt3QkFDMUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7cUJBQzdDO29CQUNELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQzdCO2dCQUVELElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO29CQUN6QixJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFFNUMsSUFBSSxNQUFNLElBQUksWUFBWSxFQUFFO3dCQUMxQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO3FCQUNsQzs7b0JBRUQsT0FBTztpQkFDUjtnQkFFRCxJQUFJLE1BQU0sSUFBSSxZQUFZLEVBQUU7b0JBQzFCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztpQkFDbEI7Z0JBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtvQkFDeEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDbEM7YUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFjTSx3Q0FBTTs7Ozs7Ozs7Ozs7OztZQUFiO2dCQUNFLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMxQztRQWFELHNCQUFXLHdEQUFtQjs7Ozs7Ozs7Ozs7OztnQkFBOUI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDakQ7OztXQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFVTSwwQ0FBUTs7Ozs7Ozs7O1lBQWY7O29CQUNNLFlBQTJCO2dCQUUvQixJQUFJLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUU7b0JBQ3hELE9BQU87aUJBQ1I7Z0JBRUQsWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFFckUsSUFBSSxDQUFDLFlBQVksRUFBRTtvQkFDakIsT0FBTztpQkFDUjtnQkFFRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUVyQyxJQUFJLElBQUksQ0FBQyxzQkFBc0IsRUFBRTtvQkFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO2lCQUNwQztnQkFFRCxJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQzthQUNqQztRQVlELHNCQUFXLHVEQUFrQjs7Ozs7Ozs7Ozs7Z0JBQTdCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUMxQzs7O1dBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBaUJNLHdDQUFNOzs7Ozs7Ozs7Ozs7Ozs7O1lBQWI7Z0JBQ0UsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUMzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUEyRE0sc0NBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBQVgsVUFBWSxjQUFtQixFQUFFLFlBQTZCO2dCQUE3Qiw2QkFBQTtvQkFBQSxvQkFBNkI7OztvQkFDeEQsVUFBeUI7O29CQUN6QixXQUEwQjs7b0JBQzFCLE9BQThCOztvQkFDOUIsWUFBNkI7O29CQUM3QixVQUFtQjs7b0JBQ25CLFlBQXFCOztvQkFDckIsZ0JBQXdCOztvQkFDeEIsYUFBcUI7Z0JBRXpCLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO2dCQUM5QixVQUFVLEdBQUcsT0FBTyxjQUFjLEtBQUssUUFBUSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEdBQUcsY0FBYyxDQUFDO2dCQUN2RyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQzs7O2dCQUkvQixJQUFJLFVBQVUsS0FBSyxXQUFXLElBQUksSUFBSSxDQUFDLG9CQUFvQixFQUFFO29CQUMzRCxPQUFPO2lCQUNSO2dCQUVELGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ3JELGFBQWEsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNqRCxZQUFZLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixDQUFDO2dCQUNoRCxZQUFZLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUM7Z0JBRTNFLFVBQVUsR0FBRyxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFFeEQsSUFBSSxDQUFDLFVBQVUsRUFBRTtvQkFDZixPQUFPO2lCQUNSO2dCQUVELElBQUksWUFBWSxJQUFJLFlBQVksRUFBRTtvQkFDaEMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQW1CO3dCQUN2QyxJQUFJLElBQUksS0FBSyxVQUFVLEVBQUU7NEJBQ3ZCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO3lCQUN2QjtxQkFDRixDQUFDLENBQUM7aUJBQ0o7cUJBQU0sSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsc0JBQXNCLEVBQUU7b0JBQ3ZELFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFtQjt3QkFDdkMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7cUJBQ3hCLENBQUMsQ0FBQztpQkFDSjtnQkFFRCxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQzthQUMvQjs7Ozs7Ozs7Ozs7Ozs7O1FBUU0seUNBQU87Ozs7Ozs7O1lBQWQsVUFBZSxZQUE2Qjs7b0JBQ3RDLFVBQVUsR0FBRyxJQUFJOztvQkFDZixPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWM7Ozs7b0JBSS9CLGtCQUEyQjtnQkFFL0IsSUFBSSxDQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDNUMsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBRUQsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQW1COzt3QkFDbkMsWUFBMkI7b0JBRS9CLElBQUksQ0FBQyxVQUFVLEVBQUU7d0JBQ2YsT0FBTztxQkFDUjtvQkFFRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7O3dCQUVsQixPQUFPO3FCQUNSOztvQkFHRCxZQUFZLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7b0JBQ3JGLGtCQUFrQixHQUFHLFlBQVksS0FBSyxJQUFJLElBQUksWUFBWSxDQUFDLFNBQVMsS0FBSyxJQUFJLENBQUM7OztvQkFJOUUsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxrQkFBa0IsRUFBRTt3QkFDeEMsVUFBVSxHQUFHLEtBQUssQ0FBQztxQkFDcEI7O2lCQUVGLENBQUMsQ0FBQztnQkFFSCxPQUFPLFVBQVUsQ0FBQzthQUNuQjs7Ozs7Ozs7Ozs7Ozs7UUFRTSwyREFBeUI7Ozs7Ozs7WUFBaEM7O29CQUNRLFFBQVEsR0FBb0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZOztvQkFDOUQsc0JBQXNCLEdBQVcsSUFBSTtnQkFFekMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQW1CLEVBQUUsS0FBYTtvQkFDbEQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO3dCQUNsQixzQkFBc0IsR0FBRyxLQUFLLENBQUM7cUJBQ2hDO2lCQUNGLENBQUMsQ0FBQztnQkFFSCxJQUFJLHNCQUFzQixLQUFLLElBQUksRUFBRTs7b0JBRW5DLHNCQUFzQixHQUFHLENBQUMsQ0FBQztpQkFDNUI7cUJBQU0sSUFBSSxzQkFBc0IsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRTtvQkFDdkQsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsQ0FBQyxDQUFDO2lCQUNyRDtnQkFFRCxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO2FBQ3JEOzs7Ozs7Ozs7Ozs7OztRQVFNLHFEQUFtQjs7Ozs7OztZQUExQjtnQkFDRSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3hEOzs7Ozs7Ozs7Ozs7OztRQVFNLGtEQUFnQjs7Ozs7OztZQUF2Qjs7b0JBQ00sWUFBMkI7O29CQUMzQixrQkFBMkI7Z0JBRS9CLElBQUksQ0FBQyxjQUFjLENBQUMscUJBQXFCLEVBQUUsQ0FBQztnQkFFNUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3BGLElBQUksa0JBQWtCLEVBQUU7b0JBQ3RCLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixFQUFFLENBQUM7b0JBQzdELElBQUksQ0FBQyxXQUFXLEdBQUcsWUFBWSxDQUFDO2lCQUNqQzthQUNGOztvQkFqckJGUSxhQUFVOzs7Ozt3QkFyQkYscUJBQXFCO3dCQURyQixnQkFBZ0I7OztRQXdzQnpCLDhCQUFDO0tBbHJCRDs7Ozs7Ozs7O1FDcEJFLDZCQUFtQixVQUFtQztZQUFuQyxlQUFVLEdBQVYsVUFBVSxDQUF5QjtTQUFJO1FBSTFELHNCQUFXLHVEQUFzQjs7O2dCQUFqQzs7b0JBQ1EsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLG1CQUFtQjtnQkFDakQsSUFBSSxDQUFDLGdCQUFnQixFQUFFO29CQUNyQixPQUFPLEtBQUssQ0FBQztpQkFDZDtnQkFDRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7YUFDOUM7OztXQUFBO1FBRUQsc0JBQVcsNERBQTJCOzs7Z0JBQXRDO2dCQUNFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO2FBQzNGOzs7V0FBQTtRQUVELHNCQUFXLHdEQUF1Qjs7O2dCQUFsQztnQkFDRSxPQUFPLENBQUMsSUFBSSxDQUFDLDJCQUEyQixJQUFJLElBQUksQ0FBQyxzQkFBc0IsQ0FBQzthQUN6RTs7O1dBQUE7UUFFRCxzQkFBVyw0REFBMkI7OztnQkFBdEM7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsMkJBQTJCLElBQUksSUFBSSxDQUFDLHNCQUFzQixDQUFDO2FBQ3hFOzs7V0FBQTs7b0JBM0JGQSxhQUFVOzs7Ozt3QkFGRix1QkFBdUI7OztRQThCaEMsMEJBQUM7S0E1QkQ7Ozs7Ozs7UUNGSSx1QkFBdUIsR0FBRyxDQUFDO0FBRS9CO1FBQUE7O1lBaUJrQixVQUFLLEdBQVcsRUFBRSxDQUFDOztZQUd0QixRQUFHLEdBQVcsQ0FBQyx1QkFBdUIsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDO1lBTW5CLGFBQVEsR0FBWSxLQUFLLENBQUM7WUFFaEQsd0JBQW1CLEdBQXlCLElBQUlOLGVBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQWE5RjtRQW5CQyxzQkFBVyxxQ0FBRTs7O2dCQUFiO2dCQUNFLE9BQU8sOEJBQTRCLElBQUksQ0FBQyxHQUFLLENBQUM7YUFDL0M7OztXQUFBOzs7O1FBTUQscUNBQUs7OztZQUFMO2dCQUNFLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDakIsT0FBTztpQkFDUjs7Ozs7Z0JBTUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDekM7O29CQXhDRk8sWUFBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSwwQkFBMEI7d0JBQ3BDLFFBQVEsRUFBRSxtVEFVUDt3QkFDSCxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsa0NBQWtDLEVBQUU7cUJBQ3BEOzs7NEJBR0VKLFFBQUssU0FBQyxPQUFPOzBCQUdiQSxRQUFLLFNBQUMsSUFBSTsrQkFNVkEsUUFBSyxTQUFDLCtCQUErQjswQ0FFckNDLFNBQU0sU0FBQyxlQUFlOztRQWF6Qiw0QkFBQztLQXpDRDs7Ozs7OztRQ0FFLDhCQUFtQixzQkFBd0M7WUFBeEMsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUFrQjtTQUFJOztvQkFGaEVULFlBQVMsU0FBQyxFQUFFLFFBQVEsRUFBRSxrQkFBa0IsRUFBRTs7Ozs7d0JBRnZCTSxjQUFXOzs7UUFLL0IsMkJBQUM7S0FIRDs7Ozs7OztRQ0VFLG9DQUFtQiw0QkFBOEM7WUFBOUMsaUNBQTRCLEdBQTVCLDRCQUE0QixDQUFrQjtTQUFJOztvQkFGdEVOLFlBQVMsU0FBQyxFQUFFLFFBQVEsRUFBRSx3QkFBd0IsRUFBRTs7Ozs7d0JBRjdCTSxjQUFXOzs7UUFLL0IsaUNBQUM7S0FIRDs7Ozs7OztRQ0VFLCtCQUFtQix1QkFBeUM7WUFBekMsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUFrQjtTQUFJOztvQkFGakVOLFlBQVMsU0FBQyxFQUFFLFFBQVEsRUFBRSxtQkFBbUIsRUFBRTs7Ozs7d0JBRnhCTSxjQUFXOzs7UUFLL0IsNEJBQUM7S0FIRDs7Ozs7OztRQ0VFLDRCQUFtQixvQkFBc0M7WUFBdEMseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFrQjtTQUFJOztvQkFGOUROLFlBQVMsU0FBQyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRTs7Ozs7d0JBRnJCTSxjQUFXOzs7UUFLL0IseUJBQUM7S0FIRDs7Ozs7OztRQ1FJLGVBQWUsR0FBRyxDQUFDOzs7Ozs7Ozs7OztBQVl2Qjs7Ozs7O1FBaUJFLHVCQUNVLFVBQW1DLEVBQ3BDLGNBQXFDLEVBQ3JDLGFBQStCO1lBRjlCLGVBQVUsR0FBVixVQUFVLENBQXlCO1lBQ3BDLG1CQUFjLEdBQWQsY0FBYyxDQUF1QjtZQUNyQyxrQkFBYSxHQUFiLGFBQWEsQ0FBa0I7Ozs7OztZQWlEaEMsc0JBQWlCLEdBQUcsS0FBSyxDQUFDOzs7Ozs7OztZQTBDUywyQkFBc0IsR0FBMEIsSUFBSUQsZUFBWSxFQUFFLENBQUM7Ozs7OztZQU90RywwQkFBcUIsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7O1lBMkMvQiwrQkFBMEIsR0FBMEIsSUFBSUEsZUFBWSxFQUFFLENBQUM7Ozs7Ozs7Ozs7WUFXakMsbUJBQWMsR0FBWSxLQUFLLENBQUM7Ozs7OztZQU9yRSxnQkFBVyxHQUFHLEtBQUssQ0FBQzs7Ozs7O1lBcUN1QixxQkFBZ0IsR0FBMEIsSUFBSUEsZUFBWSxFQUFFLENBQUM7Ozs7OztZQU94RyxjQUFTLEdBQUcsS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7WUE0Q08sYUFBUSxHQUF5QixJQUFJQSxlQUFZLENBQVMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7O1lBU25FLFdBQU0sR0FBeUIsSUFBSUEsZUFBWSxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7WUFpQmhELGlCQUFZLEdBQWdDLElBQUlBLGVBQVksRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFtQmpFLHdCQUFtQixHQUFnQyxJQUFJQSxlQUFZLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBbUJwRSwwQkFBcUIsR0FBZ0MsSUFBSUEsZUFBWSxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQW1CNUUsc0JBQWlCLEdBQWdDLElBQUlBLGVBQVksRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBdUJsRSx3QkFBbUIsR0FBZ0MsSUFBSUEsZUFBWSxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF1QnJFLHlCQUFvQixHQUF5QixJQUFJQSxlQUFZLEVBQUUsQ0FBQztZQUUzRCx3QkFBbUIsR0FBeUIsSUFBSUEsZUFBWSxFQUFFLENBQUM7Ozs7Ozs7Ozs7OztZQWF2RixRQUFHLEdBQVEsQ0FBQyxlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQzs7Ozs7O1lBNkMvQyxjQUFTLEdBQVksS0FBSyxDQUFDO1NBbmIvQjtRQWdFSixzQkFBVywyQ0FBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUEzQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQzthQUMvQjs7Ozs7Ozs7Ozs7Ozs7Z0JBUUQsVUFDNEIsR0FBWTs7b0JBQ2hDLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRztnQkFDckIsSUFBSSxPQUFPLEtBQUssSUFBSSxDQUFDLGlCQUFpQixFQUFFO29CQUN0QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsT0FBTyxDQUFDO29CQUNqQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUMzQzthQUNGOzs7V0FmQTtRQStDRCxzQkFBVywrQ0FBb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUEvQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQzthQUNuQzs7Ozs7Ozs7Ozs7Ozs7Z0JBUUQsVUFDZ0MsR0FBWTs7b0JBQ3BDLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRztnQkFDckIsSUFBSSxPQUFPLEtBQUssSUFBSSxDQUFDLHFCQUFxQixFQUFFO29CQUMxQyxJQUFJLENBQUMscUJBQXFCLEdBQUcsT0FBTyxDQUFDO29CQUNyQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUMvQzthQUNGOzs7V0FmQTtRQW1ERCxzQkFBVyxxQ0FBVTs7Ozs7Ozs7Ozs7OztnQkFBckI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO2FBQ3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBYUQsVUFDc0IsR0FBWTs7b0JBQzFCLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRztnQkFDckIsSUFBSSxPQUFPLEtBQUssSUFBSSxDQUFDLFdBQVcsRUFBRTtvQkFDaEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7b0JBQzNCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQ3JDO2FBQ0Y7OztXQXBCQTtRQTBDRCxzQkFBVyxtQ0FBUTs7Ozs7Ozs7Ozs7OztnQkFBbkI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO2FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQWVELFVBQ29CLEdBQVk7O29CQUN4QixPQUFPLEdBQUcsQ0FBQyxDQUFDLEdBQUc7Z0JBQ3JCLElBQUksT0FBTyxLQUFLLElBQUksQ0FBQyxTQUFTLEVBQUU7b0JBQzlCLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO2lCQUMxQjthQUNGOzs7V0FyQkE7UUFnTUQsc0JBQVcsNkJBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBQWI7Ozs7b0JBR1EsZ0JBQWdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQzs7O2dCQUlwRCxJQUFJLGdCQUFnQixJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFOztvQkFFcEMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLGVBQWUsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDO2lCQUMzQztnQkFDRCxPQUFPLHFCQUFtQixJQUFJLENBQUMsR0FBSyxDQUFDO2FBQ3RDOzs7V0FBQTtRQVVELHNCQUFXLDBDQUFlOzs7Ozs7Ozs7Ozs7Ozs7OztnQkFBMUI7Z0JBQ0UsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQzthQUMvQjs7O1dBQUE7UUFxQkQsc0JBQVcsb0NBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBQXBCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDOzs7Ozs7YUFPL0M7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBU0QsVUFBcUIsS0FBYztnQkFDakMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7YUFDeEI7OztXQVhBO1FBbUJELHNCQUFXLGtDQUFPOzs7Ozs7Ozs7Ozs7O2dCQUFsQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxLQUFLLElBQUksQ0FBQzthQUM3Qzs7O1dBQUE7UUFFRCxzQkFBVyxtQ0FBUTs7O2dCQUFuQjtnQkFDRSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQzthQUN0Qjs7O1dBQUE7UUFhRCxzQkFBVyxrQ0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBQWxCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQzthQUNqRTs7O1dBQUE7UUFVRCxzQkFBVyw0Q0FBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUE1Qjs7b0JBQ1EsWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQztnQkFFOUQsSUFBSSxDQUFDLFlBQVksRUFBRTtvQkFDakIsT0FBTyxJQUFJLENBQUM7aUJBQ2I7Z0JBRUQsT0FBTyxZQUFZLENBQUMsU0FBUyxDQUFDO2FBQy9COzs7V0FBQTtRQU9ELHNCQUFXLGdDQUFLOzs7Ozs7Ozs7OztnQkFBaEI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDO2FBQzVDOzs7V0FBQTtRQU9ELHNCQUFXLG1DQUFROzs7Ozs7Ozs7OztnQkFBbkI7Z0JBQ0UsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO29CQUNyQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsdUJBQXVCLENBQUM7aUJBQ2xEO2dCQUNELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQzthQUM1Qzs7O1dBQUE7UUFPRCxzQkFBVyx3Q0FBYTs7Ozs7Ozs7Ozs7Z0JBQXhCO2dCQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFO29CQUN4QixPQUFPO2lCQUNSO2dCQUNELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyw0QkFBNEIsQ0FBQzthQUN6RDs7O1dBQUE7UUFPRCxzQkFBVywyQ0FBZ0I7Ozs7Ozs7Ozs7O2dCQUEzQjtnQkFDRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO2FBQzlCOzs7V0FBQTtRQU9ELHNCQUFXLGtDQUFPOzs7Ozs7Ozs7OztnQkFBbEI7Z0JBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2xCLE9BQU87aUJBQ1I7Z0JBQ0QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLHNCQUFzQixDQUFDO2FBQzdDOzs7V0FBQTtRQVdELHNCQUFXLHFDQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUFyQjtnQkFDRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2FBQ3hCOzs7V0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBYU0sbUNBQVc7Ozs7Ozs7Ozs7OztZQUFsQjtnQkFDRSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7YUFDcEM7Ozs7Ozs7Ozs7Ozs7O1FBUU0sZ0NBQVE7Ozs7Ozs7WUFBZjs7b0JBQ1EsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVO2dCQUNsQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRTtvQkFDM0QsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO29CQUNuQixJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztpQkFDekM7YUFDRjtRQVVELHNCQUFXLHFDQUFVOzs7Ozs7Ozs7Ozs7Ozs7OztnQkFBckI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3ZEOzs7V0FBQTs7b0JBcG9CRk8sWUFBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSxpQkFBaUI7d0JBQzNCLFFBQVEsRUFBRSwyQkFBMkI7d0JBQ3JDLElBQUksRUFBRTs0QkFDSixNQUFNLEVBQUUsSUFBSTs0QkFDWixvQkFBb0IsRUFBRSxVQUFVOzRCQUNoQyx3QkFBd0IsRUFBRSxZQUFZOzRCQUN0QyxnQkFBZ0IsRUFBRSxTQUFTOzRCQUMzQix5QkFBeUIsRUFBRSxNQUFNO3lCQUNsQztxQkFDRjs7Ozs7d0JBNUJRLHVCQUF1Qjt3QkFEdkIscUJBQXFCO3dCQURyQixnQkFBZ0I7Ozs7Z0NBa0R0QmdCLGVBQVksU0FBQyxrQkFBa0I7bUNBWS9CQSxlQUFZLFNBQUMscUJBQXFCOytCQVVsQ0EsZUFBWSxTQUFDLG9CQUFvQjtxQ0FVakNBLGVBQVksU0FBQywwQkFBMEI7dUNBaUN2Q3BCLFFBQUssU0FBQywyQkFBMkI7NkNBZ0JqQ0MsU0FBTSxTQUFDLGlDQUFpQzsyQ0FpQ3hDRCxRQUFLLFNBQUMsK0JBQStCO2lEQWdCckNDLFNBQU0sU0FBQyxxQ0FBcUM7cUNBWTVDRCxRQUFLLFNBQUMsNkJBQTZCO2lDQThCbkNBLFFBQUssU0FBQyxtQ0FBbUM7dUNBY3pDQyxTQUFNLFNBQUMseUNBQXlDOytCQWdDaERELFFBQUssU0FBQyxpQ0FBaUM7K0JBbUJ2Q0MsU0FBTSxTQUFDLHVCQUF1Qjs2QkFTOUJBLFNBQU0sU0FBQyxxQkFBcUI7bUNBaUI1QkEsU0FBTSxTQUFDLHVCQUF1QjswQ0FtQjlCQSxTQUFNLFNBQUMscUJBQXFCOzRDQW1CNUJBLFNBQU0sU0FBQyx1QkFBdUI7d0NBbUI5QkEsU0FBTSxTQUFDLG1CQUFtQjswQ0F1QjFCQSxTQUFNLFNBQUMscUJBQXFCOzJDQXVCNUJBLFNBQU0sU0FBQyxzQkFBc0I7MENBRTdCQSxTQUFNLFNBQUMsMkJBQTJCOzBCQWFsQ0QsUUFBSyxTQUFDLElBQUk7O1FBME9iLG9CQUFDO0tBcm9CRDs7Ozs7OztRQytNRSxtQkFDK0IsVUFBa0IsRUFDeEMsVUFBbUMsRUFDbkMsY0FBcUMsRUFDckMsYUFBK0IsRUFDL0IsbUJBQXdDLEVBQ3ZDLFVBQXNCLEVBQzlCLE9BQXdCO1lBTkssZUFBVSxHQUFWLFVBQVUsQ0FBUTtZQUN4QyxlQUFVLEdBQVYsVUFBVSxDQUF5QjtZQUNuQyxtQkFBYyxHQUFkLGNBQWMsQ0FBdUI7WUFDckMsa0JBQWEsR0FBYixhQUFhLENBQWtCO1lBQy9CLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7WUFDdkMsZUFBVSxHQUFWLFVBQVUsQ0FBWTs7OztZQWhNUixTQUFJLEdBQUcsSUFBSSxDQUFDOzs7OztZQU1SLGFBQVEsR0FBRyxJQUFJLENBQUM7WUFXcEMsa0JBQWEsR0FBWSxLQUFLLENBQUM7WUFLdkMsVUFBSyxHQUFHLEtBQUssQ0FBQztZQXdCTixjQUFTLEdBQVksS0FBSyxDQUFDO1lBa0IzQixnQkFBVyxHQUFZLEtBQUssQ0FBQztZQWtCN0Isb0JBQWUsR0FBRyxLQUFLLENBQUM7WUFpQnhCLG9CQUFlLEdBQVksS0FBSyxDQUFDOzs7Ozs7WUFVQSx5QkFBb0IsR0FBWSxLQUFLLENBQUM7Ozs7O1lBU2hELGlCQUFZLEdBQTBCLElBQUlILGVBQVksQ0FBVSxLQUFLLENBQUMsQ0FBQzs7Ozs7O1lBT3pFLGFBQVEsR0FBc0IsSUFBSUEsZUFBWSxDQUFNLEtBQUssQ0FBQyxDQUFDOzs7Ozs7WUFPM0QsbUJBQWMsR0FBc0IsSUFBSUEsZUFBWSxDQUFNLEtBQUssQ0FBQyxDQUFDOzs7O1lBS2xFLFlBQU8sR0FBc0IsSUFBSUEsZUFBWSxDQUFNLEtBQUssQ0FBQyxDQUFDOzs7OztZQU0vQyx1QkFBa0IsR0FBc0IsSUFBSUEsZUFBWSxDQUFNLEtBQUssQ0FBQyxDQUFDOzs7Ozs7WUFPakYsZUFBVSxHQUFzQixJQUFJQSxlQUFZLENBQU0sS0FBSyxDQUFDLENBQUM7Ozs7O1lBT3pELG1CQUFjLEdBQXNCLElBQUlBLGVBQVksQ0FBTSxLQUFLLENBQUMsQ0FBQzs7WUEyQnhGLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztZQVd6QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLHdCQUF3QixFQUFFLEVBQy9CLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxFQUNuQyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsRUFDN0IsSUFBSSxDQUFDLHdCQUF3QixFQUFFLEVBQy9CLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUM1QixDQUFDO1lBRUYsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM3QztRQWhNRCxzQkFDSSxtQ0FBWTs7O2dCQUtoQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7YUFDM0I7Ozs7Ozs7Ozs7Z0JBUkQsVUFDaUIsS0FBYztnQkFDN0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO2dCQUM3QixJQUFJLENBQUMsVUFBVSxDQUFDLHNCQUFzQixHQUFHLEtBQUssQ0FBQzthQUNoRDs7O1dBQUE7UUFXRCxzQkFDSSxvQ0FBYTs7Ozs7Ozs7OztnQkFEakIsVUFDa0IsSUFBYTtnQkFDN0IsSUFBSSxJQUFJLEVBQUU7b0JBQ1IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO2lCQUN4QztnQkFDRCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzthQUNuQjs7O1dBQUE7UUFRRCxzQkFDSSwrQkFBUTs7O2dCQUtaO2dCQUNFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQzthQUN2Qjs7Ozs7Ozs7Ozs7Ozs7Z0JBUkQsVUFDYSxLQUFjO2dCQUN6QixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7Z0JBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO2FBQzFDOzs7V0FBQTtRQWNELHNCQUNJLGlDQUFVOzs7Z0JBS2Q7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO2FBQ3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBUkQsVUFDZSxLQUFjO2dCQUMzQixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7Z0JBQzNCLElBQUksQ0FBQyxVQUFVLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDO2FBQzVDOzs7V0FBQTtRQWNELHNCQUNJLHFDQUFjOzs7Z0JBS2xCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQzthQUM3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQVJELFVBQ21CLEtBQWM7Z0JBQy9CLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQztnQkFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRyxLQUFLLENBQUM7YUFDOUM7OztXQUFBO1FBYUQsc0JBQ0kscUNBQWM7OztnQkFLbEI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO2FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7O2dCQVJELFVBQ21CLEtBQWM7Z0JBQy9CLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQztnQkFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRyxLQUFLLENBQUM7YUFDOUM7OztXQUFBO1FBWUQsc0JBQUksMENBQW1COzs7Z0JBQXZCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixHQUFHLE1BQU0sR0FBRyxPQUFPLENBQUM7YUFDckQ7OztXQUFBO1FBbURELHNCQUFXLGtDQUFXOzs7Z0JBQXRCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7YUFDcEM7Ozs7Z0JBRUQsVUFBdUIsSUFBbUI7Z0JBQ3hDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNsQzs7O1dBSkE7UUFNRCxzQkFBVyw2QkFBTTs7O2dCQUFqQjtnQkFDRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUM7YUFDMUM7OztXQUFBO1FBRUQsc0JBQVcsOEJBQU87OztnQkFBbEI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDO2FBQzNDOzs7V0FBQTtRQUVELHNCQUFXLCtCQUFROzs7Z0JBQW5CO2dCQUNFLE9BQU8sb0JBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLElBQWlCLFNBQVMsQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsQ0FBQzthQUNoRzs7O1dBQUE7Ozs7UUF5Qk0sc0NBQWtCOzs7WUFBekI7Z0JBQ0UsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDdkMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7Z0JBQ2xFLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2FBQzFCOzs7O1FBRU0sNkJBQVM7OztZQUFoQjtnQkFDRSxJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQzthQUMvQjs7OztRQUVNLCtCQUFXOzs7WUFBbEI7Z0JBQ0UsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUEsQ0FBQyxDQUFDO2FBQ2xEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQVlNLDBCQUFNOzs7Ozs7Ozs7Ozs7WUFBYixVQUFjLGtCQUF5QjtnQkFBekIsbUNBQUE7b0JBQUEseUJBQXlCOztnQkFDckMsSUFBSSxrQkFBa0IsRUFBRTtvQkFDdEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2lCQUNwQjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUMxQjthQUNGOzs7Ozs7Ozs7Ozs7UUFPTSwrQkFBVzs7Ozs7O1lBQWxCO2dCQUNFLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtvQkFDdkIsT0FBTztpQkFDUjtnQkFFRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDZDs7Ozs7Ozs7UUFLTSx3QkFBSTs7OztZQUFYO2dCQUNFLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO2dCQUVsQixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtvQkFDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2lCQUN2Qzs7Z0JBR0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO2dCQUV2QyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM5Qjs7Ozs7Ozs7UUFLTSx5QkFBSzs7OztZQUFaO2dCQUNFLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtvQkFDdkIsT0FBTztpQkFDUjtnQkFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztnQkFDbkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDL0I7Ozs7Ozs7Ozs7Ozs7UUFPTSwwQkFBTTs7Ozs7OztZQUFiLFVBQWMsSUFBYTtnQkFDekIsSUFBSSxJQUFJLEVBQUU7b0JBQ1IsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2lCQUNiO3FCQUFNO29CQUNMLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztpQkFDZDthQUNGOzs7Ozs7OztRQUtNLDRCQUFROzs7O1lBQWY7Z0JBQ0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQzthQUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQWdCTSx3QkFBSTs7Ozs7Ozs7Ozs7Ozs7OztZQUFYLFVBQVksa0JBQWtDO2dCQUFsQyxtQ0FBQTtvQkFBQSx5QkFBa0M7O2dCQUM1QyxJQUFJLGtCQUFrQixFQUFFO29CQUN0QixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7aUJBQ2xCO3FCQUFNO29CQUNMLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ3hCO2FBQ0Y7Ozs7Ozs7Ozs7OztRQU9NLDZCQUFTOzs7Ozs7WUFBaEI7Z0JBQ0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUUsQ0FBQzthQUM3Qjs7Ozs7Ozs7Ozs7Ozs7UUFRTSwwQkFBTTs7Ozs7OztZQUFiO2dCQUNFLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDMUI7Ozs7Ozs7Ozs7UUFNTSwrQkFBVzs7Ozs7WUFBbEI7Z0JBQ0UsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNqQixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7aUJBQ3ZCO2FBQ0Y7Ozs7Ozs7Ozs7OztRQU9NLGtDQUFjOzs7Ozs7WUFBckI7O29CQUNRLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVzs7b0JBQzlCLHVCQUF1QixHQUFHLFdBQVcsQ0FBQyxVQUFVLElBQUksV0FBVyxDQUFDLGNBQWM7Z0JBRXBGLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtvQkFDdkIsT0FBTztpQkFDUjtnQkFFRCxXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNoQyxJQUFJLENBQUMsdUJBQXVCLEVBQUU7b0JBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ3RCO2dCQUVELElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsdUJBQXVCLEVBQUU7b0JBQ2hELElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztpQkFDZDthQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBVU0sd0JBQUk7Ozs7Ozs7Ozs7WUFBWCxVQUFZLE1BQWM7Z0JBQ3hCLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQ1gsT0FBTztpQkFDUjtnQkFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUM5Qjs7Ozs7Ozs7Ozs7O1FBT00seUJBQUs7Ozs7OztZQUFaO2dCQUNFLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQzVCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDckI7Ozs7UUFFTyw0Q0FBd0I7OztZQUFoQztnQkFBQSxpQkFLQztnQkFKQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQ2tDLGdCQUFNLENBQUMsY0FBTSxPQUFBSCx3QkFBaUIsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLEdBQUEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO29CQUN0RyxLQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO29CQUN2QixLQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztpQkFDeEMsQ0FBQyxDQUFDO2FBQ0o7Ozs7UUFFTyxnREFBNEI7OztZQUFwQztnQkFBQSxpQkFLQztnQkFKQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDRyxnQkFBTSxDQUFDLGNBQU0sT0FBQUgsd0JBQWlCLENBQUMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxHQUFBLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztvQkFDMUcsS0FBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQkFDM0IsS0FBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7aUJBQ3hDLENBQUMsQ0FBQzthQUNKOzs7O1FBRU8sMENBQXNCOzs7WUFBOUI7Z0JBQUEsaUJBRUM7Z0JBREMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLGNBQWMsRUFBRSxHQUFBLENBQUMsQ0FBQzthQUNsRjs7OztRQUVPLDRDQUF3Qjs7O1lBQWhDO2dCQUFBLGlCQUVDO2dCQURDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsa0JBQWtCLEVBQUUsR0FBQSxDQUFDLENBQUM7YUFDbEY7Ozs7UUFFTyx3Q0FBb0I7OztZQUE1QjtnQkFBQSxpQkFFQztnQkFEQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLEdBQUEsQ0FBQyxDQUFDO2FBQzNGOzs7O1FBRU8sMENBQXNCOzs7WUFBOUI7Z0JBQUEsaUJBTUM7O29CQUxPLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUM1QyxJQUFJLE9BQU8sRUFBRTtvQkFDWCxPQUFPLENBQUMsZ0JBQWdCLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsR0FBQSxDQUFDLENBQUM7b0JBQ25FLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFBLENBQUMsQ0FBQztpQkFDdEU7YUFDRjs7OztRQUVPLHFDQUFpQjs7O1lBQXpCOztnQkFFRSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7b0JBQ2QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO2lCQUN4QzthQUNGOzs7O1FBRU8sc0NBQWtCOzs7WUFBMUI7Z0JBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2xCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztpQkFDcEI7Z0JBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUM1Qjs7b0JBN2NGeEIsWUFBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSxZQUFZO3dCQUN0QixTQUFTLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSxxQkFBcUIsRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUIsQ0FBQzt3QkFDbEcsaXpFQUE0Qjt3QkFDNUIsSUFBSSxFQUFFOzRCQUNKLG9CQUFvQixFQUFFLE1BQU07NEJBQzVCLG1CQUFtQixFQUFFLGNBQWM7NEJBQ25DLG1CQUFtQixFQUFFLGNBQWM7NEJBQ25DLG1CQUFtQixFQUFFLGNBQWM7NEJBQ25DLGtCQUFrQixFQUFFLDhCQUE4Qjt5QkFDbkQ7cUJBQ0Y7Ozs7O3dCQWdNNEMsTUFBTSx1QkFBOUNlLFNBQU0sU0FBQ1UsY0FBVzt3QkEvTWQsdUJBQXVCO3dCQUR2QixxQkFBcUI7d0JBRnJCLGdCQUFnQjt3QkFDaEIsbUJBQW1CO3dCQWhCMUJ0QixhQUFVO3dCQUdWd0Msa0JBQWU7Ozs7MkJBbUNkL0MsUUFBSyxTQUFDLGVBQWU7K0JBTXJCQSxRQUFLLFNBQUMsbUJBQW1CO21DQU16QkEsUUFBSyxTQUFDLGlDQUFpQztvQ0FldkNBLFFBQUssU0FBQyxlQUFlOytCQWNyQkEsUUFBSyxTQUFDLDZCQUE2QjtpQ0FrQm5DQSxRQUFLLFNBQUMsK0JBQStCO3FDQWtCckNBLFFBQUssU0FBQyw0QkFBNEI7cUNBaUJsQ0EsUUFBSyxTQUFDLHlCQUF5QjsyQ0FlL0JBLFFBQUssU0FBQyxnQ0FBZ0M7bUNBU3RDQyxTQUFNLFNBQUMscUJBQXFCOytCQU81QkEsU0FBTSxTQUFDLG1CQUFtQjtxQ0FPMUJBLFNBQU0sU0FBQyxtQkFBbUI7OEJBSzFCQSxTQUFNLFNBQUMsa0JBQWtCO3lDQU16QkEsU0FBTSxTQUFDLDZCQUE2QjtpQ0FPcENBLFNBQU0sU0FBQyxpQkFBaUI7cUNBT3hCQSxTQUFNLFNBQUMscUJBQXFCOzRCQUU1Qk8sa0JBQWUsU0FBQyxhQUFhO29DQUM3QkEsa0JBQWUsU0FBQyxxQkFBcUI7a0NBQ3JDRixZQUFTLFNBQUMsYUFBYTs7UUE2UjFCLGdCQUFDO0tBOWNEOzs7Ozs7O0FDdEJBLFFBQWEsb0JBQW9CLEdBQVE7UUFDdkMsTUFBTSxFQUFFLFFBQVE7UUFDaEIsUUFBUSxFQUFFLFVBQVU7UUFDcEIsSUFBSSxFQUFFLE1BQU07UUFDWixNQUFNLEVBQUUsUUFBUTtRQUNoQixNQUFNLEVBQUUsUUFBUTtLQUNqQjs7QUFFRCxRQUFhLG1CQUFtQixHQUFRO1FBQ3RDLE1BQU0sRUFBRSxlQUFlO1FBQ3ZCLFFBQVEsRUFBRSxpQkFBaUI7UUFDM0IsSUFBSSxFQUFFLGFBQWE7UUFDbkIsTUFBTSxFQUFFLGVBQWU7UUFDdkIsTUFBTSxFQUFFLGVBQWU7S0FDeEI7QUFFRDtRQWlDRSx5QkFBbUIsVUFBbUMsRUFBUyxhQUErQjtZQUEzRSxlQUFVLEdBQVYsVUFBVSxDQUF5QjtZQUFTLGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtZQVR4RSxTQUFJLEdBQVcsRUFBRSxDQUFDO1lBRUMsYUFBUSxHQUFZLEtBQUssQ0FBQztZQUU1QixXQUFNLEdBQVksS0FBSyxDQUFDOztZQUc3QixlQUFVLEdBQXlCLElBQUlULGVBQVksQ0FBUyxLQUFLLENBQUMsQ0FBQztTQUVIOzs7Ozs7UUFFMUYsbURBQXlCOzs7OztZQUFqQyxVQUFrQyxZQUF5QixFQUFFLFlBQW9CO2dCQUEvQyw2QkFBQTtvQkFBQSxpQkFBeUI7O2dCQUN6RCxJQUFJLG9CQUFvQixDQUFDLFlBQVksQ0FBQyxLQUFLLFlBQVksRUFBRTtvQkFDdkQsT0FBTyxJQUFJLENBQUM7aUJBQ2I7Z0JBQ0QsSUFBSSxtQkFBbUIsQ0FBQyxZQUFZLENBQUMsS0FBSyxZQUFZLEVBQUU7b0JBQ3RELE9BQU8sSUFBSSxDQUFDO2lCQUNiO2dCQUNELE9BQU8sS0FBSyxDQUFDO2FBQ2Q7UUFFRCxzQkFBVyxxQ0FBUTs7O2dCQUFuQjtnQkFDRSxPQUFPLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQzVEOzs7V0FBQTtRQUVELHNCQUFXLG1DQUFNOzs7Z0JBQWpCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDMUQ7OztXQUFBO1FBRUQsc0JBQVcsdUNBQVU7OztnQkFBckI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQzthQUM5RDs7O1dBQUE7UUFFRCxzQkFBVyxxQ0FBUTs7O2dCQUFuQjtnQkFDRSxPQUFPLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQzVEOzs7V0FBQTtRQUVELHNCQUFXLHFDQUFROzs7Z0JBQW5CO2dCQUNFLE9BQU8sSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDNUQ7OztXQUFBO1FBRUQsc0JBQVcsNENBQWU7OztnQkFBMUI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQzthQUN0RDs7O1dBQUE7UUFFRCxzQkFBVywrQ0FBa0I7OztnQkFBN0I7Z0JBQ0UsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNuQixPQUFPLEVBQUUsQ0FBQztpQkFDWDtnQkFDRCxPQUFPLElBQUksQ0FBQzthQUNiOzs7V0FBQTtRQUVELHNCQUFXLHVDQUFVOzs7Z0JBQXJCOzs7b0JBRVEsUUFBUSxHQUFHLElBQUk7O29CQUNmLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVTs7b0JBQ3JCLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVc7O2dCQUd4QyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUU7b0JBQ3BDLE9BQU8sQ0FBQyxRQUFRLENBQUM7aUJBQ2xCO2dCQUVELElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUMsb0JBQW9CLElBQUksQ0FBQyxJQUFJLEVBQUU7b0JBQ3RELE9BQU8sSUFBSSxDQUFDO2lCQUNiO2dCQUVELElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDakIsT0FBTyxDQUFDLFFBQVEsQ0FBQztpQkFDbEI7Z0JBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLEdBQUcsQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsRUFBRTtvQkFDNUUsT0FBTyxRQUFRLENBQUM7aUJBQ2pCO2dCQUVELElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUU7b0JBQzFDLE9BQU8sUUFBUSxDQUFDO2lCQUNqQjtnQkFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssR0FBRyxDQUFDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFO29CQUNuRSxPQUFPLFFBQVEsQ0FBQztpQkFDakI7Z0JBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUMsR0FBRyxDQUFDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFO29CQUN0RSxPQUFPLFFBQVEsQ0FBQztpQkFDakI7Z0JBRUQsT0FBTyxDQUFDLFFBQVEsQ0FBQzthQUNsQjs7O1dBQUE7UUFFRCxzQkFBVyxxQ0FBUTs7O2dCQUFuQjs7O29CQUVRLE1BQU0sR0FBRyxJQUFJOztvQkFDYixHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVU7O2dCQUczQixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUU7b0JBQ3BDLE9BQU8sQ0FBQyxNQUFNLENBQUM7aUJBQ2hCO2dCQUVELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtvQkFDZixPQUFPLElBQUksQ0FBQztpQkFDYjtnQkFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2pCLE9BQU8sQ0FBQyxNQUFNLENBQUM7aUJBQ2hCO2dCQUVELElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsa0JBQWtCLEVBQUU7b0JBQzdDLE9BQU8sTUFBTSxDQUFDO2lCQUNmO2dCQUVELElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsaUJBQWlCLEVBQUU7b0JBQ3hDLE9BQU8sTUFBTSxDQUFDO2lCQUNmO2dCQUVELElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRTtvQkFDM0MsT0FBTyxNQUFNLENBQUM7aUJBQ2Y7Z0JBRUQsT0FBTyxDQUFDLE1BQU0sQ0FBQzthQUNoQjs7O1dBQUE7Ozs7UUFFRCwrQkFBSzs7O1lBQUw7Z0JBQ0UsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNuQixPQUFPO2lCQUNSO2dCQUVELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzdDOztvQkExSkZPLFlBQVMsU0FBQzt3QkFDVCxRQUFRLEVBQUUsbUJBQW1CO3dCQUM3QixRQUFRLEVBQUUsa3NCQWlCUDt3QkFDSCxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsd0JBQXdCLEVBQUUsb0JBQW9CLEVBQUUsVUFBVSxFQUFFO2lDQUNsRSx5Q0FBeUM7cUJBQ25EOzs7Ozt3QkF4Q1EsdUJBQXVCO3dCQUR2QixnQkFBZ0I7Ozs7MkJBMkN0QkosUUFBSyxTQUFDLE1BQU07K0JBRVpBLFFBQUssU0FBQyx5QkFBeUI7NkJBRS9CQSxRQUFLLFNBQUMsdUJBQXVCO2lDQUc3QkMsU0FBTSxTQUFDLHdCQUF3Qjs7UUE0SGxDLHNCQUFDO0tBM0pEOzs7Ozs7O1FDbkJBO1NBSUM7O29CQUpBVCxZQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsd0NBQXdDLEVBQUU7O1FBSWpFLDBCQUFDO0tBSkQ7Ozs7Ozs7UUNXRSwwQkFBbUIsV0FBa0M7WUFBbEMsZ0JBQVcsR0FBWCxXQUFXLENBQXVCO1NBQUk7O29CQVYxRFksWUFBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSxvQkFBb0I7d0JBQzlCLFFBQVEsRUFBRSxxTUFJVDt3QkFDRCxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsb0JBQW9CLEVBQUU7cUJBQ3RDOzs7Ozt3QkFWUSxxQkFBcUI7OztRQWE5Qix1QkFBQztLQVhEOzs7Ozs7O1FDeUJFLDhCQUFtQixVQUFtQyxFQUFTLGNBQXFDO1lBQWpGLGVBQVUsR0FBVixVQUFVLENBQXlCO1lBQVMsbUJBQWMsR0FBZCxjQUFjLENBQXVCO1NBQUk7Ozs7UUFFaEcsd0NBQVM7OztZQUFqQjtnQkFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtvQkFDZCxNQUFNLElBQUksS0FBSyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7aUJBQzlFO2FBQ0Y7UUFFRCxzQkFBVyxvQ0FBRTs7O2dCQUFiO2dCQUNFLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM1RDs7O1dBQUE7UUFFRCxzQkFBVyw0Q0FBVTs7O2dCQUFyQjtnQkFDRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLG9CQUFvQixDQUFDO2FBQzNHOzs7V0FBQTtRQUVELHNCQUFXLDJDQUFTOzs7Z0JBQXBCO2dCQUNFLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQzthQUMxQjs7O1dBQUE7UUFFRCxzQkFBVyw0Q0FBVTs7O2dCQUFyQjtnQkFDRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7YUFDNUI7OztXQUFBO1FBRUQsc0JBQVcsNkNBQVc7OztnQkFBdEI7Z0JBQ0UsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQy9EOzs7V0FBQTs7OztRQUVELG9DQUFLOzs7WUFBTDtnQkFDRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7O2dCQUdqQixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtvQkFDckMsT0FBTztpQkFDUjtnQkFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDakM7O29CQWhFRkEsWUFBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSwyQkFBMkI7d0JBQ3JDLFFBQVEsRUFBRSx5UEFJUDt3QkFDSCxJQUFJLEVBQUU7NEJBQ0osTUFBTSxFQUFFLElBQUk7NEJBQ1osc0JBQXNCLEVBQUUsV0FBVzs0QkFDbkMsc0JBQXNCLEVBQUUsSUFBSTs0QkFDNUIsc0JBQXNCLEVBQUUsTUFBTTs0QkFDOUIsa0JBQWtCLEVBQUUsTUFBTTs0QkFDMUIsZ0JBQWdCLEVBQUUsV0FBVzs0QkFDN0Isa0JBQWtCLEVBQUUsWUFBWTs0QkFDaEMsa0JBQWtCLEVBQUUsY0FBYzs0QkFDbEMsa0JBQWtCLEVBQUUsWUFBWTt5QkFDakM7cUJBQ0Y7Ozs7O3dCQXJCUSx1QkFBdUI7d0JBRHZCLHFCQUFxQjs7OzsyQkF3QjNCSixRQUFLLFNBQUMsTUFBTTs7UUE2Q2YsMkJBQUM7S0FqRUQ7Ozs7Ozs7QUNZQSxRQUFhLHFCQUFxQixHQUFVO1FBQzFDLFNBQVM7UUFDVCxhQUFhO1FBQ2IsZ0JBQWdCO1FBQ2hCLG9CQUFvQjtRQUNwQixlQUFlO1FBQ2YscUJBQXFCO1FBQ3JCLG1CQUFtQjtRQUNuQixrQkFBa0I7UUFDbEIscUJBQXFCO1FBQ3JCLG9CQUFvQjtRQUNwQiwwQkFBMEI7S0FDM0I7QUFFRDtRQUFBO1NBSytCOztvQkFMOUJQLFdBQVEsU0FBQzt3QkFDUixPQUFPLEVBQUUsQ0FBQ0MsbUJBQVksRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDO3dCQUN2RCxZQUFZLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQzt3QkFDckMsT0FBTyxFQUFFLENBQUMscUJBQXFCLENBQUM7cUJBQ2pDOztRQUM2QixzQkFBQztLQUwvQjs7Ozs7OztRQzlCQTtZQVkwQixlQUFVLEdBQVcsRUFBRSxDQUFDOztZQVcvQixRQUFHLEdBQVcsR0FBRyxDQUFDO1lBQ2hCLFVBQUssR0FBVyxDQUFDLENBQUM7U0FxSHRDO1FBaElDLHNCQUNJLDhCQUFFOzs7Z0JBSU47Z0JBQ0UsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO2FBQ2pCOzs7O2dCQVBELFVBQ08sS0FBYTtnQkFDbEIsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7Z0JBQ2pCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO2FBQ3hCOzs7V0FBQTtRQVdELHNCQUNJLHlDQUFhOzs7Ozs7O1lBRGpCO2dCQUVFLE9BQU8sSUFBSSxDQUFDO2FBQ2I7OztXQUFBO1FBR0Qsc0JBQ0ksd0NBQVk7OztnQkFEaEI7Z0JBRUUsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO2FBQ3RCOzs7V0FBQTtRQUVELHNCQUNJLHNDQUFVOzs7O2dCQURkLFVBQ2UsS0FBdUI7Z0JBQ3BDLElBQUksQ0FBQyxRQUFRLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDOUM7OztXQUFBO1FBR0Qsc0JBQ0kscUNBQVM7OztnQkFEYjtnQkFFRSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7YUFDbkI7OztXQUFBO1FBRUQsc0JBQ0ksbUNBQU87Ozs7Z0JBRFgsVUFDWSxLQUF1QjtnQkFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUMzQzs7O1dBQUE7UUFHRCxzQkFDSSxxQ0FBUzs7O2dCQURiO2dCQUVFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQzthQUNuQjs7O1dBQUE7UUFFRCxzQkFDSSxtQ0FBTzs7OztnQkFEWCxVQUNZLEtBQXVCO2dCQUNqQyxJQUFJLENBQUMsS0FBSyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzNDOzs7V0FBQTtRQUdELHNCQUNJLHdDQUFZOzs7Z0JBRGhCO2dCQUVFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQzthQUN0Qjs7O1dBQUE7UUFFRCxzQkFDSSxzQ0FBVTs7OztnQkFEZCxVQUNlLEtBQXVCO2dCQUNwQyxJQUFJLENBQUMsUUFBUSxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzlDOzs7V0FBQTtRQUdELHNCQUNJLHVDQUFXOzs7Z0JBRGY7Z0JBRUUsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO2FBQ3JCOzs7V0FBQTtRQUVELHNCQUNJLHFDQUFTOzs7O2dCQURiLFVBQ2MsS0FBdUI7Z0JBQ25DLElBQUksQ0FBQyxPQUFPLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDN0M7OztXQUFBO1FBR0Qsc0JBQ0ksc0NBQVU7OztnQkFEZDtnQkFFRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDcEI7OztXQUFBO1FBRUQsc0JBQ0ksb0NBQVE7Ozs7Z0JBRFosVUFDYSxLQUF1QjtnQkFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUM1Qzs7O1dBQUE7UUFHRCxzQkFDSSw0Q0FBZ0I7OztnQkFEcEI7Z0JBRUUsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO2FBQzFCOzs7V0FBQTtRQUVELHNCQUNJLDBDQUFjOzs7O2dCQURsQixVQUNtQixLQUF1QjtnQkFDeEMsSUFBSSxDQUFDLFlBQVksR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNsRDs7O1dBQUE7UUFVRCxzQkFBSSx3Q0FBWTs7Ozs7Ozs7O2dCQUFoQjtnQkFDRSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQ25CLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztpQkFDeEI7Z0JBQ0QsT0FBVSxJQUFJLENBQUMsS0FBSyxNQUFHLENBQUM7YUFDekI7OztXQUFBOzs7Ozs7OztRQUtELHdDQUFlOzs7O1lBQWY7Z0JBQ0UsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQzthQUNsRjtRQUVELHNCQUFJLG9DQUFROzs7Z0JBQVo7Z0JBQ0UsSUFBSSxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7b0JBQ3pDLE9BQU8sV0FBVyxDQUFDO2lCQUNwQjtnQkFDRCxJQUFJLHFCQUFxQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDbkMsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBQ0QsT0FBTyxRQUFRLENBQUM7YUFDakI7OztXQUFBOztvQkE1SUZVLFlBQVMsU0FBQzt3QkFDVCxRQUFRLEVBQUUsa0JBQWtCO3dCQUM1QixRQUFRLEVBQUUsOE5BR1Q7cUJBQ0Y7OztpQ0FNRWEsY0FBVyxTQUFDLFNBQVM7eUJBQ3JCakIsUUFBSzswQkFVTEEsUUFBSyxTQUFDLFFBQVE7NEJBQ2RBLFFBQUssU0FBQyxVQUFVO2lDQUNoQkEsUUFBSyxTQUFDLGVBQWU7b0NBR3JCaUIsY0FBVyxTQUFDLGdCQUFnQjttQ0FNNUJBLGNBQVcsU0FBQyxlQUFlO2lDQUszQmpCLFFBQUssU0FBQyxZQUFZO2dDQU1sQmlCLGNBQVcsU0FBQyxxQkFBcUI7OEJBS2pDakIsUUFBSyxTQUFDLFNBQVM7Z0NBTWZpQixjQUFXLFNBQUMsWUFBWTs4QkFLeEJqQixRQUFLLFNBQUMsU0FBUzttQ0FNZmlCLGNBQVcsU0FBQyxlQUFlO2lDQUszQmpCLFFBQUssU0FBQyxZQUFZO2tDQU1sQmlCLGNBQVcsU0FBQyxjQUFjO2dDQUsxQmpCLFFBQUssU0FBQyxXQUFXO2lDQU1qQmlCLGNBQVcsU0FBQyxhQUFhOytCQUt6QmpCLFFBQUssU0FBQyxVQUFVO3VDQU1oQmlCLGNBQVcsU0FBQyxvQkFBb0I7cUNBS2hDakIsUUFBSyxTQUFDLGdCQUFnQjtnQ0FNdEJBLFFBQUssU0FBQyxjQUFjOzBCQUNwQkEsUUFBSyxTQUFDLFFBQVE7O1FBNkJqQixxQkFBQztLQTdJRDs7Ozs7OztBQ0NBLFFBQWEsMkJBQTJCLEdBQWdCLENBQUMsY0FBYyxDQUFDO0FBRXhFO1FBQUE7U0FLb0M7O29CQUxuQ1AsV0FBUSxTQUFDO3dCQUNSLE9BQU8sRUFBRSxDQUFDQyxtQkFBWSxDQUFDO3dCQUN2QixZQUFZLEVBQUUsQ0FBQywyQkFBMkIsQ0FBQzt3QkFDM0MsT0FBTyxFQUFFLENBQUMsMkJBQTJCLENBQUM7cUJBQ3ZDOztRQUNrQywyQkFBQztLQUxwQzs7Ozs7OztRQ2FBO1NBb0I2Qjs7b0JBcEI1QkQsV0FBUSxTQUFDO3dCQUNSLE9BQU8sRUFBRTs0QkFDUCxpQkFBaUI7NEJBQ2pCLGFBQWE7NEJBQ2IsYUFBYTs0QkFDYixjQUFjOzRCQUNkLGdCQUFnQjs0QkFDaEIsaUJBQWlCOzRCQUNqQixvQkFBb0I7NEJBQ3BCLGtCQUFrQjs0QkFDbEIsZUFBZTs0QkFDZixjQUFjOzRCQUNkLGVBQWU7NEJBQ2YsZ0JBQWdCOzRCQUNoQixlQUFlOzRCQUNmLG9CQUFvQjs0QkFDcEIsZ0JBQWdCOzRCQUNoQixvQkFBb0I7eUJBQ3JCO3FCQUNGOztRQUMyQixvQkFBQztLQXBCN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNiSSxRQUFRLEdBQUcsQ0FBQzs7Ozs7QUFNaEI7UUFBQTs7WUFnQ2UsUUFBRyxHQUFXLENBQUMsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUM7O1lBT2pCLHFCQUFnQixHQUFXLElBQUksQ0FBQzs7WUFHNUMsU0FBSSxHQUFXLElBQUksQ0FBQzs7WUFHYixhQUFRLEdBQVksS0FBSyxDQUFDOztZQUc1QixXQUFNLEdBQUcsS0FBSyxDQUFDO1lBRWxDLGFBQVEsR0FBRyxLQUFLLENBQUM7WUFnQmpCLG1CQUFjLEdBQVksS0FBSyxDQUFDO1lBaUJqQyx3QkFBbUIsR0FBMEIsSUFBSUksZUFBWSxDQUFVLEtBQUssQ0FBQyxDQUFDO1lBWWxELFdBQU0sR0FBRyxJQUFJQSxlQUFZLENBQVUsS0FBSyxDQUFDLENBQUM7Ozs7O1lBb0JyRSxxQkFBZ0IsR0FBRyxVQUFDLENBQU0sS0FBTyxDQUFDO1lBTWxDLHNCQUFpQixHQUFHLGVBQVEsQ0FBQztTQWV0QztRQXRHQyxzQkFBVyxxQ0FBRTs7O2dCQUFiO2dCQUNFLE9BQU8sa0JBQWdCLElBQUksQ0FBQyxHQUFLLENBQUM7YUFDbkM7OztXQUFBO1FBZ0JELHNCQUFXLDBDQUFPOzs7Z0JBQWxCO2dCQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQzthQUN0Qjs7OztnQkFFRCxVQUNtQixLQUFjO2dCQUMvQixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUMzQixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7d0JBQ3ZCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztxQkFDOUI7b0JBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDeEI7YUFDRjs7O1dBVkE7UUFjRCxzQkFBVyxnREFBYTs7O2dCQUF4QjtnQkFDRSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7YUFDNUI7Ozs7Z0JBRUQsVUFDeUIsS0FBYztnQkFDckMsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLEtBQUssRUFBRTtvQkFDakMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO3dCQUNqQixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO3FCQUN4QjtvQkFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQzlCO2FBQ0Y7OztXQVZBOzs7OztRQWVPLGdEQUFnQjs7OztZQUF4QixVQUF5QixLQUFjO2dCQUNyQyxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztnQkFDNUIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7YUFDcEQ7Ozs7O1FBRU8sMENBQVU7Ozs7WUFBbEIsVUFBbUIsS0FBYztnQkFDL0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7Z0JBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNqQzs7OztRQUlNLHNDQUFNOzs7WUFBYjtnQkFDRSxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztnQkFDN0IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNyQzs7Ozs7UUFFRCwwQ0FBVTs7OztZQUFWLFVBQVcsS0FBVTtnQkFDbkIsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO29CQUNsQixLQUFLLEdBQUcsS0FBSyxDQUFDO2lCQUNmO2dCQUNELElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQzFCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO2lCQUN0QjthQUNGOzs7OztRQVFELGdEQUFnQjs7OztZQUFoQixVQUFpQixRQUFhO2dCQUM1QixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDO2FBQ2xDOzs7OztRQUlELGlEQUFpQjs7OztZQUFqQixVQUFrQixTQUFjO2dCQUM5QixJQUFJLENBQUMsaUJBQWlCLEdBQUcsU0FBUyxDQUFDO2FBQ3BDOzs7O1FBRU0scUNBQUs7OztZQUFaO2dCQUNFLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2FBQzFCOzs7O1FBRUQsdURBQXVCOzs7WUFBdkI7Z0JBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2xCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztpQkFDZjthQUNGOztvQkF2SUZPLFlBQVMsU0FBQzt3QkFDVCxRQUFRLEVBQUUsY0FBYzt3QkFDeEIsUUFBUSxFQUFFLDJnQ0FtQlA7d0JBQ0gsSUFBSSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxrQkFBa0IsRUFBRSxVQUFVLEVBQUU7Ozs7Ozt3QkFNNUcsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUV1RCx1QkFBaUIsRUFBRSxXQUFXLEVBQUVDLGFBQVUsQ0FBQyxjQUFNLE9BQUEscUJBQXFCLEdBQUEsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQztxQkFDL0c7OzswQkFHRTVELFFBQUssU0FBQyxJQUFJO3VDQU9WQSxRQUFLLFNBQUMsa0JBQWtCOzJCQUd4QkEsUUFBSyxTQUFDLE1BQU07K0JBR1pBLFFBQUssU0FBQyxhQUFhOzZCQUduQkEsUUFBSyxTQUFDLFdBQVc7OEJBUWpCQSxRQUFLLFNBQUMsWUFBWTtvQ0FnQmxCQSxRQUFLLFNBQUMsa0JBQWtCOzBDQVV4QkMsU0FBTSxTQUFDLHdCQUF3Qjs2QkFhL0JBLFNBQU0sU0FBQyxrQkFBa0I7O1FBeUM1Qiw0QkFBQztLQXhJRDs7Ozs7OztBQ1BBLFFBQWEsdUJBQXVCLEdBQWdCLENBQUMscUJBQXFCLENBQUM7QUFFM0U7UUFBQTtTQUMyQzs7b0JBRDFDUixXQUFRLFNBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQ0MsbUJBQVksQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDLHVCQUF1QixDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsdUJBQXVCLENBQUMsRUFBRTs7UUFDeEUsa0NBQUM7S0FEM0M7Ozs7Ozs7Ozs7OztRQ0FBO1NBSXdDOztvQkFKdkNELFdBQVEsU0FBQzt3QkFDUixPQUFPLEVBQUUsQ0FBQ0MsbUJBQVksQ0FBQzt3QkFDdkIsT0FBTyxFQUFFLENBQUMsMkJBQTJCLEVBQUUsbUJBQW1CLENBQUM7cUJBQzVEOztRQUNzQywrQkFBQztLQUp4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMQSxhQUFnQixRQUFRO1FBRXRCLE9BQU87WUFDTHdELGdCQUFLLENBQUMsTUFBTSxFQUFFdEMsZ0JBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDM0RELHFCQUFVLENBQUMsZUFBZSxFQUFFLENBQUNFLGtCQUFPLENBQUMsa0JBQWtCLEVBQUVELGdCQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxR0QscUJBQVUsQ0FBQyxlQUFlLEVBQUUsQ0FBQ0MsZ0JBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUVDLGtCQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO1NBQzNHLENBQUM7SUFDSixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNQRCxhQUFnQixJQUFJLENBQUMsT0FBbUI7UUFBbkIsd0JBQUE7WUFBQSxXQUFtQjs7UUFDdEMsT0FBTztZQUNMRixxQkFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDQyxnQkFBSyxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUVDLGtCQUFPLENBQUMsa0JBQWtCLEVBQUVELGdCQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUdELHFCQUFVLENBQUMsV0FBVyxFQUFFLENBQUNFLGtCQUFPLENBQUMsa0JBQWtCLEVBQUVELGdCQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDOUUsQ0FBQztJQUNKLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ0xELGFBQWdCLFNBQVMsQ0FBQyxTQUFpQjs7WUFDckMsU0FBUyxHQUFXLElBQUk7UUFDNUIsSUFBSSxTQUFTLEtBQUssSUFBSSxFQUFFO1lBQ3RCLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQztTQUNqQzthQUFNLElBQUksU0FBUyxLQUFLLE1BQU0sRUFBRTtZQUMvQixTQUFTLEdBQUcsb0JBQW9CLENBQUM7U0FDbEM7YUFBTSxJQUFJLFNBQVMsS0FBSyxNQUFNLEVBQUU7WUFDL0IsU0FBUyxHQUFHLG1CQUFtQixDQUFDO1NBQ2pDO2FBQU0sSUFBSSxTQUFTLEtBQUssT0FBTyxFQUFFO1lBQ2hDLFNBQVMsR0FBRyxvQkFBb0IsQ0FBQztTQUNsQzthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxTQUFTLEdBQUcsdUJBQXVCLENBQUMsQ0FBQztTQUM3RTtRQUNELE9BQU87WUFDTEQscUJBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQ0MsZ0JBQUssQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUVDLGtCQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO1lBQ25HRixxQkFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDRSxrQkFBTyxDQUFDLGtCQUFrQixFQUFFRCxnQkFBSyxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDcEcsQ0FBQztJQUNKLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ2pCRCxhQUFnQixLQUFLLENBQUMsU0FBaUI7O1lBQ2pDLFNBQVMsR0FBVyxJQUFJO1FBQzVCLElBQUksU0FBUyxLQUFLLElBQUksRUFBRTtZQUN0QixTQUFTLEdBQUcsbUJBQW1CLENBQUM7U0FDakM7YUFBTSxJQUFJLFNBQVMsS0FBSyxNQUFNLEVBQUU7WUFDL0IsU0FBUyxHQUFHLG9CQUFvQixDQUFDO1NBQ2xDO2FBQU0sSUFBSSxTQUFTLEtBQUssTUFBTSxFQUFFO1lBQy9CLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQztTQUNqQzthQUFNLElBQUksU0FBUyxLQUFLLE9BQU8sRUFBRTtZQUNoQyxTQUFTLEdBQUcsb0JBQW9CLENBQUM7U0FDbEM7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsU0FBUyxHQUFHLHVCQUF1QixDQUFDLENBQUM7U0FDN0U7UUFDRCxPQUFPO1lBQ0xELHFCQUFVLENBQUMsV0FBVyxFQUFFLENBQUNDLGdCQUFLLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRUMsa0JBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7WUFDdkZGLHFCQUFVLENBQUMsV0FBVyxFQUFFLENBQUNFLGtCQUFPLENBQUMsa0JBQWtCLEVBQUVELGdCQUFLLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDeEYsQ0FBQztJQUNKLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9